<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>VGGT-SLAM：Dense RGB SLAM Optimized on the SL(4) Manifold</title>
      <link href="2025/05/29/paper-reading-vggt-slam/"/>
      <url>2025/05/29/paper-reading-vggt-slam/</url>
      
        <content type="html"><![CDATA[<h1 id="VGGT-SLAM-Dense-RGB-SLAM-Optimized-on-the-SL-4-Manifold"><a href="#VGGT-SLAM-Dense-RGB-SLAM-Optimized-on-the-SL-4-Manifold" class="headerlink" title="VGGT-SLAM: Dense RGB SLAM Optimized on the SL(4) Manifold"></a>VGGT-SLAM: Dense RGB SLAM Optimized on the SL(4) Manifold</h1><p><img src="/images/paper-reading-vggt-slam/image-20250529153907398.png"></p><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><ul><li><p>However, VGGT is limited in the number of frames that can be processed by GPU memory. For example, in the case of an NVIDIA GeForce RTX 4090 with 24 GB, this is limited to approximately 60 frames, making larger reconstructions requiring hundreds or thousands of frames infeasible.</p><blockquote><p>VGGT在GPU memory受限的情况下，做large-scale的重建是不可行的。</p></blockquote></li><li><p>While related works align submaps using similarity transforms (i.e., translation, rotation, and scale), we show that such approaches are inadequate in the case of uncalibrated cameras.</p><blockquote><p>相关的工作也能够对齐submap，但是在相机没有标定的情况下比较难以实现。</p></blockquote></li><li><p>Sim(3) is insufficient to align submaps due to a projective ambiguity, motivating our SL(4)-based SLAM.</p><blockquote><p>由于投影模糊，Sim(3)不足以对齐子地图，这激发了我们基于SL(4)的SLAM。</p></blockquote></li></ul><h2 id="为什么sim3存在问题？"><a href="#为什么sim3存在问题？" class="headerlink" title="为什么sim3存在问题？"></a>为什么sim3存在问题？</h2><h3 id="论文中的描述"><a href="#论文中的描述" class="headerlink" title="论文中的描述"></a>论文中的描述</h3><p>One may suspect that a simple, trivial solution would be to create multiple submaps with VGGT where each submap contains at least one overlapping frame, and solve for the scale parameter between submaps (as the reconstruction does not capture metric scale), with VGGT’s estimated poses being used to align rotation and translation (i.e., estimating a Sim(3) transformation between submaps). While we demonstrate Sim(3) optimization shows impressive reconstructions in many cases, we empirically observe that the feed-forward nature of VGGT with uncalibrated cameras introduces a projective ambiguity, which in addition to the Sim(3) DOF includes shear, stretch, and perspective DOF, especially when the disparity between frames becomes small. This ambiguity cannot be fully resolved through a similarity transformation alone.</p><blockquote><p>有人可能会认为，一个简单直接的解决方案是使用VGGT创建多个子地图，每个子地图至少包含一帧重叠画面，并通过求解子地图之间的尺度参数（因为重建过程无法捕获真实尺度），同时利用VGGT估计的位姿来对齐旋转和平移（即估算子地图间的Sim(3)变换）。虽然我们证明了Sim(3)优化在多数情况下能实现出色的重建效果，但实际观测发现：当使用未标定相机时，VGGT的前馈特性会引入投影歧义——这种歧义除了包含Sim(3)的自由度外，还涉及剪切、拉伸和透视自由度，尤其在帧间视差较小时更为明显。仅靠相似变换无法完全消除这种歧义。</p></blockquote><h3 id="我之前的实验"><a href="#我之前的实验" class="headerlink" title="我之前的实验"></a>我之前的实验</h3><p>我之前也用sim3做过类似的事情，确实也是存在这个问题。虽然之后可以做BA去优化，但是BA只能优化sparse的点，毕竟track是sparse的。除非我们进行dense的track，这样我们才能真正解决这个问题，但是这样的话，开销太大了。</p><p>比如在scannet数据集上，我使用VGGT得到了下面两个submap，现在我希望进行sim3的对齐。</p><img src="/images/paper-reading-vggt-slam/image-20250529154659534.png" style="zoom: 50%;"><img src="/images/paper-reading-vggt-slam/image-20250529154707568.png" style="zoom: 50%;"><p>sim3对齐之后的位姿：</p><img src="/images/paper-reading-vggt-slam/image-20250529154721008.png" style="zoom: 50%;"><p>对齐之后的mesh：（分层挺明显的）</p><img src="/images/paper-reading-vggt-slam/image-20250529154731930.png" style="zoom: 50%;"><img src="/images/paper-reading-vggt-slam/image-20250529154745809.png" style="zoom: 50%;"><h3 id="补充一个我的观点"><a href="#补充一个我的观点" class="headerlink" title="补充一个我的观点"></a>补充一个我的观点</h3><p><strong>CVPR 2025 Oral</strong>《MoGe: Unlocking Accurate Monocular Geometry Estimation for Open-Domain Images with Optimal Training Supervision》在下图指出了scale-invariant会出现不一致的监督信号，这会导致模型估计出来的depth存在歧义。</p><p><img src="/images/paper-reading-vggt-slam/image-20250529155507771.png"></p><p>Scale-invariant就是认为gt_depth与pred_depth相差了一个scale，我们有pred_depth = scale * gt_depth；</p><p>Affine-invariant就是认为gt_depth与pred_depth相差了一个scale和shift，我们有pred_depth  = scale * gt_depth + shift；</p><p>想象一下，拍摄同一个物体，距离近拍摄一张图，和距离远但是变焦缩放后再拍摄一张图像，看起来好像物体是同样大小的，但是深度却相差很大。对于背景复杂的场景，主体大小不变或者主体占比很小，而背景变化了，可能预测的depth还好，但如果背景比较简单，网络对主体的关注度更高，预测的depth就可能会出问题了。</p><p><strong>这种情况最著名的就是，希区柯克变焦。</strong>下面是我以前拍的一段希区柯克变焦视频。</p><p>【西工大图书馆希区柯克变焦】 <a href="https://www.bilibili.com/video/BV11w7VzgESF/?share_source=copy_web&amp;vd_source=5040c17d0665f566f786d3874bbfd13d">https://www.bilibili.com/video/BV11w7VzgESF/?share_source=copy_web&amp;vd_source=5040c17d0665f566f786d3874bbfd13d</a></p><img src="/images/paper-reading-vggt-slam/image-20250529160644232.png" style="zoom: 50%;"><img src="/images/paper-reading-vggt-slam/image-20250529160656238.png" style="zoom: 50%;"><p>尽管VGGT-SLAM没有指出这一点，但是，VGGT会有这个问题吗？VGGT是用scale-invariant训练的吗？</p><p>是的是的，有的有的！看VGGT论文3.4 Training部分，depth loss和pointmap是follow的DUSt3R的。</p><img src="/images/paper-reading-vggt-slam/image-20250529161040681.png" style="zoom:50%;"><p>而DUSt3R是怎么做的呢？在DUSt3R论文3.2. Traning Objective部分，这个其实就是scale-invariant的loss。</p><img src="/images/paper-reading-vggt-slam/image-20250529161129051.png" style="zoom:50%;"><h2 id="做了什么？"><a href="#做了什么？" class="headerlink" title="做了什么？"></a>做了什么？</h2><p>We present VGGT-SLAM, a dense RGB SLAM system constructed by incrementally and globally aligning submaps created from the feed-forward scene reconstruction approach VGGT using only uncalibrated monocular cameras.</p><blockquote><p>关键词：Dense RGB SLAM、incrementally and globally aligning submaps、uncalibrated</p></blockquote><p><strong>论文的贡献：</strong></p><ul><li><p>Firstly, we present the first SLAM system that leverages the feed-forward scene reconstruction capabilities ofVGGT [68], extending it to large-scale scenes that cannot be reconstructed from a single inference of VGGT. Our system operates entirely with monocular RGB cameras and does not require known camera intrinsics or consistent calibration across frames. Importantly, it achieves this without any additional training.</p><blockquote><p>将VGGT扩展到了large-scale的重建，只需要RGB相机，不需要相机的内参或者校准。</p></blockquote></li><li><p>Secondly, while Sim(3) optimization is often sufficient, we identify and analyze scenarios where projective ambiguity arises, as presented in Fig. 1. In these cases, conventional similarity transforms do not fully resolve scale and alignment issues. We highlight this limitation and demonstrate how incorporating projective constraints addresses the problem.</p><blockquote><p>虽然Sim(3)优化通常是足够的，但作者识别并分析了出现投影歧义的场景，传统的sim3不能够完全解决这个问题。而作者他们结合了projective constraints来解决这个问题。</p></blockquote></li><li><p>Finally, we propose the first factor graph formulation that operates directly on the SL(4) manifold to address projective ambiguity. Even in practical scenarios, where projective ambiguity is less dominant, we show that SL(4)-based optimization achieves performance competitive with or superior to other state-of-the-art learning-based SLAM approaches, offering a principled framework for handling cases where similarity transformations are insufficient.</p><blockquote><p>提出了第一个直接作用于SL(4)流形的因子图公式来解决投影歧义。即使在投影模糊不占主导地位的实际场景中，我们也表明基于SL(4)的优化实现了与其他最先进的基于学习的SLAM方法相竞争或优于的性能，为处理相似转换不足的情况提供了一个原则性框架。</p></blockquote></li></ul><h2 id="与相似的工作MASt3R-SLAM的对比"><a href="#与相似的工作MASt3R-SLAM的对比" class="headerlink" title="与相似的工作MASt3R-SLAM的对比"></a>与相似的工作MASt3R-SLAM的对比</h2><p>Most similar to ours is MASt3R-SLAM [44]. MASt3R-SLAM leverages MASt3R to construct an impressive real time dense monocular SLAM system that does not require known calibration. Their pipeline also includes efficient optimization over Sim(3) poses and loop closures. Since MASt3R is limited to two input frames at a time, here, we desire to build on top of the more powerful VGGT architecture for a SLAM system which can leverage broader information of the scene by taking in an arbitrary number of frames for feed-forward reconstruction (bounded by computational limits) and provides direct estimates of camera poses. However, as mentioned, fusing submaps from VGGT goes beyond a traditional point cloud registration problem as alignment cannot be effectively performed with only a similarity transformation. Unlike MASt3R-SLAM, as will be discussed in Sec. 4.2, we do not need to estimate correspondences between frames.</p><blockquote><p>与我们最相似的是MASt3R-SLAM[44]。MASt3R-SLAM利用MASt3R构建一个令人印象深刻的实时密集单目SLAM系统，不需要已知的校准。他们的管道还包括对Sim(3)姿势和闭环的有效优化。由于MASt3R一次限制为两个输入帧，在这里，<strong>我们希望为SLAM系统构建更强大的VGGT架构</strong>，该系统可以通过采用任意数量的帧进行前馈重建（受计算限制限制）来利用更广泛的场景信息，并提供对相机姿势的直接估计。然而，如前所述，融合来自VGGT的子地图超越了传统的点云配准问题，因为仅通过相似性变换无法有效地进行对齐。与MASt3R-SLAM不同，我们不需要估计帧之间的对应关系，这将在4.2节中讨论。</p></blockquote><h2 id="VGGT-SLAM-system"><a href="#VGGT-SLAM-system" class="headerlink" title="VGGT-SLAM system"></a>VGGT-SLAM system</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>VGGT-SLAM接受的从VGGT来的输入是什么？下面红框的内容</p><p><img src="/images/paper-reading-vggt-slam/image-20250529162618736.png"></p><p><img src="/images/paper-reading-vggt-slam/image-20250529162503357.png"></p><h3 id="Incremental-submap-based-keyframe-selection-and-generation"><a href="#Incremental-submap-based-keyframe-selection-and-generation" class="headerlink" title="Incremental submap-based keyframe selection and generation"></a>Incremental submap-based keyframe selection and generation</h3><p>VGGT-SLAM是怎么选择传递给VGGT的图像集合的呢？基于图像间的视差估计，选择关键帧，传递给VGGT一个关键帧列表。</p><p>毕竟VGGT是支持视差比较大的重建的，如果喂给VGGT稠密的帧，比如1秒30帧全塞进去，效果反而不一定好。</p><p>回顾论文abstract提到的内容“实际观测发现：当使用未标定相机时，VGGT的前馈特性会引入投影歧义——这种歧义除了包含Sim(3)的自由度外，还涉及剪切、拉伸和透视自由度，尤其<strong>在帧间视差较小时更为明显</strong>”。所以这里论文选择使用关键帧列表来作为VGGT的输入。</p><p><img src="/images/paper-reading-vggt-slam/image-20250529164532506.png"></p><p><strong>初始化和图像集合</strong>：</p><ul><li>首先，构建一个名为<code>Ilatest</code>的图像集，用于存储顺序接收到的图像。</li></ul><p><strong>视差估计和阈值选择</strong>：</p><ul><li>使用<strong>Lucas-Kanade光流法</strong>（Lucas-Kanade Optical Flow）来估算相邻图像之间的视差。这种方法能够估算图像的像素位移，进而获得视差信息。</li><li>选择一个图像作为关键帧的条件是：当前图像与上一张关键帧之间的视差大于一个用户定义的阈值<code>τdisparity</code>。即，只有在视差足够大时，才会将当前帧选为关键帧。</li><li>视差较大的帧有助于改善相对深度估计，因为它们提供了多视角信息，这对于精确的3D重建是有益的。使用多视角信息能够减少所需处理的图像数量，提高性能。</li></ul><p><strong>关键帧的添加</strong>：</p><ul><li>如果当前帧的视差足够高，它会被指定为关键帧，并添加到<code>Ilatest</code>列表中。</li><li>该列表的大小有限制（<code>w</code>），一旦达到了这个限制，新的图像就不会再加入到列表中。</li></ul><p><strong>构建子图像集</strong>：</p><ul><li>除了<code>Ilatest</code>，每个子图（submap）还会通过追加其他两组图像来构建：<ol><li><strong>Mprior</strong>：从上一个子图（submap）中选取的<strong>最后一个非回环闭合的帧</strong>（即<code>Mprior</code>），这个帧用于维持子图之间的连续性。</li><li><strong>Iloop</strong>：用于回环闭合的图像集合。最多可以包含<code>wloop</code>帧，这些帧将被用于子图的回环闭合。</li></ol></li><li>最终，构建子图的图像集为：<code>Ilatest ← {Mprior}∪Ilatest∪Iloop</code>，即将上述三组图像集合拼接起来，作为子图的图像输入。</li></ul><p><strong>生成子图</strong>：</p><ul><li>上述构建好的图像集将被输入到<strong>VGGT</strong>中，用于生成最终的子图<code>Slatest</code>。</li></ul><h3 id="Local-submap-alignment-addressing-projective-ambiguity"><a href="#Local-submap-alignment-addressing-projective-ambiguity" class="headerlink" title="Local submap alignment addressing projective ambiguity"></a>Local submap alignment addressing projective ambiguity</h3><p>为什么存在projective ambiguity呢？如何解决这个问题呢？</p><h4 id="想要解决的问题"><a href="#想要解决的问题" class="headerlink" title="想要解决的问题"></a>想要解决的问题</h4><p><strong>首先，我们跟着论文的思路，搞清楚自己要解决的问题是什么。</strong></p><p>我们希望解决的是求一个变换矩阵H，将两个有重叠的submap对齐，这里的矩阵H可以是SE(3)，也可以是Sim(3)，同样，也可以是SL(4)。比如对于lidar slam，就是一个SE(3)矩阵，而对于单目SLAM的回环等可能存在尺度差异的情况，就是一个Sim(3)矩阵。</p><h4 id="为什么会存在projective-ambiguity？"><a href="#为什么会存在projective-ambiguity？" class="headerlink" title="为什么会存在projective ambiguity？"></a>为什么会存在projective ambiguity？</h4><p>VGGT出来的点云并不是典型的点云，而是由未标定的相机构建的点云。回顾R. I. Hartley and A. Zisserman写的《Multiple View Geometry in Computer Vision》，<strong>投影重建定理</strong>（Projective Reconstruction Theorem）指出，如果来自未校准相机的两幅图像之间的对应关系唯一地决定了基本矩阵（fundamental matrix），那么该对应关系可以用来重建相应的3D点，但只是一个15自由度的单应（homography）变换。这种变换对于任何相应的点都是相同的，除了连接相机中心的直线上的点，因为这些点不能唯一地重建。</p><p>由于相机没有标定，最终的重建结果与Ground Truth之间仅相差一个<strong>投影变换（homography）</strong>，这个变换有15个自由度，属于**SL(4)**群。<code>SL(4)</code>是所有行列式为1的4×4实矩阵的群。论文特别强调<code>SL(4)</code>与常见的<code>SL(3)</code>有所不同，后者用于通常的图像变形任务，如图像配准和图像扭曲，它只有8个自由度。<code>SL(4)</code>群的投影变换可以描述三维场景的重建中出现的投影不确定性，而<code>SL(3)</code>则通常用于二维图像中的变换。</p><p>当场景先验可用时，重构可以转换为仿射重构（即，保留平行线），例如，如果已知点位于平行线上。如果进一步的先验已知，例如场景中的线是正交的，那么重建可以转换为度量重建（与真正的欧几里得重建只相差一个相似变换）。<strong>因此，VGGT能够利用学习到的场景先验来估计度量重建</strong>，但正如论文图1中所示，在最一般的情况下，当<strong>场景先验的估计不可靠时，重建会因projective ambiguity而不同</strong>，需要15自由度的单应性矩阵来校正。</p><h4 id="关于Projective-Reconstruction-Theorem"><a href="#关于Projective-Reconstruction-Theorem" class="headerlink" title="关于Projective Reconstruction Theorem"></a>关于Projective Reconstruction Theorem</h4><p><strong>为了更好地理解上面的问题，建议学习一下Projective Reconstruction∗</strong></p><p>这是专门的pdf链接：<a href="https://users.cecs.anu.edu.au/~hartley/Papers/PDF/Hartley:Encyclopedia.pdf">https://users.cecs.anu.edu.au/~hartley/Papers/PDF/Hartley:Encyclopedia.pdf</a></p><p>下面是我的一个简单介绍：</p><p><strong>关于二维平面的单应变换</strong></p><p>从<a href="https://docs.opencv.org/4.x/d9/dab/tutorial_homography.html">opencv文档</a>中找一张图来举例，二维的单应变换是将一个平面内的点映射到另一个平面内的二维投影变换，描述了三维空间平面上的点，投影到不同平面上，这些平面之间的点坐标是什么关系。</p><p><img src="/images/paper-reading-vggt-slam/homography_transformation_example2.jpg"></p><p>给定了三维空间的坐标系，我们可以通过匹配点求R和t，以及平面方程$n^TP+d =0$。</p><p>这样，整个过程可以描述为：<br>$$<br>\begin{align*}<br>s_1p_1 &amp;= KP \\<br>s_2p_2 &amp;= K(RP + t) \\<br>n^T P + d &amp;= 0 \quad \Rightarrow \quad -\frac{n^T P}{d} = 1 \\<br>s_2p_2 &amp;= K(RP + t \cdot 1) = K\left(RP - \frac{tn^T}{d}P\right) \\<br>&amp;= K\left(R - \frac{tn^T}{d}\right)P = s_1 K\left(R - \frac{tn^T}{d}\right) K^{-1} p_1 \\<br>m &amp;= \frac{s_1}{s_2} \\<br>p_2 &amp;= m K\left(R - \frac{tn^T}{d}\right) K^{-1} p_1 = m H p_1 \\<br>H &amp;= K\left(R - \frac{tn^T}{d}\right) K^{-1}<br>\end{align*}<br>$$<br>这个二维的单应变换矩阵H包含了相机内参、旋转、平移、平面方程。比如在相机标定的时候，我们拿着相机绕着标定板移动，可以通过求解H矩阵，得到相机的内参。由于p1和p2都是齐次坐标，因此H矩阵第三列最后一项h9是可以被另外两个数表示的，这导致H矩阵只有8个自由度，而且第三列与p1相乘的结果是尺度因子，后面也会被消掉。</p><p><strong>关于三维空间的单应变换</strong></p><p>回顾相机标定的例子，这是一个利用二维平面的单应变换求相机内参的过程，这有个前提——我们知道标定板的参数。假如我们并不知道标定板的参数，那这个过程是有歧义的，$\frac{t n^T}{d}$ 无法确定，导致 $H = K \left( R - \frac{t n^T}{d} \right) K^{-1}$ 中的 $R - \frac{t n^T}{d}$ 不唯一，从而相机内参也不唯一。这进一步导致，我们恢复出来的三维坐标具有不确定性，这种不确定性可能表现为坐标系的某种变换，例如缩放、旋转或畸变。恢复出的三维坐标可能在比例上不准确，或者点之间的相对位置关系失真，无法反映标定板在真实世界中的实际几何结构。</p><p>现在，我们抛开标定板，我们来审视三维空间中任意物体的重建，我们并不知道三维空间中物体的边长等相关的信息，也不知道相机的内参。这样的话，重建出来的点云和恢复的相机内参并不是唯一的，他们都会包含一个unknown projective transformation。</p><p>回顾课程<a href="http://web.stanford.edu/class/cs231a/">CS231A: Computer Vision, From 3D Perception to 3D Reconstruction and beyond</a>的透视投影矩阵(Perspective Projection Matrices)M。</p><img src="/images/paper-reading-vggt-slam/image-20221012165344068.png" style="zoom:50%;"><p>我们可以把二维平面的单应变换推广到三维空间中的单应变换：<br>$$<br>\begin{align*}<br>p_1 &amp;= H_{2d} p_2 \\<br>p_1 &amp;= M_1 P_1, \quad p_2 = M_2 P_2 \\<br>M_1 P_1 &amp;= H_{2d} M_2 P_2 \quad \Rightarrow \quad P_1 = M_1^+ H_{2d} M_2 P_2 \\<br>M_1^{+} &amp;= \left( M_1^T M_1 \right)^{-1} M_1^T \\<br>P_1 &amp;= H_{3d} P_2<br>\end{align*}<br>$$<br>这里的H矩阵是一个非奇异的4x4矩阵，表示齐次坐标之间的映射关系。</p><p>利用这个关系很容易看出，我们并不知道三维空间中物体的边长等相关的信息，也不知道相机的内参的时候，我们只能给定对应的图像坐标xij，这样的话透视投影矩阵Pi和三维点Xj不是唯一的，他们是多解的。<br>$$<br>\begin{align*}<br>x_{ij} &amp;= P_iX_j \\<br>&amp;= (P_iH^{-1})(HX_j) \\<br>&amp;= P_i’X_j’<br>\end{align*}<br>$$<br>事实上，存在一个完整的解集，表示所有可能的矩阵 H的选择。所有这些解通过投影变换相互关联，因此称为投影等价解。一个特定的解，由满足 $x_{ij} = P_iX_j$ 的相机矩阵 Pi 和点 Xj 组成，被称为场景的投影重建，它是通过给定的对应图像点计算得到的。</p><p><img src="/images/paper-reading-vggt-slam/image-20250529193426020.png"></p><p>这里我们介绍<strong>投影重建定理</strong>（The projective reconstruction theorem）：在重建问题中，之前提到过投影等价解的问题，即通过不同的投影变换可能会得到不同的解。换句话说，从二维图像中的对应点出发，我们可能会得到多组不同的三维重建解，它们彼此通过投影变换关联。但是，如果有足够多的对应点（至少8个），并且这些点不处于某些特殊的退化配置中（例如，所有点都在同一直线上，或者在同一平面内等），那么从这些点出发<strong>得到的三维重建解是唯一的，且这些解只会在投影变换下发生变化</strong>。即，<strong>虽然通过不同的投影变换可以得到不同的解，但它们代表的是同一物理场景</strong>。</p><p>也就是说，<strong>如果我们不知道相机内参，我们三维重建出来的结果，和真实的场景会相差一个投影变换。即，存在projective ambiguity。</strong></p><h4 id="如何解决这个问题呢？"><a href="#如何解决这个问题呢？" class="headerlink" title="如何解决这个问题呢？"></a>如何解决这个问题呢？</h4><p>VGGT-SLAM输入给VGGT的图像集为：<code>Ilatest ← {Mprior}∪Ilatest∪Iloop</code>，这说明submap之间存在完全一样的图像帧，这样可以产生密集的匹配关系（毕竟同一张图，不需要特征匹配）。</p><p>通过这个完全一样的图像帧，就可以去求解单应矩阵。由于单应矩阵是按比例估计的，论文按行列式的四次方根进行缩放，使得行列式是单位行列式，这样得到的矩阵属于SL(4)。</p><p>对这个问题，这个工作特意设计好了，不同的submap有完全一样的图像帧，可以得到完全对应的两个点云，这么dense的correspondence，干什么不能干？所以这篇论文求一个Homography，不过维度不一样，常见的是相机标定的Homography，是平面的；而这里是三维的，从SL(3)拓展到了SL(4)。</p><p>这里重建出来的场景和gt还是会相差一个投影变换，但是论文把不同的submap与gt相差的投影变换统一起来了，这样即使分成多个submap的重建，看起来也是几何一致的，不会存在扭曲或者分层的情况。</p><p><strong>另外，本节内容建议看对应的论文章节，更直观：</strong></p><img src="/images/paper-reading-vggt-slam/image-20250529170601400.png" style="zoom:50%;"><img src="/images/paper-reading-vggt-slam/image-20250529170627279.png" style="zoom:50%;"><h3 id="Loop-closures"><a href="#Loop-closures" class="headerlink" title="Loop closures"></a>Loop closures</h3><p><strong>图像检索（步骤 1）</strong>：</p><ul><li><strong>计算关键帧图像描述符</strong>：在每个子图中，计算并存储每个关键帧的图像描述符，使用的是SALAD描述符。</li><li><strong>回环闭合图像搜索</strong>：当最新的子图大小达到一定阈值（记作 <code>w</code>）时，系统会搜索之前子图中的关键帧，与最新子图中的关键帧进行相似性比较，寻找最相似的关键帧。<ul><li>相似性比较是基于图像描述符的L2范数（欧几里得距离）。</li><li>只有当相似度超过用户定义的阈值（<code>τdesc</code>）时，才会考虑该帧，以避免误匹配。</li><li>选出一组最相似的帧（记作 <code>Iloop</code>），这些帧将作为当前子图的关键帧并加入子图中。</li></ul></li></ul><p><strong>相对单应性估计（步骤 2）</strong>：</p><ul><li><strong>计算单应性</strong>：在图像检索过程后，系统会估计回环闭合帧（来自 <code>Iloop</code>）与检索到的子图之间的相对单应性（homography）。<ul><li>该过程不需要估计特征点对应关系，而是直接使用公式（文中提到的公式(2)）在 <code>Iloop</code> 中的帧和其在子图中的对应帧之间计算单应性。</li></ul></li><li><strong>添加回环闭合约束</strong>：通过计算得到的单应性，为最新子图 <code>Slatest</code> 和检索到的子图之间提供回环闭合约束，并将这些约束添加到因子图中。</li></ul><p><strong>替代方法</strong>：可以不使用SALAD描述符，而是使用VGGT的微调DINO骨干网络的输出令牌来生成图像描述符。然而，这种方法需要更多的内存，因为DINO输出的特征比SALAD描述符更大。相比之下，原始的SALAD方法更为节省内存，因为它存储的是较小的描述符，并且避免了存储实际图像。</p><h3 id="Backend-Nonlinear-factor-graph-optimization-on-the-SL-4-manifold"><a href="#Backend-Nonlinear-factor-graph-optimization-on-the-SL-4-manifold" class="headerlink" title="Backend: Nonlinear factor graph optimization on the SL(4) manifold"></a>Backend: Nonlinear factor graph optimization on the SL(4) manifold</h3><p>在前面的种种铺垫之后，我们现在知道VGGT-SLAM最终的目的就是，让所有的submap与gt相比，拥有相同的Homography矩阵。所以论文设计的代价函数就是：</p><img src="/images/paper-reading-vggt-slam/image-20250529215346081.png" style="zoom:50%;"><p>通过线性最小二乘可以求解这个问题，具体看论文的内容即可。</p><img src="/images/paper-reading-vggt-slam/image-20250529215708342.png" style="zoom:50%;"><h2 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h2><p><strong>我其实觉得VGGT-SLAM的实验反而证明了，VGGT训练的是比较好的，因为我看sim3和SL4其实没有太大的差别，这说明VGGT学的是很接近GT的，每次输出的结果与GT的Homography是非常相似的。</strong></p><p><img src="/images/paper-reading-vggt-slam/image-20250529215748246.png"></p><p><img src="/images/paper-reading-vggt-slam/image-20250529215905251.png"></p><p><img src="/images/paper-reading-vggt-slam/image-20250529215921317.png"></p><p><img src="/images/paper-reading-vggt-slam/image-20250529215933508.png"></p><p><img src="/images/paper-reading-vggt-slam/image-20250529215951769.png"></p><p><img src="/images/paper-reading-vggt-slam/image-20250529220108317.png"></p>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视觉SLAM </tag>
            
            <tag> 大模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DUSt3R系列工作盘点</title>
      <link href="2025/04/14/paper-reading-dust3r-series-01/"/>
      <url>2025/04/14/paper-reading-dust3r-series-01/</url>
      
        <content type="html"><![CDATA[<h2 id="DUSt3R-基础"><a href="#DUSt3R-基础" class="headerlink" title="DUSt3R 基础"></a>DUSt3R 基础</h2><h3 id="DUSt3R-Geometric-3D-Vision-Made-Easy"><a href="#DUSt3R-Geometric-3D-Vision-Made-Easy" class="headerlink" title="DUSt3R: Geometric 3D Vision Made Easy"></a>DUSt3R: Geometric 3D Vision Made Easy</h3><p><img src="/images/paper-reading-dust3r-series-01/image-20250324154136111.png"></p><p><img src="/images/paper-reading-dust3r-series-01/image-20250324154146525.png"></p><h3 id="Grounding-Image-Matching-in-3D-with-MASt3R"><a href="#Grounding-Image-Matching-in-3D-with-MASt3R" class="headerlink" title="Grounding Image Matching in 3D with MASt3R"></a>Grounding Image Matching in 3D with MASt3R</h3><p><img src="/images/paper-reading-dust3r-series-01/image-20250324154218264.png"></p><h2 id="DUSt3R相关工作"><a href="#DUSt3R相关工作" class="headerlink" title="DUSt3R相关工作"></a>DUSt3R相关工作</h2><h3 id="MASt3R-SfM-a-Fully-Integrated-Solution-for-Unconstrained-Structure-from-Motion"><a href="#MASt3R-SfM-a-Fully-Integrated-Solution-for-Unconstrained-Structure-from-Motion" class="headerlink" title="MASt3R-SfM: a Fully-Integrated Solution for Unconstrained Structure-from-Motion"></a>MASt3R-SfM: a Fully-Integrated Solution for Unconstrained Structure-from-Motion</h3><p><img src="/images/paper-reading-dust3r-series-01/image-20250324160355105.png"></p><blockquote><p>这个工作像我们之前做的项目，用dust3r来做，也是构建了合理的image pair去重建。</p></blockquote><h3 id="MASt3R-SLAM-Real-Time-Dense-SLAM-with-3D-Reconstruction-Priors"><a href="#MASt3R-SLAM-Real-Time-Dense-SLAM-with-3D-Reconstruction-Priors" class="headerlink" title="MASt3R-SLAM: Real-Time Dense SLAM with 3D Reconstruction Priors"></a>MASt3R-SLAM: Real-Time Dense SLAM with 3D Reconstruction Priors</h3><p><strong>这篇论文用了很多mast3r-sfm里面的东西。</strong></p><p>**motivation: **However, SLAM is yet to become a plug-and-play algorithm as it requires hardware expertise and calibration. Even for a minimal single camera setup with no additional sensing such as an IMU, a SLAM solution that reliably provides both accurate poses and consistent dense maps in-the-wild does not exist. Achieving such a reliable dense SLAM system would open new research avenues for spatial intelligence.</p><p>**slam和sfm相比: **While previous work has applied these priors to SfM in an offline setting with unordered image collections [10], SLAM receives data incrementally and must maintain real-time operation. This requires new perspectives on low-latency matching, careful map maintenance, and efficient methods for large-scale optimisation.</p><p>**pipeline: **本质上这是一个传统的SLAM方法，mast3r取代了其中深度获取、feature计算、回环检测的功能。也没有对mast3r进行训练。</p><p><img src="/images/paper-reading-dust3r-series-01/image-20250324161002504.png"></p><p><strong>Pointmap Matching</strong></p><p>这部分比较有意思，不过思路非常简单，先通过投影优化得到一个粗匹配，再根据feature实现细匹配。这个算法可以用cuda实现并行化，速度非常快。比mast3r论文里面的fast nn快不少。</p><img src="/images/paper-reading-dust3r-series-01/image-20250325153224276.png" style="zoom:50%;"><p><strong>不过这也导致这篇论文引入了一个假设：相机必须要有一个唯一的光心。</strong></p><img src="/images/paper-reading-dust3r-series-01/image-20250324161519198.png" style="zoom:50%;"><p><strong>Tracking and Pointmap Fusion</strong></p><img src="/images/paper-reading-dust3r-series-01/image-20250325152828469.png" style="zoom: 50%;"><p>Tracking部分，最小化3D点误差可能没有那么鲁棒，因为深度预测不一致的情况是频繁的。所以论文基于上面这个公式进行了修改，还是像Pointmap Matching那样计算directional ray error：</p><img src="/images/paper-reading-dust3r-series-01/image-20250325153103167.png" style="zoom:50%;"><p>最终，位姿求解通过下面的公式：</p><img src="/images/paper-reading-dust3r-series-01/image-20250325153401821.png" style="zoom:50%;"><p>Pointmap Fusion部分，论文提到初始的pointmap具有较大的误差和较低的置信度，他们尝试了各种方法，最后发现加权平均最适合在过滤噪声的同时保持一致性。因此通过如下的公式来进行pointmap fusion：</p><img src="/images/paper-reading-dust3r-series-01/image-20250325153608115.png" style="zoom:50%;"><p><strong>Graph Construction and Loop Closure</strong></p><p>关键帧添加标准：valid matches数量低于阈值，或者unique keyframe pixels低于阈值（这里不太理解，可能得看代码了）；</p><p>通过mast3r-sfm使用的ASMK框架来从encoded features中检索图像，实现loop detection；</p><p>检索分数高于阈值，将encoded features pair提交给mast3r decoder，如果根据Pointmap Matching的结果匹配数量高于阈值，则添加双向边。</p><p><strong>Backend Optimisation</strong></p><p>这部分的目的是保证位姿和几何形状的全局一致性。</p><blockquote><p>公式写大了，编号挤下去了哈哈哈哈哈</p></blockquote><img src="/images/paper-reading-dust3r-series-01/image-20250325153816338.png" style="zoom:50%;"><p><strong>Relocalisation</strong></p><p>做的比较传统，跟丢之后查数据库，查到有匹配的帧再添加新的边到graph中。</p><p><strong>Known Calibration</strong></p><p>从实验来看，这个对位姿精度提升比较大，但是对重建的精度提升有限。</p><p>论文做的和我想得差不多，利用相机内参来调整pointmap，反向投影，并且在像素空间上计算残差。</p><img src="/images/paper-reading-dust3r-series-01/image-20250325154203475.png" style="zoom:50%;"><p><strong>Limitations and Future Work</strong></p><p>论文提到的这个点很有意思：While we can estimate accurate geometry by filtering pointmaps in the frontend, we do not currently refine all geometry in the full global optimisation. While DROIDSLAM optimises per-pixel depth via bundle adjustment, this framework permits incoherent geometry. A method that can make pointmaps globally consistent in 3D while retaining the coherence of the original MASt3R predictions all in real-time would be an interesting direction for future work.</p><p><strong>现在我们还只能拿mast3r出来的pointmap稍加调整，用于重建，但是这些点真的对吗？这些点如果不对，应该怎么去进行调整呢？</strong></p><blockquote><p>最简单的思路：加入3DGS，通过渲染的误差来优化点的位置，还能够生成新的点。。。</p><p>复杂点的思路目前暂时没有了。</p></blockquote><h3 id="SLAM3R-Real-Time-Dense-Scene-Reconstruction-from-Monocular-RGB-Videos"><a href="#SLAM3R-Real-Time-Dense-Scene-Reconstruction-from-Monocular-RGB-Videos" class="headerlink" title="SLAM3R: Real-Time Dense Scene Reconstruction from Monocular RGB Videos"></a>SLAM3R: Real-Time Dense Scene Reconstruction from Monocular RGB Videos</h3><p><img src="/images/paper-reading-dust3r-series-01/image-20250324155702081.png"></p><p>这篇文章做的还是非常有意思非常新颖的。</p><p>I2P和L2W都是基于dust3r的。I2P相当于原始的dust3r，根据图像得到点云；而L2W相当于点云版本的dust3r，根据scene和local得到融合后的scene。</p><h3 id="InstantSplat-Unbounded-Sparse-view-Pose-free-Gaussian-Splatting-in-40-Seconds"><a href="#InstantSplat-Unbounded-Sparse-view-Pose-free-Gaussian-Splatting-in-40-Seconds" class="headerlink" title="InstantSplat: Unbounded Sparse-view Pose-free Gaussian Splatting in 40 Seconds"></a>InstantSplat: Unbounded Sparse-view Pose-free Gaussian Splatting in 40 Seconds</h3><p>这看着只是把dust3r拿过来用了一下。</p><p><img src="/images/paper-reading-dust3r-series-01/image-20250325173556315.png"></p><h3 id="Splatt3R-Zero-shot-Gaussian-Splatting-from-Uncalibrated-Image-Pairs"><a href="#Splatt3R-Zero-shot-Gaussian-Splatting-from-Uncalibrated-Image-Pairs" class="headerlink" title="Splatt3R: Zero-shot Gaussian Splatting from Uncalibrated Image Pairs"></a>Splatt3R: Zero-shot Gaussian Splatting from Uncalibrated Image Pairs</h3><p>这个做的比InstantSplat有意思，添加了一个Gaussian Head</p><p><img src="/images/paper-reading-dust3r-series-01/image-20250326210358052.png"></p><h3 id="Fast3R-Towards-3D-Reconstruction-of-1000-Images-in-One-Forward-Pass"><a href="#Fast3R-Towards-3D-Reconstruction-of-1000-Images-in-One-Forward-Pass" class="headerlink" title="Fast3R: Towards 3D Reconstruction of 1000+ Images in One Forward Pass"></a>Fast3R: Towards 3D Reconstruction of 1000+ Images in One Forward Pass</h3><p><img src="/images/paper-reading-dust3r-series-01/image-20250326210604839.png"></p><p>关于Fusion Transformer</p><img src="/images/paper-reading-dust3r-series-01/image-20250326211536047.png" style="zoom:50%;"><h3 id="Light3R-SfM-Towards-Feed-forward-Structure-from-Motion"><a href="#Light3R-SfM-Towards-Feed-forward-Structure-from-Motion" class="headerlink" title="Light3R-SfM: Towards Feed-forward Structure-from-Motion"></a>Light3R-SfM: Towards Feed-forward Structure-from-Motion</h3><p><img src="/images/paper-reading-dust3r-series-01/image-20250326214218768.png"></p><h3 id="Align3R-Aligned-Monocular-Depth-Estimation-for-Dynamic-Videos"><a href="#Align3R-Aligned-Monocular-Depth-Estimation-for-Dynamic-Videos" class="headerlink" title="Align3R: Aligned Monocular Depth Estimation for Dynamic Videos"></a>Align3R: Aligned Monocular Depth Estimation for Dynamic Videos</h3><p>这和Pow3R做的好像啊。不过这个工作可以从视频中估计一致性的深度、点云和相机姿态。</p><p>人家Pow3R更关注怎么利用额外的信息提升重建精度。</p><p><img src="/images/paper-reading-dust3r-series-01/image-20250326221400752.png"></p><h3 id="Spann3R-3D-Reconstruction-with-Spatial-Memory"><a href="#Spann3R-3D-Reconstruction-with-Spatial-Memory" class="headerlink" title="Spann3R: 3D Reconstruction with Spatial Memory"></a>Spann3R: 3D Reconstruction with Spatial Memory</h3><p>从哪里看到对Spann3R的评价，说这个工作比较适合对物体进行重建，对场景的重建效果很不好。</p><p><img src="/images/paper-reading-dust3r-series-01/image-20250326214339434.png"></p><img src="/images/paper-reading-dust3r-series-01/image-20250326221037225.png" style="zoom:50%;"><h3 id="Pow3R-Empowering-Unconstrained-3D-Reconstruction-with-Camera-and-Scene-Priors"><a href="#Pow3R-Empowering-Unconstrained-3D-Reconstruction-with-Camera-and-Scene-Priors" class="headerlink" title="Pow3R: Empowering Unconstrained 3D Reconstruction with Camera and Scene Priors"></a>Pow3R: Empowering Unconstrained 3D Reconstruction with Camera and Scene Priors</h3><p>Dust3R不需要camera内外参信息就能完成重建，但如果在应用中有已知的内外参或稀疏深度可以在Dust3R的基础上继续提高吗？Pow3R对Dust3R的结构加装了额外模块，带来了一些提升，但也只有一点点🤏🏻</p><p><img src="/images/paper-reading-dust3r-series-01/image-20250326211856918.png"></p>]]></content>
      
      
      <categories>
          
          <category> 三维视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三维重建 </tag>
            
            <tag> 大模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VGGT：Visual Geometry Grounded Transformer</title>
      <link href="2025/04/06/paper-reading-vggt/"/>
      <url>2025/04/06/paper-reading-vggt/</url>
      
        <content type="html"><![CDATA[<h1 id="VGGT-Visual-Geometry-Grounded-Transformer"><a href="#VGGT-Visual-Geometry-Grounded-Transformer" class="headerlink" title="VGGT: Visual Geometry Grounded Transformer"></a>VGGT: Visual Geometry Grounded Transformer</h1><h2 id="Motivation-amp-Contributions"><a href="#Motivation-amp-Contributions" class="headerlink" title="Motivation &amp; Contributions"></a>Motivation &amp; Contributions</h2><p><strong>Motivation</strong>：3D视觉研究中，模型通常被限制用于处理单个任务，但这样很多时候还需要使用visual geometry optimization的方法来得到可以用的效果。VGGT希望在此做出改变，从一组场景的图像，直接预测这组图像的3D属性。</p><p><strong>Contributions</strong>：To summarize, we make the following contributions: </p><ul><li>We introduce VGGT, a large feed-forward transformer that, given one, a few, or even hundreds of images of a scene, can predict all its key 3D attributes, including camera intrinsics and extrinsics, point maps, depth maps, and 3D point tracks, in seconds. </li><li>We demonstrate that VGGT’s predictions are directly usable, being highly competitive and usually better than those of state-of-the-art methods that use slow post-processing optimization techniques. </li><li>We also show that, when further combined with BA post-processing, VGGT achieves state-of-the-art results across the board, even when compared to methods that specialize in a subset of 3D tasks, often improving quality substantially.</li></ul><blockquote><p><strong>我对第三点非常好奇，与BA后处理相结合，是怎么做的，似乎没有开源的代码。这个我必须去github提issue，询问一下！</strong></p></blockquote><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p>简单明了的Architecture Overview👍</p><p><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250405212205455.png"></p><h3 id="Problem-definition-and-notation"><a href="#Problem-definition-and-notation" class="headerlink" title="Problem definition and notation"></a>Problem definition and notation</h3><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250405213528961.png" style="zoom:67%;"><p>一个可能比较关键的信息，网络架构被设计为，除了第一帧之外，所有帧不管怎么排序都是等价的。这是否说明，第一帧（参考帧）的选取，比较关键？</p><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250405215039601.png" style="zoom:67%;"><h3 id="Feature-Backbone"><a href="#Feature-Backbone" class="headerlink" title="Feature Backbone"></a>Feature Backbone</h3><p>略，论文里面有非常详细的介绍，直观易懂</p><h3 id="Prediction-heads"><a href="#Prediction-heads" class="headerlink" title="Prediction heads"></a>Prediction heads</h3><p>略，论文里面有非常详细的介绍，直观易懂</p><h3 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h3><h4 id="Training-Loss"><a href="#Training-Loss" class="headerlink" title="Training Loss"></a>Training Loss</h4><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250406152134514.png" style="zoom:67%;"><h4 id="Ground-Truth-Coordinate-Normalization"><a href="#Ground-Truth-Coordinate-Normalization" class="headerlink" title="Ground Truth Coordinate Normalization"></a>Ground Truth Coordinate Normalization</h4><p>这部分提了一个比较有意思的点:Importantly, unlike DUSt3R, we do not apply such normalization to the predictions output by the transformer; instead, we force it to learn the normalization we choose from the training data.</p><blockquote><p>作者强迫VGGT去学习作者从训练数据选择的normalization，而不是像DUSt3R一样把归一化应用到网络的输出上。这是否说明，对于同一组数据，VGGT每次预测的输出，基本是一样的呢？</p></blockquote><h4 id="Implementation-Details"><a href="#Implementation-Details" class="headerlink" title="Implementation Details"></a>Implementation Details</h4><p>训练的输入是随机的2-24帧；</p><p>训练使用了64张A100，花了9天时间。</p><h4 id="Training-Data"><a href="#Training-Data" class="headerlink" title="Training Data"></a>Training Data</h4><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250406153423825.png" style="zoom:50%;"><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p>VGGT+BA的效果是最好的，不过花费额的时间可能会稍微长一点。</p><blockquote><p>得去找找BA的代码才行！！！</p></blockquote><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250406153526905.png" style="zoom:67%;"><p>此外，从下面这个实验来看，预测local geometry + pose的结果比预测global geometry要好。</p><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250406153609477.png" style="zoom:67%;"><p>从消融实验来看，就像建元汇报说的那样，如果没有track，指标会下降。</p><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250406153820020.png" style="zoom:67%;"><p>其他的实验看论文吧~</p><h2 id="Discussions"><a href="#Discussions" class="headerlink" title="Discussions"></a>Discussions</h2><p>这部分作者写了很多，非常值得看一看。</p><h3 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h3><ul><li>不支持鱼眼、全景图像</li><li>极端的旋转会导致重建性能下降</li><li>大量的非刚性形变会在导致重建失败</li></ul><p>不过作者说微调可以解决这些问题。</p><h3 id="Runtime-and-Memory"><a href="#Runtime-and-Memory" class="headerlink" title="Runtime and Memory"></a>Runtime and Memory</h3><p><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250406154805976.png"></p><p>这里提到一些比较值得关注的信息：</p><ul><li><p>VGGT可以自由选择不同的branch，其中camera head是lightweight，只占用5%的运行时间和2%的GPU memory</p><blockquote><p>作者之前提到过：</p><p>VGGT模型训练好之后，加了一个类似于Lora的层，做一些简单的fine tune</p><p>把gt camera作为input，通过简单的MLP层inject进去，这样的information injection，最后的accuracy可以提高的非常高。</p><p>这个实验可以证明，这个模型是可以有up bound的。</p></blockquote></li><li><p>DPT heads可以逐帧预测，这样可以节省GPU内存占用</p></li></ul><h3 id="Patchifying"><a href="#Patchifying" class="headerlink" title="Patchifying"></a>Patchifying</h3><p>DINOv2 model</p><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250406155610010.png" style="zoom:67%;"><h3 id="Differentiable-BA"><a href="#Differentiable-BA" class="headerlink" title="Differentiable BA"></a>Differentiable BA</h3><p>看起来，VGGT的BA和VGGSfM的BA是差不多的？</p><p>不过作者提到尽管Differentiable BA表现了良好的性能，但是会导致每个training step慢4倍。</p><p>作者提到尽管他们选择在VGGT中不包含Differentiable BA，但是这也是大规模无监督训练的一个有前途的方向，可以在缺乏明确3D注释的场景中作为有效的监督信号！</p><h3 id="Single-view-Reconstruction"><a href="#Single-view-Reconstruction" class="headerlink" title="Single-view Reconstruction"></a>Single-view Reconstruction</h3><p>与DUSt3R和MASt3R不同的是，VGGT不需要duplicate single image。</p><h3 id="Normalizing-Prediction"><a href="#Normalizing-Prediction" class="headerlink" title="Normalizing Prediction"></a>Normalizing Prediction</h3><p>作者对training data做了normalization，作者的观点是：像DUSt3R这样把归一化用在网络预测的工作，不是收敛所必需的，也不利于最终的模型性能，可能会在训练阶段引入额外的不稳定性。</p><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>论文写的挺好的。这篇工作非常有挖掘的潜力，简单的网络结构，简单的loss function，大道至简。</p><p>整理一下作者演讲时提到的内容：</p><ul><li><p>Pairwise Design这种方法在深度学习时代有一个问题，很难全局训练整个场景，有一种路线是训练的时候per pair，测试的时候把多个pair的结果fusion起来，这样效果很好，但模型本身是见不到这个场景的；另一个路线是训练的时候对每一个pair进行fusion，但是作者之前做过一些尝试，这样的尝试对GPU Memory的负担太大了，作者认为不是一个可行的方案。</p></li><li><p><strong>整个框架中，最特质化的是Alternating-Attention</strong></p><p><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250403210459889.png"></p><p>为什么用global attention呢，因为多帧输入，我们希望多帧输出也很简单。</p><p>为什么需要frame attention呢，有两个原因：</p><ul><li><p>直觉上，大量的global self attention层会让模型confused，tokens的信息会在场景的层面上被平均。</p></li><li><p>另外一个更重要的原因是，不希望用frame index做position embedding，这涉及到permutation equivariant的问题。</p><p>当输入多张图片重建整个场景的时候，重建的顺序不应该随着图片输入的顺序而改变的，这是一个很重要的性质。</p><p>如果给transformer用frame index embedding，这样的性质无法保证。</p><p>所以得用Frame Attention，让模型自发的学习每一帧特征聚类。</p></li></ul></li><li><p>这种完全tokenize化的设计，以及Frame Attention保证了训练的时候可以<strong>用随机的帧数</strong>进行训练。测试的时候模型展现了很好的泛化能力。</p><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250403210723658.png" style="zoom:33%;"></li><li><p>即使从来没有训练过VGGT学习single view task，但是VGGT的表现和领域内的SOTA基本相当。</p><p><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250403212448594.png"></p><p>作者的理解：由于Alternating-Attention的设计，当输入的图片为1的时候，不需要duplicate这张图片，global attention会自然的退化为frame wised attention，保证了VGGT的泛化性。</p><p>和浙大彭思达交流这个问题，彭的意见是：很可能是因为多帧训练消除了monocular supervision的ambiguity，所以模型反而学得更好。这个可能会对monocular depth领域有一些新的启发。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 三维视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三维重建 </tag>
            
            <tag> 大模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Visual Geometry Grounded Deep Structure From Motion</title>
      <link href="2025/04/05/paper-reading-vggsfm/"/>
      <url>2025/04/05/paper-reading-vggsfm/</url>
      
        <content type="html"><![CDATA[<h1 id="Visual-Geometry-Grounded-Deep-Structure-From-Motion"><a href="#Visual-Geometry-Grounded-Deep-Structure-From-Motion" class="headerlink" title="Visual Geometry Grounded Deep Structure From Motion"></a>Visual Geometry Grounded Deep Structure From Motion</h1><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>近期SfM的工作仅仅是通过深度学习来增强SfM中的特定流程，但整理的pipeline还是原始的、不可微分的。</p><p>因此，这篇文章想要提出一种新的pipeline，即VGGSfM，其中每一个component都是fully differentiable！</p><h2 id="Problem-Setting"><a href="#Problem-Setting" class="headerlink" title="Problem Setting"></a>Problem Setting</h2><p>对于一组无序图像，VGGSfM估计相机内外参数和场景的点云。</p><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250405193417214.png" style="zoom:50%;"><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><blockquote><p>这部分写的还挺好的，嘎嘎截图就好了，都能看懂。</p></blockquote><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250405192848640.png"></p><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250405194835724.png" style="zoom:50%;"><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250405195020099.png" style="zoom:50%;"><p>VGGSfM可以分解下面四个阶段：</p><ul><li>【利用图像，估计约束】point tracking</li><li>【利用图像和约束，估计位姿】initial camera estimator</li><li>【利用约束和位姿，估计点云】triangulator</li><li>【根据约束、位姿、点云，进行BA，优化位姿和点云】Bundle Adjustment</li></ul><h3 id="Tracking"><a href="#Tracking" class="headerlink" title="Tracking"></a>Tracking</h3><p>这部分使用deep feed-forward tracking function，基于之前video point tracking的方法来实现。</p><blockquote><p>难怪建元在VGGT汇报的时候会说，希望通过大量的YouTube视频怎么怎么。。。VGGT本来是打算沿着VGGSfM做下来的。。。</p></blockquote><p>不过这部分设计和video point tracking是有区别的，因为SfM的图像是无序的，不能假定temporal smoothness or ordering，并且需要sub-pixel accuracy。</p><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250405201719035.png" style="zoom:67%;"><h3 id="Learnable-camera-amp-point-initialization"><a href="#Learnable-camera-amp-point-initialization" class="headerlink" title="Learnable camera &amp; point initialization"></a>Learnable camera &amp; point initialization</h3><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250405205009391.png" style="zoom:50%;"><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250405205018729.png" style="zoom:50%;"><h3 id="Bundle-adjustment"><a href="#Bundle-adjustment" class="headerlink" title="Bundle adjustment"></a>Bundle adjustment</h3><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250405205101630.png" style="zoom:50%;"><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250405205221360.png" style="zoom:50%;"><h3 id="Method-details"><a href="#Method-details" class="headerlink" title="Method details"></a>Method details</h3><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250405205323286.png" style="zoom:50%;"><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250405205329959.png" style="zoom:50%;"><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p>略，看论文吧。</p><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>说白了这篇文章做的事情就是：</p><ul><li>基于之前的video point tracker，设计了一个Deep point tracker，不过这个tracker支持无序图像的track</li><li>设计了一个deep camera predictor，基于transformer，估计出一个比较粗糙的pose</li><li>设计了一个deep triangulator，同样基于transformer，估计一个initial point cloud</li><li>由于网络直接估计出来的pose和point cloud误差比较大，再通过Differentiable BA来进行优化</li></ul><p>感觉这些idea，从目前来看似乎“每个人都想的到”，但现在已经不是2023年了。</p><blockquote><p>训练的部分还挺好的，用的随机帧数。FLARE都2025年了，还在固定8views的输入。</p></blockquote><p><strong>从效果上来看，differentiable BA还是比较重要的，需要关注一下！</strong></p><ul><li>引用：Luis Pineda, Taosha Fan, Maurizio Monge, Shobha Venkataraman, Paloma Sodhi, Ricky TQ Chen, Joseph Ortiz, Daniel DeTone, Austin Wang, Stuart Anderson, et al. Theseus: A library for differentiable nonlinear optimization. Advances in Neural Information Processing Systems, 35:3801– 3818, 2022. 2, 5</li><li>代码：<a href="https://github.com/facebookresearch/theseus">https://github.com/facebookresearch/theseus</a></li><li>论文：<a href="https://arxiv.org/abs/2207.09442">https://arxiv.org/abs/2207.09442</a></li></ul><p>==<strong>疑问：</strong>为什么需要differential BA？==</p>]]></content>
      
      
      <categories>
          
          <category> 三维视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三维重建 </tag>
            
            <tag> 大模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FLARE：Feed-forward Geometry, Appearance and Camera Estimation from Uncalibrated Sparse Views</title>
      <link href="2025/04/03/paper-reading-flare/"/>
      <url>2025/04/03/paper-reading-flare/</url>
      
        <content type="html"><![CDATA[<h1 id="FLARE-Feed-forward-Geometry-Appearance-and-Camera-Estimation-from-Uncalibrated-Sparse-Views"><a href="#FLARE-Feed-forward-Geometry-Appearance-and-Camera-Estimation-from-Uncalibrated-Sparse-Views" class="headerlink" title="FLARE: Feed-forward Geometry, Appearance and Camera Estimation from Uncalibrated Sparse Views"></a>FLARE: Feed-forward Geometry, Appearance and Camera Estimation from Uncalibrated Sparse Views</h1><h2 id="Motivation-amp-Contributions"><a href="#Motivation-amp-Contributions" class="headerlink" title="Motivation &amp; Contributions"></a>Motivation &amp; Contributions</h2><p><strong>Problem Setting：</strong>infer high-quality camera poses and 3D geometry from uncalibrated sparse-view images (i.e., as few as 2-8 inputs), which is a challenging yet practical setting in real-world applications.</p><p><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250403153051119.png"></p><p>Primary Contributions:</p><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250405150551279.png" style="zoom:50%;"><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p><strong>关键词</strong>：feed-forward model，cascaded learning paradigm</p><p><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250405151215026.png"></p><h3 id="Neural-Pose-Predictor"><a href="#Neural-Pose-Predictor" class="headerlink" title="Neural Pose Predictor"></a>Neural Pose Predictor</h3><p>受到posediffusion、vggsfm等工作的影响，这篇工作也放弃了feature matching，并且将位姿估计问题表述为image space to camera space的direct transformation问题，通过end-to-end transformer model来求解。</p><blockquote><p>此处作者提到了一个重要的观察：We observe that the estimated poses do not need to be very accurate—only approximating the ground truth distribution is enough. This aligns with our key insight: camera poses, even imperfect, provide essential geometric priors and spatial initialization, which significantly reduces the complexity for geometry and appearance reconstruction.</p><p>即估计的pose不需要非常精确，只要能提供必要的几何先验和空间初始化，也能够降低几何和外观重建的复杂性。</p></blockquote><p><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250405162614103.png"></p><h3 id="Multi-view-Geometry-Estimation"><a href="#Multi-view-Geometry-Estimation" class="headerlink" title="Multi-view Geometry Estimation"></a>Multi-view Geometry Estimation</h3><p>这部分的思路： Our key idea is to first learn camera-centric geometry in local frames (camera coordinate system) and then build a neural scene projector to transform it into a global world coordinate system with the guidance of estimated poses.</p><blockquote><p>先学习局部的几何，之后再在pose的指导下转换到全局坐标系</p><blockquote><p>疑问：既然已经有了FLARE这样的工作，pose可以指导网络来更好的重建。那么，给VGGT接上BA后处理的意义又在哪里呢？</p></blockquote></blockquote><p><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250405162554447.png"></p><h4 id="Camera-centric-Geometry-Estimation"><a href="#Camera-centric-Geometry-Estimation" class="headerlink" title="Camera-centric Geometry Estimation"></a>Camera-centric Geometry Estimation</h4><p>image tokens + camera tokens输入，输出local point tokens和refined pose。</p><p>通过DPT-based decoder得到local dense point map和confidence map。</p><p><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250405163131880.png"></p><h4 id="Global-Geometry-Projection"><a href="#Global-Geometry-Projection" class="headerlink" title="Global Geometry Projection"></a>Global Geometry Projection</h4><p>local point tokens和refined pose作为输入，输出global image tokens。</p><p>通过DPT-based decoder得到global dense point map和confidence map。</p><p><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250405163139834.png"></p><h3 id="3D-Gaussians-for-Appearance-Modeling"><a href="#3D-Gaussians-for-Appearance-Modeling" class="headerlink" title="3D Gaussians for Appearance Modeling"></a>3D Gaussians for Appearance Modeling</h3><p>类似于splatt3r，通过gaussian head来预测gaussian parameters。</p><p><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250405163345749.png"></p><h3 id="Training-Loss"><a href="#Training-Loss" class="headerlink" title="Training Loss"></a>Training Loss</h3><p>由于这是一个joint learning framework，因此使用由camera pose loss、geometry loss、Gaussian Splatting loss组合成的multi-task loss来进行训练。</p><p>其中camera pose loss参考VGGSFM</p><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250405164322954.png" style="zoom:50%;"><p>而geometry loss类似dust3r</p><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250405164403330.png" style="zoom:50%;"><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250405164505734.png" style="zoom:50%;"><p>Gaussian Splatting loss如下所示，还包括了depth loss，用depth anything来估计depth</p><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250405164654361.png" style="zoom:50%;"><p>最终，total loss为</p><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250405164709142.png" style="zoom:67%;"><h2 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h2><p>模型使用8 views作为input（而VGGT是随机的views）。</p><p>其他的实验看论文吧。。。</p><p><img src="/images/paper-reading-FLARE-VGGSFM-VGGT/image-20250405165448598.png"></p><p>使用camera centric，可以迫使网络去关注局部的几何，这样就不会过多关注global geometry。</p><p>上面w/o camera centric是同样的参数量训练一周的结果。</p><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>我对网络估计coarse pose，再refine，之后把refine pose用于估计global scene的过程非常的感兴趣。</p><p>FLARE估计local geometry的思路，其实和VGGT估计depth不谋而合，<strong>这两个工作或许验证了一点：estimate pose &amp; local geometry，再进行global reconstruction，效果可能会更好！</strong></p><p><strong>另外，已知的pose如何帮助网络更好的重建，是个人认为非常值得关注的问题。类似于prompt depth anything，其实也可以做一个prompt pose anything。或者，我们在VGGT的基础上，引入pose的指导，引入modern BA。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 三维视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三维重建 </tag>
            
            <tag> 大模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DenseSplat：Densifying Gaussian Splatting SLAM with Neural Radiance Prior</title>
      <link href="2025/02/22/paper-reading-densesplat/"/>
      <url>2025/02/22/paper-reading-densesplat/</url>
      
        <content type="html"><![CDATA[<h1 id="DenseSplat-Densifying-Gaussian-Splatting-SLAM-with-Neural-Radiance-Prior"><a href="#DenseSplat-Densifying-Gaussian-Splatting-SLAM-with-Neural-Radiance-Prior" class="headerlink" title="DenseSplat: Densifying Gaussian Splatting SLAM with Neural Radiance Prior"></a>DenseSplat: Densifying Gaussian Splatting SLAM with Neural Radiance Prior</h1><img src="/images/paper-reading-DenseSplat/image-20250222160543971.png"><blockquote><p>从这张图看，GPU内存占用还是挺高，而且fps也没有特别突出。</p></blockquote><p><strong>论文的motivation</strong>：Gaussian SLAM systems excel in real-time rendering and fine-grained reconstruction compared to NeRF-based systems. However, their reliance on extensive keyframes is impractical for deployment in real-world robotic systems, which typically operate under sparse-view conditions that can result in substantial holes in the map.</p><blockquote><p>这个motivation看着，不是很令人信服</p></blockquote><p><strong>论文的核心思路</strong>：To address these challenges, we propose <strong>employing NeRF priors to densify the Gaussian SLAM system</strong>. This densification is achieved through two primary mechanisms using the NeRF model: (1) its interpolation capabilities efficiently close the gaps in the map with densely positioned Gaussian primitives, and (2) it offers a robust initialization of Gaussian primitives that can be densified using extremely sparse keyframes. Moreover, NeRF-based sampling ensures an even distribution of Gaussian primitives aligned with the scene geometry and allows for manageable granularity in the scene representation through specific sampling ratios. Coupled with loop closure and bundle adjustment (BA), our method delivers state-of-the art performance across large-scale synthetic and real-world datasets.</p><blockquote><p>核心思路就是标黑的这句话：使用NeRF先验来实现Gaussian的致密化。</p></blockquote><p><strong>论文的contribution</strong>：</p><ul><li><p>We propose DenseSplat, the first SLAM system combining the advantages of NeRF and 3DGS, capable of realtime tracking, mapping, and loop correction using only sparsely sampled keyframes.</p><blockquote><p>能够只使用稀疏关键帧运行整个SLAM系统。</p></blockquote></li><li><p>By leveraging NeRF priors, DenseSplat effectively fills the gaps from unobserved or obstructed viewpoints.</p><blockquote><p>在NeRF的先验下，可以有效地填补空洞。</p></blockquote></li><li><p>We implement geometry-aware primitive sampling and pruning strategies that control the granularity of the Gaussian representation and prune inactive primitives, ensuring a high-fidelity map and real-time processing.</p><blockquote><p>几何感知的原语采样和修剪策略，控制高斯表示的粒度和修剪不活跃的原语</p></blockquote></li><li><p>We compare our method with state-of-the-art (SOTA) approaches on multiple datasets, including a challenging large-scale apartment dataset, where DenseSplat achieves superior performance.</p><blockquote><p>SOTA，而且跑了一个大规模公寓的数据集？</p></blockquote></li></ul><h2 id="System-Pipeline"><a href="#System-Pipeline" class="headerlink" title="System Pipeline"></a>System Pipeline</h2><p><img src="/images/paper-reading-DenseSplat//image-20250222161430992.png"></p><blockquote><p><strong>问题：</strong>NeRF与3DGS相比，有很好的插值能力，这带来了很好的空洞填补的能力。如果不用NeRF，3DGS可能只能填充拍到的部分，对于拍摄死角还是无法填补空洞。</p></blockquote><p>系统分为Tracking和Mapping。</p><ul><li><p>Tracking：</p><p>论文提到的做法：NeRF-based Camera Tracking，apply loop closure and bundle adjustment based on the fine-grained Gaussian map to correct accumulative drift.</p><blockquote><p>说白了就是Tracking就是一个小的NeRF SLAM。。。然后手动接了一个gaussian mapping的后端。</p></blockquote></li><li><p>Mapping：</p><p>论文提到的做法：Fine-grained Gaussian Map，这部分讲的有点点混乱，还是看论文了。</p></li><li><p>Loop Closure：</p><p>非常僵硬的地图矫正策略，企图通过优化的方式来实现loop correct，论文的说法是：our method supports real-time re-rendering and the correction of BA-induced drift errors.</p></li></ul><p>从这些信息来看的话，我严重怀疑这是一个基于Co-SLAM套了个3DGS mapping的工作。</p><h2 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h2><p>看实验的话，比较的还是老一套，做得好的SLAM系统就那么几个：</p><img src="/images/paper-reading-DenseSplat//image-20250222221852741.png" style="zoom:67%;"><img src="/images/paper-reading-DenseSplat/image-20250222221907343.png" style="zoom:67%;"><img src="/images/paper-reading-DenseSplat/image-20250222222139322.png" style="zoom:67%;"><blockquote><p>从这个实验来看的话，很多地方都比较接近Co-SLAM的表现。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式表示 </tag>
            
            <tag> 3D Gaussian Splatting </tag>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>法线图的坐标系转换</title>
      <link href="2025/02/21/normal-transform/"/>
      <url>2025/02/21/normal-transform/</url>
      
        <content type="html"><![CDATA[<h1 id="法线图的坐标系转换"><a href="#法线图的坐标系转换" class="headerlink" title="法线图的坐标系转换"></a>法线图的坐标系转换</h1><p>乙巳正月廿四日，余察位姿、深度诸图，其制式各异，存法亦殊。尤甚者，法线图所载之向，或南辕北辙，不能相契。遂穷四十八变，逐一试之，终得正解。乃纂其法，录于下方，以资后学，博诸君一哂耳。</p><p><img src="/images/normal-transform/normals.png"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">import</span> cv2<span class="token keyword">from</span> itertools <span class="token keyword">import</span> permutations<span class="token punctuation">,</span> product<span class="token keyword">def</span> <span class="token function">apply_channel_swap</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span> swap_order<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    Apply channel swap to the image based on the given channel swap order.    swap_order should be a tuple of indices, e.g., (0, 1, 2) means no swap.    """</span>    <span class="token keyword">return</span> img<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> swap_order<span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">invert_channel</span><span class="token punctuation">(</span>img<span class="token punctuation">,</span> channel_indices<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    Invert specific channels in the image (255 - value for the given channels).    channel_indices is a list of channel indices to be inverted (e.g., [0, 1] for R and G).    """</span>    img_copy <span class="token operator">=</span> img<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> channel <span class="token keyword">in</span> channel_indices<span class="token punctuation">:</span>        img_copy<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> channel<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">255</span> <span class="token operator">-</span> img_copy<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> channel<span class="token punctuation">]</span>    <span class="token keyword">return</span> img_copy<span class="token comment"># 读取A组和B组图像</span>base_path <span class="token operator">=</span> <span class="token string">'/media/Dataset/room'</span>A_path <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>base_path<span class="token punctuation">,</span> <span class="token string">'normals_from_gm-prepare'</span><span class="token punctuation">)</span>B_path <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>base_path<span class="token punctuation">,</span> <span class="token string">'normals_from_pretrain'</span><span class="token punctuation">)</span>img_name <span class="token operator">=</span> <span class="token string">'00000011.png'</span>A_img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>A_path<span class="token punctuation">,</span> img_name<span class="token punctuation">)</span><span class="token punctuation">)</span>B_img <span class="token operator">=</span> cv2<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>B_path<span class="token punctuation">,</span> img_name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 获取所有通道交换组合</span>swap_orders <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>permutations<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 获取所有取反操作的组合</span>invert_combinations <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>product<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">]</span><span class="token punctuation">,</span> repeat<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 对每个通道是否取反</span><span class="token comment"># 保存每种操作组合的结果</span>output_path <span class="token operator">=</span> <span class="token string">'output'</span>os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span>output_path<span class="token punctuation">,</span> exist_ok<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token keyword">for</span> swap_order <span class="token keyword">in</span> swap_orders<span class="token punctuation">:</span>    <span class="token keyword">for</span> invert_comb <span class="token keyword">in</span> invert_combinations<span class="token punctuation">:</span>        <span class="token comment"># 应用通道交换</span>        swapped_B_img <span class="token operator">=</span> apply_channel_swap<span class="token punctuation">(</span>B_img<span class="token punctuation">,</span> swap_order<span class="token punctuation">)</span>        <span class="token comment"># 根据取反操作选择要取反的通道</span>        channels_to_invert <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i<span class="token punctuation">,</span> invert <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>invert_comb<span class="token punctuation">)</span> <span class="token keyword">if</span> invert<span class="token punctuation">]</span>        inverted_B_img <span class="token operator">=</span> invert_channel<span class="token punctuation">(</span>swapped_B_img<span class="token punctuation">,</span> channels_to_invert<span class="token punctuation">)</span>        <span class="token comment"># 生成操作名称字符串</span>        swap_order_str <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'RGB'</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> swap_order<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># e.g., 'RGB', 'RBG', etc.</span>        invert_str <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'1'</span> <span class="token keyword">if</span> invert <span class="token keyword">else</span> <span class="token string">'0'</span> <span class="token keyword">for</span> invert <span class="token keyword">in</span> invert_comb<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># e.g., '000', '010', etc.</span>        adjusted_img_name <span class="token operator">=</span> <span class="token string-interpolation"><span class="token string">f"adjusted_B_</span><span class="token interpolation"><span class="token punctuation">{</span>swap_order_str<span class="token punctuation">}</span></span><span class="token string">_invert_</span><span class="token interpolation"><span class="token punctuation">{</span>invert_str<span class="token punctuation">}</span></span><span class="token string">.png"</span></span>        <span class="token comment"># 保存调整后的法线图</span>        cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>output_path<span class="token punctuation">,</span> adjusted_img_name<span class="token punctuation">)</span><span class="token punctuation">,</span> inverted_B_img<span class="token punctuation">)</span>cv2<span class="token punctuation">.</span>imwrite<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>output_path<span class="token punctuation">,</span> <span class="token string">"A.png"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> A_img<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 坐标系转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在mac与ubuntu上部署DeepSeek-R1模型 &amp; 7b和32b模型的简单对比测试</title>
      <link href="2025/01/28/deepseek-r1-deploy/"/>
      <url>2025/01/28/deepseek-r1-deploy/</url>
      
        <content type="html"><![CDATA[<h1 id="在mac与ubuntu上部署DeepSeek-R1模型-amp-7b和32b模型的对比测试"><a href="#在mac与ubuntu上部署DeepSeek-R1模型-amp-7b和32b模型的对比测试" class="headerlink" title="在mac与ubuntu上部署DeepSeek-R1模型 &amp; 7b和32b模型的对比测试"></a>在mac与ubuntu上部署DeepSeek-R1模型 &amp; 7b和32b模型的对比测试</h1><p><strong>笔者的硬件配置</strong></p><p>mac端：macbook air m1，16G内存</p><p>ubuntu端：i7-13700kf + RTX 4090，32G内存</p><h2 id="安装Ollama"><a href="#安装Ollama" class="headerlink" title="安装Ollama"></a>安装Ollama</h2><p>访问下面的网站，下载对应操作系统的安装包，根据提示安装。</p><p><a href="https://ollama.com/download">https://ollama.com/download</a></p><h3 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h3><p>安装完之后，直接打开，状态栏会出来一只小羊驼。</p><p><img src="/images/deepseek-r1-deploy/image_1.png"></p><p>打开mac的终端输入<code>ollama -v</code>，有如下的输出就说明安装成功了。</p><p><img src="/images/deepseek-r1-deploy/image_2.png"></p><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><p>ubuntu通过下面的指令可以很轻松的完成安装。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-fsSL</span> https://ollama.com/install.sh <span class="token operator">|</span> <span class="token function">sh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/deepseek-r1-deploy/image_3.png"></p><p>和mac一样，终端输入<code>ollama -v</code>，有如下的输出就说明安装成功了。</p><p><img src="/images/deepseek-r1-deploy/image_4.png"></p><h2 id="模型的选择与部署"><a href="#模型的选择与部署" class="headerlink" title="模型的选择与部署"></a>模型的选择与部署</h2><p>打开下面的网站，根据电脑的配置，选择合适的模型进行部署。</p><p><a href="https://ollama.com/library/deepseek-r1:1.5b">https://ollama.com/library/deepseek-r1:1.5b</a></p><h3 id="macOS-1"><a href="#macOS-1" class="headerlink" title="macOS"></a>macOS</h3><p>笔者认为mac有16G内存的话，可以先尝试一下7b的模型。</p><p><img src="/images/deepseek-r1-deploy/image_6.png"></p><p>看来M1 16G还是可以顺利运行7b的模型，占用的内存在2-4G之间。</p><p><img src="/images/deepseek-r1-deploy/image_7.png"></p><p><img src="/images/deepseek-r1-deploy/image_8.png"></p><h3 id="Ubuntu-1"><a href="#Ubuntu-1" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><p>Ubuntu的内存有点吃紧，担心模型对内存也有要求，笔者给了64G的swap空间，尝试运行32b的模型。</p><p><img src="/images/deepseek-r1-deploy/image_5.png"></p><p>能够顺利运行32b的模型，内存占用不多，显存占了22G。</p><p><img src="/images/deepseek-r1-deploy/image_9.png"></p><p><img src="/images/deepseek-r1-deploy/image_10.png"></p><h2 id="7b和32b模型的对比测试"><a href="#7b和32b模型的对比测试" class="headerlink" title="7b和32b模型的对比测试"></a>7b和32b模型的对比测试</h2><p>笔者准备了几类自己常问ChatGPT的问题，比较一下7b和32b模型。</p><p><strong>测试的问题比较少，代码部分内容较多，随机性还挺大的。这里只总结这三个问题的表现：</strong></p><ul><li><p>7b和32b在代码解析上差不太多，个人看不出区别来；</p></li><li><p>7b在代码报错问题上，只生成了一个解决方案，可能需要多次交互才能顺利解决问题；</p><p>32b的结果和ChatGPT比较接近，给了几个解决方案，其中有一个直接能解决问题的；</p></li><li><p>在代码生成上，需要计算的是相机视锥体，总共是5个点。7b给的代码是错误的，把相机后面不可见的区域也考虑进去了，算了8个点；32b的代码没有问题，计算的是相机视锥体。</p></li></ul><p>下面的内容感兴趣可以看看。</p><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><p>笔者使用gaussian splatting中的一段代码来测试这两个模型，下面是发送给这两个模型的内容。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">逐行注释下面的代码，并且总结这个函数和对应的公式，使用latex代码写出来。注意：我希望的是你把注释好的代码放在一起，返回我一整个代码块，然后再总结函数的功能，以及对应的公式。<span class="token keyword">def</span> <span class="token function">_ssim</span><span class="token punctuation">(</span>img1<span class="token punctuation">,</span> img2<span class="token punctuation">,</span> window<span class="token punctuation">,</span> window_size<span class="token punctuation">,</span> channel<span class="token punctuation">,</span> size_average<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    mu1 <span class="token operator">=</span> F<span class="token punctuation">.</span>conv2d<span class="token punctuation">(</span>img1<span class="token punctuation">,</span> window<span class="token punctuation">,</span> padding<span class="token operator">=</span>window_size <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">,</span> groups<span class="token operator">=</span>channel<span class="token punctuation">)</span>    mu2 <span class="token operator">=</span> F<span class="token punctuation">.</span>conv2d<span class="token punctuation">(</span>img2<span class="token punctuation">,</span> window<span class="token punctuation">,</span> padding<span class="token operator">=</span>window_size <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">,</span> groups<span class="token operator">=</span>channel<span class="token punctuation">)</span>    mu1_sq <span class="token operator">=</span> mu1<span class="token punctuation">.</span><span class="token builtin">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    mu2_sq <span class="token operator">=</span> mu2<span class="token punctuation">.</span><span class="token builtin">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    mu1_mu2 <span class="token operator">=</span> mu1 <span class="token operator">*</span> mu2    sigma1_sq <span class="token operator">=</span> F<span class="token punctuation">.</span>conv2d<span class="token punctuation">(</span>img1 <span class="token operator">*</span> img1<span class="token punctuation">,</span> window<span class="token punctuation">,</span> padding<span class="token operator">=</span>window_size <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">,</span> groups<span class="token operator">=</span>channel<span class="token punctuation">)</span> <span class="token operator">-</span> mu1_sq    sigma2_sq <span class="token operator">=</span> F<span class="token punctuation">.</span>conv2d<span class="token punctuation">(</span>img2 <span class="token operator">*</span> img2<span class="token punctuation">,</span> window<span class="token punctuation">,</span> padding<span class="token operator">=</span>window_size <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">,</span> groups<span class="token operator">=</span>channel<span class="token punctuation">)</span> <span class="token operator">-</span> mu2_sq    sigma12 <span class="token operator">=</span> F<span class="token punctuation">.</span>conv2d<span class="token punctuation">(</span>img1 <span class="token operator">*</span> img2<span class="token punctuation">,</span> window<span class="token punctuation">,</span> padding<span class="token operator">=</span>window_size <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">,</span> groups<span class="token operator">=</span>channel<span class="token punctuation">)</span> <span class="token operator">-</span> mu1_mu2    C1 <span class="token operator">=</span> <span class="token number">0.01</span> <span class="token operator">**</span> <span class="token number">2</span>    C2 <span class="token operator">=</span> <span class="token number">0.03</span> <span class="token operator">**</span> <span class="token number">2</span>    ssim_map <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> mu1_mu2 <span class="token operator">+</span> C1<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> sigma12 <span class="token operator">+</span> C2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mu1_sq <span class="token operator">+</span> mu2_sq <span class="token operator">+</span> C1<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>sigma1_sq <span class="token operator">+</span> sigma2_sq <span class="token operator">+</span> C2<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> size_average<span class="token punctuation">:</span>        <span class="token keyword">return</span> ssim_map<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> ssim_map<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>对于7b，它的回答是</strong></p><p><img src="/images/deepseek-r1-deploy/image_11.png"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">_ssim</span><span class="token punctuation">(</span>img1<span class="token punctuation">,</span> img2<span class="token punctuation">,</span> window<span class="token punctuation">,</span> window_size<span class="token punctuation">,</span> channel<span class="token punctuation">,</span> size_average<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 计算img1的加权均值</span>    mu1 <span class="token operator">=</span> F<span class="token punctuation">.</span>conv2d<span class="token punctuation">(</span>img1<span class="token punctuation">,</span> window<span class="token punctuation">,</span> padding<span class="token operator">=</span>window_size <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">,</span> groups<span class="token operator">=</span>channel<span class="token punctuation">)</span>    <span class="token comment"># 计算img2的加权均值</span>    mu2 <span class="token operator">=</span> F<span class="token punctuation">.</span>conv2d<span class="token punctuation">(</span>img2<span class="token punctuation">,</span> window<span class="token punctuation">,</span> padding<span class="token operator">=</span>window_size <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">,</span> groups<span class="token operator">=</span>channel<span class="token punctuation">)</span>    <span class="token comment"># 计算img1的平方并加权均值</span>    mu1_sq <span class="token operator">=</span> mu1<span class="token punctuation">.</span><span class="token builtin">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token comment"># 计算img2的平方并加权均值</span>    mu2_sq <span class="token operator">=</span> mu2<span class="token punctuation">.</span><span class="token builtin">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token comment"># 计算img1和img2乘积的加权均值</span>    mu1_mu2 <span class="token operator">=</span> mu1 <span class="token operator">*</span> mu2    <span class="token comment"># 计算img1的方差</span>    sigma1_sq <span class="token operator">=</span> F<span class="token punctuation">.</span>conv2d<span class="token punctuation">(</span>img1 <span class="token operator">*</span> img1<span class="token punctuation">,</span> window<span class="token punctuation">,</span> padding<span class="token operator">=</span>window_size <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">,</span> groups<span class="token operator">=</span>channel<span class="token punctuation">)</span> <span class="token operator">-</span> mu1_sq    <span class="token comment"># 计算img2的方差</span>    sigma2_sq <span class="token operator">=</span> F<span class="token punctuation">.</span>conv2d<span class="token punctuation">(</span>img2 <span class="token operator">*</span> img2<span class="token punctuation">,</span> window<span class="token punctuation">,</span> padding<span class="token operator">=</span>window_size <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">,</span> groups<span class="token operator">=</span>channel<span class="token punctuation">)</span> <span class="token operator">-</span> mu2_sq    <span class="token comment"># 计算img1和img2乘积的方差</span>    sigma12 <span class="token operator">=</span> F<span class="token punctuation">.</span>conv2d<span class="token punctuation">(</span>img1 <span class="token operator">*</span> img2<span class="token punctuation">,</span> window<span class="token punctuation">,</span> padding<span class="token operator">=</span>window_size <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">,</span> groups<span class="token operator">=</span>channel<span class="token punctuation">)</span> <span class="token operator">-</span> mu1_mu2    <span class="token comment"># 避免分母为零的情况</span>    C1 <span class="token operator">=</span> <span class="token number">0.01</span> <span class="token operator">**</span> <span class="token number">2</span>    C2 <span class="token operator">=</span> <span class="token number">0.03</span> <span class="token operator">**</span> <span class="token number">2</span>    <span class="token comment"># 计算SSIM映射</span>    ssim_map <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> mu1_mu2 <span class="token operator">+</span> C1<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> sigma12 <span class="token operator">+</span> C2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mu1_sq <span class="token operator">+</span> mu2_sq <span class="token operator">+</span> C1<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>sigma1_sq <span class="token operator">+</span> sigma2_sq <span class="token operator">+</span> C2<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 返回结果的平均值或通道平均值</span>    <span class="token keyword">if</span> size_average<span class="token punctuation">:</span>        <span class="token keyword">return</span> ssim_map<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> ssim_map<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment"># SSIM公式总结：</span><span class="token comment"># SSIM(img1, img2) = [ (2μ1μ2 + C1)(2σ12 + C2) ] / [ (μ1² + μ2² + C1)(σ1² + σ2² + C2) ]</span><span class="token comment"># 其中：</span><span class="token comment"># μ1和μ2是img1和img2的加权均值</span><span class="token comment"># σ1²和σ2²是img1和img2的加权方差</span><span class="token comment"># σ12是img1和img2乘积的加权协方差</span><span class="token comment"># C1和C2是防止分母为零的常数</span><span class="token comment"># size_average参数决定返回的是整体平均值还是通道级平均值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码总结：</p><ul><li>这个函数计算两个图像之间的SSIM（结构相似性）值。</li><li>它通过滑动窗口计算均值、方差和协方差，并根据预定义的常数C1和C2进行归一化。</li><li>最终返回的是整体平均值或通道级平均值，取决于size_average参数。</li></ul><p>公式总结：<br>$$<br>SSIM(img1, img2) = \frac{(2\mu_1\mu_2 + C1)(2\sigma_{12} + C2)}{(\mu_1^2 + \mu_2^2 + C1)(\sigma_1^2 + \sigma_2^2 + C2)}<br>$$<br>其中：</p><ul><li>$\mu_1$和$\mu_2$是img1和img2的加权均值</li><li>$\sigma_1^2$和$\sigma_2^2$是img1和img2的加权方差</li><li>$\sigma_{12}$是img1和img2乘积的加权协方差</li><li>$C1 = (0.01)^2$和$C2 = (0.03)^2$是防止分母为零的常数</li></ul><p><strong>对于32b，它的回答是</strong></p><p><img src="/images/deepseek-r1-deploy/image_12.png"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">_ssim</span><span class="token punctuation">(</span>img1<span class="token punctuation">,</span> img2<span class="token punctuation">,</span> window<span class="token punctuation">,</span> window_size<span class="token punctuation">,</span> channel<span class="token punctuation">,</span> size_average<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 计算第一个图像的局部均值 (Local mean of the first image)</span>    mu1 <span class="token operator">=</span> F<span class="token punctuation">.</span>conv2d<span class="token punctuation">(</span>img1<span class="token punctuation">,</span> window<span class="token punctuation">,</span> padding<span class="token operator">=</span>window_size <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">,</span> groups<span class="token operator">=</span>channel<span class="token punctuation">)</span>        <span class="token comment"># 计算第二个图像的局部均值 (Local mean of the second image)</span>    mu2 <span class="token operator">=</span> F<span class="token punctuation">.</span>conv2d<span class="token punctuation">(</span>img2<span class="token punctuation">,</span> window<span class="token punctuation">,</span> padding<span class="token operator">=</span>window_size <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">,</span> groups<span class="token operator">=</span>channel<span class="token punctuation">)</span>    <span class="token comment"># 计算两个均值的平方 (Square of means)</span>    mu1_sq <span class="token operator">=</span> mu1<span class="token punctuation">.</span><span class="token builtin">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    mu2_sq <span class="token operator">=</span> mu2<span class="token punctuation">.</span><span class="token builtin">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>        <span class="token comment"># 计算两个图像均值的乘积 (Product of means)</span>    mu1_mu2 <span class="token operator">=</span> mu1 <span class="token operator">*</span> mu2    <span class="token comment"># 计算第一个图像的方差 (Variance of the first image)</span>    sigma1_sq <span class="token operator">=</span> F<span class="token punctuation">.</span>conv2d<span class="token punctuation">(</span>img1 <span class="token operator">*</span> img1<span class="token punctuation">,</span> window<span class="token punctuation">,</span> padding<span class="token operator">=</span>window_size <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">,</span> groups<span class="token operator">=</span>channel<span class="token punctuation">)</span> <span class="token operator">-</span> mu1_sq        <span class="token comment"># 计算第二个图像的方差 (Variance of the second image)</span>    sigma2_sq <span class="token operator">=</span> F<span class="token punctuation">.</span>conv2d<span class="token punctuation">(</span>img2 <span class="token operator">*</span> img2<span class="token punctuation">,</span> window<span class="token punctuation">,</span> padding<span class="token operator">=</span>window_size <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">,</span> groups<span class="token operator">=</span>channel<span class="token punctuation">)</span> <span class="token operator">-</span> mu2_sq    <span class="token comment"># 计算两个图像之间的协方差 (Covariance between images)</span>    sigma12 <span class="token operator">=</span> F<span class="token punctuation">.</span>conv2d<span class="token punctuation">(</span>img1 <span class="token operator">*</span> img2<span class="token punctuation">,</span> window<span class="token punctuation">,</span> padding<span class="token operator">=</span>window_size <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">,</span> groups<span class="token operator">=</span>channel<span class="token punctuation">)</span> <span class="token operator">-</span> mu1_mu2    <span class="token comment"># 定义常数项，防止除零操作（一般取远小于图像亮度变化范围的值）</span>    C1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0.01</span> <span class="token operator">*</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span>    C2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0.03</span> <span class="token operator">*</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span>    <span class="token comment"># 计算SSIM相似度映射图</span>    ssim_map <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> mu1_mu2 <span class="token operator">+</span> C1<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> sigma12 <span class="token operator">+</span> C2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">/</span> \               <span class="token punctuation">(</span><span class="token punctuation">(</span>mu1_sq <span class="token operator">+</span> mu2_sq <span class="token operator">+</span> C1<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>sigma1_sq <span class="token operator">+</span> sigma2_sq <span class="token operator">+</span> C2<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 根据需要返回整体平均值或通道平均值</span>    <span class="token keyword">if</span> size_average<span class="token punctuation">:</span>        <span class="token keyword">return</span> ssim_map<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> ssim_map<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>函数总结：</p><p>该函数实现了结构相似性指数 (Structural Similarity Index, SSIM) 的计算。SSIM是一种衡量两幅图像相似度的指标，考虑了亮度（luminance）、对比度（contrast）和结构（structure）之间的差异。</p><p>公式总结：</p><p>SSIM的计算公式如下：<br>$$<br>SSIM(x, y) = \frac{(2\mu_x\mu_y + C_1)(2\sigma_{xy} + C_2)}{(\mu_x^2 + \mu_y^2 + C_1)(\sigma_x^2 + \sigma_y^2 + C_2)}<br>$$<br>其中：</p><ul><li>$\mu_x, \mu_y$ 是图像x和y的局部均值</li><li>$\sigma_x^2, \sigma_y^2$是图像x和y的方差</li><li>$\sigma_{xy}$ 是图像x和y的协方差</li><li>$C_1 = (0.01L)^2, C_2 = (0.03L)^2$是常数项，L是像素的最大值（默认为255）</li></ul><h3 id="代码报错问题排查-amp-如何解决报错"><a href="#代码报错问题排查-amp-如何解决报错" class="headerlink" title="代码报错问题排查&amp;如何解决报错"></a>代码报错问题排查&amp;如何解决报错</h3><p>这是笔者运行MonoGS的时候遇到的一个问题，下面的代码块是发送给模型的内容。</p><p>这个问题已经通过ChatGPT解决，原因是这段代码认为系统没有显示器或图形界面，切换 <code>matplotlib</code> 的后端为无显示后端，例如 <code>Agg</code>就可以了。（吐槽：matplotlib这里没有创建图形界面，保存图片居然还需要xxxxxx）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">下面这段代码，以前都没有报错过，现在突然就报错了。这是为什么？如何解决报错的问题？<span class="token keyword">def</span> <span class="token function">evaluate_evo</span><span class="token punctuation">(</span>poses_gt<span class="token punctuation">,</span> poses_est<span class="token punctuation">,</span> plot_dir<span class="token punctuation">,</span> label<span class="token punctuation">,</span> monocular<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment">## Plot</span>    traj_ref <span class="token operator">=</span> PosePath3D<span class="token punctuation">(</span>poses_se3<span class="token operator">=</span>poses_gt<span class="token punctuation">)</span>    traj_est <span class="token operator">=</span> PosePath3D<span class="token punctuation">(</span>poses_se3<span class="token operator">=</span>poses_est<span class="token punctuation">)</span>    traj_est_aligned <span class="token operator">=</span> trajectory<span class="token punctuation">.</span>align_trajectory<span class="token punctuation">(</span>        traj_est<span class="token punctuation">,</span> traj_ref<span class="token punctuation">,</span> correct_scale<span class="token operator">=</span>monocular    <span class="token punctuation">)</span>    <span class="token comment">## RMSE</span>    pose_relation <span class="token operator">=</span> metrics<span class="token punctuation">.</span>PoseRelation<span class="token punctuation">.</span>translation_part    data <span class="token operator">=</span> <span class="token punctuation">(</span>traj_ref<span class="token punctuation">,</span> traj_est_aligned<span class="token punctuation">)</span>    ape_metric <span class="token operator">=</span> metrics<span class="token punctuation">.</span>APE<span class="token punctuation">(</span>pose_relation<span class="token punctuation">)</span>    ape_metric<span class="token punctuation">.</span>process_data<span class="token punctuation">(</span>data<span class="token punctuation">)</span>    ape_stat <span class="token operator">=</span> ape_metric<span class="token punctuation">.</span>get_statistic<span class="token punctuation">(</span>metrics<span class="token punctuation">.</span>StatisticsType<span class="token punctuation">.</span>rmse<span class="token punctuation">)</span>    ape_stats <span class="token operator">=</span> ape_metric<span class="token punctuation">.</span>get_all_statistics<span class="token punctuation">(</span><span class="token punctuation">)</span>    Log<span class="token punctuation">(</span><span class="token string">"RMSE ATE \[m]"</span><span class="token punctuation">,</span> ape_stat<span class="token punctuation">,</span> tag<span class="token operator">=</span><span class="token string">"Eval"</span><span class="token punctuation">)</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>            os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>plot_dir<span class="token punctuation">,</span> <span class="token string">"stats_{}.json"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>label<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token string">"w"</span><span class="token punctuation">,</span>            encoding<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token punctuation">,</span>    <span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>        json<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>ape_stats<span class="token punctuation">,</span> f<span class="token punctuation">,</span> indent<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>    plot_mode <span class="token operator">=</span> evo<span class="token punctuation">.</span>tools<span class="token punctuation">.</span>plot<span class="token punctuation">.</span>PlotMode<span class="token punctuation">.</span>xy    fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>报错为  File <span class="token string">"slam.py"</span><span class="token punctuation">,</span> line <span class="token number">325</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">&gt;</span>    slam <span class="token operator">=</span> SLAM<span class="token punctuation">(</span>config<span class="token punctuation">,</span> save_dir<span class="token operator">=</span>save_dir<span class="token punctuation">)</span>  File <span class="token string">"slam.py"</span><span class="token punctuation">,</span> line <span class="token number">145</span><span class="token punctuation">,</span> <span class="token keyword">in</span> __init__    self<span class="token punctuation">.</span>frontend<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span>  File <span class="token string">"/home/immortalqx/Projects/MonoGS-noted/utils/slam_frontend.py"</span><span class="token punctuation">,</span> line <span class="token number">554</span><span class="token punctuation">,</span> <span class="token keyword">in</span> run    monocular<span class="token operator">=</span>self<span class="token punctuation">.</span>monocular<span class="token punctuation">,</span>  File <span class="token string">"/home/immortalqx/Projects/MonoGS-noted/utils/eval_utils.py"</span><span class="token punctuation">,</span> line <span class="token number">110</span><span class="token punctuation">,</span> <span class="token keyword">in</span> eval_ate    monocular<span class="token operator">=</span>monocular<span class="token punctuation">,</span>  File <span class="token string">"/home/immortalqx/Projects/MonoGS-noted/utils/eval_utils.py"</span><span class="token punctuation">,</span> line <span class="token number">50</span><span class="token punctuation">,</span> <span class="token keyword">in</span> evaluate_evo    fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>  File <span class="token string">"/home/immortalqx/package/anaconda3/envs/MonoGS/lib/python3.7/site-packages/matplotlib/pyplot.py"</span><span class="token punctuation">,</span> line <span class="token number">809</span><span class="token punctuation">,</span> <span class="token keyword">in</span> figure    FigureClass<span class="token operator">=</span>FigureClass<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>  File <span class="token string">"/home/immortalqx/package/anaconda3/envs/MonoGS/lib/python3.7/site-packages/matplotlib/pyplot.py"</span><span class="token punctuation">,</span> line <span class="token number">325</span><span class="token punctuation">,</span> <span class="token keyword">in</span> new_figure_manager    <span class="token keyword">return</span> _get_backend_mod<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>new_figure_manager<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>  File <span class="token string">"/home/immortalqx/package/anaconda3/envs/MonoGS/lib/python3.7/site-packages/matplotlib/backend_bases.py"</span><span class="token punctuation">,</span> line <span class="token number">3494</span><span class="token punctuation">,</span> <span class="token keyword">in</span> new_figure_manager    <span class="token keyword">return</span> cls<span class="token punctuation">.</span>new_figure_manager_given_figure<span class="token punctuation">(</span>num<span class="token punctuation">,</span> fig<span class="token punctuation">)</span>  File <span class="token string">"/home/immortalqx/package/anaconda3/envs/MonoGS/lib/python3.7/site-packages/matplotlib/backends/_backend_tk.py"</span><span class="token punctuation">,</span> line <span class="token number">966</span><span class="token punctuation">,</span> <span class="token keyword">in</span> new_figure_manager_given_figure    manager <span class="token operator">=</span> cls<span class="token punctuation">.</span>FigureManager<span class="token punctuation">(</span>canvas<span class="token punctuation">,</span> num<span class="token punctuation">,</span> window<span class="token punctuation">)</span>  File <span class="token string">"/home/immortalqx/package/anaconda3/envs/MonoGS/lib/python3.7/site-packages/matplotlib/backends/_backend_tk.py"</span><span class="token punctuation">,</span> line <span class="token number">423</span><span class="token punctuation">,</span> <span class="token keyword">in</span> __init__    self<span class="token punctuation">.</span>toolbar <span class="token operator">=</span> self<span class="token punctuation">.</span>_get_toolbar<span class="token punctuation">(</span><span class="token punctuation">)</span>  File <span class="token string">"/home/immortalqx/package/anaconda3/envs/MonoGS/lib/python3.7/site-packages/matplotlib/backends/_backend_tk.py"</span><span class="token punctuation">,</span> line <span class="token number">446</span><span class="token punctuation">,</span> <span class="token keyword">in</span> _get_toolbar    toolbar <span class="token operator">=</span> NavigationToolbar2Tk<span class="token punctuation">(</span>self<span class="token punctuation">.</span>canvas<span class="token punctuation">,</span> self<span class="token punctuation">.</span>window<span class="token punctuation">)</span>  File <span class="token string">"/home/immortalqx/package/anaconda3/envs/MonoGS/lib/python3.7/site-packages/matplotlib/backends/_backend_tk.py"</span><span class="token punctuation">,</span> line <span class="token number">558</span><span class="token punctuation">,</span> <span class="token keyword">in</span> __init__    command<span class="token operator">=</span><span class="token builtin">getattr</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">,</span>  File <span class="token string">"/home/immortalqx/package/anaconda3/envs/MonoGS/lib/python3.7/site-packages/matplotlib/backends/_backend_tk.py"</span><span class="token punctuation">,</span> line <span class="token number">680</span><span class="token punctuation">,</span> <span class="token keyword">in</span> _Button    NavigationToolbar2Tk<span class="token punctuation">.</span>_set_image_for_button<span class="token punctuation">(</span>self<span class="token punctuation">,</span> b<span class="token punctuation">)</span>  File <span class="token string">"/home/immortalqx/package/anaconda3/envs/MonoGS/lib/python3.7/site-packages/matplotlib/backends/_backend_tk.py"</span><span class="token punctuation">,</span> line <span class="token number">659</span><span class="token punctuation">,</span> <span class="token keyword">in</span> _set_image_for_button    image <span class="token operator">=</span> ImageTk<span class="token punctuation">.</span>PhotoImage<span class="token punctuation">(</span>im<span class="token punctuation">.</span>resize<span class="token punctuation">(</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> master<span class="token operator">=</span>self<span class="token punctuation">)</span>  File <span class="token string">"/home/immortalqx/package/anaconda3/envs/MonoGS/lib/python3.7/site-packages/PIL/Image.py"</span><span class="token punctuation">,</span> line <span class="token number">2171</span><span class="token punctuation">,</span> <span class="token keyword">in</span> resize    im <span class="token operator">=</span> im<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>size<span class="token punctuation">,</span> resample<span class="token punctuation">,</span> box<span class="token punctuation">)</span>  File <span class="token string">"/home/immortalqx/package/anaconda3/envs/MonoGS/lib/python3.7/site-packages/PIL/Image.py"</span><span class="token punctuation">,</span> line <span class="token number">2193</span><span class="token punctuation">,</span> <span class="token keyword">in</span> resize    <span class="token keyword">return</span> self<span class="token punctuation">.</span>_new<span class="token punctuation">(</span>self<span class="token punctuation">.</span>im<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>size<span class="token punctuation">,</span> resample<span class="token punctuation">,</span> box<span class="token punctuation">)</span><span class="token punctuation">)</span>ValueError<span class="token punctuation">:</span> height <span class="token keyword">and</span> width must be <span class="token operator">&gt;</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>7b模型的回答</strong></p><p><img src="/images/deepseek-r1-deploy/image_13.png"></p><p>通过这种方法，你应该能够解决报错的问题。如果问题仍然存在，请提供更多相关代码或上下文以便进一步诊断。</p><p>最终答案：在调用<code>plt.figure()</code>时，如果没有传递适当的<code>figsize</code>参数，可能导致绘图区域无效。通过添加合适的<code>figsize</code>参数（如10x6英寸）可以解决问题：</p><p>修改后的代码如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">evaluate_evo</span><span class="token punctuation">(</span>poses_gt<span class="token punctuation">,</span> poses_est<span class="token punctuation">,</span> plot_dir<span class="token punctuation">,</span> label<span class="token punctuation">,</span> monocular<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment">## Plot</span>    traj_ref <span class="token operator">=</span> PosePath3D<span class="token punctuation">(</span>poses_se3<span class="token operator">=</span>poses_gt<span class="token punctuation">)</span>    traj_est <span class="token operator">=</span> PosePath3D<span class="token punctuation">(</span>poses_se3<span class="token operator">=</span>poses_est<span class="token punctuation">)</span>    traj_est_aligned <span class="token operator">=</span> trajectory<span class="token punctuation">.</span>align_trajectory<span class="token punctuation">(</span>        traj_est<span class="token punctuation">,</span> traj_ref<span class="token punctuation">,</span> correct_scale<span class="token operator">=</span>monocular    <span class="token punctuation">)</span>    <span class="token comment">## RMSE</span>    pose_relation <span class="token operator">=</span> metrics<span class="token punctuation">.</span>PoseRelation<span class="token punctuation">.</span>translation_part    data <span class="token operator">=</span> <span class="token punctuation">(</span>traj_ref<span class="token punctuation">,</span> traj_est_aligned<span class="token punctuation">)</span>    ape_metric <span class="token operator">=</span> metrics<span class="token punctuation">.</span>APE<span class="token punctuation">(</span>pose_relation<span class="token punctuation">)</span>    ape_metric<span class="token punctuation">.</span>process_data<span class="token punctuation">(</span>data<span class="token punctuation">)</span>    ape_stat <span class="token operator">=</span> ape_metric<span class="token punctuation">.</span>get_statistic<span class="token punctuation">(</span>metrics<span class="token punctuation">.</span>StatisticsType rmse<span class="token punctuation">)</span>    ape_stats <span class="token operator">=</span> ape_metric<span class="token punctuation">.</span>get_all_statistics<span class="token punctuation">(</span><span class="token punctuation">)</span>    Log<span class="token punctuation">(</span><span class="token string">"RMSE ATE \[m\]"</span><span class="token punctuation">,</span> ape_stat<span class="token punctuation">,</span> tag<span class="token operator">=</span><span class="token string">"Eval"</span><span class="token punctuation">)</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>            os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>plot_dir<span class="token punctuation">,</span> <span class="token string">"stats_{}.json"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>label<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token string">"w"</span><span class="token punctuation">,</span>            encoding<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token punctuation">,</span>    <span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>        json<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>ape_stats<span class="token punctuation">,</span> f<span class="token punctuation">,</span> indent<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>    plot_mode <span class="token operator">=</span> evo<span class="token punctuation">.</span>tools<span class="token punctuation">.</span>plot<span class="token punctuation">.</span>PlotMode<span class="token punctuation">.</span>xy    fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 添加合适的图尺寸</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>32b模型的回答</strong></p><p><img src="/images/deepseek-r1-deploy/image_14.png"></p><p>为了解决报错的问题，请按照以下步骤操作：</p><ol><li><p><strong>检查当前Python环境</strong>：确保你使用的是支持图形输出的环境，或者在没有 GUI 的环境中正确配置了matplotlib。</p></li><li><p><strong>修改代码以设置合适的backend</strong>：</p><p>在你的代码中添加以下两行，放在任何导入matplotlib.pyplot之前：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> matplotlibmatplotlib<span class="token punctuation">.</span>use<span class="token punctuation">(</span><span class="token string">'Agg'</span><span class="token punctuation">)</span>  <span class="token comment"># 设置为非交互式backend</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>显式指定绘图大小（可选）</strong>：</p><p>如果仍然有问题，可以在创建figure时明确设置大小，确保宽高都是正数：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>处理异常情况</strong>：</p><p>在绘图之前，添加错误检查，防止负值或零尺寸被传递给绘图函数。</p></li><li><p><strong>重新运行代码</strong>：</p><p>应用上述修改后，再次执行代码，观察是否还出现相同错误。</p></li></ol><p>如果问题依然存在，请进一步核实PIL库的版本以及系统环境的变化，并考虑其他可能的解决方案。</p><h3 id="代码补充-amp-生成"><a href="#代码补充-amp-生成" class="headerlink" title="代码补充&amp;生成"></a>代码补充&amp;生成</h3><p>笔者不喜欢让AI生成所有的代码，笔者一般是搭建一个框架让AI来补充，并提供一些必要的说明。因此这里对比一下7b和32b模型的代码补充和生成的能力，下面是发送给模型的内容。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">我需要补充下面的代码，根据相机旋转camera_rotation、相机平移camera_position、相机的fov_x和fov_y，来计算相机视锥体的bbox，只需要计算2D的bbox，buffer_distance是对bbox扩展的比例。<span class="token keyword">def</span> <span class="token function">visualHull</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> camera_rotation<span class="token punctuation">,</span> camera_position<span class="token punctuation">,</span> buffer_distance<span class="token punctuation">,</span> fov_x<span class="token punctuation">,</span> fov_y<span class="token punctuation">,</span> min_x<span class="token punctuation">,</span> max_x<span class="token punctuation">,</span> min_z<span class="token punctuation">,</span> max_z<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 计算相机坐标系下的视锥体</span>        <span class="token comment"># 将相机坐标系下的视锥体变换到世界坐标系中</span>        <span class="token comment"># 计算世界坐标系下视锥体的bbox，并且根据buffer_distance进行扩展</span>        <span class="token comment"># 根据传入的min_x, max_x, min_z, max_z，更新min_x, max_x, min_z, max_z</span>        <span class="token comment"># 返回更新之后的min_x, max_x, min_z, max_z</span>        <span class="token keyword">return</span> min_x<span class="token punctuation">,</span> max_x<span class="token punctuation">,</span> min_z<span class="token punctuation">,</span> max_z<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>7b模型的回答</strong></p><p><img src="/images/deepseek-r1-deploy/image_16.png"></p><p>看起来你正在尝试在相机坐标系中定义一个视锥体（视界盒），然后将其变换到世界坐标系中，并根据缓冲距离扩展这个视界盒的边界框（bbox）。以下是具体的实现步骤和代码示例：</p><p>函数实现思路</p><ol><li><strong>相机坐标系到世界坐标系转换</strong><br>首先，需要将相机位置和旋转参数转换为齐次变换矩阵。通过这个矩阵可以将相机坐标系中的点转换到世界坐标系。</li><li><strong>生成视锥体边界点</strong><br>根据相机的FOV（水平和垂直）、缓冲距离和其他参数，计算出在相机坐标系中视锥体的边界点。</li><li><strong>变换到世界坐标系</strong><br>使用齐次变换矩阵将这些边界点转换到世界坐标系中。</li><li><strong>计算bbox并扩展</strong><br>计算这些点的最小和最大值（x, y, z），然后根据缓冲距离扩展bbox。</li><li><strong>更新边界参数</strong><br>根据传入的min_x、max_x等参数，更新这些参数。</li></ol><p>实现代码</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">def</span> <span class="token function">visualHull</span><span class="token punctuation">(</span>camera_rotation<span class="token punctuation">,</span> camera_position<span class="token punctuation">,</span> buffer_distance<span class="token punctuation">,</span> fov_x<span class="token punctuation">,</span> fov_y<span class="token punctuation">,</span> min_x<span class="token punctuation">,</span> max_x<span class="token punctuation">,</span> min_z<span class="token punctuation">,</span> max_z<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    计算相机视锥体的bbox，并根据缓冲距离进行扩展。        输入：        camera_rotation: 相机旋转矩阵（3x3）        camera_position: 相机位置向量（3D）        buffer_distance: 扩展的距离比例        fov_x: 水平视场角（度）        fov_y: 垂直视场角（度）        min_x, max_x, min_z, max_z: 初始边界参数        输出：        更新后的min_x, max_x, min_z, max_z    """</span>    <span class="token comment"># 将相机旋转矩阵扩展为齐次变换矩阵</span>    homogeneous_matrix <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    homogeneous_matrix<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> camera_rotation    homogeneous_matrix<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1.0</span>    homogeneous_matrix<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> camera_position        <span class="token comment"># 定义相机坐标系中的视锥体边界点</span>    <span class="token comment"># 计算水平和垂直的切片范围</span>    h_width <span class="token operator">=</span> np<span class="token punctuation">.</span>tan<span class="token punctuation">(</span>np<span class="token punctuation">.</span>radians<span class="token punctuation">(</span>fov_x <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">-</span>min_z <span class="token operator">-</span> buffer_distance<span class="token punctuation">)</span>    v_height <span class="token operator">=</span> np<span class="token punctuation">.</span>tan<span class="token punctuation">(</span>np<span class="token punctuation">.</span>radians<span class="token punctuation">(</span>fov_y <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>max_z <span class="token operator">+</span> buffer_distance<span class="token punctuation">)</span>        <span class="token comment"># 生成边界点</span>    x_points <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>h_width<span class="token punctuation">,</span> h_width<span class="token punctuation">,</span> <span class="token operator">-</span>h_width<span class="token punctuation">,</span> <span class="token operator">-</span>h_width<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># x方向的两个端点</span>        z_points <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">-</span>min_z<span class="token punctuation">,</span> max_z<span class="token punctuation">,</span> <span class="token operator">-</span>min_z<span class="token punctuation">,</span> max_z<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> buffer_distance  <span class="token comment"># z方向的两个端点</span>        y_points <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>v_height<span class="token punctuation">,</span> v_height<span class="token punctuation">,</span> <span class="token operator">-</span>v_height<span class="token punctuation">,</span> <span class="token operator">-</span>v_height<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># y方向的两个端点</span>        <span class="token comment"># 创建所有组合</span>    points <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> x <span class="token keyword">in</span> x_points<span class="token punctuation">:</span>        <span class="token keyword">for</span> z <span class="token keyword">in</span> z_points<span class="token punctuation">:</span>            <span class="token keyword">for</span> y <span class="token keyword">in</span> y_points<span class="token punctuation">:</span>                point <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                world_point <span class="token operator">=</span> homogeneous_matrix @ point                points<span class="token punctuation">.</span>append<span class="token punctuation">(</span>world_point<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 添加变换后的点</span>        <span class="token comment"># 计算bbox（世界坐标系下的边界）</span>    <span class="token keyword">if</span> <span class="token keyword">not</span> points<span class="token punctuation">:</span>        <span class="token keyword">return</span> min_x<span class="token punctuation">,</span> max_x<span class="token punctuation">,</span> min_z<span class="token punctuation">,</span> max_z        world_min_x <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">min</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">for</span> p <span class="token keyword">in</span> points<span class="token punctuation">]</span><span class="token punctuation">)</span>    world_max_x <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">for</span> p <span class="token keyword">in</span> points<span class="token punctuation">]</span><span class="token punctuation">)</span>    world_min_y <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">min</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> p <span class="token keyword">in</span> points<span class="token punctuation">]</span><span class="token punctuation">)</span>    world_max_y <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> p <span class="token keyword">in</span> points<span class="token punctuation">]</span><span class="token punctuation">)</span>    world_min_z <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">min</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token keyword">for</span> p <span class="token keyword">in</span> points<span class="token punctuation">]</span><span class="token punctuation">)</span>    world_max_z <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token keyword">for</span> p <span class="token keyword">in</span> points<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment"># 根据缓冲距离扩展bbox</span>    extended_buffer_distance <span class="token operator">=</span> buffer_distance <span class="token operator">/</span> <span class="token number">2.0</span>        new_min_x <span class="token operator">=</span> world_min_x <span class="token operator">-</span> extended_buffer_distance    new_max_x <span class="token operator">=</span> world_max_x <span class="token operator">+</span> extended_buffer_distance    new_min_y <span class="token operator">=</span> world_min_y <span class="token operator">-</span> extended_buffer_distance    new_max_y <span class="token operator">=</span> world_max_y <span class="token operator">+</span> extended_buffer_distance    new_min_z <span class="token operator">=</span> world_min_z <span class="token operator">-</span> extended_buffer_distance    new_max_z <span class="token operator">=</span> world_max_z <span class="token operator">+</span> extended_buffer_distance        <span class="token comment"># 根据传入的参数更新边界值</span>    min_x_new <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>min_x<span class="token punctuation">,</span> new_min_x<span class="token punctuation">)</span>    max_x_new <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>max_x<span class="token punctuation">,</span> new_max_x<span class="token punctuation">)</span>    min_y_new <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>min_y<span class="token punctuation">,</span> new_min_y<span class="token punctuation">)</span>  <span class="token comment"># 如果需要扩展y方向，可以考虑增加这两个变量</span>        <span class="token comment"># 返回更新后的参数（假设只关注x和z）</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>min_x_new<span class="token punctuation">,</span> max_x_new<span class="token punctuation">,</span> min_z_new<span class="token punctuation">,</span> max_z_new<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用说明</p><ol><li><p><strong>输入参数</strong>：</p><ul><li><code>camera_rotation</code>: 相机旋转矩阵（3x3）。</li><li><code>camera_position</code>: 相机位置向量（3D）。</li><li><code>buffer_distance</code>: 扩展的距离比例。</li><li><code>fov_x</code> 和 <code>fov_y</code>: 水平和垂直视场角，以度为单位。</li><li><code>min_x, max_x, min_z, max_z</code>: 初始边界参数。</li></ul></li><li><p><strong>输出</strong>：</p><ul><li>返回更新后的边界参数 <code>(min_x_new, max_x_new, min_z_new, max_z_new)</code>。</li></ul></li></ol><p>示例</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 初始化参数</span>min_x <span class="token operator">=</span> <span class="token number">0</span>max_x <span class="token operator">=</span> <span class="token number">10</span>min_z <span class="token operator">=</span> <span class="token number">5</span>max_z <span class="token operator">=</span> <span class="token number">20</span><span class="token comment"># 相机参数</span>camera_rotation <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                             <span class="token punctuation">[</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                             <span class="token punctuation">[</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 无旋转</span>camera_position <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">15.0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment"># 相机位置</span><span class="token comment"># 计算视觉锥体并扩展bbox</span>buffer_distance <span class="token operator">=</span> <span class="token number">1.0</span>fov_x <span class="token operator">=</span> <span class="token number">60.0</span>fov_y <span class="token operator">=</span> <span class="token number">45.0</span>new_min_x<span class="token punctuation">,</span> new_max_x<span class="token punctuation">,</span> new_min_z<span class="token punctuation">,</span> new_max_z <span class="token operator">=</span> visualHull<span class="token punctuation">(</span>camera_rotation<span class="token punctuation">,</span> camera_position<span class="token punctuation">,</span> buffer_distance<span class="token punctuation">,</span> fov_x<span class="token punctuation">,</span> fov_y<span class="token punctuation">,</span> min_x<span class="token punctuation">,</span> max_x<span class="token punctuation">,</span> min_z<span class="token punctuation">,</span> max_z<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"更新后的边界："</span><span class="token punctuation">,</span> new_min_x<span class="token punctuation">,</span> new_max_x<span class="token punctuation">,</span> new_min_z<span class="token punctuation">,</span> new_max_z<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意事项</p><ol><li><strong>单位转换</strong>：视场角需要从度转换为弧度。</li><li><strong>相机坐标系方向</strong>：如果相机的z轴指向物体，需调整视锥体的方向（如将 <code>min_z</code> 和 <code>max_z</code> 替换为 <code>-min_z</code> 和 <code>-max_z</code>）。</li><li><strong>扩展距离</strong>：buffer_distance 可以根据需求调整，控制bbox的扩展程度。</li></ol><p>希望这个实现对您有帮助！</p><p><strong>32b模型的回答</strong></p><p><img src="/images/deepseek-r1-deploy/image_15.png"></p><p>步骤说明：</p><ol><li><p><strong>定义参数</strong>：<br>确定所有输入参数的意义和单位。</p></li><li><p><strong>视锥体顶点生成</strong>：</p><ul><li>根据<code>fov_x</code>和<code>fov_y</code>计算视锥体底面矩形的宽度和高度。</li><li>生成矩形四个顶点在相机坐标系下的坐标。</li></ul></li><li><p><strong>应用旋转和平移变换</strong>：</p><ul><li>对每个顶点应用<code>camera_rotation</code>，将其从相机坐标系转换到世界坐标系。</li><li>将每个顶点加上<code>camera_position</code>向量，完成平移到世界坐标系的转换。</li></ul></li><li><p><strong>计算包围盒</strong>：</p><ul><li>收集所有变换后的顶点和原点（视锥体顶点）在x和z方向上的最小值和最大值。</li><li>这些极值构成了包围盒的范围。</li></ul></li><li><p><strong>扩展包围盒</strong>：</p><ul><li>根据<code>buffer_distance</code>，向外扩展包围盒的尺寸。这里假设<code>buffer_distance</code>是一个比例，乘以当前包围盒的尺寸进行扩展。</li></ul></li><li><p><strong>更新全局范围</strong>：</p><ul><li>将扩展后的包围盒与传入的<code>min_x</code>, <code>max_x</code>, <code>min_z</code>, <code>max_z</code>进行比较，并更新这些值，确保它们包含更大的范围。</li></ul></li><li><p><strong>返回结果</strong>：</p><ul><li>返回更新后的四个边界值。</li></ul></li></ol><p>代码实现：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">def</span> <span class="token function">visualHull</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> camera_rotation<span class="token punctuation">,</span> camera_position<span class="token punctuation">,</span> buffer_distance<span class="token punctuation">,</span> fov_x<span class="token punctuation">,</span> fov_y<span class="token punctuation">,</span> min_x<span class="token punctuation">,</span> max_x<span class="token punctuation">,</span> min_z<span class="token punctuation">,</span> max_z<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 计算视锥体底面矩形的宽度和高度（假设距离为1单位长度）</span>    half_width <span class="token operator">=</span> np<span class="token punctuation">.</span>tan<span class="token punctuation">(</span>fov_x <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>    half_height <span class="token operator">=</span> np<span class="token punctuation">.</span>tan<span class="token punctuation">(</span>fov_y <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token comment"># 视锥体顶点在相机坐标系下</span>    vertices_camera <span class="token operator">=</span> <span class="token punctuation">[</span>        <span class="token punctuation">[</span>half_width<span class="token punctuation">,</span> <span class="token operator">-</span>half_height<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span>half_width<span class="token punctuation">,</span> half_height<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token operator">-</span>half_width<span class="token punctuation">,</span> half_height<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span><span class="token operator">-</span>half_width<span class="token punctuation">,</span> <span class="token operator">-</span>half_height<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">]</span>    <span class="token punctuation">]</span>        <span class="token comment"># 将顶点变换到世界坐标系</span>    vertices_world <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> vertex <span class="token keyword">in</span> vertices_camera<span class="token punctuation">:</span>        <span class="token comment"># 应用旋转</span>        rotated_vertex <span class="token operator">=</span> np<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>camera_rotation<span class="token punctuation">,</span> vertex<span class="token punctuation">)</span>        <span class="token comment"># 平移到相机位置</span>        world_vertex <span class="token operator">=</span> rotated_vertex <span class="token operator">+</span> camera_position        vertices_world<span class="token punctuation">.</span>append<span class="token punctuation">(</span>world_vertex<span class="token punctuation">)</span>        <span class="token comment"># 计算包围盒的极值（包括视锥体顶点原点）</span>    x_coords <span class="token operator">=</span> <span class="token punctuation">[</span>v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">for</span> v <span class="token keyword">in</span> vertices_world<span class="token punctuation">]</span>    z_coords <span class="token operator">=</span> <span class="token punctuation">[</span>v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token keyword">for</span> v <span class="token keyword">in</span> vertices_world<span class="token punctuation">]</span>        current_min_x <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>x_coords<span class="token punctuation">)</span>    current_max_x <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>x_coords<span class="token punctuation">)</span>    current_min_z <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>z_coords<span class="token punctuation">)</span>    current_max_z <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>z_coords<span class="token punctuation">)</span>        <span class="token comment"># 包括视锥体顶点原点</span>    origin <span class="token operator">=</span> camera_position    x_coords<span class="token punctuation">.</span>append<span class="token punctuation">(</span>origin<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    z_coords<span class="token punctuation">.</span>append<span class="token punctuation">(</span>origin<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    current_min_x <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>current_min_x<span class="token punctuation">,</span> origin<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    current_max_x <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>current_max_x<span class="token punctuation">,</span> origin<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    current_min_z <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>current_min_z<span class="token punctuation">,</span> origin<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    current_max_z <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>current_max_z<span class="token punctuation">,</span> origin<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment"># 扩展包围盒</span>    width <span class="token operator">=</span> current_max_x <span class="token operator">-</span> current_min_x    height <span class="token operator">=</span> current_max_z <span class="token operator">-</span> current_min_z        expanded_width <span class="token operator">=</span> width <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> buffer_distance<span class="token punctuation">)</span>    expanded_height <span class="token operator">=</span> height <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> buffer_distance<span class="token punctuation">)</span>        expanded_min_x <span class="token operator">=</span> current_min_x <span class="token operator">-</span> <span class="token punctuation">(</span>expanded_width <span class="token operator">-</span> width<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>    expanded_max_x <span class="token operator">=</span> current_max_x <span class="token operator">+</span> <span class="token punctuation">(</span>expanded_width <span class="token operator">-</span> width<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>    expanded_min_z <span class="token operator">=</span> current_min_z <span class="token operator">-</span> <span class="token punctuation">(</span>expanded_height <span class="token operator">-</span> height<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>    expanded_max_z <span class="token operator">=</span> current_max_z <span class="token operator">+</span> <span class="token punctuation">(</span>expanded_height <span class="token operator">-</span> height<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>        <span class="token comment"># 更新全局范围</span>    <span class="token keyword">if</span> expanded_min_x <span class="token operator">&lt;</span> min_x<span class="token punctuation">:</span>        min_x <span class="token operator">=</span> expanded_min_x    <span class="token keyword">if</span> expanded_max_x <span class="token operator">&gt;</span> max_x<span class="token punctuation">:</span>        max_x <span class="token operator">=</span> expanded_max_x    <span class="token keyword">if</span> expanded_min_z <span class="token operator">&lt;</span> min_z<span class="token punctuation">:</span>        min_z <span class="token operator">=</span> expanded_min_z    <span class="token keyword">if</span> expanded_max_z <span class="token operator">&gt;</span> max_z<span class="token punctuation">:</span>        max_z <span class="token operator">=</span> expanded_max_z        <span class="token keyword">return</span> <span class="token punctuation">(</span>min_x<span class="token punctuation">,</span> max_x<span class="token punctuation">,</span> min_z<span class="token punctuation">,</span> max_z<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明：</p><ul><li><p><strong>视锥体生成</strong>：根据给定的水平和垂直视场角（<code>fov_x</code> 和 <code>fov_y</code>），计算出视锥体底面矩形在相机坐标系下的四个顶点。假设视锥体的高度为1单位长度。</p></li><li><p><strong>坐标变换</strong>：每个顶点先通过旋转矩阵<code>camera_rotation</code>转换到世界坐标系，然后再应用平移变换，加上相机的位置向量<code>camera_position</code>。</p></li><li><p><strong>包围盒计算</strong>：收集所有变换后的顶点和原点（视锥体的顶点）在x和z方向上的最小值和最大值，从而得到包围盒的范围。</p></li><li><p><strong>扩展包围盒</strong>：根据给定的<code>buffer_distance</code>（这里作为比例），向外扩展包围盒的尺寸。计算新的极值，并确保扩展后的包围盒正确覆盖原视锥体区域。</p></li><li><p><strong>更新全局范围</strong>：将扩展后的包围盒与传入的全局边界进行比较，更新这些边界以包含更大的范围。</p></li><li><p><strong>返回结果</strong>：最后，返回更新后的四个边界值<code>min_x</code>, <code>max_x</code>, <code>min_z</code>, 和 <code>max_z</code>。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gaussian Splatting SLAM(MonoGS)代码梳理</title>
      <link href="2025/01/18/code-reading-monogs/"/>
      <url>2025/01/18/code-reading-monogs/</url>
      
        <content type="html"><![CDATA[<h1 id="Gaussian-Splatting-SLAM-MonoGS-代码梳理"><a href="#Gaussian-Splatting-SLAM-MonoGS-代码梳理" class="headerlink" title="Gaussian Splatting SLAM(MonoGS)代码梳理"></a>Gaussian Splatting SLAM(MonoGS)代码梳理</h1><p><strong>Gaussian Splatting SLAM</strong></p><p>CVPR 2024 <font color="red">(Highlight &amp; Best Demo Award)</font></p><ul><li><strong>主页</strong>：<a href="https://rmurai.co.uk/projects/GaussianSplattingSLAM">https://rmurai.co.uk/projects/GaussianSplattingSLAM</a></li><li><strong>代码</strong>：<a href="https://github.com/muskie82/MonoGS">https://github.com/muskie82/MonoGS</a></li><li><strong>论文</strong>：<a href="https://arxiv.org/abs/2312.06741">https://arxiv.org/abs/2312.06741</a></li><li><strong>视频</strong>：<a href="https://www.youtube.com/watch?v=x604ghp9R_Q">https://www.youtube.com/watch?v=x604ghp9R_Q</a></li></ul><h2 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h2><p>MonoGS整体分为两个线程：Tracking和Mapping。</p><p>Keyframing只是衔接Tracking线程和Mapping线程，选择Tracking线程中的某些frame作为keyframe，而Mapping也只对keyframe做重建。</p><p><img src="/images/code-reading-monogs/0.png"></p><h2 id="代码整体逻辑"><a href="#代码整体逻辑" class="headerlink" title="代码整体逻辑"></a>代码整体逻辑</h2><p>整个SLAM系统作为一个类实现在<code>SLAM.py</code>中，而且在<code>__init__()</code>的时候就运行了所有的线程：</p><ul><li>gui_process</li><li>backend_process</li><li>frontend_process</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># ################## SYSTEM STEP 2.1.3 : 启动各个进程 ################## START</span><span class="token comment"># 为什么先创建 backend_process, 再创建 gui_process？</span><span class="token comment"># 改了一下顺序跑代码，看起来是没有影响的。</span><span class="token comment"># backend_process = mp.Process(target=self.backend.run) # 官方的顺序</span><span class="token keyword">if</span> self<span class="token punctuation">.</span>use_gui<span class="token punctuation">:</span>    <span class="token comment"># 创建一个 GUI 进程，目标函数为 slam_gui.run，传递参数 self.params_gui</span>    gui_process <span class="token operator">=</span> mp<span class="token punctuation">.</span>Process<span class="token punctuation">(</span>target<span class="token operator">=</span>slam_gui<span class="token punctuation">.</span>run<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>params_gui<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 启动 GUI 进程</span>    gui_process<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 等待5秒，主要是等 GUI 界面加载好</span>    time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token comment"># 创建一个多进程对象 backend_process，目标函数为 self.backend.run</span>backend_process <span class="token operator">=</span> mp<span class="token punctuation">.</span>Process<span class="token punctuation">(</span>target<span class="token operator">=</span>self<span class="token punctuation">.</span>backend<span class="token punctuation">.</span>run<span class="token punctuation">)</span>  <span class="token comment"># 我改动的顺序</span><span class="token comment"># 启动 backend_process 进程</span>backend_process<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 主进程运行frontend</span>self<span class="token punctuation">.</span>frontend<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 前端运行结束了，利用队列传递信息，让后端暂停</span>backend_queue<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"pause"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># 记录结束的时间</span>end<span class="token punctuation">.</span>record<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 在CUDA设备上同步所有流（streams）</span>torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>synchronize<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># empty the frontend queue</span><span class="token comment"># ################## SYSTEM STEP 2.1.3 : 启动各个进程 ################## END</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行线程之前，各种初始化工作；</p><p>运行线程之后，evaluation和线程的收尾工作，彻底关闭所有线程。</p><h2 id="Tracking-frontend-process"><a href="#Tracking-frontend-process" class="headerlink" title="Tracking(frontend process)"></a>Tracking(frontend process)</h2><p><strong>初始化</strong>：</p><p>在<code>slam.py</code>的<code>__init__()</code>中调用，仅仅是设置好各种参数。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">    <span class="token comment"># 初始化SLAM的前端</span>    self<span class="token punctuation">.</span>frontend <span class="token operator">=</span> FrontEnd<span class="token punctuation">(</span>self<span class="token punctuation">.</span>config<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment"># 指定前端的一系列参数</span>    self<span class="token punctuation">.</span>frontend<span class="token punctuation">.</span>dataset <span class="token operator">=</span> self<span class="token punctuation">.</span>dataset    self<span class="token punctuation">.</span>frontend<span class="token punctuation">.</span>background <span class="token operator">=</span> self<span class="token punctuation">.</span>background    self<span class="token punctuation">.</span>frontend<span class="token punctuation">.</span>pipeline_params <span class="token operator">=</span> self<span class="token punctuation">.</span>pipeline_params    self<span class="token punctuation">.</span>frontend<span class="token punctuation">.</span>frontend_queue <span class="token operator">=</span> frontend_queue    self<span class="token punctuation">.</span>frontend<span class="token punctuation">.</span>backend_queue <span class="token operator">=</span> backend_queue    self<span class="token punctuation">.</span>frontend<span class="token punctuation">.</span>q_main2vis <span class="token operator">=</span> q_main2vis    self<span class="token punctuation">.</span>frontend<span class="token punctuation">.</span>q_vis2main <span class="token operator">=</span> q_vis2main    self<span class="token punctuation">.</span>frontend<span class="token punctuation">.</span>set_hyperparams<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行</strong>：</p><p>在<code>slam.py</code>的<code>__init__()</code>中调用，主线程运行tracking。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 主进程运行frontend</span>self<span class="token punctuation">.</span>frontend<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>运行逻辑</strong>：</p><p>Tracking线程的逻辑比Mapping线程要复杂一些。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>    cur_frame_idx <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment"># 根据相机内参生成一个投影矩阵（Projection Matrix）用于计算 3D 图像的投影变换，图形学用的比较多？</span>    <span class="token comment"># znear 和 zfar 是 3D 投影中视锥体的近裁剪平面和远裁剪平面的距离，用于定义相机能够捕获的深度范围</span>    projection_matrix <span class="token operator">=</span> getProjectionMatrix2<span class="token punctuation">(</span>        znear<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">,</span>        zfar<span class="token operator">=</span><span class="token number">100.0</span><span class="token punctuation">,</span>        fx<span class="token operator">=</span>self<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>fx<span class="token punctuation">,</span>        fy<span class="token operator">=</span>self<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>fy<span class="token punctuation">,</span>        cx<span class="token operator">=</span>self<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>cx<span class="token punctuation">,</span>        cy<span class="token operator">=</span>self<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>cy<span class="token punctuation">,</span>        W<span class="token operator">=</span>self<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>width<span class="token punctuation">,</span>        H<span class="token operator">=</span>self<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>height<span class="token punctuation">,</span>    <span class="token punctuation">)</span><span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    projection_matrix <span class="token operator">=</span> projection_matrix<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token operator">=</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>    tic <span class="token operator">=</span> torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>Event<span class="token punctuation">(</span>enable_timing<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    toc <span class="token operator">=</span> torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>Event<span class="token punctuation">(</span>enable_timing<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token comment">#################################</span>    <span class="token comment"># 正式进入tracking线程</span>    <span class="token comment">#################################</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token comment">#################################</span>        <span class="token comment"># 和GUI界面通信，获取GUI界面的控制信息</span>        <span class="token comment">#################################</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>q_vis2main<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>pause<span class="token punctuation">:</span>                <span class="token keyword">continue</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            data_vis2main <span class="token operator">=</span> self<span class="token punctuation">.</span>q_vis2main<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>pause <span class="token operator">=</span> data_vis2main<span class="token punctuation">.</span>flag_pause            <span class="token keyword">if</span> self<span class="token punctuation">.</span>pause<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>backend_queue<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"pause"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">continue</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>backend_queue<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"unpause"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment">#################################</span>        <span class="token comment">#################################</span>        <span class="token comment"># tracking线程的内部逻辑</span>        <span class="token comment">#################################</span>        <span class="token comment"># 如果backend没有发送控制信息，进行正常的tracking流程</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>frontend_queue<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment">#################################</span>            <span class="token comment"># tracking前的逻辑判断</span>            <span class="token comment">#################################</span>            tic<span class="token punctuation">.</span>record<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment"># 如果运行完了整个序列，保存结果，结束循环</span>            <span class="token comment"># TODO 疑问：为什么让frontend来做这个事情，不等backend把最后几个keyframe处理一下吗？</span>            <span class="token keyword">if</span> cur_frame_idx <span class="token operator">&gt;=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>dataset<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> self<span class="token punctuation">.</span>save_results<span class="token punctuation">:</span>                    eval_ate<span class="token punctuation">(</span>                        self<span class="token punctuation">.</span>cameras<span class="token punctuation">,</span>                        self<span class="token punctuation">.</span>kf_indices<span class="token punctuation">,</span>                        self<span class="token punctuation">.</span>save_dir<span class="token punctuation">,</span>                        <span class="token number">0</span><span class="token punctuation">,</span>                        final<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>                        monocular<span class="token operator">=</span>self<span class="token punctuation">.</span>monocular<span class="token punctuation">,</span>                    <span class="token punctuation">)</span>                    save_gaussians<span class="token punctuation">(</span>                        self<span class="token punctuation">.</span>gaussians<span class="token punctuation">,</span> self<span class="token punctuation">.</span>save_dir<span class="token punctuation">,</span> <span class="token string">"final"</span><span class="token punctuation">,</span> final<span class="token operator">=</span><span class="token boolean">True</span>                    <span class="token punctuation">)</span>                <span class="token keyword">break</span>            <span class="token comment"># 如果需要初始化，进行等待</span>            <span class="token comment"># 只有被reset的时候才会需要初始化</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>requested_init<span class="token punctuation">:</span>                time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.01</span><span class="token punctuation">)</span>                <span class="token keyword">continue</span>            <span class="token comment"># 如果是单线程，而且刚创建关键帧，就先进行等待</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>single_thread <span class="token keyword">and</span> self<span class="token punctuation">.</span>requested_keyframe <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>                time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.01</span><span class="token punctuation">)</span>                <span class="token keyword">continue</span>            <span class="token comment"># 如果没有完成初始化，而且刚创建关键帧，也进行等待</span>            <span class="token keyword">if</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>initialized <span class="token keyword">and</span> self<span class="token punctuation">.</span>requested_keyframe <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>                time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.01</span><span class="token punctuation">)</span>                <span class="token keyword">continue</span>            <span class="token comment"># 创建当前帧的viewpoint</span>            viewpoint <span class="token operator">=</span> Camera<span class="token punctuation">.</span>init_from_dataset<span class="token punctuation">(</span>                self<span class="token punctuation">.</span>dataset<span class="token punctuation">,</span> cur_frame_idx<span class="token punctuation">,</span> projection_matrix            <span class="token punctuation">)</span>            <span class="token comment"># 根据边缘检测等策略，创建grad mask</span>            viewpoint<span class="token punctuation">.</span>compute_grad_mask<span class="token punctuation">(</span>self<span class="token punctuation">.</span>config<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>cameras<span class="token punctuation">[</span>cur_frame_idx<span class="token punctuation">]</span> <span class="token operator">=</span> viewpoint            <span class="token comment"># 进行初始化，注意：frontend初始化时，reset为True。</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>reset<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>initialize<span class="token punctuation">(</span>cur_frame_idx<span class="token punctuation">,</span> viewpoint<span class="token punctuation">)</span>                self<span class="token punctuation">.</span>current_window<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur_frame_idx<span class="token punctuation">)</span>                cur_frame_idx <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">continue</span>            <span class="token comment"># 判断是否完成初始化。</span>            <span class="token comment"># 对于rgb-d，运行了initialize函数就初始化了；</span>            <span class="token comment"># 对于mono，如果current_window积攒了足够的数据，就认为能够支持正确的初始化。</span>            self<span class="token punctuation">.</span>initialized <span class="token operator">=</span> self<span class="token punctuation">.</span>initialized <span class="token keyword">or</span> <span class="token punctuation">(</span>                <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>current_window<span class="token punctuation">)</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>window_size            <span class="token punctuation">)</span>            <span class="token comment">#################################</span>            <span class="token comment"># Tracking</span>            render_pkg <span class="token operator">=</span> self<span class="token punctuation">.</span>tracking<span class="token punctuation">(</span>cur_frame_idx<span class="token punctuation">,</span> viewpoint<span class="token punctuation">)</span>            <span class="token comment">#################################</span>            <span class="token comment"># 和GUI相关的代码，对tracking主要逻辑没有影响</span>            <span class="token comment">#################################</span>            current_window_dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>            current_window_dict<span class="token punctuation">[</span>self<span class="token punctuation">.</span>current_window<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>current_window<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>            keyframes <span class="token operator">=</span> <span class="token punctuation">[</span>self<span class="token punctuation">.</span>cameras<span class="token punctuation">[</span>kf_idx<span class="token punctuation">]</span> <span class="token keyword">for</span> kf_idx <span class="token keyword">in</span> self<span class="token punctuation">.</span>current_window<span class="token punctuation">]</span>            self<span class="token punctuation">.</span>q_main2vis<span class="token punctuation">.</span>put<span class="token punctuation">(</span>                gui_utils<span class="token punctuation">.</span>GaussianPacket<span class="token punctuation">(</span>                    gaussians<span class="token operator">=</span>clone_obj<span class="token punctuation">(</span>self<span class="token punctuation">.</span>gaussians<span class="token punctuation">)</span><span class="token punctuation">,</span>                    current_frame<span class="token operator">=</span>viewpoint<span class="token punctuation">,</span>                    keyframes<span class="token operator">=</span>keyframes<span class="token punctuation">,</span>                    kf_window<span class="token operator">=</span>current_window_dict<span class="token punctuation">,</span>                <span class="token punctuation">)</span>            <span class="token punctuation">)</span>            <span class="token comment">#################################</span>            <span class="token comment">#################################</span>            <span class="token comment"># keyframe创建、管理流程</span>            <span class="token comment">#################################</span>            <span class="token comment"># 如果创建了新的keyframe，那么释放当前帧的内存，并且跳过下面的步骤</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>requested_keyframe <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>cleanup<span class="token punctuation">(</span>cur_frame_idx<span class="token punctuation">)</span>                cur_frame_idx <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">continue</span>            <span class="token comment"># 如果目前没有新的keyframe，开始判断是否创建keyframe</span>            last_keyframe_idx <span class="token operator">=</span> self<span class="token punctuation">.</span>current_window<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>            check_time <span class="token operator">=</span> <span class="token punctuation">(</span>cur_frame_idx <span class="token operator">-</span> last_keyframe_idx<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> self<span class="token punctuation">.</span>kf_interval            curr_visibility <span class="token operator">=</span> <span class="token punctuation">(</span>render_pkg<span class="token punctuation">[</span><span class="token string">"n_touched"</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">long</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment"># 如果与上一个关键帧距离过大，或者重叠度较低&amp;和上个关键帧有一定的距离，就创建关键帧</span>            create_kf <span class="token operator">=</span> self<span class="token punctuation">.</span>is_keyframe<span class="token punctuation">(</span>                cur_frame_idx<span class="token punctuation">,</span>                last_keyframe_idx<span class="token punctuation">,</span>                curr_visibility<span class="token punctuation">,</span>                self<span class="token punctuation">.</span>occ_aware_visibility<span class="token punctuation">,</span>            <span class="token punctuation">)</span>            <span class="token comment"># 如果当前的滑动窗口没有满，使用更宽松的条件判断是否需要创建关键帧</span>            <span class="token comment"># TODO 疑问：如果是这样的话，可以把create_kf的条件也放进来吧？</span>            <span class="token comment">#           不过应该不存在上面的条件满足，但下面的条件不满足的情况。</span>            <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>current_window<span class="token punctuation">)</span> <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>window_size<span class="token punctuation">:</span>                union <span class="token operator">=</span> torch<span class="token punctuation">.</span>logical_or<span class="token punctuation">(</span>                    curr_visibility<span class="token punctuation">,</span> self<span class="token punctuation">.</span>occ_aware_visibility<span class="token punctuation">[</span>last_keyframe_idx<span class="token punctuation">]</span>                <span class="token punctuation">)</span><span class="token punctuation">.</span>count_nonzero<span class="token punctuation">(</span><span class="token punctuation">)</span>                intersection <span class="token operator">=</span> torch<span class="token punctuation">.</span>logical_and<span class="token punctuation">(</span>                    curr_visibility<span class="token punctuation">,</span> self<span class="token punctuation">.</span>occ_aware_visibility<span class="token punctuation">[</span>last_keyframe_idx<span class="token punctuation">]</span>                <span class="token punctuation">)</span><span class="token punctuation">.</span>count_nonzero<span class="token punctuation">(</span><span class="token punctuation">)</span>                point_ratio <span class="token operator">=</span> intersection <span class="token operator">/</span> union                create_kf <span class="token operator">=</span> <span class="token punctuation">(</span>                    check_time                    <span class="token keyword">and</span> point_ratio <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>config<span class="token punctuation">[</span><span class="token string">"Training"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"kf_overlap"</span><span class="token punctuation">]</span>                <span class="token punctuation">)</span>            <span class="token comment"># 如果是单线程模式，还要再检查一遍时间间隔是否满足要求。</span>            <span class="token comment"># WHY？因为单线程不想创建太多的关键帧？</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>single_thread<span class="token punctuation">:</span>                create_kf <span class="token operator">=</span> check_time <span class="token keyword">and</span> create_kf            <span class="token comment"># 如果确定当前帧是关键帧，创建关键帧</span>            <span class="token keyword">if</span> create_kf<span class="token punctuation">:</span>                <span class="token comment"># 将当前帧添加到滑动窗口，并且删除与当前帧重叠度小于阈值的关键帧</span>                <span class="token comment"># 如果重叠度都大于阈值，而且滑动窗口的size超了，就删除重叠的最少的那个关键帧（看起来像个BUG，为什么重叠度都这么大还会创建关键帧呢）</span>                self<span class="token punctuation">.</span>current_window<span class="token punctuation">,</span> removed <span class="token operator">=</span> self<span class="token punctuation">.</span>add_to_window<span class="token punctuation">(</span>                    cur_frame_idx<span class="token punctuation">,</span>                    curr_visibility<span class="token punctuation">,</span>                    self<span class="token punctuation">.</span>occ_aware_visibility<span class="token punctuation">,</span>                    self<span class="token punctuation">.</span>current_window<span class="token punctuation">,</span>                <span class="token punctuation">)</span>                <span class="token comment"># monocular的情况下，如果没有完成initialized，而且又有keyframe被删除，说明新进来的帧overlap较少，需要resetting。</span>                <span class="token keyword">if</span> self<span class="token punctuation">.</span>monocular <span class="token keyword">and</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>initialized <span class="token keyword">and</span> removed <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                    self<span class="token punctuation">.</span>reset <span class="token operator">=</span> <span class="token boolean">True</span>                    Log<span class="token punctuation">(</span>                        <span class="token string">"Keyframes lacks sufficient overlap to initialize the map, resetting."</span>                    <span class="token punctuation">)</span>                    <span class="token keyword">continue</span>                <span class="token comment"># 如果是monocular，使用渲染的depth和opacity来为当前关键帧创建depth</span>                <span class="token comment"># 如果是RGB-D，直接使用观测的depth，渲染的结果就不用了</span>                depth_map <span class="token operator">=</span> self<span class="token punctuation">.</span>add_new_keyframe<span class="token punctuation">(</span>                    cur_frame_idx<span class="token punctuation">,</span>                    depth<span class="token operator">=</span>render_pkg<span class="token punctuation">[</span><span class="token string">"depth"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                    opacity<span class="token operator">=</span>render_pkg<span class="token punctuation">[</span><span class="token string">"opacity"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                    init<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>                <span class="token punctuation">)</span>                <span class="token comment"># 向backend发送消息，将new keyframe发送过去</span>                self<span class="token punctuation">.</span>request_keyframe<span class="token punctuation">(</span>                    cur_frame_idx<span class="token punctuation">,</span> viewpoint<span class="token punctuation">,</span> self<span class="token punctuation">.</span>current_window<span class="token punctuation">,</span> depth_map                <span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment"># 否则，释放当前帧的内存</span>                self<span class="token punctuation">.</span>cleanup<span class="token punctuation">(</span>cur_frame_idx<span class="token punctuation">)</span>            cur_frame_idx <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token comment">#################################</span>            <span class="token comment"># 保存当前帧的评估结果</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>                self<span class="token punctuation">.</span>save_results                <span class="token keyword">and</span> self<span class="token punctuation">.</span>save_trj                <span class="token keyword">and</span> create_kf                <span class="token keyword">and</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>kf_indices<span class="token punctuation">)</span> <span class="token operator">%</span> self<span class="token punctuation">.</span>save_trj_kf_intv <span class="token operator">==</span> <span class="token number">0</span>            <span class="token punctuation">)</span><span class="token punctuation">:</span>                Log<span class="token punctuation">(</span><span class="token string">"Evaluating ATE at frame: "</span><span class="token punctuation">,</span> cur_frame_idx<span class="token punctuation">)</span>                eval_ate<span class="token punctuation">(</span>                    self<span class="token punctuation">.</span>cameras<span class="token punctuation">,</span>                    self<span class="token punctuation">.</span>kf_indices<span class="token punctuation">,</span>                    self<span class="token punctuation">.</span>save_dir<span class="token punctuation">,</span>                    cur_frame_idx<span class="token punctuation">,</span>                    monocular<span class="token operator">=</span>self<span class="token punctuation">.</span>monocular<span class="token punctuation">,</span>                <span class="token punctuation">)</span>            toc<span class="token punctuation">.</span>record<span class="token punctuation">(</span><span class="token punctuation">)</span>            torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>synchronize<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment"># FIXME 看起来如果创建了关键帧，frontend还需要等一等，这样的话tracking的速率就被限制了</span>            <span class="token comment">#  这里可能是一个小trick，keyframe到了backend之后，就要优化场景的gaussian了</span>            <span class="token comment">#  而这个期间，场景的gaussian可能不太适合tracking，会影响tracking的结果</span>            <span class="token comment">#</span>            <span class="token comment">#  可能的改进思路：创建一个mask，新增的区域不参与tracking，这样就可以全速tracking了。</span>            <span class="token comment">#   但是这样可能也有问题，overlapping变小了，tracking的结果不一定更好。</span>            <span class="token comment">#   说到底还是inverse 3DGS的tracking太脆弱了。。。</span>            <span class="token keyword">if</span> create_kf<span class="token punctuation">:</span>                <span class="token comment"># throttle at 3fps when keyframe is added</span>                duration <span class="token operator">=</span> tic<span class="token punctuation">.</span>elapsed_time<span class="token punctuation">(</span>toc<span class="token punctuation">)</span>                time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token number">0.01</span><span class="token punctuation">,</span> <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token number">3.0</span> <span class="token operator">-</span> duration <span class="token operator">/</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment"># 如果接收到了控制信息，优先处理控制信息</span>            data <span class="token operator">=</span> self<span class="token punctuation">.</span>frontend_queue<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"sync_backend"</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>sync_backend<span class="token punctuation">(</span>data<span class="token punctuation">)</span>            <span class="token keyword">elif</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"keyframe"</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>sync_backend<span class="token punctuation">(</span>data<span class="token punctuation">)</span>                self<span class="token punctuation">.</span>requested_keyframe <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"init"</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>sync_backend<span class="token punctuation">(</span>data<span class="token punctuation">)</span>                self<span class="token punctuation">.</span>requested_init <span class="token operator">=</span> <span class="token boolean">False</span>            <span class="token keyword">elif</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"stop"</span><span class="token punctuation">:</span>                Log<span class="token punctuation">(</span><span class="token string">"Frontend Stopped."</span><span class="token punctuation">)</span>                <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Mapping-backend-process"><a href="#Mapping-backend-process" class="headerlink" title="Mapping(backend process)"></a>Mapping(backend process)</h2><p><strong>初始化</strong>：</p><p>与Tracking相同，在<code>slam.py</code>的<code>__init__()</code>中调用，仅仅是设置好各种参数。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 初始化SLAM的后端</span>self<span class="token punctuation">.</span>backend <span class="token operator">=</span> BackEnd<span class="token punctuation">(</span>self<span class="token punctuation">.</span>config<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment"># 指定后端的一系列参数</span>self<span class="token punctuation">.</span>backend<span class="token punctuation">.</span>gaussians <span class="token operator">=</span> self<span class="token punctuation">.</span>gaussiansself<span class="token punctuation">.</span>backend<span class="token punctuation">.</span>background <span class="token operator">=</span> self<span class="token punctuation">.</span>backgroundself<span class="token punctuation">.</span>backend<span class="token punctuation">.</span>cameras_extent <span class="token operator">=</span> <span class="token number">6.0</span>self<span class="token punctuation">.</span>backend<span class="token punctuation">.</span>pipeline_params <span class="token operator">=</span> self<span class="token punctuation">.</span>pipeline_paramsself<span class="token punctuation">.</span>backend<span class="token punctuation">.</span>opt_params <span class="token operator">=</span> self<span class="token punctuation">.</span>opt_paramsself<span class="token punctuation">.</span>backend<span class="token punctuation">.</span>frontend_queue <span class="token operator">=</span> frontend_queueself<span class="token punctuation">.</span>backend<span class="token punctuation">.</span>backend_queue <span class="token operator">=</span> backend_queueself<span class="token punctuation">.</span>backend<span class="token punctuation">.</span>live_mode <span class="token operator">=</span> self<span class="token punctuation">.</span>live_modeself<span class="token punctuation">.</span>backend<span class="token punctuation">.</span>set_hyperparams<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行</strong>：</p><p>在<code>slam.py</code>的<code>__init__()</code>中调用，创建一个子线程运行mapping。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 创建一个多进程对象 backend_process，目标函数为 self.backend.run</span>backend_process <span class="token operator">=</span> mp<span class="token punctuation">.</span>Process<span class="token punctuation">(</span>target<span class="token operator">=</span>self<span class="token punctuation">.</span>backend<span class="token punctuation">.</span>run<span class="token punctuation">)</span><span class="token comment"># 启动 backend_process 进程</span>backend_process<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行逻辑</strong>：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment">#################################</span>    <span class="token comment"># 直奔主题，进入Mapping的主要流程</span>    <span class="token comment">#################################</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token comment"># 如果没有控制信息发送过来</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>backend_queue<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 如果是pause、当前关键帧窗口为空、单线程模式，进行等待</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>pause<span class="token punctuation">:</span>                time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.01</span><span class="token punctuation">)</span>                <span class="token keyword">continue</span>            <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>current_window<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.01</span><span class="token punctuation">)</span>                <span class="token keyword">continue</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>single_thread<span class="token punctuation">:</span>                time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.01</span><span class="token punctuation">)</span>                <span class="token keyword">continue</span>            <span class="token comment"># 否则，多线程&amp;关键帧窗口不为空，优化当前关键帧窗口，迭代1次</span>            self<span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>current_window<span class="token punctuation">)</span>            <span class="token comment"># 如果距离上一次发送关键帧已经迭代优化了10次以上，还是优化当前关键帧窗口，并且进行prune，迭代10次</span>            <span class="token comment"># 其实last_sent是记录上次和frontend同步到现在，mapping迭代了多少轮。</span>            <span class="token comment"># 不过同步一般发生在frontend向backend发送keyframe。</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>last_sent <span class="token operator">&gt;=</span> <span class="token number">10</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>current_window<span class="token punctuation">,</span> prune<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> iters<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>                self<span class="token punctuation">.</span>push_to_frontend<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token comment"># 如果有控制信息发过来</span>            data <span class="token operator">=</span> self<span class="token punctuation">.</span>backend_queue<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"stop"</span><span class="token punctuation">:</span>                <span class="token keyword">break</span>            <span class="token keyword">elif</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"pause"</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>pause <span class="token operator">=</span> <span class="token boolean">True</span>            <span class="token keyword">elif</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"unpause"</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>pause <span class="token operator">=</span> <span class="token boolean">False</span>            <span class="token keyword">elif</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"color_refinement"</span><span class="token punctuation">:</span> <span class="token comment"># 结束整个SLAM之前调用，刷一波指标</span>                self<span class="token punctuation">.</span>color_refinement<span class="token punctuation">(</span><span class="token punctuation">)</span>                self<span class="token punctuation">.</span>push_to_frontend<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">elif</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"init"</span><span class="token punctuation">:</span> <span class="token comment"># frontend在init的时候会给这里发一个init指令</span>                cur_frame_idx <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                viewpoint <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>                depth_map <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>                Log<span class="token punctuation">(</span><span class="token string">"Resetting the system"</span><span class="token punctuation">)</span>                self<span class="token punctuation">.</span>reset<span class="token punctuation">(</span><span class="token punctuation">)</span>                self<span class="token punctuation">.</span>viewpoints<span class="token punctuation">[</span>cur_frame_idx<span class="token punctuation">]</span> <span class="token operator">=</span> viewpoint                <span class="token comment"># 往场景中添加new keyframe的点云</span>                self<span class="token punctuation">.</span>add_next_kf<span class="token punctuation">(</span>                    cur_frame_idx<span class="token punctuation">,</span> viewpoint<span class="token punctuation">,</span> depth_map<span class="token operator">=</span>depth_map<span class="token punctuation">,</span> init<span class="token operator">=</span><span class="token boolean">True</span>                <span class="token punctuation">)</span>                <span class="token comment"># 初始化地图</span>                self<span class="token punctuation">.</span>initialize_map<span class="token punctuation">(</span>cur_frame_idx<span class="token punctuation">,</span> viewpoint<span class="token punctuation">)</span>                self<span class="token punctuation">.</span>push_to_frontend<span class="token punctuation">(</span><span class="token string">"init"</span><span class="token punctuation">)</span>            <span class="token keyword">elif</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"keyframe"</span><span class="token punctuation">:</span> <span class="token comment"># 如果frontend往这里发送了keyframe</span>                cur_frame_idx <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                viewpoint <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>                current_window <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>                depth_map <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span>                self<span class="token punctuation">.</span>viewpoints<span class="token punctuation">[</span>cur_frame_idx<span class="token punctuation">]</span> <span class="token operator">=</span> viewpoint                self<span class="token punctuation">.</span>current_window <span class="token operator">=</span> current_window                self<span class="token punctuation">.</span>add_next_kf<span class="token punctuation">(</span>cur_frame_idx<span class="token punctuation">,</span> viewpoint<span class="token punctuation">,</span> depth_map<span class="token operator">=</span>depth_map<span class="token punctuation">)</span>                opt_params <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>                frames_to_optimize <span class="token operator">=</span> self<span class="token punctuation">.</span>config<span class="token punctuation">[</span><span class="token string">"Training"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"pose_window"</span><span class="token punctuation">]</span>                iter_per_kf <span class="token operator">=</span> self<span class="token punctuation">.</span>mapping_itr_num <span class="token keyword">if</span> self<span class="token punctuation">.</span>single_thread <span class="token keyword">else</span> <span class="token number">10</span>                <span class="token keyword">if</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>initialized<span class="token punctuation">:</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>                        <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>current_window<span class="token punctuation">)</span>                        <span class="token operator">==</span> self<span class="token punctuation">.</span>config<span class="token punctuation">[</span><span class="token string">"Training"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"window_size"</span><span class="token punctuation">]</span>                    <span class="token punctuation">)</span><span class="token punctuation">:</span>                        frames_to_optimize <span class="token operator">=</span> <span class="token punctuation">(</span>                            self<span class="token punctuation">.</span>config<span class="token punctuation">[</span><span class="token string">"Training"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"window_size"</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span>                        <span class="token punctuation">)</span>                        iter_per_kf <span class="token operator">=</span> <span class="token number">50</span> <span class="token keyword">if</span> self<span class="token punctuation">.</span>live_mode <span class="token keyword">else</span> <span class="token number">300</span>                        Log<span class="token punctuation">(</span><span class="token string">"Performing initial BA for initialization"</span><span class="token punctuation">)</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        iter_per_kf <span class="token operator">=</span> self<span class="token punctuation">.</span>mapping_itr_num                <span class="token keyword">for</span> cam_idx <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>current_window<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> self<span class="token punctuation">.</span>current_window<span class="token punctuation">[</span>cam_idx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                        <span class="token keyword">continue</span>                    viewpoint <span class="token operator">=</span> self<span class="token punctuation">.</span>viewpoints<span class="token punctuation">[</span>current_window<span class="token punctuation">[</span>cam_idx<span class="token punctuation">]</span><span class="token punctuation">]</span>                    <span class="token keyword">if</span> cam_idx <span class="token operator">&lt;</span> frames_to_optimize<span class="token punctuation">:</span>                        opt_params<span class="token punctuation">.</span>append<span class="token punctuation">(</span>                            <span class="token punctuation">{</span>                                <span class="token string">"params"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>viewpoint<span class="token punctuation">.</span>cam_rot_delta<span class="token punctuation">]</span><span class="token punctuation">,</span>                                <span class="token string">"lr"</span><span class="token punctuation">:</span> self<span class="token punctuation">.</span>config<span class="token punctuation">[</span><span class="token string">"Training"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"lr"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"cam_rot_delta"</span><span class="token punctuation">]</span>                                <span class="token operator">*</span> <span class="token number">0.5</span><span class="token punctuation">,</span>                                <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"rot_{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>viewpoint<span class="token punctuation">.</span>uid<span class="token punctuation">)</span><span class="token punctuation">,</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">)</span>                        opt_params<span class="token punctuation">.</span>append<span class="token punctuation">(</span>                            <span class="token punctuation">{</span>                                <span class="token string">"params"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>viewpoint<span class="token punctuation">.</span>cam_trans_delta<span class="token punctuation">]</span><span class="token punctuation">,</span>                                <span class="token string">"lr"</span><span class="token punctuation">:</span> self<span class="token punctuation">.</span>config<span class="token punctuation">[</span><span class="token string">"Training"</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">"lr"</span><span class="token punctuation">]</span><span class="token punctuation">[</span>                                    <span class="token string">"cam_trans_delta"</span>                                <span class="token punctuation">]</span>                                <span class="token operator">*</span> <span class="token number">0.5</span><span class="token punctuation">,</span>                                <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"trans_{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>viewpoint<span class="token punctuation">.</span>uid<span class="token punctuation">)</span><span class="token punctuation">,</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">)</span>                    opt_params<span class="token punctuation">.</span>append<span class="token punctuation">(</span>                        <span class="token punctuation">{</span>                            <span class="token string">"params"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>viewpoint<span class="token punctuation">.</span>exposure_a<span class="token punctuation">]</span><span class="token punctuation">,</span>                            <span class="token string">"lr"</span><span class="token punctuation">:</span> <span class="token number">0.01</span><span class="token punctuation">,</span>                            <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"exposure_a_{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>viewpoint<span class="token punctuation">.</span>uid<span class="token punctuation">)</span><span class="token punctuation">,</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">)</span>                    opt_params<span class="token punctuation">.</span>append<span class="token punctuation">(</span>                        <span class="token punctuation">{</span>                            <span class="token string">"params"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>viewpoint<span class="token punctuation">.</span>exposure_b<span class="token punctuation">]</span><span class="token punctuation">,</span>                            <span class="token string">"lr"</span><span class="token punctuation">:</span> <span class="token number">0.01</span><span class="token punctuation">,</span>                            <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"exposure_b_{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>viewpoint<span class="token punctuation">.</span>uid<span class="token punctuation">)</span><span class="token punctuation">,</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">)</span>                self<span class="token punctuation">.</span>keyframe_optimizers <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>opt_params<span class="token punctuation">)</span>                <span class="token comment"># 这里为什么要map两次呢？看起来像是迭代一定次数后做一次prune，为了代码方便就分两次写了？</span>                self<span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>current_window<span class="token punctuation">,</span> iters<span class="token operator">=</span>iter_per_kf<span class="token punctuation">)</span>                self<span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>current_window<span class="token punctuation">,</span> prune<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>                self<span class="token punctuation">.</span>push_to_frontend<span class="token punctuation">(</span><span class="token string">"keyframe"</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">"Unprocessed data"</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>    <span class="token comment">#################################</span>    <span class="token comment"># 清理用于通信的两个队列中的信息</span>    <span class="token keyword">while</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>backend_queue<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>backend_queue<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>frontend_queue<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>frontend_queue<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 3D Gaussian Splatting </tag>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NeRF &amp; 3DGS in SLAM &amp; Robotics</title>
      <link href="2024/11/26/nerf-3dgs-in-slam-robotics/"/>
      <url>2024/11/26/nerf-3dgs-in-slam-robotics/</url>
      
        <content type="html"><![CDATA[<h1 id="NeRF-amp-3DGS-in-SLAM-amp-Robotics"><a href="#NeRF-amp-3DGS-in-SLAM-amp-Robotics" class="headerlink" title="NeRF &amp; 3DGS in SLAM &amp; Robotics"></a>NeRF &amp; 3DGS in SLAM &amp; Robotics</h1><h2 id="How-NeRFs-and-3DGS-are-Reshaping-SLAM"><a href="#How-NeRFs-and-3DGS-are-Reshaping-SLAM" class="headerlink" title="How NeRFs and 3DGS are Reshaping SLAM"></a>How NeRFs and 3DGS are Reshaping SLAM</h2><p><img src="/images/nerf-3dgs-in-slam-robotics/image-20241126212310183.png"></p><p><strong>关于 ideal SLAM criteria</strong>：As we outline the ideal SLAM criteria, several key aspects emerge. These include global consistency, robust camera tracking, accurate surface modeling, real-time performance, accurate prediction in unobserved regions, scalability to large scenes, and robustness to noisy data. 即，全局一致性、稳健的相机跟踪、精确的表面建模、实时性能、未观察区域的准确预测、大型场景的可扩展性以及对噪声数据的鲁棒性。</p><p><strong>NeRF、3DGS与传统方法相比具备的优点</strong>：including continuous surface modeling, reduced memory requirements, improved noise/outlier handling, and enhanced hole filling and scene inpainting capabilities for occluded or sparse observations. In addition, they have the potential to produce denser and more compact maps that can be reconstructed as 3D meshes at arbitrary resolutions. However, it is important to note that at this early stage, the strengths of each technique coexist with specific challenges and limitations. 即，连续表面建模，减少内存需求，改进噪声/异常值处理，增强孔填充和场景绘制能力，用于遮挡或稀疏观测。此外，它们有可能产生更密集、更紧凑的地图，可以以任意分辨率重建为3D网格。</p><blockquote><p>个人认为，不能仅仅局限在SLAM这个话题上，SLAM主要是面向Robotics的。</p><p>在Robotics中，如果有了NeRF、3DGS表示的地图，可以进行更多的拓展。</p></blockquote><p><strong>新一代的SLAM最主要的问题</strong>：This analysis highlights how, despite the great promise brought by this new generation of SLAM systems, most of them are still unsatisfactory in terms of hardware and runtime requirements, making them not yet ready for realtime applications. 即，大多数方法在硬件和运行时需求方面仍然令人不满意，这使得它们尚未为实时应用程序做好准备。</p><img src="/images/nerf-3dgs-in-slam-robotics/image-20241122200927453.png" style="zoom: 67%;"><p><strong>3DGS的问题</strong>：However, these methods have several limitations, including a heavy reliance on initialization and a lack of control over primitive growth in unobserved regions. Furthermore, the original 3DGS-based scene representation requires a large number of 3D Gaussian primitives to achieve high-fidelity reconstruction, resulting in substantial memory consumption. </p><blockquote><p>这个问题我也观察到了，初始化很大程度决定了训练的上限，观察区域边缘的3DGS会一直膨胀，这是一个非常不好的现象。</p></blockquote><p><strong>NeRF vs. 3DGS in SLAM</strong>：NeRF-style SLAM, which relies mostly on MLP(s), is well suited for novel view synthesis, mapping and tracking but faces challenges such as oversmoothing, susceptibility to catastrophic forgetting, and computational inefficiency due to its reliance on perpixel ray marching. 3DGS bypasses per-pixel ray marching and exploits sparsity through differentiable rasterization over primitives. This benefits SLAM with an explicit volumetric representation, fast rendering, rich optimization, direct gradient flow, increased map capacity, and explicit spatial extent control. Thus, while NeRF shows a remarkable ability to synthesize novel views, its slow training speed and difficulty in adapting to SLAM are significant drawbacks. 3DGS, with its efficient rendering, explicit representation, and rich optimization capabilities, emerges as a powerful alternative. Despite its advantages, current 3DGS-style SLAM approaches have limitations. These include scalability issues for large scenes, the lack of a direct mesh extraction algorithm (although recent methods such as [192] have been proposed), the inability to accurately encode precise geometry and, among others, the potential for uncontrollable Gaussian growth into unobserved areas, causing artifacts in rendered views and the underlying 3D structure. Moreover, the computational complexity of 3DGS-based SLAM systems is significantly higher than NeRF-based methods, which can hinder real-time performance and practical deployment, especially on resource-constrained devices. In order to mitigate these issues, recent research efforts, such as CompactGSSLAM [114], have focused on developing compact 3D Gaussian scene representations that optimize storage efficiency while maintaining high-quality reconstruction, rapid training convergence, and real-time rendering capabilities.</p><blockquote><p>总结就是：</p><ul><li><p>NeRF SLAM在新视角合成、跟踪、建图上有优势；但是存在过度平滑、容易遗忘和计算效率过低的问题；</p><p>这导致NeRF的方法相对于3DGS来说，其实不是很适合SLAM。</p></li><li><p>3DGS SLAM有显示表示，渲染和优化更快，有直接的梯度流动，更高的地图容量，可以显示控制地图范围；但是3DGS目前扩展性差、大场景下表现不好、缺乏直接的mesh提取算法、几何精度比较差、未观测区域的高斯增长可能导致伪影、计算复杂度高。</p><p>不过3DGS主要凭借高效的渲染和显示的表示，在SLAM中更加有优势。</p></li></ul></blockquote><h2 id="SLAM-Meets-NeRF"><a href="#SLAM-Meets-NeRF" class="headerlink" title="SLAM Meets NeRF"></a>SLAM Meets NeRF</h2><p><strong>在NeRF SLAM中，用SDF取代volume density的优势</strong>：</p><ul><li>SDF values and volume densities decoded by MLP networks cannot be mutated without losing texture features. However, since zero iso-surface decision boundaries are abrupt, the use of SDF values can enable the extraction of surfaces containing texture features.</li><li>A loss function based on SDF values constrains the on-surface points and off-surface points, so SDF values can provide more geometric information.</li><li>The loss function of an SDF sets the SDF value away from the surface of the object as a cut-off value. Combined with the voxel skipping strategy, unnecessary calculations can be avoided, while the volume density is affected by floating objects in the air, which requires more sampling points and more calculations. Combined with the voxel skipping strategy, unnecessary calculations can be avoided. And because the volume density is affected by floating objects in the air, the calculation cost is large.</li><li>An SDF value can visually describe the distance between a sampling point and an object’s surface, which is conducive to the realization of AR and VR.</li></ul><p>不过这样也会导致新的问题：SDF代替volume density会导致孔洞填补的能力减弱。</p><h2 id="Neural-Fields-in-Robotics"><a href="#Neural-Fields-in-Robotics" class="headerlink" title="Neural Fields in Robotics"></a>Neural Fields in Robotics</h2><blockquote><p>这篇综述主要关注：pose estimation, manipulation, navigation, physics, and autonomous driving</p></blockquote><p><img src="/images/nerf-3dgs-in-slam-robotics/image-20241126212040417.png"></p><p><strong>Typical robotic pipeline</strong>：At the core of a typical robotic pipeline is <strong>the synergy between perception and action.</strong> The perception system gathers sensory data from devices such as RGB cameras, LiDAR, and depth sensors and transforms them into a coherent model of the environment — such as a 3D map that enables the robot to maneuver through dynamic, obstacle-rich spaces. The quality of this representation directly impacts the robot’s decision-making or policy, which translates the perceived environment into actions, enabling it to avoid moving forklifts, pick up scattered objects, or plan a safe path in an emergency.</p><p><strong>Typical robotic pipeline中对环境建模的方法存在的问题</strong>：Traditionally, robots have modeled their environments using data structures like point clouds, voxel grids, meshes, and Truncated Signed Distance Functions (TSDF). While these representations have advanced robotic capabilities, they struggle to capture fine geometric details, particularly in complex or dynamic environments, leading to suboptimal performance in adaptable scenarios. 即，这些方法难以捕捉精细的几何细节，特别是在复杂或动态环境中，导致在适应场景中性能不佳。</p><p><strong>与传统地图表示方法相比，NeRF在Robotics中的优势</strong>：</p><ul><li><p><strong>High-Quality 3D Reconstructions</strong>: NFs generate detailed 3D representations of environments, which are crucial for tasks like <strong>navigation, manipulation, and scene understanding</strong> [24–28].</p><blockquote><p>对机器人的导航、操作、场景理解很有帮助。</p></blockquote></li><li><p><strong>Multi-Sensor Integration</strong>: NFs can seamlessly integrate data from multiple sensors, such as LiDAR and RGB cameras, providing a more robust and adaptable perception of the environment [29, 30].</p><blockquote><p>在3DGS中，这个优势更加明显了，Lidar和Camera更容易结合起来了。</p><p><strong>注</strong>：这个点还不确定，可能得看看LVI-SAM、R2live、R3live等基于传统方法的工作。</p></blockquote></li><li><p><strong>Continuous and Compact Representations</strong>: Unlike voxel grids or point clouds, which are inherently discrete, NFs offer continuous representations that capture fine spatial details using fewer parameters, enhancing computational efficiency [22, 31].</p><blockquote><p>更少的参数，更精细的空间细节</p></blockquote></li><li><p><strong>Generalization and Adaptation</strong>: Once trained, NFs can generate novel viewpoints of a scene, even from previously unseen perspectives, which is particularly valuable for exploration or manipulation tasks. This ability is enabled by generalizable NeRF methods [32–34].</p><blockquote><p>新视角生成对探索、操作等任务特别有价值</p></blockquote></li><li><p><strong>Integration with Foundation Models</strong>: NFs can be combined with foundation models like CLIP [35] or DINO [36], enabling robots to interpret and respond to natural language queries or other semantic inputs [37, 38].</p><blockquote><p>可以和foundation model进行结合</p></blockquote></li></ul><p><img src="/images/nerf-3dgs-in-slam-robotics/image-20241126212027493.png"></p><p><img src="/images/nerf-3dgs-in-slam-robotics/image-20241126212150042.png"></p><h3 id="Neural-Fields-for-Pose-Estimation"><a href="#Neural-Fields-for-Pose-Estimation" class="headerlink" title="Neural Fields for Pose Estimation"></a>Neural Fields for Pose Estimation</h3><p><strong>Camera Pose Estimation</strong>：对定位、建图等任务很重要。</p><p>略，这部分太熟悉了。。。</p><p><strong>Object Pose Estimation</strong>：对操作、交互等任务很重要。</p><p>论文描述的工作基本上是围绕如何估计场景中物体的3D bounding box，也提到了一些同时估计物体姿态和对物体进行重建的。</p><p><strong>Takeaways and Open Challenges in Neural Fields for Pose Estimation</strong>：</p><ul><li>在静态场景中有了重大进展，但是面对动态场景，还有很多值得探索的空间；</li><li>open-vocabulary 6D object pose estimation。</li></ul><h3 id="Neural-Fields-for-Robotic-Manipulation"><a href="#Neural-Fields-for-Robotic-Manipulation" class="headerlink" title="Neural Fields for Robotic Manipulation"></a>Neural Fields for Robotic Manipulation</h3><p><strong>Manipulation的关键问题</strong>：One of the key challenges in robotic manipulation is obtaining a precise geometric representation of both the objects and the environment involved in the task. An effective representation must also capture the environment dynamics, offering a robust 3D understanding of the objects. 即，获得任务中涉及的物体和环境的精确几何表示，并且最好是捕捉环境的动态变化，提供对object的鲁棒3D理解。</p><p>机械臂、灵巧手如果想要操纵物体、控制物体的话，需要生成“抓点”，grasps。有一些方法已经可以合成3-DoF的grasps了，但是缺乏精确的方向控制。而6-DoF的方法可以完全控制RPY，操纵能力更强。</p><p>综述提到了很多论文针对“透明”或者“镜面”物体展开了工作，看起来NeRF、3DGS可能在这方面做得比较好。</p><p>另外，综述提到了GaussianGrasper，这个工作提出了6-DoF的抓取方法，支持对open-vocabulary object进行抓取，这能够让机器人理解和执行基于自然语言指令的任务。</p><p>也有一些工作比如SplatSim，用于实现Sim2Real传输，减少合成数据和真实数据之间的偏移。</p><blockquote><p>这个在知乎上也有人讨论，不过单看指标还是存在较大的偏移，只不过肉眼看这感觉要好很多了。。。</p></blockquote><p><strong>Takeaways and Open Challenges in Neural Fields for Manipulation</strong>:</p><ul><li><p>NFs have emerged as powerful techniques for robust 3D understanding in robotic manipulation tasks, such as grasping and pick-and-place. These representations capture detailed geometrical information and support generalization across diverse object shapes and categories. NFs have also been employed to identify optimal grasp points, improving the success rate of robotic grasps in cluttered environments. Additionally, some methods integrate these representations with language models, enabling open-vocabulary manipulation through natural language instructions.</p><p>即，为机器人操纵抓取等任务提供了强大的3D理解能力。这些表示方法捕获了详细的几何信息，并且支持跨不同对象形状和类别的泛化。另外也可以用于识别最佳抓取点，提高了机器人在杂乱环境中抓取的成功率。也可以和一些语言模型集成在一起，通过自然语言指令实现开放词汇操作。</p></li><li><p>Despite these advancements, significant challenges remain. Current approaches rely on extensive multi-view inputs or costly per-scene optimization, limiting their applicability in complex, dynamic, or unstructured environments. Furthermore, incorporating physical intuitions about object affordances and robot dynamics into the learned representations could lead to more physically grounded manipulation policies (see Sec. III-D). Finally, scaling these methods to dynamic scenes with multiple agents or articulated objects is an ongoing challenge that must be addressed for real-world deployment.</p><p>即，当前的方法依赖于足够的多视图输入和逐场景的优化，限制了这种方法在复杂、动态或者非结构化环境中的适用性。</p></li></ul><h3 id="Neural-Fields-for-Navigation"><a href="#Neural-Fields-for-Navigation" class="headerlink" title="Neural Fields for Navigation"></a>Neural Fields for Navigation</h3><p>这篇综述将Navigation分为四个部分：Planning, Exploration, Visual Localization, and Feature Fields。</p><p><strong>Takeaways and Open Challenges in Neural Fields for Navigation</strong>:</p><ul><li><p>While Neural Fields have made significant strides in navigation, key challenges still remain. Current methods focus mainly on static environments and tasks like image-goal and vision-language navigation. Future work could extend NFs to dynamic settings, incorporating fast reconstruction techniques for real-time updates in evolving environments [186]. Another crucial direction is dynamic scene pose estimation (Sec. III-A3) to aid reconstruction and navigation in dynamic environments.</p><p>即，当前的方法侧重于静态环境和图像目标和视觉语言导航等任务，未来可以考虑扩展到动态场景。</p></li><li><p>The integration of generative NFs also holds great potential. Recent diffusion model advances [39, 187] could facilitate efficient scene editing and environment creation, narrowing the sim-to-real gap. Additionally, leveraging foundation models for large-scale mobile manipulation and scene generalization could unlock further advancements. Integrating Vision-Language Models (VLMs) with implicit representations for enhanced commonsense reasoning within NFs offers another promising frontier for future exploration.</p><p>即，将VLM和隐式表示相结合。</p></li></ul><h3 id="Neural-Fields-for-Physics"><a href="#Neural-Fields-for-Physics" class="headerlink" title="Neural Fields for Physics"></a>Neural Fields for Physics</h3><p>略，不太看得懂。放过自己。</p><h3 id="Neural-Fields-in-Autonomous-Driving"><a href="#Neural-Fields-in-Autonomous-Driving" class="headerlink" title="Neural Fields in Autonomous Driving"></a>Neural Fields in Autonomous Driving</h3><p>综述开头这一段的观点和知乎上一些讨论很相近：High-quality mapping of large-scale environments is essential for autonomous driving systems. A high-fidelity map of the entire operating domain serves as a powerful prior for various tasks, including robot localization (see Sec. III-A), navigation, and collision avoidance (see Sec. III-C). Additionally, largescale scene reconstructions facilitate closed-loop robotic simulations. Autonomous driving systems are often evaluated by re-simulating previously encountered scenarios; however, any deviation from the original encounter can alter the vehicle’s trajectory, necessitating high-fidelity novel view renderings along the adjusted path. In addition to basic view synthesis, scene-conditioned NeRFs can modify environmental lighting conditions, such as camera exposure, weather, or time of day, further enhancing simulation scenarios.</p><p>Neural Fields have become a prominent framework in autonomous driving due to their ability to generate photorealistic 3D environments from RGB images. These environments are highly valuable for constructing immersive simulation systems with several key features, as previously discussed: First, NFs offer extensive manipulability and compositionality (Sec. III-E1), allowing for the seamless integration and manipulation of objects within a scene. This facilitates the simulation of complex scenarios, such as collisions, which are difficult to replicate in physical settings. Second, they produce scenes with impressive photorealism (Sec. III-E2), enabling realistic simulations from visual data. Finally, their strong generalizability (Sec. III-E3) from sparse inputs allows for creating accurate, scalable environments, enhancing research in embodied AI. These traits, as discussed in the following subsections, enable the creation of simulated environments that faithfully represent real-world scenarios, thereby facilitating research in embodied AI.</p><blockquote><p>主要说的是，有助于闭环模拟，而且NeRF、3DGS可以进行场景编辑甚至修改照明条件。</p><p>NeRF、3DGS在自动驾驶中关注度确实非常高的。</p></blockquote><p><strong>Takeaways and Open Challenges in Neural Fields for Autonomous Driving</strong>:</p><ul><li>Despite the promising progress in NFs for autonomous driving, several open challenges remain. Current methods focus on photorealistic simulators, which are dynamic, compositional, and realistic. One avenue of future work is training policies in such NF-based simulators and transferring them to the real-world. Connecting the success of NFs in autonomous driving with real-world deployment is an exciting avenue for future work. Generalizable reconstruction has seen some early signs of life with recent works but still remains largely underexplored. Future works could look at the efficiency of generalizable outdoor scene reconstruction methods, as well as advances that focus on sim2real transfer and pose-free reconstruction. This avenue of research is exciting as it opens the door for creating photorealistic simulators from a few images in the real world.</li><li>Another promising direction for autonomous driving research is integrating generative methods like diffusion models with the NFs’ paradigm. Future work could look at creating new scenarios via NF editing that are difficult to create in the real world, such as collision avoidance to train policies via reward models in NFs’ simulation. Generative asset creation through a few images from the real world is another potential avenue for NF’s research for autonomous driving.</li><li>Furthermore, the integration of NFs into generative models such as shown in Lift3D [220] and Adv3D [221] facilitates data augmentation, addressing the challenges posed by the diversity of driving scenes. Given the high costs associated with capturing all potential scenarios, data augmentation emerges as a valuable strategy and promising future direction for expanding training datasets and improving model performance.</li></ul><h3 id="OPEN-CHALLENGES-OF-NEURAL-FIELDS-IN-ROBOTICS"><a href="#OPEN-CHALLENGES-OF-NEURAL-FIELDS-IN-ROBOTICS" class="headerlink" title="OPEN CHALLENGES OF NEURAL FIELDS IN ROBOTICS"></a>OPEN CHALLENGES OF NEURAL FIELDS IN ROBOTICS</h3><ul><li><strong>Efficiency</strong>: NFs are computationally intensive and may not naturally operate in real-time, which is often a critical requirement for robotics applications. There is a need for significant optimization or simplification to make these models run efficiently on robotics hardware, which may have limited computational resources compared to dedicated GPUs used in data centers.</li><li><strong>Dynamic environments</strong>: Robotics often involve operating in dynamic environments where objects and scene configurations change over time. Capturing and updating NFs to reflect these changes in real-time remains a challenging task.</li><li><strong>Sensor integration</strong>: Effectively integrating data from various sensors (e.g., LiDAR, RGB cameras, depth sensors) to enhance the robustness and performance of NFs is relatively under-explored. Advanced sensor fusion techniques could potentially bridge this gap.</li><li><strong>Generalization</strong>: Existing techniques often require dense input data and struggle with sensor noise or occlusions. Developing methods that can leverage priors learned from web-scale datasets to generalize across varied scenarios offers a promising direction.</li><li><strong>Physical information</strong>: While NFs excel at representing visual aspects, they do not inherently understand physical properties like weight or friction. Extending NFs to incorporate physics simulations could enable more realistic interactions for robots.</li><li><strong>Data efficiency and augmentation</strong>: Current approaches are data-hungry, which is impractical for real-world applications. Innovations in data-efficient learning techniques and realistic data augmentation could help in overcoming these limitations.</li><li><strong>Multi-modal, multi-task, and efficient scene understanding</strong>: Developing neural field approaches that can handle multiple tasks and modalities simultaneously while maintaining efficiency in scene understanding is crucial for holistic robotic perception.</li><li><strong>Performance evaluation</strong>: Establishing standardized metrics and benchmarks for evaluating the performance of NFs in robotic applications will be essential for tracking progress and comparing different approaches.</li><li><strong>Collaborative frameworks</strong>: There is a need for frameworks that support collaboration between robots using NFs, enabling them to share learnings and improve collective understanding and decision-making in complex environments.</li></ul><h2 id="NeRF-in-Robotics"><a href="#NeRF-in-Robotics" class="headerlink" title="NeRF in Robotics"></a>NeRF in Robotics</h2><p><img src="/images/nerf-3dgs-in-slam-robotics/image-20241126153553406.png"></p><p>这篇文章基本上是对各种工作的总结。</p><h2 id="3D-Gaussian-Splatting-in-Robotics-A-Survey"><a href="#3D-Gaussian-Splatting-in-Robotics-A-Survey" class="headerlink" title="3D Gaussian Splatting in Robotics: A Survey"></a>3D Gaussian Splatting in Robotics: A Survey</h2><p><img src="/images/nerf-3dgs-in-slam-robotics/image-20241126163019699.png"></p><p>这篇文章和上一篇文章结构几乎一模一样，不过做了一些讨论。</p><p><strong>关于Robust Tracking</strong>：Existing 3DGS-based SLAM methods, although demonstrating high accuracy in dense mapping, typically fail to achieve accurate and robust tracking, especially in complex real-world scenarios. This limitation in current 3DGS-based SLAM systems is due to their reliance on directly using RGB information of image for pose optimization. Such reliance heavily depends on the quality and texture information of the images. However, in real-world robotic applications, image quality is prone to camera motion blur, degrading the performance of 3DGS-based SLAM. Moreover, there are some scenes with limited texture information, such as sky or walls, leading to insufficient constraints for pose estimation. The following presents corresponding directions to improve the robustness of tracking.</p><ul><li><strong>Camera motion blur.</strong> Camera motion blur is primarily caused by rapid movements of the robot and slow shutter speed of the camera, leading to blurry images. Although deblurring methods have been researched (Section 4.1.1) and used in SLAM [116], these methods fail to directly convert captured blurry images into sharp ones. Instead, they simulate motion blur by averaging virtual sharp images captured during the camera exposure time to synthesize blurry images. These synthesized blurry images are then used to construct loss with the observed blurry images for Gaussian optimization, ensuring that the constructed scene is deblurred. However, such methods fail to address the degradation of image quality in the observed images caused by motion blur, which adversely affects tracking performance that relies on high-quality images for pose optimization. A suitable research direction is to leverage the advantages of 3DGS representation, such as geometric information and spatial distribution, to perform tracking. This method can reduce the reliance on image quality.</li><li><strong>Limited texture information.</strong> In real-world scenes, there are some corner cases where the environmental texture information is limited, leading to insufficient constraints for pose optimization that solely relies on image quality. Although some 3DGS-based SLAM methods [128], [129] have utilized multi-sensor fusion traditional SLAM as odometry for tracking, these methods fail when traditional SLAM is unable to handle complex corner cases. A potential research direction is to incorporate original sensor data of multiple sensors, such as IMU, wheel encoders, and LiDAR, with 3D Gaussian representation to provide sufficient constraints for pose optimization. This approach not only leverages the spatial structural information and dense scene representation offered by 3DGS, but also exploits the various constraints from multi-sensor information.</li></ul><p><strong>关于Lifelong Mapping and Localization</strong>：Current 3DGS methods primarily focus on short-term reconstruction and localization. However, in most real-world scenarios, the environment undergoes constant changes over time. A prebuilt map that fails to consider these changes may quickly become outdated and unreliable. Consequently, it is crucial to maintain an up-to-date model of the environment to facilitate the long-term operation or navigation of robots. Although some traditional methods [217], [218] have achieved long-term mapping, these approaches focus on constructing and updating sparse maps, which are insufficient for downstream robotic tasks. Therefore, a promising research direction is lifelong 3DGS-based dense mapping and localization. Since 3DGS is an explicit and dense representation, the dynamic update and refinement of the Gaussian map can be achieved through explicit editing of Gaussian primitives. Additionally, we believe that the inconsistencies in the Gaussian map caused by longterm dynamic changes can be optimized by leveraging the inner constraints between Gaussian primitives. Therefore, by harnessing the explicit representation and inherent constraints among Gaussian primitives, lifelong mapping and localization can be achieved.</p><blockquote><p>有一点个人很喜欢：虽然一些传统方法[217]，[218]已经实现了长期的映射，但这些方法主要集中在<strong>构建和更新稀疏地图，这对于下游机器人任务来说是不够的</strong>。因此，基于3dgs的终身密集映射与定位是一个很有前景的研究方向。</p></blockquote><p><strong>关于Large-scale Relocalization</strong>：In robotic applications, it is necessary for robots to relocate their current poses upon entering a pre-established map. However, existing 3DGS-based relocalization methods [144], [145] either require a coarse initial pose or are only capable of achieving relocalization in small indoor scenes. These methods struggle to perform relocalization in large-scale outdoor scenes without an initial pose. Unfortunately, it is challenging to obtain a coarse initial pose for relocalization in practical robotic applications. Therefore, a meaningful research direction is large-scale relocalization without prior poses. We believe that constructing a submap index library or descriptor based on 3DGS representation facilitates coarse pose regression. In addition, the coarse pose can be refined through a registration process that leverages geometric and appearance features within the 3DGS representation.</p><blockquote><p>无先验姿态的大规模再定位是一个有意义的研究方向</p></blockquote><p><strong>关于Sim-to-Real Manipulation</strong>：Collecting real-world manipulation datasets is challenging, leading to a scarcity of data for training effective grasping in real scenarios. Therefore, grasping methods often require initial training in simulation environments before being transferred to real-world settings. Although 3DGS-based sim-to-real method [219] has been explored, it has limitation in generalization. Specifically, this approach heavily depends on scene-specific training, which hinders its ability to generalize and transfer learned knowledge between similar task scenarios. Consequently, this method still requires a substantial amount of real-world datasets for training. Furthermore, the discrepancies in material and physical properties between simulation and reality environments can lead to significant differences in training data distributions for manipulation tasks. These discrepancies may potentially result in entirely different operation strategies. However, existing method [220] only enables modeling the physical properties of real-world scenarios. Therefore, a promising research direction involves directly incorporating uncertainty and environmental features into the 3DGS representation to enhance generalization and property modeling.</p><h2 id="Foundation-Models-in-Robotics-Applications-Challenges-and-the-Future"><a href="#Foundation-Models-in-Robotics-Applications-Challenges-and-the-Future" class="headerlink" title="Foundation Models in Robotics: Applications, Challenges, and the Future"></a>Foundation Models in Robotics: Applications, Challenges, and the Future</h2><p><img src="/images/nerf-3dgs-in-slam-robotics/image-20241126170838896.png"></p><p>看起来NeRF相关的内容主要集中在“Perception”部分：</p><ul><li><p><strong>Open-Vocabulary 3D Scene and Object Representations</strong></p><p>Scene representations allow robots to understand their surroundings, facilitate spatial reasoning, and provide contextual awareness. Language-driven scene representations align textual descriptions with visual scenes, enabling robots to associate words with objects, locations, and relationships.</p><ul><li><p><strong>Language Grounding in 3D Scene:</strong> </p><p>NeRF可以为机器人提供强几何先验，但其并不是foundation model。然而，CLIP这样的foundation model却可以和NeRF相结合，从环境中提取语义信息。因此后面出现了LERF，结合CLIP和NeRF。</p><p>目前的VLM可以对2D图像进行推理，但是并没有专门去考虑3D上的问题。但是可以用2D的VLM来监督3D的模型，比如FeatureNeRF。</p></li><li><p><strong>Scene Editing</strong></p><p>When an embodied agent relies on an implicit representation of the world, the capability to edit and update this representation enhances the robot’s adaptability. For instance, consider a scenario where a robot utilizes a pretrained NeRF model of an environment for navigation and manipulation. If a portion of the environment changes, being able to adjust the NeRF without retraining the model from scratch saves time and resources.</p></li></ul></li></ul><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p>Paper &amp; Workshop：</p><ul><li>How NeRFs and 3D Gaussian Splatting are Reshaping SLAM: a Survey, <em>arXiv, 2024</em>. [<a href="https://arxiv.org/pdf/2402.13255.pdf">Paper</a>]</li><li>SLAM Meets NeRF: A Survey of Implicit SLAM Methods, <em>World Electric Vehicle Journal, 2024</em>. [<a href="https://www.mdpi.com/2032-6653/15/3/85">Paper</a>]</li><li>Neural Fields in Robotics: A Survey, <em>arXiv, 2024</em>.[<a href="https://arxiv.org/abs/2410.20220">Paper</a>]</li><li>NeRF in Robotics: A Survey, <em>arXiv, 2024</em>.[<a href="https://arxiv.org/pdf/2405.01333">Paper</a>]</li><li>3D Gaussian Splatting in Robotics: A Survey, arXiv, 2024.[<a href="https://arxiv.org/abs/2410.12262">Paper</a>]</li><li>Foundation Models in Robotics: Applications, Challenges, and the Future, arXiv, 2023. [<a href="https://arxiv.org/abs/2312.07843">Paper</a>]</li><li><strong>RoboNerF</strong>: 1st Workshop on Neural Fields in Robotics, <em>ICRA, 2024</em>. [<a href="https://robonerf.github.io/2024/">Website</a>] [<a href="https://www.youtube.com/watch?v=jyEZtbXs3fg">Video</a>]</li></ul><p>知乎上相关的讨论：</p><ul><li><p>nerf或者是跟其相关的3D重建方法怎么应用在自动驾驶或者机器人领域？ - 刘斯坦的回答 - 知乎<br><a href="https://www.zhihu.com/question/578721901/answer/3476777188">https://www.zhihu.com/question/578721901/answer/3476777188</a></p><blockquote><p>这个回答讲的主要是如何将NeRF用于闭环仿真。所谓闭环仿真，就是穿越回到某个历史节点后，优化你的行为，然后对造成的后果进行仿真，修改历史。并且讨论了NeRF的Domain Gap有多大，提到了一个叫做NDS的指标，表示NeRF目前只是堪堪可用的。另外提到了有很多现实生活中的物体并不适合mesh建模，比如树叶、头发丝。</p></blockquote></li><li><p>NeRF/3DGS&amp;Beyond10.17（3DGS机器人综述、GS^3、Long-LRM、SplatPose+、LoGS、GSORB-SLAM、4-LEGS、Magnituder Layers等） - NeRF 3DGS日报的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/1563839191">https://zhuanlan.zhihu.com/p/1563839191</a></p><blockquote><p>这篇文章提到的第二篇论文，还挺有意思，传统方法不能操作豆子、坚果、大米，但是他们在3DGS上面做到了。</p></blockquote></li><li><p>机器人技术中的 3D 高斯splatting：综述 - 黄浴的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/4309431179">https://zhuanlan.zhihu.com/p/4309431179</a></p><blockquote><p>昨天早上发的，还挺巧。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 3D Gaussian Splatting </tag>
            
            <tag> NeRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读PIN-SLAM(TRO 2024)</title>
      <link href="2024/11/21/paper-reading-pin-slam/"/>
      <url>2024/11/21/paper-reading-pin-slam/</url>
      
        <content type="html"><![CDATA[<h1 id="论文阅读《PIN-SLAM-LiDAR-SLAM-Using-a-Point-Based-Implicit-Neural-Representation-for-Achieving-Global-Map-Consistency》"><a href="#论文阅读《PIN-SLAM-LiDAR-SLAM-Using-a-Point-Based-Implicit-Neural-Representation-for-Achieving-Global-Map-Consistency》" class="headerlink" title="论文阅读《PIN-SLAM: LiDAR SLAM Using a Point-Based Implicit Neural Representation for Achieving Global Map Consistency》"></a>论文阅读《PIN-SLAM: LiDAR SLAM Using a Point-Based Implicit Neural Representation for Achieving Global Map Consistency》</h1><p><img src="/images/paper-reading-pin-slam/image-20241115195333282.png"></p><p><strong>论文想要解决的问题</strong>：These SLAM approaches <strong>lack support for direct loop closure corrections</strong> and are <strong>not able to build globally consistent maps of larger scenes</strong>. This is mainly due to the usage of regular grid-based local feature embeddings, which are not elastic and resilient to loop corrections.</p><p><strong>论文的核心目标</strong>：The main focus of this work is a LiDAR SLAM system for building globally consistent maps using a PIN map representation.</p><p><strong>论文为什么选择neural point表示场景</strong>：We opt to use a neural point-based implicit representation, which has two main advantages over grid-based representations: <strong>the flexibility of spatial distribution and the elasticity for transformations</strong>. Recent work (Point-SLAM) only makes use of the first advantage for neural RGB-D SLAM at the cost of scalability and inefficient neighborhood querying. Instead, we exploit the second and more important advantage to build a globally consistentmap that can be corrected while online mapping after closing a loop, which is essential for large-scale LiDAR-based SLAM.</p><p>论文在Introduction提到，Mapping部分主要是基于之前的工作SHINE-Mapping，而Odometry部分是扩展了之前的工作LocNDF。</p><blockquote><p>工作是延续的，非常扎实，令人羡慕。</p></blockquote><p><strong>论文提出了四个key claims</strong>：</p><ol><li>Our SLAM system achieves <strong>localization accuracy better or on par with state-of-the-art</strong> LiDAR odometry/SLAM approaches and is more accurate than recent implicit neural SLAM methods on various datasets using different range sensors.</li><li>Our method can conduct <strong>large-scale globally consistent mapping with loop closure</strong> thanks to the elastic neural point representation.</li><li>Our map representation is <strong>more compact than the previous counterparts</strong> and <strong>can be used to reconstruct accurate and complete meshes at an arbitrary resolution</strong>.</li><li>Our correspondence-free scan-to-implicit map registration and the efficient neural point indexing by voxel hashing enable our algorithm to <strong>run at the sensor frame rate on a single NVIDIA A4000</strong> graphics processing unit (GPU).</li></ol><p><strong>论文对基于Submap的方法的评价</strong>：The submap-based methods accumulate the observations as a submap and assume the submap is a locally defined rigid body. The pseudoglobal consistency is maintained by optimizing a graph linking submaps and their associated poses through submap-to-submap registrations. The usage of submaps decreases the number of nodes and edges in PGO, thus saving computational effort. However, these methods have issues of ambiguity in the overlapping region of the adjacent submaps and determining appropriate criteria for submap division to balance the rigidity and efficiency.</p><p><strong>论文的Pipeline</strong>：</p><p><img src="/images/paper-reading-pin-slam/image-20241115205159958.png"></p><p>论文将他们的方法分成5个部分：</p><ol><li><strong>Preprocessing</strong>：对于输入点云$P$，通过体素下采样到用于registration的点云$P_r$和用于mapping的点云$P_m$；</li><li><strong>Odometry</strong>：通过将点云$P_r$与local map $M_l$的implicit SDF进行配准来估计全局的位姿$T_{WC_t}$，并将前后两帧的变换$T_{C_{t-1}C_t}$作为一条边添加到Pose Graph $G$中。</li><li><strong>Mapping</strong>：根据地图$M$过滤掉用于mapping的点云$P_m$中的动态点，并沿着从传感器到$P_m$中每个点的射线进行采样，得到训练样本$D$，并使用在Odometry中计算的位姿$T_{WC_t}$将其转换到世界坐标系中。使用靠近场景表面的样本$D_s \subset D$来初始化新的neural point，并且将他们附加到地图$M$上，并且重置local map $M_l$，让其以当前位置$T_{WC_t}$为中心。使用采样的点$D_s$来更新训练样本池$D_p$，并且使用$D_p$和SDF监督来优化local map $M_l$中的neural point feature。最后将更新之后的local map $M_l$分配回global map $M$中。</li><li><strong>Loop closure detection</strong>：通过local map $M_l$生成一个本地极坐标上下文描述符$U_t$。之后通过比较当前帧和候选帧描述符之间的特征距离来搜索潜在的loop closure。一旦检测到当前帧$C_t$和候选帧$C_k$之间的存在闭环，就通过将当前帧点云$P_r$和以候选帧位置$t_{WC_k}$为中心的local map $M_l$进行配准，来验证是否真的存在闭环。如果配准成功，就将配准产生的变换$T_{C_kC_t}$作为新的边添加到Pose Graph $G$中。</li><li><strong>Pose graph optimization</strong>：加入loop closure edge之后，对pose graph $G$进行优化。优化之后对global map $M$中每个neural point的位置和方向及其关联帧进行变换，以保证全局一致性。在完成loop correction之后，对训练样本池$D_p$进行变换，并且重置local map $M_l$。</li></ol><h2 id="Neural-Point-Based-Map-Representation"><a href="#Neural-Point-Based-Map-Representation" class="headerlink" title="Neural Point-Based Map Representation"></a>Neural Point-Based Map Representation</h2><p><strong>Map Representation</strong>：</p><p>neural point $m_i$保存了自己的位置$x_i$，并且有一个四元数$q_i$表示自身坐标框架的方向，特征向量$f^g_i$编码了局部的几何形状，时间戳$t^c_i$表示这个neural point创建的时间，时间戳$t^u_i$表示这个neural point最后更新的时间，$\mu_i$表示该点是否活跃、是否稳定。通过将neural point $m_i$与$t^m_i$时刻的位姿$T_{WC_{t^m_i}}$相关联，可以通过更新所有时刻的位姿来直接操纵地图，其中$t^m_i = [(t^c_i + t^u_i)/2]$。</p><p><img src="/images/paper-reading-pin-slam/image-20241117154530033.png"></p><p>其中这个四元数$q_i$，是用来保证neural point经过decoder解码得到的SDF对刚体变换具有不变性。如下图(a)部分所示，decoder$D^g_\theta$输入的是相邻neural point的feature $f^g_i$和在该neural point坐标系下被查询点的位置$d_i$，输出的是被查询点在该neural point影响下的SDF值$s_i$。整个过程与Point-NeRF和Point-SLAM计算体密度的过程基本一致。从下图(b)部分可以看到，这种策略使得预测的SDF值对局部的平移和旋转具有不变性，从而使得经过loop closure之后的地图具有弹性。</p><p><img src="/images/paper-reading-pin-slam/image-20241117160700343.png"></p><p>笔者认为这一步做的非常巧妙。四元数$q_i$定义了每一个neural point自己的坐标系，查询SDF需要把neural point的feature和查询点在坐标系中的位置输入到网络，相当于是每一个neural point都有了自己的“形状”，这些“形状”叠到一起构成了一个局部的几何表面。经过loop closure之后每个“形状”也会相应的被旋转平移，而不是简单的把“形状”的中心挪到校正之后的位置去，这样的话就不需要通过子地图把每个点的相对位置绑起来也能保证loop closure之后局部的几何稳定了。</p><p>这个过程有一点3DGS的味道了，但是单个3DGS很难像这里的单个neural point那样有非常明确的几何意义。</p><blockquote><p><strong>疑问</strong>：为什么Point-NeRF、Point-SLAM、Loopy-SLAM以及PIN-SLAM对于体密度或SDF值，都是单独解码之后，再通过逆距离加权？而颜色相关的，则是通过网络得到一个新的feature，将这个feature进行逆距离加权之后再解码得到颜色？</p></blockquote><p><strong>Map Data Structure</strong>：</p><p>为了实现快速的neural point索引和邻域搜索，PIN-SLAM维护了一个voxel resolution固定为$v_p$和hash table size为$T$的voxel hashing data structure。这个数据结构用于组织地图中的neural point，保证每个voxel中的neural point不超过1个。</p><p>PIN-SLAM借鉴了《Instant neural graphics primitives with a multiresolution hash encoding》和《“KISS-ICP: In defense ofpoint-to-point ICP–simple, accurate, and robust registration if done the right way》这两个工作，通过spatial hashing function $\kappa = h(p_W)$将$p_W \in \mathbb{R}^3$映射到hash table中的$\kappa \in \mathbb{Z}$。其中hash table中每一项存储地图中neural point的索引，默认值为-1，表示这一项暂时没有对应的neural point。</p><p>与Point-SLAM相比，PIN-SLAM借助voxel structure，实现了更快的进行K近邻搜索。</p><p><strong>Map Initialization and Update</strong>：</p><p>PIN-SLAM会根据每个时刻输入的点云初始化或更新neural point。</p><p>对于在时刻$t$获取的世界坐标系$W$下的某一个点$p_W$，满足以下任意一种情况时，会初始化一个新的neural point $m_k$放到地图$M$中，并且将对应的hash table中的项设置为该neural point的索引，即$\kappa = k$。</p><ol><li>对应的hash table中的项没有被占用，即$\kappa = -1$；</li><li>存在哈希冲突，但是在voxel structure中，存储的neural point与希望被添加的neural point之间距离很远；</li><li>存在哈希冲突，但是存储的neural point已经不再活跃，即$D(t) - D(t^u_\kappa) &gt; d_l$。</li></ol><p>新初始化的neural point $m_k$，位置$x = p_W$，而四元数被设置为单位四元数$ q = (1,0,0,0)$，特征向量被初始化为零向量$f^g=0$，创建时间和最后更新时间被设置为$t^c = t^u = t$，稳定性$\mu = 0$。</p><p>对于存在哈希冲突的情况2和3，原来存储的neural point不会被删除，只会让hash table不再索引到该点，该点仍然会被保存在global map中。论文说这样做是为了loop closure correction和globally consistent map adjustment。</p><p><strong>Local Map</strong>：</p><p>PIN-SLAM使用local map是为了“avoid the alignment to the inconsistent historical observations caused by odometry drift”。</p><blockquote><p>有很多NeRF SLAM和3DGS SLAM是frame-to-model的，可以看《How NeRFs and 3D Gaussian Splatting are Reshaping SLAM: a Survey》的<a href="https://pic1.zhimg.com/v2-f388d6e1060fc226d00df0a36ba5582a_1440w.jpg">表格</a>。</p><p>frame-to-model可能存在的问题是，model构建的不太好，导致frame的位姿计算的也不好，进而导致更新的model也不好，从而frame又在存在drift的model上再计算位姿。</p><p>而PIN-SLAM这里使用了local map，一定程度上可以避免这个问题（吗？）</p></blockquote><p>论文提到之前一些工作中，local map是使用spatial window（比如MULLS、KISS-ICP）或temporal window（比如ElasticFusion）来定义的，论文觉得这两种方法可以结合起来使用，但又发现实际上里程计的drift可能与累计经过的距离成正比，而不是与时间成正比。因此，PIN-SLAM的temporal window用travel distance threshold来代替timestep threshold。</p><p>具体来说，对于以$t$时刻的位置$t_{WC_t}$为中心的local map $M_l$，这个local map包括spatial window $| x_i - t_{WC_t} |_2 &lt; r_l$和temporal window $D(t) - D(t_i^c) &lt; d_l$。其中$r_l$是local spatial window的半径，$d_l$是前面提到的travel distance threshold。</p><p><strong>Map Training Samples</strong>：</p><p>和Point-SLAM的采样策略比较类似，PIN-SLAM是在表面采样一个点，再在表面附近采样$Ns$个点，表面附近的$N_s$个点的深度服从正态分布。另外，也会在表面到相机之间的空间中均匀采样$N_f$个点，在表面后的一定空间中均匀采样$N_b$个点。</p><p>最终会得到如下所示的训练样本：<br>$$<br>D = {(u_j,\hat s_j , t) | j = 1,…,N_t}<br>$$<br>其中，$N_t = M_t(1+N_s+N_f+N_b)$，$M_t$是用于mapping的点云$P_m$中点的个数，$u_j$表示第$j$个采样点，$\hat s_j$表示SDF值，被定义为$\hat s_j = |p|_2 - d$。论文提到$\hat s_j$可能总是会被高估，但是计算速度很快，而且在样本接近表面的时候是一个很好的近似值。</p><p>为了解决incremental mapping中的“catastrophic forgetting”，PIN-SLAM维护了一个训练样本池$D_p$，类似于Point-SLAM等方法中的关键帧。</p><p><strong>Map Training Losses</strong>：</p><p><img src="/images/paper-reading-pin-slam/image-20241121153238442.png"></p><p><img src="/images/paper-reading-pin-slam/image-20241121153248786.png"></p><h2 id="Preprocessing"><a href="#Preprocessing" class="headerlink" title="Preprocessing"></a>Preprocessing</h2><p>在介绍论文pipeline到时候提到，PIN-SLAM对于输入点云$P$，通过体素下采样到用于registration的点云$P_r$和用于mapping的点云$P_m$，其中用于registration的点云$P_r$使用了较大的voxel size，而用于mapping的点云$P_m$使用了较小的voxel size。降采样的过程中，每个voxel只保留最接近体素中心的那个点。</p><p>Lidar存在因为运动导致的畸变，PIN-SLAM基于匀速运动模型，在该模型的基础上先通过逐点时间戳插值运动预测，在Odometry估计位姿之前对$P_r$进行去畸变，再通过Odometry估计的更准确的位姿来对$P_m$进行去畸变。</p><h2 id="Odometry-Estimation"><a href="#Odometry-Estimation" class="headerlink" title="Odometry Estimation"></a>Odometry Estimation</h2><p>该部分是基于已有的工作《LocNDF: Neural distance field mapping for robot localization》，LocNDF实现的是针对已知地图进行定位的方法。</p><p><img src="/images/paper-reading-pin-slam/image-20241121160918836.png"></p><p>之前的一些neural implicit SLAM，比如iMAP、Point-SLAM、Vox-fusion、NICE-SLAM等，优化目标是depth rendering loss，可以认为是point-to-point metric。而PIN-SLAM优化目标是point-to-model SDF loss，类似于ICP中的point-to-plane metric。</p><p>根据论文《Efficient variants of the ICP algorithm》的研究，后一种方法具有更快的收敛速度和更稳健的优化。</p><h2 id="Mapping-and-Local-BA"><a href="#Mapping-and-Local-BA" class="headerlink" title="Mapping and Local BA"></a>Mapping and Local BA</h2><p>PIN-SLAM首先会去除动态点，只保留静态点用于Mapping。</p><p>下面提到了一个比较有意思的做法，PIN-SLAM是在最初的$F_{mlp}$个时刻内，同时优化local map $M_l$中的neural point feature $f^g$和decoder的参数$D^g_\theta$，而在$F_{mlp}$个时刻之后，就freeze $D^g_\theta$了，只优化neural point feature了。这样可以避免因为decoder不断变化导致的灾难性遗忘。</p><p><img src="/images/paper-reading-pin-slam/image-20241121170316273.png"></p><p>对于local BA，论文中是这么描述的：</p><p><img src="/images/paper-reading-pin-slam/image-20241121171042766.png"></p><h2 id="Loop-Closure-Detection"><a href="#Loop-Closure-Detection" class="headerlink" title="Loop Closure Detection"></a>Loop Closure Detection</h2><p>PIN-SLAM首先检测local loop closure。即，对于当前位置$t_t$和当前帧$C_t$，与历史位置$t_{t_i}$和历史帧$C_{t_i}$，其中$t_i &lt; t$而且$D(t) - D(t_i) &gt; d_l$，判断两个位置是否满足以下关系：<br>$$<br>| t_t - t_{t_i} |<em>2 &lt; d</em>{loop}<br>$$<br>这种local loop closure比较适合在drift较小的情况下，判断是否又回到了过去经过的位置。</p><p>如果没有检测到local loop closure，PIN-SLAM会通过比较frame-wise descriptors来搜索global loop closure。PIN-SLAM针对典型的驾驶场景，参考Scan Context和Scan Context++等工作，提出了一种“neural point feature enhanced local map descriptor”，论文为每一个时刻$t$的local map生成对应的local context descriptor $U_t$。</p><p>当检测到candidate loop，PIN-SLAM将当前帧点云$P_r$与候选帧$C_k$对应的local map $M_l$进行配准。</p><ul><li>对于local loop，使用单位矩阵进行初始化；</li><li>对于global loop，使用semimetric localization的结果作为初值。</li></ul><p>如果配准成功，PIN-SLAM会将配准之后的变换$T_{C_kC_t}$作为pose graph $G$中连接节点$C_k$和$C_t$的loop closure edge。否则，这个candidate loop会被否定。</p><h2 id="Globally-Consistent-Implicit-Neural-Map-Adjustment"><a href="#Globally-Consistent-Implicit-Neural-Map-Adjustment" class="headerlink" title="Globally Consistent Implicit Neural Map Adjustment"></a>Globally Consistent Implicit Neural Map Adjustment</h2><p>笔者认为这部分是PIN-SLAM中最吸引人的，不过在前面的章节中已经有很多铺垫，论文在这部分着墨并不多。</p><p><img src="/images/paper-reading-pin-slam/image-20241121212323987.png"></p><h2 id="EXTENSION-TO-RGB-D-OR-METRIC-SEMANTIC-SLAM"><a href="#EXTENSION-TO-RGB-D-OR-METRIC-SEMANTIC-SLAM" class="headerlink" title="EXTENSION TO RGB-D OR METRIC-SEMANTIC SLAM"></a>EXTENSION TO RGB-D OR METRIC-SEMANTIC SLAM</h2><p>论文在这个章节演示了如何将PIN-SLAM扩展到RGB-D或者Metric-Semantic SLAM。思路其实挺简单的，给每一个neural point增加对应的RGB或者Semantic的feature就可以了，然后创建对应的MLP作为decoder，当然为了进行训练，也会构建对应的损失函数。</p><p><img src="/images/paper-reading-pin-slam/image-20241121214746710.png"></p><p><img src="/images/paper-reading-pin-slam/image-20241121215057434.png"></p><h2 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h2><p>KITTI数据集上，论文的odometry与其他LIDAR odometry比较平均相对平移漂移误差（%）：</p><p><img src="/images/paper-reading-pin-slam/image-20241121215842185.png"></p><p>KITTI数据集上，与不同的SLAM比较ATE RMSE：</p><p><img src="/images/paper-reading-pin-slam/image-20241121220046078.png"></p><p>KITTI数据集上，Loop Closure的直观效果：</p><p><img src="/images/paper-reading-pin-slam/image-20241121220407142.png"></p><p>Replica数据集上，拓展到RGB-D的PIN-SLAM与其他NeRF SLAM方法比较ATE RMSE：</p><p><img src="/images/paper-reading-pin-slam/image-20241121220626709.png"></p><p>在kitti数据集的四个序列上，与传统方法（上）和基于学习的方法（中）比较loop closure detection的召回率：</p><p><img src="/images/paper-reading-pin-slam/image-20241121220855248.png"></p><p>在NEWER COLLEGE数据集上和其他方法比较三维重建的质量：</p><p><img src="/images/paper-reading-pin-slam/image-20241121221021656.png"></p><p>地图压缩率实验：</p><p><img src="/images/paper-reading-pin-slam/image-20241121221402200.png"></p><p>在KITTI seq 00上不同子模块的处理时间：</p><p><img src="/images/paper-reading-pin-slam/image-20241121221557068.png"></p><p>对KITTI seq 00-10的平均运算速度和定位误差的比较：</p><p><img src="/images/paper-reading-pin-slam/image-20241121221643870.png"></p><h2 id="总结-amp-讨论"><a href="#总结-amp-讨论" class="headerlink" title="总结&amp;讨论"></a>总结&amp;讨论</h2><p>这篇文章非常扎实，工作做得非常完整，实验做得也非常充分。论文的工作、实验紧紧围绕SLAM(Simultaneous Localization and Mapping)中的localization和mapping，没有像其他NeRF SLAM、3DGS SLAM方法一样展示PSNR、SSIM等结果（笔者认为PSNR、SSIM主要是新视角合成的指标了，放在SLAM来展示有点奇怪，不过好像大家都爱比较这几个指标）。从实验结果上看，无论是localization还是mapping都非常有竞争力。</p><p>令笔者眼前一亮的是论文中elastic neural point的设计，通过这一设计实现的loop closure能够调整场景中的neural point，非常惊艳。这还是笔者第一次在NeRF、3DGS的方法中见到可以调整场景表示（比如MLP、grid feature、neural point、3DGS）的方法。</p><blockquote><p>理论上也可以让每一帧对应一个MLP，或者每一帧对应一个submap，但是这样的方法笔者觉得不是很好。</p></blockquote><p>论文在Limitations and future work提到了几点：</p><ul><li>可以引入IMU来实现更准确、高效的SLAM系统；</li><li>目前PIN-SLAM使用的是固定分辨率的neural point，后续可以考虑在场景中自适应的分布和移动neural point来提高重建的质量；</li><li>可以使用i-Kdtree等方法，在不使用voxel的情况下实现高效的最近邻搜索；</li><li>另外，也可以考虑借助语义信息进一步增强位姿估计和回环检测。</li></ul>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式表示 </tag>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neural Point SLAM回顾</title>
      <link href="2024/11/16/neural-point-slam/"/>
      <url>2024/11/16/neural-point-slam/</url>
      
        <content type="html"><![CDATA[<h1 id="Neural-Point-SLAM回顾"><a href="#Neural-Point-SLAM回顾" class="headerlink" title="Neural Point SLAM回顾"></a>Neural Point SLAM回顾</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><a href="https://immortalqx.github.io/2024/11/11/neural-point-rendering">上一篇文章</a>笔者回顾了Neural Point Rendering相关的工作，这篇文章笔者将聚焦于Neural Point在SLAM上的一些应用。</p><p>在NeRF时代出现的iMAP、NICE-SLAM、Co-SLAM等工作，他们的tracking基本都是渲染图像-计算损失-反向优化位姿；尽管也有Orbeez-SLAM、GO-SLAM等工作，但他们都借助了ORB-SLAM、Droid-SLAM等External Tracker，并不是在NeRF表示的场景之上直接做tracking的。</p><p>而到了3DGS时代，或许是因为研究惯性，早期的3DGS SLAM工作还是沿用了老一套的tracking方法：渲染图像-计算损失-反向优化位姿。</p><blockquote><p>是不是NeRF SLAM做一半转3DGS了，偷看(/ω＼*)……… (/ω•＼*)</p></blockquote><p>而到现在笔者写这篇文章，也没有了解到多少直接在3DGS上进行tracking的SLAM工作。另外，无论是NeRF SLAM还是3DGS SLAM，绝大部分工作都是通过子地图拼接来实现loop closure，或者只是通过位姿图优化(PGO)等方法在回环时调整了每一帧的位姿，并且需要进行额外的迭代优化来矫正地图。</p><blockquote><p>如果有笔者没有注意到的工作，欢迎在评论区讨论分享！！！</p><p>RGBD GS-ICP SLAM可以算一篇在3DGS上进行tracking的工作，但代码实现上看着很奇怪。。。</p></blockquote><p><img src="/images/neural-point-slam/image-20241111205712720-1731733908093-1.png" alt="《How NeRFs and 3D Gaussian Splatting are Reshaping SLAM: a Survey》中的表格"></p><p>不过，自从Point-NeRF等工作出现后，基于Neural Point的SLAM逐渐涌现。Point-SLAM将Neural Point的思路引入SLAM领域，而Point-SLAM的作者进一步提出了后续工作——Loopy-SLAM，在Point-SLAM的基础上实现了基于子地图拼接的Loop Closure。之后PIN-SLAM在Neural Point表示场景的框架下，实现了无需子地图的Loop Closure。</p><p>接下来笔者将着重介绍这三篇工作。</p><h2 id="Point-SLAM-Dense-Neural-Point-Cloud-based-SLAM-ICCV-2023"><a href="#Point-SLAM-Dense-Neural-Point-Cloud-based-SLAM-ICCV-2023" class="headerlink" title="Point-SLAM: Dense Neural Point Cloud-based SLAM (ICCV 2023)"></a>Point-SLAM: Dense Neural Point Cloud-based SLAM (ICCV 2023)</h2><p><img src="/images/neural-point-slam/image-20241113160839894-1731733908093-2.png"></p><p><strong>论文想要解决的问题</strong>：Can point-based neural scene representations be used for tracking and mapping for real-time capable SLAM?</p><p><strong>论文的贡献</strong>：</p><ul><li>We present Point-SLAM, a real-time capable dense RGBD SLAM approach which anchors neural features in a point cloud that grows iteratively in a data-driven manner during scene exploration. We demonstrate that the proposed neural point-based scene representation can be effectively used for both mapping and tracking.</li><li>We propose a dynamic point density strategy which allows for computational and memory efficiency gains and trade reconstruction accuracy against speed and memory.</li><li>Our approach shows clear benefits on a variety of datasets in terms of tracking, rendering and mapping accuracy.</li></ul><p><strong>论文的Pipeline</strong>：</p><p><img src="/images/neural-point-slam/image-20241112210239564-1731733908093-3.png"></p><h3 id="Neural-Point-Cloud-Representation"><a href="#Neural-Point-Cloud-Representation" class="headerlink" title="Neural Point Cloud Representation"></a>Neural Point Cloud Representation</h3><p><strong>场景表示</strong>：场景被表示为neural point cloud，每一个neural point包括位置、几何特征、颜色特征。</p><p><img src="/images/neural-point-slam/image-20241112210614858-1731733908093-4.png"></p><p><strong>Point Adding Strategy</strong>：</p><ul><li>采样阶段：在图像平面上均匀采样$X$个像素，并且在具有最高颜色梯度幅度的前$10Y$个像素中采样$Y$个像素。</li><li>判断是否需要添加点：利用深度图的信息，将像素点转换到三维空间，并且在每个点的半径$r$内查找是否有neural point。如果没有neural point，则需要添加neural point。</li><li>添加新的neural point：对于半径$r$内没有查找到neural point的那些像素点，需要沿着该像素的射线添加3个neural point，这三个点以该像素点的深度$D$为中心，偏移量为$(1-\rho)D$和$(1+\rho)D$，其中$\rho \in (0,1)$，是一个超参数，表示期望深度噪声。</li><li>初始化新的neural point：使用正态分布初始化每一个neural point的特征向量。</li></ul><p>这个添加点的策略允许在不提前知道场景边界的情况下进行建图，并且可以在场景探索过程中动态地调整特征点的分布，即使是不再访问新的场景部分，它也会收敛到有限的点集。</p><p><strong>Dynamic Resolution</strong>：</p><p>为了节省计算和内存资源，每个区域点的数量、密度都是动态调整的。</p><p>颜色梯度比较大的地方，可能信息比较丰富，就需要更大的点密度，Point Adding Strategy的搜索半径就可以设置的小一些。反过来，颜色梯度非常小的地方，那说明信息很少，可以更低的点密度，Point Adding Strategy的搜索半径可以更大一些。</p><p><img src="/images/neural-point-slam/image-20241112225654506-1731733908093-5.png"></p><h3 id="Rendering"><a href="#Rendering" class="headerlink" title="Rendering"></a>Rendering</h3><p><strong>解码器设计</strong>：Point-SLAM吸收了NICE-SLAM中decoder的设计思路，使用与NICE-SLAM相同结构的解码器。其中geometry decoder表示为$h$，和NICE-SLAM一样都是预训练好的网络，网络参数被固定住不再优化；而color decoder表示为$g_\xi$，和NICE-SLAM一样，网络的参数$\xi$是需要训练的。</p><p><strong>采样策略</strong>：与NICE-SLAM采样策略不同的是，Point-NeRF对于有深度的像素，在$(1-\rho)D$和$(1+\rho)D$之间均匀采样5个点，而对于没有深度的像素，在5cm和$1.2D_{max}$之间采样25个点。</p><p><strong>Neural Point查找</strong>：对于每一个采样点，在半径$2r$内查找neural point，至少需要查找到两个点，否则该点的占用率为0。如果存在多个点，就只取最近的8个点来计算。</p><p><strong>渲染过程</strong>：与NICE-SLAM、Point-NeRF等工作一样，都是采用体渲染得到深度和颜色。</p><p><strong>与Point-NeRF在渲染上的区别</strong>：Point-SLAM像NICE-SLAM一样，设计了geometry feature和color feature，而Point-NeRF只有color feature。另外，Point-SLAM对color feature采用了“Per-point processing”的处理，而geometry feature没有经过这个处理。</p><h3 id="Mapping-and-Tracking"><a href="#Mapping-and-Tracking" class="headerlink" title="Mapping and Tracking"></a>Mapping and Tracking</h3><p><strong>Mapping阶段</strong>：在Mapping阶段，Point-SLAM在RGBD帧上均匀渲染$M$个像素，并且使用如下所示的损失函数。在最开始的迭代中，Point-SLAM只使用深度项进行优化，之后剩下的60%次迭代中才会引入颜色项。</p><p><img src="/images/neural-point-slam/image-20241113151534897-1731733908093-6.png"></p><p><strong>Tracking阶段</strong>：Point-SLAM在每一帧中采样$M_t$个像素，并且使用恒速运动模型来初始化位姿。tracking使用的损失函数为：</p><p><img src="/images/neural-point-slam/image-20241113151854777-1731733908093-7.png"></p><h3 id="Exposure-Compensation"><a href="#Exposure-Compensation" class="headerlink" title="Exposure Compensation"></a>Exposure Compensation</h3><p>对于帧间曝光变化较大的场景，论文使用额外的模块来减少相应像素之间的色差。</p><h3 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h3><blockquote><p>论文展示了非常多的实验结果，下面只截取一部分。</p></blockquote><p><img src="/images/neural-point-slam/image-20241113160505424-1731733908093-8.png"></p><p><img src="/images/neural-point-slam/image-20241113160526160-1731733908093-9.png"></p><p><img src="/images/neural-point-slam/image-20241113160601067-1731733908093-10.png"></p><p><img src="/images/neural-point-slam/image-20241113160540402-1731733908093-11.png"></p><p><img src="/images/neural-point-slam/image-20241113160627377-1731733908093-12.png"></p><blockquote><p>为什么fr1/desk2和fr1/room，传统的几个SLAM方法都跑失败了？？？</p></blockquote><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><ul><li><p>如果允许对neural point的位置进行动态优化，可以更好的处理深度噪声。</p><blockquote><p>不过3DGS优化了每一个高斯的位置，也还是有比较严重的噪声。</p></blockquote></li><li><p>点密度的局部自适应基于简单的启发式方法，理想情况下，这一过程可以通过学习的方法来实现。</p></li><li><p>对运动模糊和高光反射比较敏感。</p></li></ul><h2 id="Loopy-SLAM-Dense-Neural-SLAM-with-Loop-Closures-CVPR-2024"><a href="#Loopy-SLAM-Dense-Neural-SLAM-with-Loop-Closures-CVPR-2024" class="headerlink" title="Loopy-SLAM: Dense Neural SLAM with Loop Closures (CVPR 2024)"></a>Loopy-SLAM: Dense Neural SLAM with Loop Closures (CVPR 2024)</h2><p><img src="/images/neural-point-slam/image-20241113161118522-1731733908093-13.png"></p><p><strong>论文提到的观点</strong>：</p><p>作者认为SLAM可以分为耦合和解耦合的方法，其中<strong>耦合的方法指的是使用相同的场景表示来进行tracking和mapping，解耦的方法对每个任务都使用独立的框架</strong>。</p><ul><li><p>目前解耦的方法能够实现更好的跟踪精度，但是会产生不期望的数据冗余和独立性。耦合方法中，除了MIPS_Fusion之外，其他所有方法都是实现的frame-to-model tracking，这会导致面对现实场景中带有噪声的数据，估计的位姿会产生显著的漂移。</p><blockquote><p>但是frame-to-frame不应该更容易漂移？只不过frame-to-model太容易受到噪声影响了，毕竟model构建的不好，新来的frame估计的位姿也不好，又导致更新之后的model更差了，开始滚雪球了。</p></blockquote><p>作者提到的解耦的方法：</p><ul><li>Orbeez-slam</li><li>Newton: Neural view-centric mapping for on-the-fly large-scale slam.</li><li>NeRF-SLAM: Real-Time Dense Monocular SLAM with Neural Radiance Fields</li><li>Go-slam: Global optimization for consistent 3d instant reconstruction.</li></ul></li><li><p>作者认为tracking和mapping是耦合的任务，可以用相同的场景表示。但是解耦方法基本都使用多分辨率哈希网格，这样不容易进行地图校正，而<strong>基于点的表示方法特别适合进行地图校正</strong>。（论文的motivation）</p><p>作者提到的耦合的方法：</p><ul><li>Eslam: Efficient dense slam system based on hybrid representation of signed distance fields</li><li>Point-slam: Dense neural point cloud-based slam.</li><li>iMAP: Implicit Mapping and Positioning in Real-Time.</li><li>Co-slam: Joint coordinate and sparse parametric encodings for neural real-time slam</li><li>Vox-fusion: Dense tracking and mapping with voxel-based neural implicit representation.</li><li>Nice-slam: Neural implicit scalable encoding for slam.</li></ul></li></ul><p><strong>论文的贡献</strong>：</p><ul><li>We propose Loopy-SLAM, a dense RGBD SLAM approach which anchors neural features in point cloud submaps that grow iteratively in a data-driven manner during scene exploration. We dynamically create submaps depending on the camera motion and progressively build a pose graph between the submap keyframes. Global place recognition is used to detect loop closures online and to globally align the trajectory and the submaps with simple and efficient rigid corrections directly on the scene representation.</li><li>We propose a direct way of implementing loop closure for dense neural SLAM that does not require any gradient updates of the scene representation or reintegration strategies, contrary to previous works.</li><li>Traditionally, rigid submap registration may create visible seams in the overlapping regions. Our approach based on neural point clouds avoids this and we apply feature refinement of color and geometry at the end of the trajectory capture. We further introduce a feature fusion strategy of the submaps in the overlapping regions to avoid excessive memory usage and to improve the rendering performance.</li></ul><p><strong>论文的Pipeline</strong>：</p><p><img src="/images/neural-point-slam/image-20241114154645443-1731733908093-14.png"></p><h3 id="Neural-Point-Cloud-based-SLAM"><a href="#Neural-Point-Cloud-based-SLAM" class="headerlink" title="Neural Point Cloud-based SLAM"></a>Neural Point Cloud-based SLAM</h3><p>这部分基本与Point-SLAM是一样的，多了子地图构建的内容。</p><p>子地图的第一帧作为global keyframe，在当前子地图中，当前帧与对应的global keyframe的旋转角度或者相对平移超过设定的阈值，就会创建新的子地图。</p><p>在每个子地图中还会间隔一定帧选择一次local keyframe，用于优化子地图。但是当新的子地图被初始化时，这些local keyframe会被删除。</p><h3 id="Loop-Closure-and-Refinement"><a href="#Loop-Closure-and-Refinement" class="headerlink" title="Loop Closure and Refinement"></a>Loop Closure and Refinement</h3><p>与MIPS-Fusion相比的话，Loopy-SLAM的loop closure比较功利，每次开始新的submap就检测一次回环。MIPS-Fusion是开启新的submap之后，如果再回到之前submap的subvolume中才会检测，而且还有额外的条件。</p><p><strong>Global Place Recognition</strong>：每个全局关键帧都被添加到视觉词袋Bow数据库中用于全局位置识别。这里论文cue了一下MIPS-Fusion，作者认为MIPS-Fusion这种通过重叠的submap去检测回环，只适合较小漂移的校正。</p><p><strong>Pose Graph Optimization</strong>：每个节点$T_s \in SE(3)$表示global keyframe在世界坐标系下的位姿的correction。姿态图中包括了两种边，其中odometry edge连接了相邻子地图的global keyframe，并且使用单位矩阵作为约束；loop edge连接不相邻的子地图的global keyframe，每次完成一个子地图就查询词袋（Bow）数据库，根据查询结果添加loop edge。PGO最终的输出是对global keyframe姿态的一组刚性校正变换$T$。</p><p><strong>Loop Edge Constraints</strong>：对于子地图$P^s$和$P^t$之间的loop edge，需要计算约束条件$T_{st}$。论文提到，直接使用子地图中的neural point cloud是不稳定的，有两个原因：</p><ol><li>密集表面配准方法需要在表面均匀采样，但是子地图的分辨率是动态的；</li><li>子地图中的锚定点（应该就是地图中的neural point）来自单个深度观测，可能会存在噪声，从而影响配准的结果。</li></ol><p>因此，论文使用由粗到精的方法来对齐两个子地图，为了减轻上面提到的问题，论文通过volumetric TSDF Fusion来整合与子地图相关联的所有深度帧，并通过marching cubes提取表面，在表面上均匀采样得到新的点云$S^s$和$S^t$。</p><p>粗对齐阶段，论文使用Rusu等人（Fast point feature histograms (fpfh) for 3d registration）的全局配准方法。</p><p>精配准阶段，论文使用ICP在完整分辨率的点云上进行配准。</p><p><strong>Feature Fusion and Refinement</strong>：在Tracking结束之后，Loopy SLAM会将所有子地图连接到一起组成一个global neural point cloud。这个过程首先在重叠的子地图区域进行特征融合来压缩模型，由于Loopy SLAM是基于Point SLAM的工作，本质上还是feature+decoder的结构，这里论文选择的是特征融合之后固定decoder，然后把color和geometry feature再进行优化。</p><h3 id="实验部分-1"><a href="#实验部分-1" class="headerlink" title="实验部分"></a>实验部分</h3><p>论文主要在Replica、TUM-RGBD、ScanNet上做了实验。</p><p>Tracking的结果：</p><p><img src="/images/neural-point-slam/image-20241115160846971-1731733908093-15.png"></p><p><img src="/images/neural-point-slam/image-20241115160900284-1731733908093-16.png"></p><p><img src="/images/neural-point-slam/image-20241115160948491-1731733908093-17.png"></p><p>Rendering和Reconstruction的结果：</p><p><img src="/images/neural-point-slam/image-20241115161116456-1731733908093-18.png"></p><p><img src="/images/neural-point-slam/image-20241115161139043-1731733908093-19.png"></p><p><img src="/images/neural-point-slam/image-20241115161202262-1731733908093-20.png"></p><p>运行时间、内存占用的结果：</p><p><img src="/images/neural-point-slam/image-20241115161255244-1731733908093-21.png"></p><p>场景中点的数量：</p><p><img src="/images/neural-point-slam/image-20241115161410425-1731733908093-22.png"></p><h3 id="局限性-1"><a href="#局限性-1" class="headerlink" title="局限性"></a>局限性</h3><p>下面是论文提到的局限性：</p><ul><li><p>可以结合使用frame-to-model和frame-to-frame queues的组合来构建更健壮的tracker；</p><blockquote><p>类似于构建local map，实现frame-to-local model？</p></blockquote></li><li><p>loopy-slam只利用了3D点特征，其实还可以利用关联关键帧的图像特征，从而实现更鲁棒更快速的配准；</p></li><li><p>位置识别可以通过学习的方法来提升；</p></li><li><p>loopy-slam没有实现relocalization。</p><blockquote><p>relocalization指的是tracking失败的时候，重新定位相机所在的位置，恢复tracking。</p></blockquote></li></ul><p>下面是笔者认为的局限性：</p><ul><li>没有在更大的场景中验证loop closure的有效性，比如TUM-RGBD fr3有两个专门用于回环检测的场景；</li><li>还是基于子地图拼接的思路实现的loop closure，不能够调整子地图中neural point之间的结构。</li></ul><h2 id="PIN-SLAM-LiDAR-SLAM-Using-a-Point-Based-Implicit-Neural-Representation-for-Achieving-Global-Map-Consistency-TRO-2024"><a href="#PIN-SLAM-LiDAR-SLAM-Using-a-Point-Based-Implicit-Neural-Representation-for-Achieving-Global-Map-Consistency-TRO-2024" class="headerlink" title="PIN-SLAM: LiDAR SLAM Using a Point-Based Implicit Neural Representation for Achieving Global Map Consistency (TRO 2024)"></a>PIN-SLAM: LiDAR SLAM Using a Point-Based Implicit Neural Representation for Achieving Global Map Consistency (TRO 2024)</h2><p><img src="/images/neural-point-slam/image-20241115195333282-1731733908093-23.png"></p><p><strong>论文想要解决的问题</strong>：These SLAM approaches <strong>lack support for direct loop closure corrections</strong> and are <strong>not able to build globally consistent maps of larger scenes</strong>. This is mainly due to the usage of regular grid-based local feature embeddings, which are not elastic and resilient to loop corrections.</p><p><strong>论文为什么选择neural point表示场景</strong>：We opt to use a neural point-based implicit representation, which has two main advantages over grid-based representations: <strong>the flexibility of spatial distribution and the elasticity for transformations</strong>. Recent work (Point-SLAM) only makes use of the first advantage for neural RGB-D SLAM at the cost of scalability and inefficient neighborhood querying. Instead, we exploit the second and more important advantage to build a globally consistentmap that can be corrected while online mapping after closing a loop, which is essential for large-scale LiDAR-based SLAM.</p><p>论文在Introduction提到，Mapping部分主要是基于之前的工作SHINE-Mapping，而Odometry部分是扩展了之前的工作LocNDF。</p><blockquote><p>工作是延续的，非常扎实，令人羡慕。</p></blockquote><p><strong>论文提出了四个key claims</strong>：</p><ol><li>Our SLAM system achieves <strong>localization accuracy better or on par with state-of-the-art</strong> LiDAR odometry/SLAM approaches and is more accurate than recent implicit neural SLAM methods on various datasets using different range sensors.</li><li>Our method can conduct <strong>large-scale globally consistent mapping with loop closure</strong> thanks to the elastic neural point representation.</li><li>Our map representation is <strong>more compact than the previous counterparts</strong> and <strong>can be used to reconstruct accurate and complete meshes at an arbitrary resolution</strong>.</li><li>Our correspondence-free scan-to-implicit map registration and the efficient neural point indexing by voxel hashing enable our algorithm to <strong>run at the sensor frame rate on a single NVIDIA A4000</strong> graphics processing unit (GPU).</li></ol><p><strong>论文对基于Submap的方法的评价</strong>：The submap-based methods accumulate the observations as a submap and assume the submap is a locally defined rigid body. The pseudoglobal consistency is maintained by optimizing a graph linking submaps and their associated poses through submap-to-submap registrations. The usage of submaps decreases the number of nodes and edges in PGO, thus saving computational effort. However, these methods have issues of ambiguity in the overlapping region of the adjacent submaps and determining appropriate criteria for submap division to balance the rigidity and efficiency.</p><p><strong>论文的Pipeline</strong>：</p><p><img src="/images/neural-point-slam/image-20241115205159958-1731733908093-24.png"></p><p>论文将他们的方法分成5个部分：</p><ol><li><strong>Preprocessing</strong>：对于输入点云$P$，通过体素下采样到用于registration的点云$P_r$和用于mapping的点云$P_m$；</li><li><strong>Odometry</strong>：通过将点云$P_r$与local map $M_l$的implicit SDF进行配准来估计全局的位姿$T_{WC_t}$，并将前后两帧的变换$T_{C_{t-1}C_t}$作为一条边添加到Pose Graph $G$中。</li><li><strong>Mapping</strong>：根据地图$M$过滤掉用于mapping的点云$P_m$中的动态点，并沿着从传感器到$P_m$中每个点的射线进行采样，得到训练样本$D$，并使用在Odometry中计算的位姿$T_{WC_t}$将其转换到世界坐标系中。使用靠近场景表面的样本$D_s \subset D$来初始化新的neural point，并且将他们附加到地图$M$上，并且重置local map $M_l$，让其以当前位置$T_{WC_t}$为中心。使用采样的点$D_s$来更新训练样本池$D_p$，并且使用$D_p$和SDF监督来优化local map $M_l$中的neural point feature。最后将更新之后的local map $M_l$分配回global map $M$中。</li><li><strong>Loop closure detection</strong>：通过local map $M_l$生成一个本地极坐标上下文描述符$U_t$。之后通过比较当前帧和候选帧描述符之间的特征距离来搜索潜在的loop closure。一旦检测到当前帧$C_t$和候选帧$C_k$之间的存在闭环，就通过将当前帧点云$P_r$和以候选帧位置$t_{WC_k}$为中心的local map $M_l$进行配准，来验证是否真的存在闭环。如果配准成功，就将配准产生的变换$T_{C_kC_t}$作为新的边添加到Pose Graph $G$中。</li><li><strong>Pose graph optimization</strong>：加入loop closure edge之后，对pose graph $G$进行优化。优化之后对global map $M$中每个neural point的位置和方向及其关联帧进行变换，以保证全局一致性。在完成loop correction之后，对训练样本池$D_p$进行变换，并且重置local map $M_l$。</li></ol><blockquote><p>PIN-SLAM的内容非常多，可以移步<a href="https://immortalqx.github.io/2024/11/21/paper-reading-pin-slam">这篇文章</a>。</p></blockquote><h2 id="总结-amp-讨论"><a href="#总结-amp-讨论" class="headerlink" title="总结&amp;讨论"></a>总结&amp;讨论</h2><p>在PIN-SLAM出来之前，笔者一直认为与NeRF、Neural Point相比，3DGS才是最“几何”的表示方法，毕竟3DGS显示的给出了点云，尽管这个点云有很多的噪声。</p><p>而当时一些neural point的工作，比如Point-NeRF论文中说“we find that directly optimizing the location of the existing points makes the training unstable and cannot fill the large holes”，笔者便认为neural point效果好主要是因为feature + decoder这一套流程的差值能力好，以及neural point也避免了在空白区域采样。而neural point的位置几乎无法优化，直接使用输入的点云，并且通过一些简单的加剪枝策略添加和删除点，那“几何”肯定是很好的，不过怎么利用这一点是个难解决的问题。</p><p>在Point-SLAM和Loopy-SLAM中，neural point是从RGB-D输入得到的，但是它们没有用传统的点云配准方法实现tracking，而是渲染图像-计算损失-反向优化位姿，其中Loopy-SLAM的loop closure也还是通过子地图的方式实现的，与之前一些基于feature grid的nerf slam没有太大的区别，并没有利用到neural point在几何上的优点。</p><p>而PIN-SLAM对neural point的开发很深入，不但实现了在neural point上进行tracking，也实现了不使用子地图的loop closure，工作做得非常完整。PIN-SLAM主要是面向lidar的，不过也扩展到了RGB-D的输入上，论文的实验部分展示了在Replica数据集上与一众RGB-D NeRF SLAM方法的对比，位姿精度遥遥领先。</p><p>笔者认为科研创新不是一蹴而就的，解决问题应该建立在完全认知问题的基础上。笔者目前在3DGS SLAM的研究上遇到一些困难，因此回顾了与3DGS很相似的Neural Point系列的方法，写了这两篇文章，希望能从中得到一些灵感，更全面的认识问题，也期待能和大家交流讨论。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>How NeRFs and 3D Gaussian Splatting are Reshaping SLAM: a Survey</li><li>Point-SLAM: Dense Neural Point Cloud-based SLAM</li><li>Loopy-SLAM: Dense Neural SLAM with Loop Closures</li><li>PIN-SLAM: LiDAR SLAM Using a Point-Based Implicit Neural Representation for Achieving Global Map Consistency</li></ol><p><strong>注：本文是笔者学习研究过程中的思考整理，如有错误疏漏，请各路大佬批评斧正！</strong></p>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式表示 </tag>
            
            <tag> NeRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neural Point Rendering回顾</title>
      <link href="2024/11/11/neural-point-rendering/"/>
      <url>2024/11/11/neural-point-rendering/</url>
      
        <content type="html"><![CDATA[<h1 id="Neural-Point-Rendering回顾"><a href="#Neural-Point-Rendering回顾" class="headerlink" title="Neural Point Rendering回顾"></a>Neural Point Rendering回顾</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>3D Gaussian Splatting这两年非常火，已经取代NeRF成为了计算机视觉、SLAM等领域的新热点，每周都能看到很多3DGS的工作出现。</p><p>笔者自己是研究3DGS SLAM的，在学习和做实验的过程中发现，3DGS作为一种显示的表示方法，其几何性质却没有那么好，与传统的点云数据相比，3DGS的点云只捕获了粗糙的几何结构，而且通常存在噪声，这导致3DGS虽然提供了显示的点云，但是在上面做配准很困难。目前笔者了解到在3DGS上做配准的工作只有《GaussReg: Fast 3D Registration with Gaussian Splatting》这一篇，具体可以看笔者的<a href="https://immortalqx.github.io/2024/08/16/paper-reading-gaussianreg">博客文章</a>。</p><p>与3DGS相比，笔者认为Neural Point的表示方法在几何上更有优势，因此笔者选择了neural point相关的几篇工作，做一个回顾整理。</p><h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><h3 id="Neural-Point-Based-Graphics-ECCV-2020"><a href="#Neural-Point-Based-Graphics-ECCV-2020" class="headerlink" title="Neural Point-Based Graphics (ECCV 2020)"></a>Neural Point-Based Graphics (ECCV 2020)</h3><p><img src="/images/neural-point-rendering/image-20241107193256641.png"></p><p>如下图所示，该方法使用raw point cloud作为场景几何表示，每个点都带有一个learnable neural descriptor，这个descriptor编码了局部的几何形状和外观；之后根据相机位姿，在不同的分辨率下通过z-buffer对点云进行栅格化，得到不同分辨率下的raw images，这些raw images的像素就是对应点云的descriptor；之后把这一组不同分辨率下的raw images通过类似U-net的Rendering network，可以得到最终渲染的图像。</p><p><img src="/images/neural-point-rendering/image-20241105204710606.png"></p><p>根据论文Method部分的描述，上面的具体流程为：</p><h4 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h4><p>场景被表示为带有$M$维神经描述符$D = {d_1,d_2,…,d_N}$的点云$P={p_1,p_2,…,p_N}$。需要渲染在相机$C$（提供了相机位姿和内参）下的新视图，新视图具有$W \times H$的像素网格，并且viewpoint为$p_0$。</p><h4 id="渲染过程（forward）"><a href="#渲染过程（forward）" class="headerlink" title="渲染过程（forward）"></a>渲染过程（forward）</h4><p>创建一个$M$通道、分辨率为$W \times H$的raw image，记为$S(\mathrm {P},\mathrm {D},C)$；</p><p>将场景中的点投影到目标视图上，比如对于某个点$p_i$，投影到raw image中的$(x,y)$处：<br>$$<br>S(\mathrm {P},\mathrm {D},C)[[x],[y]] = d_i<br>$$<br>由于可能存在很多点投影到相同的像素上，因此论文使用z-buffer算法来过滤被遮挡的点，只保留距离像素平面最近的那个点。但是点云缺乏拓扑信息，很容易出现孔洞，这会导致被遮挡表面的点或来自背景的点被投影到了图像上，即bleeding problem。</p><blockquote><p>可以看这个<a href="https://gamedev.stackexchange.com/questions/46963/how-to-avoid-texture-bleeding-in-a-texture-atlas">链接</a>，简单了解一下texture bleeding的现象</p></blockquote><p>论文提到，传统的解决思路是通过splatting，而他们选择创建很多不同分辨率的raw image，$S[1],S[2],…S[T]$，其中对于第i张raw image，分辨率为$\frac{W}{2^t} \times \frac{H}{2^t}$。这样的话，分辨率越高的raw image，包含的细节最多，但是bleeding的问题越严重，而分辨率越低的图像，包含了粗糙的几何细节，同时bleeding的问题越轻微。</p><blockquote><p>splatting？3D Gaussian Splatting启动！</p><p>话说这里的splatting是什么？也没有见它引用文献。。。</p><blockquote><p>可以看看这篇文章：</p><p>Splatting 抛雪球法简介 - bo233的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/660512916">https://zhuanlan.zhihu.com/p/660512916</a></p></blockquote></blockquote><p>得到不同分辨率的raw images之后，就可以通过论文的rendering network，得到最终的RGB图像了。</p><p><img src="/images/neural-point-rendering/image-20241105222855468.png"></p><h4 id="训练过程（backward）"><a href="#训练过程（backward）" class="headerlink" title="训练过程（backward）"></a>训练过程（backward）</h4><p><img src="/images/neural-point-rendering/image-20241105223310293.png"></p><p>论文是通过优化rendering network的参数$\theta$和神经描述符$D = {d_1,d_2,…,d_N}$来拟合场景的。</p><p>值得注意的是，论文提到rendering network的训练被分为两个阶段：第一阶段是在一组特定类型的场景上进行预训练，第二个阶段是在新场景上进行fine-tune。因此对于新场景的拟合，是fine-tune预训练好的rendering network和从头开始训练每一个点的descriptor。</p><h4 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h4><p>略，看原论文吧~</p><h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><ul><li><p>论文提到他们的模型不能填补较大的空洞，另外也没有研究在动态场景中的性能。</p></li><li><p>看论文中的TABLE2，每一个点的descriptor也不大，descriptor的长度和点的数量对场景的影响似乎较小。从这里看的话，这个工作渲染质量的瓶颈应该是Pipeline中的Rendering network。</p><p><img src="/images/neural-point-rendering/image-20241107191530848.png"></p></li></ul><h3 id="Point-NeRF-Point-based-Neural-Radiance-Fields-CVPR-2022"><a href="#Point-NeRF-Point-based-Neural-Radiance-Fields-CVPR-2022" class="headerlink" title="Point-NeRF: Point-based Neural Radiance Fields (CVPR 2022)"></a>Point-NeRF: Point-based Neural Radiance Fields (CVPR 2022)</h3><p><img src="/images/neural-point-rendering/image-20241107193322757.png"></p><p><strong>论文的Motivation：</strong>long reconstruction times due to the slow per-scene network fitting and the unnecessary sampling of vast empty space.</p><p><strong>论文的Pipeline：</strong></p><p><img src="/images/neural-point-rendering/image-20241107193636916.png"></p><p>论文在这张图里把自己的工作分成了两个部分，(a) Neural Point Generation和(b) Point-NeRF Representation with Volume Rendering。不过论文是按照Point-NeRF Representation和Point-NeRF Reconstruction来讲的，下面笔者也按照论文的思路来介绍。</p><h4 id="Point-NeRF-Representation"><a href="#Point-NeRF-Representation" class="headerlink" title="Point-NeRF Representation"></a>Point-NeRF Representation</h4><p><strong>场景表征</strong>：使用neural point cloud表示场景<br>$$<br>P = {(p_i, f_i, \gamma_i)|i = 1,…,N}<br>$$<br>对于第$i$个neural point，$p_i$表示该点的坐标，$f_i$是对应的neural feature vector，编码了局部场景的信息，$\gamma_i$是scale confidence value，表示该点位于实际场景表面附近的可能性。</p><p>对于三维空间中任意的一个点$x$，Point-NeRF会在半径$R$内查询周围$K$个相邻neural point，之后通过该点的坐标$x$、观察方向$d$和$K$个相邻的neural point，得到$x$处的volume density $\sigma$和view-dependent radiance $r$。这个过程对应的公式为：<br>$$<br>(\sigma,r) = \text{Point-NeRF}(x,d,p_1,f_1,\gamma_1,…,p_K,f_K,\gamma_K)<br>$$<br><strong>Per-point processing</strong>：对于相邻点的neural feature vector，Point-NeRF不是直接拿过来就给位置$x$处用的，而是过了一个MLP网络$F$，相当于是根据距离加权，做一个插值，拿到插值之后的neural feature vector。</p><blockquote><p>个人感觉这一步没必要，下面还有一个类似的处理。</p></blockquote><p>$$<br>f_{i,x} = F(f_i,x-p_i)<br>$$</p><p><strong>View-dependent radiance regression</strong>：Point-NeRF使用逆距离加权来得到位置$x$处的neural feature vector。</p><img src="/images/neural-point-rendering/image-20241107210554355.png" style="zoom: 50%;"><p>之后通过一个MLP网络$R$根据特征$f_x$和观察方向$d$回归得到位置$x$的radiance $r$。<br>$$<br>r = R(f_x,d)<br>$$<br><strong>Density regression</strong>：和上面的过程类似，不过是先计算每个相邻点的体密度，再通过逆距离加权来得到最终的体密度。</p><img src="/images/neural-point-rendering/image-20241107211223065.png" style="zoom:67%;"><h4 id="Point-NeRF-Reconstruction"><a href="#Point-NeRF-Reconstruction" class="headerlink" title="Point-NeRF Reconstruction"></a>Point-NeRF Reconstruction</h4><p><img src="/images/neural-point-rendering/image-20241107211447810.png"></p><h5 id="初始化：Generating-initial-point-based-radiance-fields"><a href="#初始化：Generating-initial-point-based-radiance-fields" class="headerlink" title="初始化：Generating initial point-based radiance fields"></a>初始化：Generating initial point-based radiance fields</h5><p>论文提到完全从头开始训练随机初始化的neural feature和MLP可能会非常慢，因此他们设计了这个初始化的模块。这里放一个哔哩哔哩UP主<a href="https://space.bilibili.com/355024665">意の茗</a>的总结：</p><p><img src="/images/neural-point-rendering/image-20241107215153253.png"></p><h5 id="优化：Optimizing-point-based-radiance-fields"><a href="#优化：Optimizing-point-based-radiance-fields" class="headerlink" title="优化：Optimizing point-based radiance fields"></a>优化：Optimizing point-based radiance fields</h5><p>论文在这里提到初始的点云，特别是其他重建方法的点云（比如Metashape或者COLMAP等方法），通常会包含孔洞和异常值，为了解决这个问题，Point-NeRF尝试过直接优化现有点的位置，但是发现这样会导致训练不稳定。因此最终的解决思路是：设计新颖的point pruning和point growing策略。</p><blockquote><p>3DGS优化了点的位置欸</p></blockquote><p><strong>Point pruning</strong></p><p>每个neural point都保存了自己的置信度$\gamma$，这个置信度表示该点是否靠近场景的表面。Point-NeRF利用这些置信度来修剪异常点，置信度低说明该点附近的区域可能是空的。因此Point-NeRF每10k次迭代就修剪掉那些$\gamma &lt; 0.1$的点。</p><p>针对每个点的置信度，论文设计了一个sparsity loss，这个损失函数会强迫每个点的置信度接近0或1。</p><img src="/images/neural-point-rendering/image-20241107221339051.png" style="zoom: 33%;"><p>论文作者认为这种剪枝技术可以去除异常点，减少相应的伪影。</p><p><strong>Point growing</strong></p><p>Point growing的目的是在不存在点的空白区域恢复信息，核心思路是逐步增长在点云边界附近的点。</p><p>具体的思路是，把每次沿着射线采样的点作为新的候选点，计算这条射线不透明度最高的位置$x_{jg}$，以及该位置到最近neural point的距离。</p><img src="/images/neural-point-rendering/image-20241107222828251.png" style="zoom:50%;"><p>如果不透明度$\alpha_j$和最近neural point的距离都大于设定的阈值，就说明位置$x_{jg}$位于场景的表面附近，但是这个位置附近又缺少neural point，Point-NeRF就会在位置$x_{jg}$新增一个neural point。</p><p>通过重复这种生长策略，Point-NeRF可以逐渐扩展并覆盖初始点云中缺失的区域，比如下图这种比较极端的情况，也可以通过该策略逐步增长新的neural point，从而覆盖整个物体表面。</p><p><img src="/images/neural-point-rendering/image-20241107223232630.png"></p><h4 id="实验部分-1"><a href="#实验部分-1" class="headerlink" title="实验部分"></a>实验部分</h4><blockquote><p>只写几个个人感兴趣的实验，其他部分看原论文吧~</p></blockquote><p>Table 1这里可以发现，Point-NeRF初始化之后就有了一个不错的结果，而经过一段时间的优化之后，各项指标都很突出。</p><p><img src="/images/neural-point-rendering/image-20241107223505876.png"></p><p>论文的Table 4还对比了点云点修剪和生长的效果，并且展示了在Point-NeRF初始化的点和COLMAP提供的点上的效果。可以看到点云修建和生长策略可以给各项指标带来很大的提升，而且使用Point-NeRF初始化的上限比COLMAP要更高</p><blockquote><p>也许因为本质上还是走的体渲染流程，初始化的点全部在表面上，采样不了几个点，所以论文P&amp;G其实主要是在物体内部疯狂生成新的点？或者在表面附近生成很多个点？</p></blockquote><img src="/images/neural-point-rendering/image-20241107224306676.png" style="zoom: 67%;"><h4 id="局限性-1"><a href="#局限性-1" class="headerlink" title="局限性"></a>局限性</h4><ul><li><p>查询MLP的次数和原版NeRF差不多，渲染速度上没有提升</p></li><li><p>点云密度和渲染质量之间需要平衡，大场景重建可能会比较吃力</p><ul><li>点云密度高，显存占用增加</li><li>降低点云密度，会降低渲染质量</li></ul></li></ul><h3 id="INPC-Implicit-Neural-Point-Clouds-for-Radiance-Field-Rendering"><a href="#INPC-Implicit-Neural-Point-Clouds-for-Radiance-Field-Rendering" class="headerlink" title="INPC: Implicit Neural Point Clouds for Radiance Field Rendering"></a>INPC: Implicit Neural Point Clouds for Radiance Field Rendering</h3><blockquote><p>2024年3月25日，在3D Gaussian Splatting浪潮席卷下，一篇Neural Point相关的工作被挂在了arxiv上~</p><blockquote><p>都年底了，这篇文章怎么还没中稿？</p></blockquote></blockquote><p><img src="/images/neural-point-rendering/image-20241108154550207.png"></p><p><strong>论文的Motivation</strong>：当前新视角生成的研究主要分为了两个方向，一个是implicit radiance fields的方法，一个是explicit point-based的方法。然而前者依赖intensive ray-marching，后者则需要a-priori point proxies。对此论文希望创建一种新的场景表示方法，结合这两种方法的优点，同时绕过ray-marching和explicit priors。</p><blockquote><p>看起来是在尝试结合3DGS和Zip-NeRF，原论文是这么说的：</p><p>More specifically, we take inspiration from current state-of-the-art approaches 3D Gaussian Splatting and Zip-NeRF: We decompose and optimize a scene into two parts, which constitutes a concept that we dub implicit point cloud.</p></blockquote><p><strong>论文对Zip-NeRF的评价</strong>：The current state-of-the-art in this field, Zip-NeRF, combines ideas from both quality and efficiency directions: It augments the underlying gridbased data structure with anti-aliasing through conical sampling, the addition of scaling information, and refined empty space skipping. While Zip-NeRF is comparably fast in training (taking about 5 hours), the rendering speed for novel views is limited to ∼ 0.2 fps on consumer-grade hardware. This approach is closest in mind to our method, as we also recombine grid-based appearance information with implicit density formulation for scene reconstruction. In contrast to Zip-NeRF, however, our method enables rasterization-based rendering, making it faster in inference.</p><p><strong>论文对3DGS的评价</strong>：Especially important here is 3D Gaussian Splatting (3DGS) which extends point rendering with anisotropic 3D Gaussians as a radiance field rendering paradigm. Apart from removing the need for a CNN to fill holes, this formulation allows them to start with a sparser point cloud that is densified by repeatedly splitting large Gaussians during the optimization.</p><p><strong>论文的Pipeline</strong>：</p><p><img src="/images/neural-point-rendering/image-20241108213938413.png"></p><p>与上面的两个工作不同，INPC的neural point是隐式的，点的位置被保存在基于八叉树的概率场中，点的外观（颜色、特征、不透明度）被保存在类似于instant-ngp的neural field中。</p><p>对于某个给定的视角，INPC会对Implicit Point Cloud进行采样，得到显示的点云（位置和特征向量），之后通过Bilinear Point Splatting得到多分辨率的2D feature map，再和Background Model的输出进行$\alpha$-blending，最后通过U-Net结构的渲染网络渲染得到该视角下的图像。</p><blockquote><p>Neural Point-Based Graphics是创建很多不同分辨率的raw image，不使用splatting。</p><p>这个工作怎么又splatting，又多分辨率？</p></blockquote><h4 id="Sparse-Point-Probability-Octree"><a href="#Sparse-Point-Probability-Octree" class="headerlink" title="Sparse Point Probability Octree"></a>Sparse Point Probability Octree</h4><p>作者在这部分开头又提到，现有的NeRF方法不需要明确的几何形状，相比之下基于点的方法在优化过程中需要长期保存显示的点云。之后又重申了本工作的一个目标是，在point-based neural rendering pipeline中消除对长期保存显示点云的需求。</p><blockquote><p><strong>质疑：</strong>看到这里仍然不理解为什么作者的目标是”One goal of this work is removing the need for a persistent set of point positions within a typical point-based neural rendering pipeline.“</p><p>这个工作似乎在追求完全隐式的场景表示方法，感觉有点极端了。这样有什么优势呢？这篇论文并没有多少篇幅进行介绍，而且也没有说清楚explicit point-based的方法需要a-priori point proxies为什么是不好的。</p><blockquote><p>也许这样可以避免point-nerf、3DGS需要的致密化？这是笔者唯一能想到的一个点了，显示的方法需要明确某个地方有多少个点，点的数量或者密度会影响最后渲染的结果，点的数量过多会导致显存占用上升。</p></blockquote></blockquote><p><strong>初始化</strong>：使用3D体素网格初始化概率场，稀疏八叉树的初始叶节点概率设置为1。也可以将点云作为先验来计算初始叶节点的概率。</p><p><strong>概率更新</strong>：叶节点的概率表示相对于其他的叶节点，场景几何占据它体积的多少。论文对此设计了一种更新策略，通过如下的公式更新所有叶节点的概率。</p><img src="/images/neural-point-rendering/image-20241111150018808.png" style="zoom: 50%;"><p>其中${b_0,…,b_n}$是使用第$i$个叶节点生成的所有点的$\alpha \text{-blending}$权重的集合，而$\lambda_u$是超参数，论文设置为0.9968。</p><p><strong>叶节点细分</strong>：上面的概率更新公式，会使得只有一部分被场景占据的叶子节点获得比较高的概率。论文的策略是对概率大于设定阈值的所有叶节点进行细分，并且叶子节点总数不能超过$256^3$。</p><p><strong>剪枝</strong>：通过上面的概率更新公式，没有覆盖到场景的叶子节点概率会指数衰减到0，删除小于指定阈值的叶子节点即可实现剪枝。</p><h4 id="Point-Sampling-Strategies"><a href="#Point-Sampling-Strategies" class="headerlink" title="Point Sampling Strategies"></a>Point Sampling Strategies</h4><p>该部分的核心思路是对Sparse Point Probability Octree进行采样，论文设计了两种采样策略：基于特定视角的采样方案（Viewpoint-Specific Sampling）和独立于视角的采样方案（Viewpoint-Independent Sampling）。对于训练，可以生成特定视角下的点云；而全局的、独立于视角的点云可以增加时间稳定性和渲染的性能，不需要对隐式的点云进行逐帧采样。</p><p><strong>Viewpoint-Specific Sampling</strong>：针对特定视角的加权方案主要考虑以下三点：1）不能在相机视锥体外采样；2）远离相机的区域少采样；3）具有较高细分级别的叶子，即代表较小体积的叶子，需要少采样。对应的公式如下：</p><img src="/images/neural-point-rendering/image-20241111152706562.png" style="zoom: 50%;"><p>其中$\mathbb{1}_{visible}$是一个指示函数，可见叶子节点返回1，不可见叶子节点返回0。$\lambda_l$表示应该采样多少较小的体素，论文设置为0.5，$d_i$表示叶子中心到图像平面之间的距离。</p><p><strong>Viewpoint-Independent Sampling</strong>：作者观察到在推理的过程中，点云采样占用了一半以上的时间，因此作者希望为所有的视角预先提取一个全局点云。这里仍然是使用上面Viewpoint-Specific Sampling的公式，不过忽略了$\mathbb{1}_{visible}$和$d_i$。</p><h4 id="Appearance-Representation"><a href="#Appearance-Representation" class="headerlink" title="Appearance Representation"></a>Appearance Representation</h4><p>采样之后，对于每个点，从多分辨率哈希网格中检索$M+1$个appearance feature，第一个feature会被转换为不透明度：<br>$$<br>\alpha_h = 1 - e^{-e^x}<br>$$<br>剩下的M个feature会用来计算球谐系数。</p><p>对于background model，论文使用了一个小型MLP，使用相应的sh编码的观看方向作为输入，计算每个像素的4D特征。</p><h4 id="Differentiable-Bilinear-Point-Splatting"><a href="#Differentiable-Bilinear-Point-Splatting" class="headerlink" title="Differentiable Bilinear Point Splatting"></a>Differentiable Bilinear Point Splatting</h4><p>论文提到之前关于point rasterization的工作（包括3DGS）可以证明，对辐射场的点渲染可以非常迅速，但是单像素点渲染（将多个点投影并离散到一个像素）会导致混叠，并且需要近似梯度。</p><p>为了避免这个情况，论文使用双线性公式，在投影之后将每个点与其最近的$2\times2$个相邻点相接。对于采样点$p_w = (x,y,z)^T$，将其投影到图像坐标$p=(u,v,d)^T$中：<br>$$<br>p = P \cdot V \cdot p_w<br>$$<br>其中$P$是相机内参，$V$是相机外参。对于最接近的$2 \times 2$像素点$p_{i \in {0…3}} = (u_i,v_i)^T$，通过如下公式计算不透明度：<br>$$<br>\alpha = \alpha_h \cdot (1 - |u-u_i|) \cdot (1 - |v - v_i|)<br>$$<br>这种方法可以让每个点能根据它们投影的位置被正确加权。</p><p>这种双线性喷溅方法有三个优点：(1)可以获得更鲁棒的梯度，(2)提高渲染的时间稳定性，(3)栅格化后的图像包含的孔洞更少，这使得填充孔洞的CNN工作更容易。</p><h4 id="Post-Processing-amp-Optimization-Loss"><a href="#Post-Processing-amp-Optimization-Loss" class="headerlink" title="Post-Processing &amp; Optimization Loss"></a>Post-Processing &amp; Optimization Loss</h4><p>这篇工作使用U-Net架构的网络进行解码，得到最终渲染的图像。</p><p>受到Plenoptic-points和3DGS的启发，这篇工作结合了逐像素损失和两个图像控件的损失函数：</p><img src="/images/neural-point-rendering/image-20241111165553227.png" style="zoom:50%;"><h4 id="实验部分-2"><a href="#实验部分-2" class="headerlink" title="实验部分"></a>实验部分</h4><blockquote><p>只写几个个人感兴趣的实验，其他部分看原论文吧~</p></blockquote><p>论文在Mip-NeRF360和Tanks&amp;Temples数据集上与多种方法进行了定量对比，在渲染质量上，这篇工作是比较有竞争力的。这里也放出了训练时间、渲染速度和存储占用的情况，在这三个点上，这篇工作表现得不太好。</p><p><img src="/images/neural-point-rendering/image-20241111170002310.png"></p><p>论文消融实验的结果如下所示。对于”G) No SfM Prior”，对LPIPS、SSIM、PSNR这三项指标的影响不是很大，说明这篇工作不需要初始点云也可以work，这里还是挺不错的。</p><p><img src="/images/neural-point-rendering/image-20241111170607252.png"></p><h4 id="局限性-2"><a href="#局限性-2" class="headerlink" title="局限性"></a>局限性</h4><p>如论文Fig5所示，这篇工作在相机附近缺乏更精细的几何细节，并且在高光度变化的数据集上表现较差。</p><p><img src="/images/neural-point-rendering/image-20241111170943800.png"></p><h2 id="总结-amp-讨论"><a href="#总结-amp-讨论" class="headerlink" title="总结&amp;讨论"></a>总结&amp;讨论</h2><p>本文回顾了Neural Point Rendering相关的几篇工作。</p><p>其中Neural Point-Based Graphics和INPC都是将场景中的neural point投影到新视角的图像平面上，得到多分辨率的feature map，之后通过U-Net解码得到最终渲染的图像。投影的过程和3DGS很类似，渲染质量的瓶颈主要在于U-Net网络，neural point特征向量的维度对渲染质量的影响较小。</p><p>而Point-NeRF结合了传统点云和NeRF的优点，通过neural point表示场景，避免对空白区域的采样。渲染质量主要取决于点云密度。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p>【论文讲解】Point-NeRF：用点云做NeRF重建，既抽象又具体，既新奇又传统（2022 CVPR Oral）</p><p><a href="https://www.bilibili.com/video/BV1X24y187RG">https://www.bilibili.com/video/BV1X24y187RG</a></p></li><li><p>【论文讲解】用点云结合3D高斯构建辐射场，成为快速训练、实时渲染的新SOTA！</p><p><a href="https://www.bilibili.com/video/BV1uV4y1Y7cA">https://www.bilibili.com/video/BV1uV4y1Y7cA</a></p></li><li><p>day4：Z-buffering（深度缓冲）</p><p><a href="https://supercodepower.com/docs/toy-renderer/day4-Z-buffering">https://supercodepower.com/docs/toy-renderer/day4-Z-buffering</a></p></li><li><p>How to avoid texture bleeding in a texture atlas?</p><p><a href="https://gamedev.stackexchange.com/questions/46963/how-to-avoid-texture-bleeding-in-a-texture-atlas">https://gamedev.stackexchange.com/questions/46963/how-to-avoid-texture-bleeding-in-a-texture-atlas</a></p></li><li><p>Splatting 抛雪球法简介 - bo233的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/660512916">https://zhuanlan.zhihu.com/p/660512916</a></p></li></ul><p><strong>注：本文是笔者学习研究过程中的思考整理，如有错误疏漏，请各路大佬批评斧正！</strong></p>]]></content>
      
      
      <categories>
          
          <category> NeRF&amp;3DGS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式表示 </tag>
            
            <tag> NeRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读：Scaffold-GS和Octree-GS</title>
      <link href="2024/10/11/paper-reading-scaffold-octreegs/"/>
      <url>2024/10/11/paper-reading-scaffold-octreegs/</url>
      
        <content type="html"><![CDATA[<h1 id="论文阅读：Scaffold-GS和Octree-GS"><a href="#论文阅读：Scaffold-GS和Octree-GS" class="headerlink" title="论文阅读：Scaffold-GS和Octree-GS"></a>论文阅读：Scaffold-GS和Octree-GS</h1><h2 id="Scaffold-GS-Structured-3D-Gaussians-for-View-Adaptive-Rendering"><a href="#Scaffold-GS-Structured-3D-Gaussians-for-View-Adaptive-Rendering" class="headerlink" title="Scaffold-GS: Structured 3D Gaussians for View-Adaptive Rendering"></a>Scaffold-GS: Structured 3D Gaussians for View-Adaptive Rendering</h2><blockquote><p>我感觉有点类似point-nerf，本质上似乎，非常接近。。。</p></blockquote><p><strong>论文的motivation：</strong>While this approach(3DGS) offers several advantages, it tends to excessively expand Gaussian balls to accommodate every training view, <strong>thereby neglecting scene structure</strong>. This <strong>results in significant redundancy and limits its scalability</strong>, particularly in the context of complex large-scale scenes. Furthermore, view-dependent effects are baked into individual Gaussian parameters with little interpolation capabilities, making it less robust to substantial view changes and lighting effects.</p><p><strong>论文的贡献：</strong>In conclusion, our contributions are</p><ol><li>Leveraging scene structure, we <strong>initiate anchor points from a sparse voxel grid</strong> to guide the distribution of local 3D Gaussians, forming a hierarchical and region-aware scene representation;</li><li>Within the view frustum, we <strong>predict neural Gaussians from each anchor on-the-fly</strong> to accommodate diverse viewing directions and distances, resulting in more robust novel view synthesis;</li><li>We develop a more reliable <strong>anchor growing and pruning strategy</strong> utilizing the predicted neural Gaussians for better scene coverage.</li></ol><p><img src="/images/paper-reading-Scaffold-OctreeGS/image-20241011170715529.png"></p><p>看起来，voxel仅仅是表示哪儿应该有点，sfm points没有被初始化为高斯，而是处理成voxel。每个voxel的中心作为锚点，然后具有一些可学习的参数。</p><p>MLP用来解码这些锚点，根据锚点的参数，获得锚点附近指定数量的高斯的参数。</p><blockquote><p>point-nerf的既视感，并且指定了每个锚点生成几个高斯。</p><p>那为什么不做一个grid feature，解码这个feature拿到高斯。。。</p></blockquote><p>致密化本质上还是3dgs的那一套，计算没有锚点的体素中gaussians的平均梯度，如果大于阈值就建立一个锚点。而如果某个锚点生成的gaussian不透明度偏低，那就删除这个锚点。</p><p><strong>20241018更新：</strong></p><ul><li><p>每一个anchor包括的数据有：</p><table><thead><tr><th>param</th><th>detail</th><th>num</th></tr></thead><tbody><tr><td>$v$</td><td>点坐标</td><td>3</td></tr><tr><td>$l_v$</td><td>scaling factor</td><td>3</td></tr><tr><td>$O_v$</td><td>learnable offsets</td><td>3k</td></tr><tr><td>$f_v$</td><td>feature</td><td>32</td></tr><tr><td></td><td></td><td>38+3k</td></tr></tbody></table><p>高斯点数相同时：</p><ul><li>$k &lt; 4$，用gaussian进行表示更节省空间</li><li>$k \geq 4$，用anchor更节省空间</li></ul></li><li><p>从anchor到gaussian：</p><p>$\mu = x_v + O_v  l_v$</p><p>其他参数通过网络解码feature拿到</p><img src="/images/paper-reading-Scaffold-OctreeGS/image-20241018150148940.png" style="zoom:67%;"></li><li><p>anchor的生长：</p><p>看论文描述，还是类似于Gaussian Splatting的ADC，平均梯度大于阈值，才会生长一个新的锚点。</p><p>同时论文还会对新的锚点进行随机淘汰（看起来是类似Compact 3DGS的learnable mask）。</p></li><li><p>anchor的删除：</p><p>如果某个anchor一直在生成不透明度比较低的高斯，就把他删掉。</p></li><li><p>看这个实验，确实是SSIM会稍微好一些：</p><p><img src="/images/paper-reading-Scaffold-OctreeGS/image-20241018162049581.png"></p></li><li><p>这个实验用的3D-GS不会是sh degree=3的吧？？？自己用sh degree=0，3DGS不改回去的话，这么比较就不是很有意义了。</p><p>不如在这里比较一下锚点数和高斯的点数，并且说明k设置的多少，即每个锚点产生多少个gaussian。</p><blockquote><p>论文里面没找到scaffold保存的是什么，如果是anchor+MLP的话，那确实可以做到还挺小的。。。</p><p>如果是最终保存的ply，用ply来对比，那就非常不合适了。</p></blockquote><img src="/images/paper-reading-Scaffold-OctreeGS/image-20241018162143198.png" style="zoom: 67%;"><img src="/images/paper-reading-Scaffold-OctreeGS/image-20241018162256737.png" style="zoom:67%;"></li><li><p>这个实验就更有意思了，看起来最终一个锚点只会产生3-5个高斯。这样的话，锚点的方法和高斯的方法，参数量其实是差不多的。</p><p>不过这个实验也挺有意义的，说明scaffold倾向于去生成不冗余的高斯。</p><img src="/images/paper-reading-Scaffold-OctreeGS/image-20241018162833086.png" style="zoom:67%;"></li></ul><h2 id="Octree-GS-Towards-Consistent-Real-time-Rendering-with-LOD-Structured-3D-Gaussians"><a href="#Octree-GS-Towards-Consistent-Real-time-Rendering-with-LOD-Structured-3D-Gaussians" class="headerlink" title="Octree-GS: Towards Consistent Real-time Rendering with LOD-Structured 3D Gaussians"></a>Octree-GS: Towards Consistent Real-time Rendering with LOD-Structured 3D Gaussians</h2><p><strong>论文的motivation：</strong>However, both of them(Scaffold-GS、Mip-Splatting等工作) <strong>inherit the view-frustum-only based Gaussian selection strategy</strong>, which gives rise to two primary issues. Firstly, this requires rendering every details of an object presented within the view frustum, regardless of whether it is observed from a near or far viewpoint. This redundancy in computation can result in potential inefficiencies and inconsistencies in rendering speed, especially in scenarios involving zoom-out trajectories in large-scale, detail-rich scenes. Secondly, the agnostic approach to LOD implies that all 3D Gaussians must compete to represent the scene across all observed views, leading to compromised rendering quality across different levels of detail.</p><p><strong>论文的贡献：</strong>We found it 1) further enhances the alignment of 3D Gaussians with the content presented in the training images, improving the rendering quality without increasing performance overhead; 2) enables consistent rendering speed by dynamically adjusting the fetched LOD on-the-fly. We demonstrate its superiority in modeling large-scale scenes and extreme-view sequences.</p><img src="/images/paper-reading-Scaffold-OctreeGS/image-20241011210235377.png" style="zoom:67%;"><p>看图注，创建的是有界的八叉树。不过用八叉树来控制细节，还挺方便的。</p><p>感觉和scaffold-gs相比，就是在它上面加了个八叉树，锚点通过八叉树来获取，根据观看距离和场景的丰富程度来给定lod的级别？其他并没有什么很新颖的内容了。</p>]]></content>
      
      
      <categories>
          
          <category> NeRF&amp;3DGS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式表示 </tag>
            
            <tag> 3D Gaussian Splatting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读《GaussianPro：3D Gaussian Splatting with Progressive Propagation》</title>
      <link href="2024/09/18/paper-reading-gaussianpro/"/>
      <url>2024/09/18/paper-reading-gaussianpro/</url>
      
        <content type="html"><![CDATA[<h1 id="论文阅读《GaussianPro-3D-Gaussian-Splatting-with-Progressive-Propagation》"><a href="#论文阅读《GaussianPro-3D-Gaussian-Splatting-with-Progressive-Propagation》" class="headerlink" title="论文阅读《GaussianPro: 3D Gaussian Splatting with Progressive Propagation》"></a>论文阅读《GaussianPro: 3D Gaussian Splatting with Progressive Propagation》</h1><p><strong>下面的笔记没有做完整，这里整理一下这篇文章的思路：</strong>（20241006）</p><p>这篇文章认为弱纹理区域，特别是平面，提供的点比较少，导致初始化不好，对此解决思路是：</p><ul><li><p>计算3DGS的深度和法向，根据alpha-blending渲染得到深度图和法向图；</p></li><li><p>根据patch match算法，计算每一个pixel对应的最优平面；</p><blockquote><p>看起来是把每一块像素认为是某个平面的，深度、法向都统一了一下？</p></blockquote></li><li><p>根据多视图几何一致性过滤不准确的深度和法向，根据过滤之后的结果与最初渲染的结果比较，重新增加一些3DGS；</p></li><li><p>明确了3DGS法向与渲染得到的法向之间的一致性，让平面上的3DGS更扁平。</p></li></ul><hr><h2 id="Abstract-amp-Introduction-amp-Related-Work"><a href="#Abstract-amp-Introduction-amp-Related-Work" class="headerlink" title="Abstract &amp; Introduction &amp; Related Work"></a>Abstract &amp; Introduction &amp; Related Work</h2><p>这篇论文看起来也是想解决3DGS目前存在的一些问题，比如sfm在弱纹理区域提供的点过少，进而导致没办法良好的初始化，比如3DGS原来的致密化策略缺少约束。论文受到classical multi-view stereo(MVS)的启发，提出了本文的方法GaussianPro，采用渐进式传播策略来指导3DGS的致密化（densification）过程。</p><p><strong>论文在Introduction部分提到了3dgs的densification策略导致了两个限制：</strong></p><ol><li><p>Sensitive to Gaussian Initialization. The SfM techniques always fail to produce 3D points and leave empty in textureless regions, and therefore the densification strategy struggles to generate reliable Gaussians to cover the scene with a poor initialization.</p><p>对高斯初始化敏感。SfM技术总是不能产生3D点，并且在无纹理的区域留下空白，因此致密化策略很难产生可靠的高斯值来覆盖初始化较差的场景。</p></li><li><p>Ignore the priors of the existing reconstructed geometry. The new Gaussians are either cloned to be the same as the old Gaussians or initialized with random positions and orientations. The less-constrained densification leads to difficulties in the optimization of 3D Gaussians, e.g., noisy geometries, and few Gaussians in texture-less regions, finally degrading the rendering quality. As shown in Figure 1, the results of 3DGS contain many noisy Gaussians and some regions are not covered by enough Gausians.</p><p>忽略现有重构几何的先验。新的高斯要么被克隆为与旧的高斯相同，要么被初始化为随机的位置和方向。约束较少的密度化导致三维高斯函数的优化困难，例如几何形状有噪声，无纹理区域的高斯函数很少，最终降低了渲染质量。如图1所示，3DGS的结果包含了很多有噪声的高斯函数，有些区域没有被足够的高斯函数覆盖。</p><p><img src="/images/paper-reading-GaussianPro/image-20240816102757561.png"></p></li></ol><p><strong>论文在Related Work这里提到了几点：</strong></p><ul><li>论文从MVS的深度优化中汲取灵感，改进gaussian的几何形状，从而获得更好的渲染效果；</li><li>3DGS对采样频率很敏感，改变相机焦距或者相机距离容易导致渲染伪影；</li><li>3DGS在没有明确约束场景几何结构的情况下会过度增长，导致大量冗余gaussian和内存消耗。</li><li>目前有一些降低3DGS存储开销的工作，但是明确约束高斯函数几何形状的工作很少，3DGS可能在远离物体表面的地方生长，从而导致冗余和新视角的渲染质量下降。论文考虑平面先验，明确约束了高斯分布的增长，可以让高斯更好的适应场景的真实几何形状，实现更好的渲染和更紧凑的表示。</li></ul><blockquote><p>基于上面几点，我觉得放在RGBD-SLAM中，光靠颜色平均值来初始化是不够的，还是需要再多考虑一下几何。毕竟我拿到了稠密的深度图，我有条件来考虑几何约束。</p></blockquote><p><strong>论文总结了自己的贡献：</strong></p><ul><li>We propose a novel Gaussian propagation strategy that guides the densification to produce more compact and accurate Gaussians, particularly in low-texture regions.</li><li>We additionally leverage a planar loss that provides a further constraint in the optimization of Gaussians.</li><li>Our method achieves new state-of-the-art rendering performance on the Waymo and MipNeRF360 datasets. Our method also presents robustness to the varying numbers of input images.</li></ul><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p>整个系统的pipeline是下面这样的：</p><p><img src="/images/paper-reading-GaussianPro/image-20240918104008376.png"></p><blockquote><p>目前的疑问，等看了后面应该就清楚了：<br>论文中这个段落描述的是：新深度与初始深度明显不同的像素被投影回3D空间作为3D点，这些点被进一步初始化为新的高斯点</p><p>而上面的图片描述的是：最后，我们确定了其渲染深度和法线明显偏离过滤后的区域，这表明现有的高斯函数可能不会不准确地捕获几何形状，因此需要更多的高斯函数。这些区域中的像素被投影到3D空间中，使用过滤后的深度和法线初始化新的高斯分布。</p><p>我的猜测：</p><ul><li><p>论文认为渲染出来的深度图是不准确的，然后他们根据一些规则，从渲染的深度和法线中选择出来了准确的那些深度和法线，再和最开始渲染的初始深度进行比较，有明显差异的就初始化为新的高斯点。</p><blockquote><p>一种逻辑自洽的感觉，论文似乎想让高斯渲染出“合理的”深度图和法线图。</p><p>不过，如果已经有深度图的话，论文这样的思路应该怎么实现呢？？？</p></blockquote></li></ul></blockquote><h3 id="Hybrid-Geometric-Representation"><a href="#Hybrid-Geometric-Representation" class="headerlink" title="Hybrid Geometric Representation"></a>Hybrid Geometric Representation</h3><p>论文提到一个问题：Due to the discrete and irregular topology of the 3D Gaussians, it is inconvenient to perceive the connectivity of geometries, like searching neighboring Gaussians on a local surface. As a result, it’s difficult to perceive the existing geometry to guide the Gaussian densification.</p><p>针对这个问题，论文给出了解决方案：Hybrid Geometric Representation，即将3D Gaussian投影到结构化的二维图像空间（深度和法线）。</p>]]></content>
      
      
      <categories>
          
          <category> NeRF&amp;3DGS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式表示 </tag>
            
            <tag> 3D Gaussian Splatting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读《GaussReg：Fast 3D Registration with Gaussian Splatting》</title>
      <link href="2024/08/16/paper-reading-gaussianreg/"/>
      <url>2024/08/16/paper-reading-gaussianreg/</url>
      
        <content type="html"><![CDATA[<h1 id="论文阅读《GaussReg-Fast-3D-Registration-with-Gaussian-Splatting》"><a href="#论文阅读《GaussReg-Fast-3D-Registration-with-Gaussian-Splatting》" class="headerlink" title="论文阅读《GaussReg: Fast 3D Registration with Gaussian Splatting》"></a>论文阅读《GaussReg: Fast 3D Registration with Gaussian Splatting》</h1><blockquote><p>ECCV 2024，第一篇做3DGS配准的工作</p></blockquote><h2 id="Abstract-amp-Introduction"><a href="#Abstract-amp-Introduction" class="headerlink" title="Abstract &amp; Introduction"></a>Abstract &amp; Introduction</h2><p><strong>论文提到NeRF在大规模场景重建时的问题：</strong></p><ul><li><p>在考虑基于NeRF的大规模场景重建时，主要面临两个挑战:</p><ul><li>1)由于现实场景中存在复杂的遮挡，通常需要捕获大量图像或视频进行大规模重建，导致数据收集过程耗时。</li><li>2)使用大量图像优化NeRF是计算密集型的。</li></ul><p>一种直接的方法是将一个大尺度的场景分成几个较小的场景，分别重建，然后用配准将这些小场景组合在一起。</p></li><li><p>而考虑两个重叠的场景，每个场景都有自己的NeRF模型，根据目前已有的工作，可以分成两种方法：</p><ul><li><p>NeRFuser，渲染图象，再重新跑SfM。这种方法的问题是，耗时过高。</p><blockquote><p>好直白的思路，这也能发paper？</p></blockquote></li><li><p>Dreg-NeRF，转成显示的体素，提取特征进行匹配。这种方法的问题有两个：</p><p>a)难以将无界场景的NeRF转换为有界体素;</p><p>b)体素网格的分辨率限制使得该方法不适合较大的场景。</p></li></ul></li></ul><p><strong>论文提到了一个有趣的问题：</strong>As GS provides a point-like representation, can we conduct GS registration resorting to point-cloud registration methods? 既然GS提供了点云表示，那么我们是否可以借助点云配准方法进行GS配准?</p><blockquote><p>鄙人也很早就考虑到了，这是一个非常有趣的问题，但是很棘手，不好解决。</p></blockquote><p><img src="/images/paper-reading-GaussianReg/image-20240815191810175.png"></p><p><strong>论文对3DGS点云的评价：</strong></p><ul><li><p>Compared with traditionally collected point cloud data, point clouds from GS only capture rough geometric structure and are usually noisy.</p><blockquote><p>是的是的！与传统采集的点云数据相比，3DGS采集的点云只捕获了粗糙的几何结构，而且通常存在噪声。</p><p>除此之外，3DGS采集的点云太过稠密了，存在冗余，但是又从图像渲染的结果来看，其实还存在密度不足的情况。</p><p>因此，如果想用简单一些的点云配准方法来配准3DGS，可以做的事情有：</p><ul><li>让3DGS捕获更好的几何结构；</li><li>让3DGS在充分表示场景的情况下减少数量（即去除冗余，并且保证局部的密度是合理的）；</li></ul></blockquote></li></ul><p><strong>论文对3DGS配准的设计：</strong></p><ul><li><p>粗配准：从3DGS中提取点云，用基于点云配准的方法进行粗配准，在已有点云配准的基础上考虑了3DGS的额外属性，比如不透明度。</p><blockquote><p>因为3DGS的点云只捕获了粗糙的几何结构，通常还存在噪声，因此粗配准没办法获得足够精确的结果，还需要进行精配准。</p></blockquote></li><li><p>精配准：图像引导的精配准pipeline，借助3DGS来渲染少量的图像，Then, the fine registration pipeline projects images into 3D volumetric features for final matching and transformation estimation.</p><blockquote><p>论文称主要想法来自于观察，GS不仅包含几何信息，还包含固有的详细图像信息，这些信息可以支持更精确的对准。</p></blockquote></li></ul><p><strong>论文的贡献：</strong></p><ul><li>第一个研究在3DGS上进行配准的；</li><li>精心设计了一个从粗到细的pipeline，充分考虑了3DGS的特点；</li><li>提出了一种图像引导的精细配准方法；</li><li>为他们提出的新任务创建了一个benchmark。</li></ul><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><img src="/images/paper-reading-GaussianReg/image-20240815191752212.png"></p><p>论文在这里对整个过程做了一个简单的介绍。</p><p>假设：两个存在overlap的场景A和B，每个场景都有自己的3DGS模型，即$Gaussian_A$和$Gaussian_B$，对应导出的点云为$Points_A$和$Points_B$，并且保留所有训练图像的camera pose，即${C_i^A = (R_i^A,T_i^A)}_{i=0}^N$和${C_j^B = (R_j^B,T_j^B)}_{j=0}^N$。</p><blockquote><p>看起来保留camera pose，是为了根据粗配准，找到能够观察到overlap区域的camera pose，然后渲染图象进行配准。</p><blockquote><p>如果是这样的话，看起来非常的不优雅。理论上不需要保留camera pose，可以自己计算一些overlap区域的视角。</p><p>而且既然保留了camera pose，为什么不直接保留图像来进行配准呢？</p></blockquote></blockquote><p>目标：找出让场景B能和A对齐的刚性变换${s,R,T}$，其中$s$是比例因子，$R$是旋转矩阵，$T$是平移向量。</p><p>粗配准阶段：输入$Points_A$和$Points_B$，输出粗变换${s_c,R_c,T_c}$。</p><p>精配准阶段：根据粗配准结果找到highly overlapping region，在这个区域周围选择合适的camera pose渲染图象。之后根据Image-Guided 3D(I3D) Feature Extraction来提取volumetric features，用于后续的local matching，最终输出粗变换${s_f,R_f,T_f}$。</p><h3 id="Coarse-Registration"><a href="#Coarse-Registration" class="headerlink" title="Coarse Registration"></a>Coarse Registration</h3><p>选择不透明度$\alpha$大于0.7（经验参数）的高斯点，根据位置和球谐，得到彩色点云$(x,y,z,r,g,b)$。</p><blockquote><p>！！！之前我设计3DGS配准的时候，不透明度用不上，现在看来其实是可以用来做一个简单的过滤，只用不透明度高的来配准。</p></blockquote><p>粗配准这边遵循了GeoTransformer的流程。</p><blockquote><p>==TODO：这部分目前不感兴趣，先略过了。这部分看起来应该就是直接用的GeoTransformer==</p></blockquote><h3 id="Image-Guided-Fine-Registration"><a href="#Image-Guided-Fine-Registration" class="headerlink" title="Image-Guided Fine Registration"></a>Image-Guided Fine Registration</h3><p>论文在这里提到因为3DGS训练过程中没有添加特定的几何约束，因此产生的点云可能会出现一定程度的失真。</p><blockquote><p>这里个人认为，在RGBD SLAM里面，尽管有深度的输入，但是本质上和sfm输入还是差不多的，仍然存在一定程度的失真。</p><p>这还是因为，训练过程中没有添加几何约束，3DGS甚至可能会为了渲染的更好把某些正确位置的点云往不正确的位置移动。</p></blockquote><p>核心思路如下所示，分为两个步骤：<strong>Overlap Image Selection</strong>和<strong>Image-Guided 3D Feature Extraction</strong>。</p><blockquote><p>结合论文和这张图就可以把这部分看得很明白了，全是干货，都不用写笔记。</p><p>不过这个过程看起来还是比较僵硬，似乎可以总结成：</p><ul><li>确定重叠的视角</li><li>渲染图象</li><li>生成深度图</li><li>选择合适的点，得到点云</li><li>按照粗配准的步骤，点云和点云之前配准</li></ul><p>并且这个fine registration network还需要训练。。。（因为，类似单目深度估计？）</p></blockquote><p><img src="/images/paper-reading-GaussianReg/image-20240815193728803.png"></p><h3 id="Gaussian-Splatting-Fusion-and-Filtering"><a href="#Gaussian-Splatting-Fusion-and-Filtering" class="headerlink" title="Gaussian Splatting Fusion and Filtering"></a>Gaussian Splatting Fusion and Filtering</h3><blockquote><p>这确实是两个场景的3DGS配准之后需要做的事情，不过我不太关注这部分，略过了。</p><p>不过这里提到了球谐函数的旋转，以后有需求可以回来看一眼。</p><p>emmm，简单看了一遍，这里写的很少，看起来仅仅是旋转了一下gaussian，，，这个代码我也写过，，，球谐的旋转确实要注意。回头检查一下自己旋转的Gaussian，把球谐部分的旋转考虑上！（不过有其他方法可以避免旋转高斯，旋转高斯太慢了，不如旋转点云再处理，，，）</p></blockquote><h2 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h2><p>论文提到了，他们融合gaussian的策略是简单的。</p><blockquote><p>深表认同，我也会，不过球谐我没考虑，这里回头注意一下。</p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>论文提到的一些工作：</strong></p><ul><li><p>NeRFuser</p><p>NeRFuser[10]中提出的方法，我们可以为每个场景渲染大量的图像，然后从SfM (structure-from-motion)中恢复所有这些图像的姿态。然而，这种方法非常耗时;</p></li><li><p>Dreg-NeRF</p><p>与DReg-NeRF方法[6]一样，我们可以从两个场景的NeRF中查询体素网格，将隐式亮度场转换为显式体素，提取特征，建立匹配关系进行配准。但该方法面临两个问题:a)难以将无界场景的NeRF转换为有界体素;B)体素网格的分辨率限制使得该方法不适合较大的场景。</p></li><li><p>GeoTransformer</p><blockquote><p>徐凯组的工作，也是这篇论文粗配准的pipeline</p><p>这里面应该是用了Transformer，看来很多东西我想躲的躲不掉了，都得看。。。</p></blockquote></li><li><p>NeRF2NeRF</p><blockquote><p>利用人工注释的关键点获得初始转换，并使用从预训练的NeRF中提取的表面场对其进行细化。</p></blockquote></li></ul><p><strong>个人评价：</strong></p><ul><li><p><strong>做的非常有意思，和我想解决的问题一样，但是走了完全不一样道路。</strong></p><p>我认为3DGS还存在太多的问题，因此需要逐步解决这些问题，然后用传统的点云配准方法进行配准；</p><p>而论文认为3DGS固然有很多的问题，但是可以精心设计一些解决方法，用传统的点云配准方法进行粗配准，再用基于图像引导的方法进行精配准。</p></li><li><p><strong>因为3DGS的表示目前还不完美，因此论文其实做了一些妥协。</strong></p><p>渲染图象再根据图像进行配准，其实<strong>放到SLAM里面来说，非常的合适，后面可以考虑一下。</strong></p><p>但是为什么要渲染图象呢？其实还是因为3DGS的表示目前还有很多小问题，只能进行妥协。但是渲染图象本质上还是在把3DGS当成隐式的表示方法，最后做出来个人觉得不是直接基于3DGS的配准。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> NeRF&amp;3DGS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 3D Gaussian Splatting </tag>
            
            <tag> 点云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读《Pixel-GS：Density Control with Pixel-aware Gradient for 3D Gaussian Splatting》</title>
      <link href="2024/07/23/paper-reading-pixel-gs/"/>
      <url>2024/07/23/paper-reading-pixel-gs/</url>
      
        <content type="html"><![CDATA[<h1 id="论文阅读《Pixel-GS-Density-Control-with-Pixel-aware-Gradient-for-3D-Gaussian-Splatting》"><a href="#论文阅读《Pixel-GS-Density-Control-with-Pixel-aware-Gradient-for-3D-Gaussian-Splatting》" class="headerlink" title="论文阅读《Pixel-GS: Density Control with Pixel-aware Gradient for 3D Gaussian Splatting》"></a>论文阅读《Pixel-GS: Density Control with Pixel-aware Gradient for 3D Gaussian Splatting》</h1><blockquote><p>看标题，感觉还是没有脱离3DGS基于梯度的Density Control策略</p><p>不过这个工作是从像素的角度来考虑点云的生长条件，更细节一些了</p><p>看了一下项目主页<a href="https://pixelgs.github.io,做的实验挺精彩的,特别是丢弃一定比例的sfm点,能看到效果很显著.不过只看指标的话,与3dgs相比也只是有一点点的提升.和之前的mini-gs一样只是提升了一点点./">https://pixelgs.github.io，做的实验挺精彩的，特别是丢弃一定比例的sfm点，能看到效果很显著。不过只看指标的话，与3DGS相比也只是有一点点的提升。和之前的Mini-GS一样只是提升了一点点。</a></p></blockquote><blockquote><p>不想记录太多东西，零散的记录一些吧。</p></blockquote><p><strong>论文中提到的观点：</strong></p><ul><li><p>对于Original 3DGS，如果输入的SfM点云过于稀疏，根据它的初始化策略，会产生椭球轴长过大的初始化高斯，从而导致这些高斯从太多的viewpoints参与了计算。这些高斯又只在中心点在投影后位于像素空间内或附近的viewpoint中会表现出比较大的梯度，这意味着从这些viewpoint看，大高斯在投影后的像素空间中覆盖了较大的区域。</p><p>但是又由于Original 3DGS的Adaptive Density Control策略，这些高斯因为从太多的viewpoint参与了计算，又只在单个viewpoint中具有显著的梯度大小，因此这些点很难被split或clone，导致重建的结果很差。</p><blockquote><p>简单总结就是：</p><p><strong>输入的点过于稀疏会导致初始化的高斯尺度过大，而尺度过大的高斯平均梯度又较小，从而导致很难参与Densification。</strong></p><blockquote><p>这个和Mini-Splatting的观点是一致的，Mini-Splatting也提到了“基于梯度的分割和克隆策略可能会在颜色过渡平滑的区域中失败，这会导致相应的过大尺寸的高斯会在优化过程中保留”。</p></blockquote><p>原文：</p><p>We observed that areas inadequately modeled often have very sparse initial SfM point clouds, leading to the initialization of Gaussians in these areas with ellipsoids having larger axis lengths. This results in their involvement in the computation from too many viewpoints. These Gaussians exhibit larger gradients only in viewpoints where the center point, after projection, is within or near the pixel space. This implies that, from these viewpoints, the large Gaussians cover a larger area in the pixel space after projection. This results in these points having a smaller average gradient size of their NDC coordinates during the “Adaptive Density Control” process every 100 iterations (Eq. 3), because they participate in the computation from too many viewpoints and only have significant gradient sizes in individual viewpoints. Consequently, it is difficult for these points to split or clone, leading to poor modeling in these areas.</p></blockquote><p>论文里面还对这个现象做了公式分析。</p></li></ul><p><strong>对论文中的一些讨论：</strong></p><ul><li><p>从Fig1可以看出，Pixel-GS与original的3DGS相比，增加了一倍的点数，才得到了些微的指标提升。。。</p><p>个人认为这里做的不是很好，如果能提升指标的同时，点数的增长没这么夸张，就很不错了。</p><img src="/images/paper-reading-pixel-gs/image-20240723151434072.png" style="zoom:80%;"></li><li><p>论文3.3 Scaled Gradient Field部分也提到了，他们通过“Pixel-aware Gradient”的方法可以解决viewpoint不足或重复纹理区域的伪影，但是这也导致相机附近的floaters过多。这主要是因为靠近相机的漂浮物占据较大的屏幕空间，且其NDC坐标梯度较大，导致点云生长过程中漂浮物数量不断增加。为了解决这个新的问题，他们做了这部分的工作。</p><blockquote><p>emmm，看到这里不想继续看下去了，个人觉得，这篇论文的工作对我而言不是很有价值。</p><p>pixel-aware确实有效果，但是也会导致新的问题，而且效果并不是很突出，还导致高斯数量增长更多。</p></blockquote></li></ul><p><strong>收获：</strong></p><ul><li><p>还是之前论文看到的观点，目前更坚定了：</p><p>Original 3DGS的Adaptive Density Control容易导致过大的高斯被保留下来，核心问题是大的高斯平均梯度可能过小。产生的原因可能是因为参与了过多viewpoint的计算，而大部分viewpoint中这个高斯影响的像素较小，导致梯度也较小，最终平均梯度也变得很小。也可能是因为纹理比较弱，颜色过渡过于平滑，从而导致平均梯度过小。</p></li><li><p>另外，论文做了一些公式推导，从理论层面讨论了上面的问题。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> NeRF&amp;3DGS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式表示 </tag>
            
            <tag> 3D Gaussian Splatting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读《Mini-Splatting：Representing Scenes with a Constrained Number of Gaussians》</title>
      <link href="2024/07/21/paper-reading-mini-splatting/"/>
      <url>2024/07/21/paper-reading-mini-splatting/</url>
      
        <content type="html"><![CDATA[<h1 id="论文阅读《Mini-Splatting-Representing-Scenes-with-a-Constrained-Number-of-Gaussians》"><a href="#论文阅读《Mini-Splatting-Representing-Scenes-with-a-Constrained-Number-of-Gaussians》" class="headerlink" title="论文阅读《Mini-Splatting: Representing Scenes with a Constrained Number of Gaussians》"></a>论文阅读《Mini-Splatting: Representing Scenes with a Constrained Number of Gaussians》</h1><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><h3 id="Densification"><a href="#Densification" class="headerlink" title="Densification"></a>Densification</h3><h4 id="Blur-Split"><a href="#Blur-Split" class="headerlink" title="Blur Split"></a>Blur Split</h4><p>这个策略的目的是：解决高斯伪影。</p><p>论文提到了，基于梯度的分割和克隆策略可能会在颜色过渡平滑的区域中失败，这会导致相应的过大尺寸的高斯会在优化过程中保留。不过3DGS也会根据投影的2D高斯分布，对屏幕空间中尺寸过大的高斯进行剪枝，但是这种方法也解决不了重建不足的问题。</p><blockquote><p>论文在这里说废话，这不是解决overlapping的问题才这么做的？</p><p>3DGS看起来只是没有着重去解决under-reconstruction的问题，就像论文分析的，基于梯度的分割和克隆策略在弱纹理的区域效果不好，没有分裂或克隆足够的高斯点，就导致了under-reconstruction的问题。</p></blockquote><p>论文说他们记录了每个像素权重最大的高斯函数的索引$i_{max}(x)$，以及对这个像素实际影响最大的高斯函数的索引$i(x)$，并且观察到高斯伪影与$i_{max}(x)$更相关，这说明具有较大的”最大贡献面积“的高斯函数会导致under-reconstruction。</p><blockquote><p>我也觉得，因为既然已经造成了影响，说明这个高斯的权重会比较大。</p><p>而伪影通常看起来不透明度都不是那么高（因为看着很模糊），有可能他们的不透明度很低，只是在深度排序里面比较靠前，导致alpha-blending中的权重就比较大了。</p></blockquote><p>因此，基于这个观察，论文根据公式（2）识别导致模糊的高斯函数，并且在优化过程中对其进行分割，这样可以增强图像清晰度。</p><p><img src="/images/paper-reading-mini-splatting/image-20240721171315625.png"></p><p>这部分的实验如下所示：</p><p><img src="/images/paper-reading-mini-splatting/image-20240721163151587.png" alt="image-20240721163151587"></p><h4 id="Depth-Reinitialization"><a href="#Depth-Reinitialization" class="headerlink" title="Depth Reinitialization"></a>Depth Reinitialization</h4><blockquote><p>这部分做的没有意思，个人感觉比较牵强了。</p><p>大家渲染深度基本都是用高斯中心的深度来进行渲染的，但是论文作者认为这个会产生误导，导致深度点云存在伪影。因此他们计算了相机射线与头球的交点，以交点的中点作为高斯的深度。</p><blockquote><p>好好看看3D高斯往2D高斯的投影，就会感觉，大家用的方法也没有问题。。。</p><p>不过只是感觉。</p></blockquote><p>这里论文提到其实用高斯中心的深度页有相似的渲染质量。</p><blockquote><p>所以其实论文效果好只是单纯的只用权重最大的高斯深度作为相似的深度了，他这个计算交点中点的方法，个人感觉没必要。。。</p></blockquote></blockquote><h3 id="Simplification"><a href="#Simplification" class="headerlink" title="Simplification"></a>Simplification</h3><p>这里没感觉到论文做了什么很突出的贡献，记录几个论文提到的观点：</p><ul><li>通过给每个高斯分布分配一个预定义的重要性值，我们可以简单地修剪低重要性的高斯分布。虽然这种策略对于去除有限数量的高斯函数是有效的，但当剪枝比相对较大时，它可能导致渲染质量的崩溃。主要问题在于<strong>高斯重要性只反映了简化前的重要性。直接剪枝很容易破坏局部几何</strong>，这反过来又降低了进一步优化后的最终渲染质量。</li><li><strong>与确定性剪枝相比，随机采样策略可以更好地保持整体几何形状</strong>。我们将高斯重要性纳入每个高斯的抽样概率，这种重要性加权采样策略具有更强的保持几何质量的能力，从而增强了最终的渲染结果</li></ul><p>总结就是：根据重要性来剪枝不好，容易破坏局部的几何结构。最好的办法是结合高斯的权重进行随机采样剪枝。</p><blockquote><p>放到SLAM里面那就是learnable-mask * weight</p><p>又是一个很方便实现而且比较有效的小技巧</p><p>learnable-mask太棒了！</p></blockquote><h2 id="Experiment"><a href="#Experiment" class="headerlink" title="Experiment"></a>Experiment</h2><p>这篇论文做了很多有意思的实验，这里记录一下</p><h3 id="剪枝和采样策略"><a href="#剪枝和采样策略" class="headerlink" title="剪枝和采样策略"></a>剪枝和采样策略</h3><p>论文提到减少高斯数最直接的方法是进行剪枝和采样，这里他们尝试了四种方法：(b) 计算每个高斯的重要性，重要性低的剪枝；(c) 随机采样；(d) 网格采样；(e) 密度保持采样。这些结果表明，在保持渲染质量的同时，解决高斯分布的低效和实现最小高斯表示需要进一步的努力。</p><p><img src="/images/paper-reading-mini-splatting/image-20240721154422922.png"></p><p>论文也提到了，修剪策略可以将高斯数量大幅减少，比如(b)方法可以从610w降低到60w，但是PSNR会降低，而且仍然会存在overlapping和under-reconstruction的问题。</p><blockquote><p>很显然啊，因为只是进行了修剪，而不是进行了更合理的density control。不管数量多寡，只要density是不合理的，就一定会存在overlapping和under-reconstruction。</p><p>从这个实验和作者的分析可以进一步的出一个结论：</p><ul><li><p>首先，高斯的数量是可以通过简单的修剪或采样数量显著减少的，对PSNR等指标影响不大；</p></li><li><p>另外，重建的结果好坏，受高斯数量多寡的影响小，受density是否合理的影响大；</p></li><li><p>不影响其他指标的同时减少高斯的数量值得研究，而在这个基础上实现更合理的density分布更值得研究，减少高斯点数和更合理的density control是相辅相成的。</p><blockquote><p>论文也是同时研究了Densification和Simplification</p></blockquote></li></ul></blockquote><h2 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h2><p>论文做了很多实验，讲了自己观察到的很多问题，并且针对性的研究了Densification和Simplification策略。</p><p>不过其中个人觉得最创新的还是Densification中的Blur Split，而Depth Reinitialization就有点牵强了。另外，Simplification这里也提到了观察到的一个重要现象，即<strong>随机采样策略可以更好地保持整体几何形状</strong>，这个在Compact 3DGS一系列的工作中得到了验证。</p><p>后续的话可以借鉴这篇论文的思路，围绕：</p><ul><li><p>更全面的Densification，而不是仅仅关注产生伪影的部分高斯；</p><blockquote><p>这个目前还是没有看到做的比较好的工作出现。</p></blockquote></li><li><p>结合高斯权重和learnable-mask的Simplification策略。</p><blockquote><p>这个应该已经不创新了，但是效果很好。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> NeRF&amp;3DGS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式表示 </tag>
            
            <tag> 3D Gaussian Splatting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读《Gaussian Splatting with Localized Points Management》</title>
      <link href="2024/07/20/paper-reading-lpm/"/>
      <url>2024/07/20/paper-reading-lpm/</url>
      
        <content type="html"><![CDATA[<h1 id="论文阅读《Gaussian-Splatting-with-Localized-Points-Management》"><a href="#论文阅读《Gaussian-Splatting-with-Localized-Points-Management》" class="headerlink" title="论文阅读《Gaussian Splatting with Localized Points Management》"></a>论文阅读《Gaussian Splatting with Localized Points Management》</h1><h2 id="Motivation-Adaptive-Density-Control的局限性"><a href="#Motivation-Adaptive-Density-Control的局限性" class="headerlink" title="Motivation: Adaptive Density Control的局限性"></a>Motivation: Adaptive Density Control的局限性</h2><p>论文在Introduction部分提到了Adaptive Density Control存在几个问题：</p><ol><li><p>Thresholding simply the average gradient for deciding the regions for point densification tends to overlook under-optimized points. For example, larger Gaussian points typically exhibit lower average gradients, frequently appearing across various views in screen space.</p><blockquote><p>单纯采用平均梯度阈值法确定点密度区域，<strong>容易忽略优化不足的点</strong>。例如，较大的高斯点通常表现出较低的平均梯度，经常出现在屏幕空间的不同视图中。</p></blockquote></li><li><p>Point sparsity makes it difficult to add sufficient and reliable points to comprehensively cover the scene. </p><blockquote><p>点稀疏性导致<strong>难以添加足够、可靠的点来全面覆盖场景</strong>。</p></blockquote></li><li><p>Falsely optimized Gaussian points could cause negative effects, e.g., occluding other good points and leading to incorrect depth estimates.</p><blockquote><p><strong>错误优化的高斯点可能会产生负面影响</strong>，例如，遮挡其他好的点并导致不正确的深度估计。</p></blockquote></li></ol><h2 id="Solution-识别导致渲染错误的点"><a href="#Solution-识别导致渲染错误的点" class="headerlink" title="Solution: 识别导致渲染错误的点"></a>Solution: 识别导致渲染错误的点</h2><p>在Introduction部分论文提到，他们的<strong>核心思路是：identifying those 3D Gaussian points leading to rendering errors，即识别那些导致渲染错误的3D高斯点。</strong></p><h3 id="Point-management-Since-existing-3DGS-variants【原方法】"><a href="#Point-management-Since-existing-3DGS-variants【原方法】" class="headerlink" title="Point management Since existing 3DGS variants【原方法】"></a>Point management Since existing 3DGS variants【原方法】</h3><p>原方法是使用平均梯度的阈值来决定点的密度。对于每一个高斯点$G_i$，3DGS跟踪所有渲染视图中位置梯度$\frac{\partial L_\pi}{\partial \mu_i}$的大小，将其平均为一个量$T_i$。每次训练迭代的时候，判断$T_i$是否超过预定义的阈值，如果超过就认为这个点不能充分代表相应的3D区域。之后会根据高斯的大小来进行处理，大的高斯会被分裂，小的高斯会被克隆。</p><p>论文提到上面这种方法<strong>无法识别所有需要点致密化的3D区域。</strong>这是因为，<strong>通常场景几何的局部复杂性变化很大，这超出了任何基于单一值的阈值的范围。</strong>此外，<strong>缺乏适当的机制来处理具有负面影响的病态点</strong>。</p><h3 id="Localized-Gaussian-Point-Management【论文方法】"><a href="#Localized-Gaussian-Point-Management【论文方法】" class="headerlink" title="Localized Gaussian Point Management【论文方法】"></a>Localized Gaussian Point Management【论文方法】</h3><p>论文提到，他们引入了一种新的模型无关点管理方法——局部点管理(localization point management, LPM)，该方法利用多视图几何约束，在图像渲染错误的指导下，识别导致3D点错误的点。这种方法可以与现有的3DGS模型无缝集成，而无需进行架构修改。</p><blockquote><p>看到这里，做一个猜测，按照论文的描述，最简单的方法可以是：</p><p>首先，生成每一帧的error map，标记每一个error map中对应的高斯点。</p><p>之后，计算每几帧error map对应的高斯点集的交集，中间存在的高斯点就是通过“多视图几何约束”识别的导致错误的高斯点。</p><p>但是错误的高斯点通常是影响固定的一个区域，而上面做交集太简单粗暴了，最好还是两张图像之间先做一个特征匹配，只计算对应区域中错误高斯点的交集。（但是这样就有点麻烦了，特征匹配会产生额外的数据，就像使用external tracker的3dgs slam一样）</p><blockquote><p>如果放到3dgs slam里面，就有两个思路了：</p><ul><li>接受external tracker，并且将其结果用于Localized Gaussian Point Management，预计对mapper的细节有提升；</li><li>拒绝使用external tracker，那么就只能实现粗暴的、基于交集的Localized Gaussian Point Management，编程实现很简单，但是不一定能提升效果。</li></ul></blockquote></blockquote><p>论文整体的pipeline如下所示：</p><img src="/images/paper-reading-lpm/image-20240720162653918.png" style="zoom: 67%;"><p><strong>Error map generation</strong>    使用论文《Z. Li, Z. Chen, Z. Li, and Y. Xu. Spacetime gaussian feature splatting for real-time dynamic view synthesis. arXiv preprint arXiv:2312.16812, 2023.》的误差函数来生成误差图</p><p><strong>Error contributing 3D zone identification</strong>    为了将渲染误差投影回3D空间，论文利用了多视图几何约束下不同视图之间的区域对应关系。这涉及以下两个关键步骤：</p><ul><li><p><strong>Cross-view region mapping</strong></p><p>选一个相邻帧作为Referred View，根据LightGlue的预测来从Current View和Reffered View中寻找匹配关系，通过匹配点来选择配对的区域，最终得到具有渲染误差的配对区域。</p></li><li><p><strong>2D-to-3D projection</strong></p><p>获得具有渲染误差的配对区域后，分别计算Current View和Reffered View中相关区域对应的视锥，并且得到射线的交点，计算这些交点的最小包围球面，该球面被认定为误差源的三维区域。</p></li></ul><p><strong>Points manipulation</strong>    论文在3DGS的ADC基础上，识别出误差源3D区域，在区域内进行局部的点添加或者几何校正。</p><p>其中，对于点的添加，考虑了两种常见的情况：</p><ul><li>在存在点的情况下，应用点密度对原始对应点进行局部补全。论文设置了一个较低的阈值来选择需要致密化的点，以增强几何细节。致密化规律与3DGS一致，但聚焦于最需要致密化的局部3D区域。具体来说，对于小高斯函数，论文的策略包括克隆高斯函数，同时保持它们的大小，并沿着位置梯度重新定位它们，以更好地捕捉新出现的几何特征。相反，位于高方差区域的较大的高斯分布被分割成较小的点，以更准确地表示底层几何形状。</li><li>在点稀疏的情况下，论文在三维区域的中心添加新的高斯点。</li></ul><p>对于几何校正，论文认为在进行alpha-blending的时候，如果误差区域最前方的点不透明度最高，就可能会遮挡有效的点，导致深度估计错误。因此论文认为这些点是潜在的病态点，对于这些点，论文的方法会重置它们的不透明度，提供校正的机会，进一步校准几何形状。</p><p>另外，为了minimize model expansion，论文根据不透明度从低到高的自适应修剪点，修剪的数量由区域中的点密度决定，这种方法可以保证论文的点管理策略保持成本效益，适应场景表示不断变化的需求。</p><blockquote><p>也就是说，论文的核心思路其实是：</p><p>对于当前帧的优化过程，首先寻找导致误差的三维区域</p><ul><li>计算current view的error map；</li><li>找一个相邻帧作为referred view，和current view通过lightglue做特征匹配，得到匹配点对；</li><li>根据匹配点对和error map得到误差区域（2D），计算current view和reffered view区域内的像素点对应的射线（计算视锥）；</li><li>求射线（视锥）的交点，计算交点的最小包围球面，球面包围的区域就是误差源的三维区域。</li></ul><p>之后在3DGS的自适应密度控制（ADC）基础上，在误差源的三维区域中进行局部的点添加或校正</p><ul><li>存在高斯点：用ADC方法进行局部补全；</li><li>不存在高斯点：在三维区域中心添加新的高斯点；</li><li>误差区域最前方点的不透明度最高：重置他们的不透明度，提供校正的机会。</li></ul></blockquote><h2 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h2><p>论文主要关注于，寻找导致渲染误差的局部三维区域，并且根据局部三维区域的情况，做了对应的处理。</p><p>从实现方法上来看：通过当前帧和相邻帧的多视图几何约束来计算误差源三维区域，之后根据区域内三种常见的情况提供了三种处理方案，整体思路还是很简单直观的。但是使用了lightglue来计算匹配点，这个过程其实会导致额外的计算资源消耗（比如要跑lightglue这个模型，要保存lightglue中间的结果），考虑到论文是致力于实现一个3dgs的插件，能够得到的信息有限，因此可以理解。</p><blockquote><p>如果是放到gaussian splatting上的话，输入的是colmap重建的结果，这中间可以访问colmap的数据库拿到匹配点对。</p><p>如果是放到3dgs slam中的话，可以使用external tracker，由external tracker提供匹配关系。</p></blockquote><p>从实验结果来看：加入论文实现的LPM模块之后，PSNR、LPIPS等指标只有些微的提升，感觉可以忽略不计；不过训练时间、高斯点数等指标也没有特别大的影响。另外，论文还测试了自适应密度控制lower threshold下3DGS的结果，高斯点数、训练时间明显提升，但是效果不一定提升，这个现象我之前也发现了，所以自适应密度控制这种方法，确实不是很适合提升一些局部的细节。这样看的话，论文为3dgs局部细节的提升做了一定的贡献。</p><p>此外，论文在最后的总结部分也提到了“While our method identifies the 3D Gaussian points that lead to rendering errors, it still follows the densification rules of 3DGS”，论文的方法本质上还是遵循3DGS的致密化规则，只是识别了导致渲染错误的3D高斯。所以如何寻找更好的致密化规则，还是值得研究的。</p>]]></content>
      
      
      <categories>
          
          <category> NeRF&amp;3DGS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式表示 </tag>
            
            <tag> 3D Gaussian Splatting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读《MotionGS：Compact Gaussian Splatting SLAM by Motion Filter》</title>
      <link href="2024/07/01/paper-reading-motiongs/"/>
      <url>2024/07/01/paper-reading-motiongs/</url>
      
        <content type="html"><![CDATA[<h1 id="论文阅读《MotionGS-Compact-Gaussian-Splatting-SLAM-by-Motion-Filter》"><a href="#论文阅读《MotionGS-Compact-Gaussian-Splatting-SLAM-by-Motion-Filter》" class="headerlink" title="论文阅读《MotionGS : Compact Gaussian Splatting SLAM by Motion Filter》"></a>论文阅读《MotionGS : Compact Gaussian Splatting SLAM by Motion Filter》</h1><blockquote><p>关键词：Compact、Motion Filter</p><p>提出了一种融合深度视觉特征、双关键帧选择和3DGS的基于3d图像的SLAM方法。</p><p>与现有的跟踪方法相比，该方法通过对每帧进行特征提取和运动滤波来实现跟踪。姿态和三维高斯的联合优化贯穿于整个映射过程。此外，通过双关键帧选择和新颖的损失函数实现了从粗到精的姿态估计和紧凑的高斯场景表示。实验结果表明，该算法不仅在跟踪和映射方面优于现有方法，而且占用的内存也更少。</p></blockquote><p>本文提出了一种新颖的基于3dgs的密集SLAM方法——MotionGS。该方法集成了深度特征提取、双关键帧选择和三维图像。在跟踪线程中，我们从每张图像中提取深度特征，通过运动滤波获得运动关键帧，并采用针对3DGS的直接姿态优化，减少处理帧数，提高跟踪性能。最后，跟踪线程通过信息过滤器不断更新和维护一个信息关键帧滑动窗口。在映射线程中，设计了一个新的损失函数来同时优化关键帧位姿和diff-gaussian-rasterization中的三维高斯。跟踪和映射线程的双重优化实现了从粗到精的姿态优化，减少了存储需求。对室内RGB-D数据集的广泛评估表明，我们的方法在跟踪、渲染和映射方面具有一流的性能。<strong>综上所述，主要贡献如下:</strong></p><ol><li>提出了一种新的基于3DGS的密集视觉SLAM方法(将深度特征提取、双关键帧选择和3DGS相结合)。该方法不仅实现了精确的实时跟踪和高保真重建，而且同时支持RGB和RGB- d输入。</li><li>设计了一种新的双关键帧策略和新的损失函数，以提高跟踪精度和保持渲染质量，同时减少内存消耗。</li><li>我们的方法在Replica和TUM-RGBD数据集上实现了最先进的跟踪、映射性能，运行速度为2.5 fps，内存使用更少。</li></ol><h2 id="System-Pipeline"><a href="#System-Pipeline" class="headerlink" title="System Pipeline"></a>System Pipeline</h2><p><img src="/images/paper-reading-MotionGS/image-20240701102610092.png"></p><h3 id="场景表示"><a href="#场景表示" class="headerlink" title="场景表示"></a>场景表示</h3><p>受到了Compact 3DGS的影响，使用了原版的3DGS+learnable mask的结构，其中learnable mask的损失函数直接用的Compact 3DGS的。</p><p>最终的损失函数很简单，如下：</p><img src="/images/paper-reading-MotionGS/image-20240701103618536.png" style="zoom:67%;"><h3 id="Dual-Keyframe-Strategy【暂时略过】"><a href="#Dual-Keyframe-Strategy【暂时略过】" class="headerlink" title="Dual Keyframe Strategy【暂时略过】"></a>Dual Keyframe Strategy【暂时略过】</h3><blockquote><p>双关键帧策略，由<strong>运动滤波器</strong>和<strong>信息滤波器</strong>组成，分别对应于<strong>运动关键帧</strong>和<strong>信息关键帧</strong>。</p><blockquote><p>之前有学长提到，这部分其实就是Droid SLAM里面的内容，只是这篇论文写的很隐晦。</p><p>这里我还要自己确认一下，把Droid SLAM这篇论文好好看看才行。</p></blockquote></blockquote><p><strong>Motion Filter</strong></p><p>对每一帧进行特征提取，只保留超过相关阈值的帧。与Droid SLAM类似，我们将三种不同的网络设计为:特征网络、上下文网络和更新网络。</p><img src="/images/paper-reading-MotionGS/image-20240701105342445.png" style="zoom:67%;"><p><strong>Correlation Pyramid</strong></p><p>略。。。</p><h3 id="3DGS-based-Direct-pose-optimization"><a href="#3DGS-based-Direct-pose-optimization" class="headerlink" title="3DGS-based Direct pose optimization"></a>3DGS-based Direct pose optimization</h3><p><strong>这里提到了3DGS渲染的结果是有一定的模糊的，因此优化gt和渲染之间的部分像素是不切实际的。</strong>虽然优化整张图象速度会比较慢，但是它和3DGS的可微分渲染框架是一致的，因此这里还是使用所有像素直接用于位姿的优化。</p><blockquote><p>深表赞同，但是这样速度真的会很慢吧。。。</p></blockquote><p>这里说受到Gaussian Splatting SLAM工作的影响，李代数可以帮助找到最小的Jacobian</p><img src="/images/paper-reading-MotionGS/image-20240701110458079.png" style="zoom:80%;"><h3 id="SLAM-System"><a href="#SLAM-System" class="headerlink" title="SLAM System"></a>SLAM System</h3><p>看到这里我可能大概明白这篇论文的实现了，我猜测是：</p><ul><li>模仿Compact 3DGS，场景表示为：原始3DGS+learnable mask</li><li>Tracking：基于Droid SLAM</li><li>Mapping：3DGS和pose的联合优化，参考Gaussian Splatting SLAM</li></ul><p>在上面的基础上，还有一些小细节、小调整。</p><h2 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h2><p>略</p><h2 id="直播课程"><a href="#直播课程" class="headerlink" title="直播课程"></a>直播课程</h2><ul><li><p><strong>MotionGS是基于MonoGS的</strong>，理由如下：</p><blockquote><p>其中2、3、4点是最最重要的！！！</p></blockquote><p><img src="/images/paper-reading-MotionGS/image-20240701141559244.png"></p><p><img src="/images/paper-reading-MotionGS/image-20240701141608819.png"></p></li><li><p><strong>Dual Keyframe Strategy</strong>中，<strong>运动滤波器 Motion Filter 和 相关金字塔 Correlation Pyramid</strong>是从Droid SLAM缝合过来的：</p><p><img src="/images/paper-reading-MotionGS/image-20240701144339320.png"></p><p><img src="/images/paper-reading-MotionGS/image-20240701144403182.png"></p><p>而信息滤波器可能只是在MonoGS的基础上做了一些小修改：</p><p><img src="/images/paper-reading-MotionGS/image-20240701144646919.png"></p></li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li><p><strong>必须要好好看一下Droid SLAM</strong>了，很多新工作都用的这个。</p></li><li><p><strong>Gaussian Splatting SLAM这篇工作做的公式推导、以及他们修改的diff-gaussian-rasterization</strong>有一些新的工作用上了，后面要多注意一下。</p></li><li><p>最值得注意的还是论文里面的这个观点，我也是很认同的：</p><p>Firstly, it is crucial to acknowledge that the rendering results of 3DGS inherently exhibit some degree of blur. It is impractical to optimize the partial pixels between real photos and rendered images. Although the pose optimization using the entire photo may slightly lag in speed, it aligns with the differentiable rendering framework of 3DGS. Therefore, all pixels are directly used to the pose optimization framework based on the photometric error between real photos and rendered images.</p><p>首先，<strong>承认3DGS的渲染结果固有地表现出一定程度的模糊是至关重要的。优化真实照片和渲染图像之间的部分像素是不切实际的。</strong>虽然使用整个照片的姿态优化可能会在速度上略有滞后，但它与3DGS的可微分渲染框架保持一致。因此，所有像素直接用于基于真实照片和渲染图像之间光度误差的姿态优化框架。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式表示 </tag>
            
            <tag> 3D Gaussian Splatting </tag>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICP算法详解</title>
      <link href="2024/06/28/icp-algorithm-explanation/"/>
      <url>2024/06/28/icp-algorithm-explanation/</url>
      
        <content type="html"><![CDATA[<h1 id="ICP算法详解"><a href="#ICP算法详解" class="headerlink" title="ICP算法详解"></a>ICP算法详解</h1><h2 id="原论文浅析-amp-补充：A-Method-for-Registration-of-3-D-Shapes"><a href="#原论文浅析-amp-补充：A-Method-for-Registration-of-3-D-Shapes" class="headerlink" title="原论文浅析&amp;补充：A Method for Registration of 3-D Shapes"></a>原论文浅析&amp;补充：A Method for Registration of 3-D Shapes</h2><p>ICP算法最早于1992年由论文《A Method for Registration of 3-D Shapes》提出，论文提到ICP算法可以用于以下的几种情况：</p><ol><li>点集</li><li>线段集（折线）</li><li>隐式曲线（用数学公式表示曲线）</li><li>参数曲线（用参数映射表示曲线）</li><li>三角面片（应该就是现在的mesh）</li><li>隐式表面（用数学公式表示的表面）</li><li>参数表面（用参数映射表示的表面）</li></ol><img src="/images/icp-algorithm-explanation/image-20240628165635002-1729843722025-22.png" style="zoom:67%;"><blockquote><p>关于3、4、6、7点有疑惑的，可以看<a href="https://immortalqx.github.io/2022/08/17/geometry-notes-1/">几何的隐式表示与显示表示</a>，或者看<a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">GAMES101: 现代计算机图形学入门</a>第5周、第6周的课件。</p></blockquote><p>由于我们主要关注<strong>点集之间的配准</strong>，因此<strong>下面主要讲论文的IV. THE ITERATIVE CLOSEST POINT ALGORITHM部分，其他部分可以看原论文。</strong></p><h3 id="ICP算法的定义"><a href="#ICP算法的定义" class="headerlink" title="ICP算法的定义"></a>ICP算法的定义</h3><p>从下面可以看出，ICP算法最核心的问题就两个，<strong>一个是如何计算最近点（最近邻问题），一个是如何求解旋转和平移（非线性最小二乘问题）</strong>。</p><img src="/images/icp-algorithm-explanation/image-20240628164637072-1729843722025-23.png" style="zoom:67%;"><p>对于有$N_p$个点${p_i}$的点集$P$，和有$N_x$个点、线段或三角面片的目标形状$X$，ICP算法可以定义为：</p><ul><li><p>$P_k$表示第$k$次迭代更新之后的点集，$q_k$表示第$k$次迭代中计算得到的旋转和平移，其中$P_0=P$，$q_0=[1,0,0,0,0,0,0]^t$，$q_0[0:3]$是单位四元数，表示旋转，$q_0[4:6]$是平移向量，表示平移。</p></li><li><p>算法的流程为：</p><ul><li><p>计算本次迭代的最近点集，$Y_k = C(P_k,X)$，平均复杂度是$O(N_p logN_x)$，最坏的情况下复杂度是$O(N_pN_x)$。需要注意，$Y_k$是目标形状$X$上的点。</p><blockquote><p>计算最近点集的问题也叫做最近邻问题，后面会详细展开讲。这里ICP认为距离最近的点就是对应点，根据对应点能计算旋转和平移。</p><blockquote><p>这部分和快速排序的时间复杂度一样</p></blockquote></blockquote></li><li><p>计算本次迭代的旋转和平移，$(q_k,d_k)=Q(P_0,Y_k)$，时间复杂度是$O(N_p)$</p><blockquote><p>这部分在论文III. MATHEMATICAL PRELIMINARIES部分有介绍，下面也会详细展开</p></blockquote></li><li><p>应用本次计算的旋转和平移，更新点集，$P_{k+1} = q_k(P_0)$，时间复杂度是$O(N_p)$</p></li><li><p>当均方误差的变化低于预设的阈值时，终止迭代。这个阈值指定了配准过程的期望精确度。</p></li></ul></li></ul><h3 id="ICP核心问题一：最近邻问题"><a href="#ICP核心问题一：最近邻问题" class="headerlink" title="ICP核心问题一：最近邻问题"></a>ICP核心问题一：最近邻问题</h3><p> <strong>这里给一个高翔新书《自动驾驶与机器人中的SLAM技术-从理论到实践》中的部分介绍。</strong></p><p><img src="/images/icp-algorithm-explanation/image-20240628205017258-1729843722025-24.png"></p><p><img src="/images/icp-algorithm-explanation/image-20240628205543494-1729843722025-25.png"></p><h3 id="ICP核心问题二：非线性最小二乘问题"><a href="#ICP核心问题二：非线性最小二乘问题" class="headerlink" title="ICP核心问题二：非线性最小二乘问题"></a>ICP核心问题二：非线性最小二乘问题</h3><h4 id="原论文方法一"><a href="#原论文方法一" class="headerlink" title="原论文方法一"></a>原论文方法一</h4><blockquote><p>对应论文中III. MATHEMATICAL PRELIMINARIES部分的C. Corresponding Point Set Registration</p><p>对应上述方法的第二步，即“计算本次迭代的旋转和平移，$(q_k,d_k)=Q(P_0,Y_k)$，时间复杂度是$O(N_p)$”。</p><blockquote><p>下面的方法应该就是SVD分解的方法。</p></blockquote></blockquote><p><strong>下面是论文中提到的求解方法，比较类似SVD分解。</strong></p><img src="/images/icp-algorithm-explanation/image-20240628180438242-1729843722025-26.png" style="zoom:67%;"><img src="/images/icp-algorithm-explanation/image-20240628180455989-1729843722025-27.png" style="zoom:67%;"><p><img src="/images/icp-algorithm-explanation/image-20240628180516684-1729843722025-28.png"></p><h4 id="原论文方法二"><a href="#原论文方法二" class="headerlink" title="原论文方法二"></a>原论文方法二</h4><blockquote><p>对应论文中IV. THE ITERATIVE CLOSEST POINT ALGORITHM部分的C. An Accelerated ICP Algorithm</p><p>对应上述方法的第二步，但是替换掉了旋转和平移的求解方法。</p><blockquote><p>下面的方法应该是梯度下降法。</p></blockquote></blockquote><p><strong>下面是原论文中提到的方法，比较类似梯度下降法，和求解最小二乘问题</strong></p><img src="/images/icp-algorithm-explanation/image-20240628180625669-1729843722025-29.png" style="zoom:67%;"><img src="/images/icp-algorithm-explanation/image-20240628180749297-1729843722025-30.png" style="zoom:67%;"><img src="/images/icp-algorithm-explanation/image-20240628180829200-1729843722025-31.png" style="zoom:67%;"><img src="/images/icp-algorithm-explanation/image-20240628180848197-1729843722025-32.png" style="zoom:67%;"><h4 id="常用方法一：SVD分解"><a href="#常用方法一：SVD分解" class="headerlink" title="常用方法一：SVD分解"></a>常用方法一：SVD分解</h4><p><img src="/images/icp-algorithm-explanation/image-20240628211432440-1729843722025-33.png"></p><p><img src="/images/icp-algorithm-explanation/image-20240628211445544-1729843722025-34.png"></p><p><img src="/images/icp-algorithm-explanation/image-20240628211509415-1729843722025-35.png"></p><h4 id="常用方法二：梯度下降法"><a href="#常用方法二：梯度下降法" class="headerlink" title="常用方法二：梯度下降法"></a>常用方法二：梯度下降法</h4><p><img src="/images/icp-algorithm-explanation/image-20240628211545626-1729843722025-36.png"></p><h2 id="经典ICP算法框架"><a href="#经典ICP算法框架" class="headerlink" title="经典ICP算法框架"></a>经典ICP算法框架</h2><p> <strong>在高翔新书《自动驾驶与机器人中的SLAM技术-从理论到实践》中，对3D点对点ICP算法的描述如下所示。</strong></p><p><img src="/images/icp-algorithm-explanation/image-20240628204739360-1729843722025-37.png"></p><p><img src="/images/icp-algorithm-explanation/image-20240628204751728-1729843722025-38.png"></p><p><strong>G-ICP论文中给出了标准ICP算法框架，如下所示。</strong></p><p><img src="/images/icp-algorithm-explanation/image-20240628203747549-1729843722025-39.png"></p><h2 id="拓展：Gaussian-Splatting中的最近邻问题"><a href="#拓展：Gaussian-Splatting中的最近邻问题" class="headerlink" title="拓展：Gaussian Splatting中的最近邻问题"></a>拓展：Gaussian Splatting中的最近邻问题</h2><p>在gaussian splatting中，包括了<a href="https://gitlab.inria.fr/bkerbl/simple-knn">submodules/simple-knn</a>，<strong>这个simple-knn并不是聚类算法，而是一个K近邻算法</strong>。</p><h3 id="代码对应部分"><a href="#代码对应部分" class="headerlink" title="代码对应部分"></a>代码对应部分</h3><p>Gaussian Splatting中使用K近邻算法的目的是为了实现初始化，每个初始化高斯点的尺度是其到最近的k个点的平均距离。</p><p><img src="/images/icp-algorithm-explanation/image-20240628212740328-1729843722025-40.png"></p><p><img src="/images/icp-algorithm-explanation/image-20240628212726640-1729843722025-41.png"></p><h3 id="simple-knn代码实现"><a href="#simple-knn代码实现" class="headerlink" title="simple-knn代码实现"></a>simple-knn代码实现</h3><p>Gaussian Splatting中直接调用的函数如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// 定义一个函数 distCUDA2，参数是一个常量引用 torch::Tensor 类型的 points，返回值类型是 torch::Tensortorch::TensordistCUDA2(const torch::Tensor&amp; points){  // 获取 points 张量的第一个维度的大小，即点的数量 P  const int P = points.size(0);  // 创建一个选项对象 float_opts，类型与 points 的数据类型相同，但数据类型设置为 torch::kFloat32  auto float_opts = points.options().dtype(torch::kFloat32);    // 使用 float_opts 选项创建一个大小为 P 的张量 means，初始值为 0.0，数据类型为 float32  torch::Tensor means = torch::full({P}, 0.0, float_opts);    // 调用 SimpleKNN::knn 函数，传入 P（点的数量）、points 的连续内存数据（转换为 float3 指针）、means 的连续内存数据  // 代码中默认的K=3，这里means得到的就是每个点到最近的三个点的平均距离的平方  SimpleKNN::knn(P, (float3*)points.contiguous().data&lt;float&gt;(), means.contiguous().data&lt;float&gt;());  // 返回 means 张量  return means;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，SimpleKNN::knn是一个“基于 Morton 编码的 K 近邻（KNN）查找算法”，这里用GPT根据submodules/simple-knn的代码生成了如下伪代码，方便理解：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">// Step 1: Normalize points and compute Morton codes// 计算xyz坐标的最小值和最大值，并且进行归一化&amp;计算morton编码minn = min(points)maxx = max(points)for each point in points:    morton_code = compute_morton_code(point, minn, maxx)// Step 2: Sort Morton codes and indices// 对morton编码进行排序和索引sort(morton_codes, indices)// Step 3: Divide points into blocks and compute bounding boxes// 分块，并且计算每个块的最小值最大值blocks = divide_into_blocks(points, block_size)for each block in blocks:    compute_min_max(block)// Step 4: KNN search// K近邻搜索for each point in points:// 首先从该点所属的block中找最近点    nearest_neighbors = find_nearest_neighbors_in_block(point, block)    for each block in blocks:// 之后再从其他的block中找最近点并且进行更新        if distance_to_block(point, block) &lt; furthest_distance(nearest_neighbors):            update_nearest_neighbors(point, block, nearest_neighbors)    // 计算与最近K个点的平均距离的平方    mean_distance = compute_mean_distance(nearest_neighbors)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Morton编码"><a href="#Morton编码" class="headerlink" title="Morton编码"></a>Morton编码</h3><p>Morton 编码（Morton Code），也称为 Z-order 曲线（Z-order Curve），是一种将多维数据映射到一维的空间填充曲线。在这种映射中，<strong>具有相邻多维坐标的点在映射到一维后也保持相邻的概率较高。</strong></p><p><strong>Morton 编码的原理</strong></p><p>Morton 编码通过<strong>交替取每个维度的比特位来实现。</strong>例如，对于三维坐标 (x, y, z)，它将每个坐标的二进制表示交替组合，形成一个新的整数。具体步骤如下：</p><ol><li><strong>将每个坐标归一化到 [0, 1] 范围内</strong>： 这通过将坐标减去最小值并除以最大值减去最小值来实现。这样可以确保所有坐标都在相同的范围内，有助于后续的比特操作。</li><li><strong>将归一化后的坐标映射到一个固定范围内的整数</strong>： 例如，将归一化后的 [0, 1] 范围内的坐标映射到 [0, 1023] 范围内（即 10 位二进制数）。</li><li><strong>将每个维度的比特交替合并</strong>： 将每个坐标的二进制表示交替取出，并组合成一个新的整数。这个过程叫做“bit interleaving”。</li></ol><p><img src="/images/icp-algorithm-explanation/13a8e3028c3b429caa827be151fe2585-1729843722025-21.png"></p>]]></content>
      
      
      <categories>
          
          <category> 三维视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 3D Gaussian Splatting </tag>
            
            <tag> 点云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读《RTG-SLAM：Real-time 3D Reconstruction at Scale Using Gaussian Splatting》</title>
      <link href="2024/06/05/paper-reading-rtg-slam/"/>
      <url>2024/06/05/paper-reading-rtg-slam/</url>
      
        <content type="html"><![CDATA[<h1 id="论文阅读《RTG-SLAM-Real-time-3D-Reconstruction-at-Scale-Using-Gaussian-Splatting》"><a href="#论文阅读《RTG-SLAM-Real-time-3D-Reconstruction-at-Scale-Using-Gaussian-Splatting》" class="headerlink" title="论文阅读《RTG-SLAM: Real-time 3D Reconstruction at Scale Using Gaussian Splatting》"></a>论文阅读《RTG-SLAM: Real-time 3D Reconstruction at Scale Using Gaussian Splatting》</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>我们提出了实时高斯SLAM (RTG-SLAM)，这是一个基于RGBD相机的实时三维重建系统，用于大规模环境的高斯溅射。该系统具有紧凑的高斯表示和高效的实时高斯优化方案。<strong>我们迫使每个高斯函数要么是不透明的，要么是接近透明的，不透明的高斯函数拟合表面和主色，透明的高斯函数拟合剩余色。</strong>通过以不同于颜色渲染的方式渲染深度，我们<strong>让单个不透明高斯很好地拟合局部表面区域，而不需要多个重叠的高斯</strong>，从而大大降低了内存和计算成本。对于动态高斯优化，我们<strong>显式地为每帧三种类型的像素添加高斯:新观察到的，具有大颜色误差的，和具有大深度误差的。</strong>我们还将所有高斯函数分为稳定的和不稳定的，其中<strong>稳定的高斯函数被期望很好地拟合先前观察到的RGBD图像，否则不稳定</strong>。我们<strong>只优化不稳定高斯函数，只渲染被不稳定高斯函数占用的像素。</strong>这样，无论是需要优化的高斯数还是需要渲染的像素都大大减少，并且可以实时进行优化。我们展示了各种大型场景的实时重建。与最先进的基于nerf的RGBD SLAM相比，我们的系统实现了类似的高质量重建，但速度约为两倍，内存成本为一半，并且在新视图合成的真实感和相机跟踪精度方面表现出卓越的性能。</p><blockquote><p>看完Abstract，感觉这篇文章主要的工作是：<strong>研究了各种让SLAM结果变好的==策略==</strong></p></blockquote><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p><img src="/images/paper-reading-rtg-slam/image-20240605200843475-1717589324365-1.png"></p><h3 id="Compact-Gaussian-Representation"><a href="#Compact-Gaussian-Representation" class="headerlink" title="Compact Gaussian Representation"></a>Compact Gaussian Representation</h3><p>使用Gaussian表示场景：</p><ul><li>每个高斯要么不透明，要么几乎透明。Each Gaussian is determined once after being added to be opaque (𝛼 = 0.99) for fitting the 3D surface and dominant color, or to be nearly transparent (𝛼 = 0.1) for fitting the residual color.</li><li>每个高斯认为是一个ellipsoid disc或者surfel。We also treat each Gaussian as an ellipsoid disc (or surfel), and record the surfel parameters including the normal n𝑖 , the confidence count 𝜂𝑖 , and the initialization timestamp 𝑡𝑖 . </li></ul><p>对于image rendering，这里应该是和Gaussian Splatting一样的，没有做什么特殊的处理；</p><p>对于depth rendering，论文说这是他们这部分的关键：</p><ul><li><p>当前的所有Gaussian SLAM渲染深度的方式都和渲染颜色的方式一样，用alpha blending。但是这会导致单个高斯渲染的深度是从中间到两边下降的，不适合用来单独拟合一些近似是平面的区域。论文这里放了一张图来展示；</p><img src="/images/paper-reading-rtg-slam/image-20240605210350123.png" style="zoom:50%;"><blockquote><p><strong>==疑问：目前对rendering部分理解的不是很透彻，有两个疑问==</strong></p><ul><li><p>为什么会导致深度从中间到两边是下降的呢，是因为3D向2D投影的过程导致的吗？</p></li><li><p>如果这样的话，RGB的渲染会不会也是从中间到两边下降的？或者说球谐可以解决这个问题，因为每个像素都是一条单独的射线？（如果球谐可以解决这种问题，还不如让深度单独带几个球谐系数）</p></li></ul></blockquote></li><li><p>每个高斯都能很好的拟合表面的局部区域，不需要多个高斯；</p></li><li><p><strong>depth rendering的核心思路是：</strong>对于每个像素，计算view ray与距离最近的不透明ellipsoid disc的交点来获得像素的深度。</p><blockquote><p>ellipsoid disc就是高斯椭球两个相对长的轴构成的椭圆面，因为论文前面提到了把短轴作为高斯的法向。</p><img src="/images/paper-reading-rtg-slam/image-20240605212807029.png" style="zoom:67%;"><blockquote><p>The normal vector is defined as the direction of the smallest eigenvector.</p></blockquote><p>看下面的公式，其实做的也挺保守：</p><ul><li>不相交就空着，当成-1（为什么会不相交呢）</li><li>如果有个高斯和相机平面的夹角比较小，影响的像素点比较多，才会把这个高斯当成Ellipse Disc来看；</li><li>而如果夹角比较大，影响的像素点少，当成Ellipse Disc处理可能误差也比较大，于是这部分的像素的深度都是根据高斯的中心点来算的。</li></ul></blockquote><img src="/images/paper-reading-rtg-slam/image-20240605214130735.png" style="zoom:67%;"></li></ul><h3 id="Online-Reconstruction-Process"><a href="#Online-Reconstruction-Process" class="headerlink" title="Online Reconstruction Process"></a>Online Reconstruction Process</h3><blockquote><p>这部分看来是把整个系统都讲了一遍</p></blockquote><h4 id="Input-pre-processing"><a href="#Input-pre-processing" class="headerlink" title="Input pre-processing"></a>Input pre-processing</h4><p>根据输入的RGB和Depth，计算local vertex map和local normal map，再利用估计的相机位姿转换成global vertex map和local normal map</p><h4 id="Gaussians-adding"><a href="#Gaussians-adding" class="headerlink" title="Gaussians adding"></a>Gaussians adding</h4><p>这里评价了Gaussian Splatting的Density Control策略是低效的，然后说自己利用基于几何和外观的高斯添加策略是更有效更可靠的，具体是根据渲染的结果计算一个掩码来确定为哪些像素添加高斯：</p><img src="/images/paper-reading-rtg-slam/image-20240608144803374.png" style="zoom:80%;"><p>这里$M_s$是应该添加新几何图形的区域，它的计算依据是：像素射线经过很少的高斯或者没有经过高斯，即新观测的区域；以及深度重渲染的误差过大，即新观测的表面区域与现有场景在这个视角下渲染的结果有区别。</p><p>这里$M_c$表示几何上准确但颜色误差过大的区域。</p><p>这里添加的策略是：</p><ul><li><p>对于$M_s$，添加高斯并且不透明度设置为0.99；</p></li><li><p>对于$M_c$​，它已经与场景中现有的不透明高斯相关联，如果是不稳定的高斯，就可以进一步优化来适应颜色，这样就不继续添加高斯；如果是稳定的高斯，那就在它的基础上加入一个不透明度为0.1的高斯来校正颜色误差。</p><p>使用透明高斯光束的优点在于，这种低不透明度的高斯光束不会引起光能的明显衰减，对其他视图的颜色影响很小。另外，在深度渲染的过程中，它们会被算法自动过滤掉，因此不会影响深度渲染。对于不透明高斯点，它们的大小被初始化为尽可能多地覆盖场景，很少重叠，而透明高斯点的半径被限制在0.01m以下，以消除对其他像素渲染结果的干扰。</p></li></ul><blockquote><p>从这里看，论文更关注几何信息，而对于颜色信息则通过添加透明高斯并加以重重限制来保证不干扰深度渲染结果的同时让颜色的渲染尽可能准确。</p></blockquote><h4 id="Gaussian-optimization"><a href="#Gaussian-optimization" class="headerlink" title="Gaussian optimization"></a>Gaussian optimization</h4><ul><li><p>根据时间顺序确定了一个窗口，每次优化都是从窗口内随机采样一帧。</p></li><li><p>不透明度的学习率设置为0，因此不透明度是固定的，不会被优化。</p><blockquote><p>直接不放到优化参数里不就好了，设置成0是因为，懒得改代码？</p></blockquote></li><li><p>color和depth还是很经典的损失函数，这里论文希望透明高斯函数专注于在不影响其他区域的情况下精炼局部的颜色，因此设计了一个正则化项。总体的损失函数是:</p><img src="/images/paper-reading-rtg-slam/image-20240608152744013.png" style="zoom:80%;"></li><li><p>论文注意到优化后的高斯函数能很好拟合当前时间窗口，但是对于之前的视图，渲染质量会下降。这里他们提出了一种融合策略，通过加权平均的方法把当前的结果和以前的结果融合到一起，这样可以有效避免遗忘问题：</p><img src="/images/paper-reading-rtg-slam/image-20240608153533128.png" style="zoom:80%;"></li><li><p>优化所有高斯是非常耗时的，因此论文不优化稳定高斯，只关注受到不稳定高斯分布影响的像素，从而避免对所有像素的优化。</p></li></ul><h4 id="State-management"><a href="#State-management" class="headerlink" title="State management"></a>State management</h4><p>一些稳定高斯和不稳定高斯之间的转换策略，以及错误高斯（长时间不稳定）的删除</p><img src="/images/paper-reading-rtg-slam/image-20240608153855692.png" style="zoom:67%;"><h4 id="Camera-tracking"><a href="#Camera-tracking" class="headerlink" title="Camera tracking"></a>Camera tracking</h4><p><strong>使用frame-to-model的ICP算法作为front-end odometry</strong>，使用前一帧中优化的高斯函数来渲染深度图、法线图，并且转换到全局空间，然后给定当前帧，通过最小化3D反向投影误差得到位姿：</p><img src="/images/paper-reading-rtg-slam/image-20240608154323318.png" style="zoom:67%;"><p>论文还提到为了减小大场景的累积漂移，用了类似ORB-SLAM2的后端优化线程，完成位姿估计的同时还会保留一组3D landmark用于后端的优化。</p><blockquote><p>和GS_ICP SLAM相比，这里ICP用的还是挺生硬的，需要保留一组3D landmark，存在数据冗余的情况。</p><p>我怀疑这里用的就是ORB-SLAM2的RGB-D前端，因为实验部分Table 2的数据也太好看了，非常接近ORB-SLAM2的结果。</p></blockquote><h4 id="Keyframes-and-global-optimization"><a href="#Keyframes-and-global-optimization" class="headerlink" title="Keyframes and global optimization"></a>Keyframes and global optimization</h4><ul><li>基于相机的运动构造关键帧列表，旋转角度或者相对平移超过了阈值就添加关键帧。</li><li>只优化每个关键帧上误差前40%的像素，并且优化过程中不更新高斯的位置，使用0.1倍率的原始学习率来优化其他的参数。</li></ul><h2 id="EVALUATION"><a href="#EVALUATION" class="headerlink" title="EVALUATION"></a>EVALUATION</h2><p>见原论文</p><h2 id="SUPPLEMENTARY-MATERIALS"><a href="#SUPPLEMENTARY-MATERIALS" class="headerlink" title="SUPPLEMENTARY MATERIALS"></a>SUPPLEMENTARY MATERIALS</h2><blockquote><p>只记录个人认为值得注意的细节</p></blockquote><h3 id="GAUSSIAN-INITIALIZATION"><a href="#GAUSSIAN-INITIALIZATION" class="headerlink" title="GAUSSIAN INITIALIZATION"></a>GAUSSIAN INITIALIZATION</h3><p>每个新的高斯都会初始化为一个平面圆盘，根据最近的三个高斯来计算轴的长度，三个轴的比例为1：1：0.1</p><img src="/images/paper-reading-rtg-slam/image-20240608155942944.png" style="zoom:67%;"><h3 id="IMPLEMENTATION-DETAILS"><a href="#IMPLEMENTATION-DETAILS" class="headerlink" title="IMPLEMENTATION DETAILS"></a>IMPLEMENTATION DETAILS</h3><p>系统由三个线程构成：高斯优化、前端在线跟踪、后端图优化。</p><p>前端在线跟踪是用python+pytorch实现的，而后端优化部分是基于ORB-SLAM2用C语言实现的。</p><h2 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h2><p>这篇文章主要是用了很多简单有效的改进策略，在工程上做了很多的工作。</p><p>另外，这篇论文的前端里程计也是基于ICP的方法，后续可能会有越来越多的RGB-D高斯SLAM使用传统的点云配准方法来做前端的里程计。高斯毕竟还是显式地表示，和点云很相似，从基于渲染损失优化位姿到传统点云配准求解位姿的发展是必然的。</p>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式表示 </tag>
            
            <tag> 3D Gaussian Splatting </tag>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gaussian Splatting中球谐的使用</title>
      <link href="2024/05/31/3dgs-notes-1/"/>
      <url>2024/05/31/3dgs-notes-1/</url>
      
        <content type="html"><![CDATA[<h1 id="Gaussian-Splatting中球谐的使用"><a href="#Gaussian-Splatting中球谐的使用" class="headerlink" title="Gaussian Splatting中球谐的使用"></a>Gaussian Splatting中球谐的使用</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在<code>class GaussianModel</code>中，球谐是通过下面的方式定义的：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">self<span class="token punctuation">.</span>_features_dc <span class="token operator">=</span> torch<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment"># 第一个球谐系数，用于表示基础颜色</span>self<span class="token punctuation">.</span>_features_rest <span class="token operator">=</span> torch<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment"># 其余的球谐系数，用于表示颜色的细节和变化</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>_features_dc</code> 和 <code>_features_rest</code> 张量的形状为 <code>(样本数, 3, 1)</code> 和 <code>(样本数, 3, (max_sh_degree + 1) ** 2 - 1)</code>，分别表示基础颜色的球谐系数和其余球谐系数。</p><blockquote><p>把相关的代码发给ChatGPT，能够帮助分析，参考链接为：<a href="https://chatgpt.com/share/35888723-ab2f-4384-ac63-0fcc87aaaa22">https://chatgpt.com/share/35888723-ab2f-4384-ac63-0fcc87aaaa22</a></p></blockquote><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>之后，通过如下的方式进行初始化：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">fused_color <span class="token operator">=</span> RGB2SH<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>np<span class="token punctuation">.</span>asarray<span class="token punctuation">(</span>pcd<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 初始化存储球谐系数的张量，每个颜色通道有(max_sh_degree + 1) ** 2个球谐系数</span>features <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>fused_color<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>max_sh_degree <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 将RGB转换后的球谐系数C0项的系数存入</span>features<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> fused_color<span class="token comment"># 其余球谐系数初始化为0</span>features<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">self<span class="token punctuation">.</span>_features_dc <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>features<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>contiguous<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>requires_grad_<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span>self<span class="token punctuation">.</span>_features_rest <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>features<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>contiguous<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>requires_grad_<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>相关的函数为：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">RGB2SH</span><span class="token punctuation">(</span>rgb<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    将RGB颜色值转换为球谐系数C0项的系数。    :param rgb: RGB颜色值。    :return: 转换后的球谐系数C0项的系数。    """</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>rgb <span class="token operator">-</span> <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token operator">/</span> C0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h2><p>在<code>class GaussianModel</code>中，球谐通过如下方式保存到ply文件中：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 从 self._features_dc 张量中分离数据，转置第二维和第三维，扁平化，变为连续存储，并复制到 CPU，最后转换为 numpy 数组</span>f_dc <span class="token operator">=</span> self<span class="token punctuation">.</span>_features_dc<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>flatten<span class="token punctuation">(</span>start_dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>contiguous<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cpu<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 从 self._features_rest 张量中分离数据，转置第二维和第三维，扁平化，变为连续存储，并复制到 CPU，最后转换为 numpy 数组</span>f_rest <span class="token operator">=</span> self<span class="token punctuation">.</span>_features_rest<span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>flatten<span class="token punctuation">(</span>start_dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>contiguous<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cpu<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>通过如下的方式，将球谐转换为RGB：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> pipe<span class="token punctuation">.</span>convert_SHs_python<span class="token punctuation">:</span>    <span class="token comment"># ************ 重点：球谐函数如何实现对颜色的掌控 **********</span>    <span class="token comment"># 将SH特征的形状调整为（batch_size * num_points，3，(max_sh_degree+1)**2）</span>    shs_view <span class="token operator">=</span> pc<span class="token punctuation">.</span>get_features<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>pc<span class="token punctuation">.</span>max_sh_degree <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token comment"># 计算相机中心到每个点的方向向量，并归一化</span>    dir_pp <span class="token operator">=</span> <span class="token punctuation">(</span>pc<span class="token punctuation">.</span>get_xyz <span class="token operator">-</span> viewpoint_camera<span class="token punctuation">.</span>camera_center<span class="token punctuation">.</span>repeat<span class="token punctuation">(</span>pc<span class="token punctuation">.</span>get_features<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 计算相机中心到每个点的方向向量，并归一化</span>    dir_pp_normalized <span class="token operator">=</span> dir_pp <span class="token operator">/</span> dir_pp<span class="token punctuation">.</span>norm<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> keepdim<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token comment"># 使用SH特征将方向向量转换为RGB颜色</span>    sh2rgb <span class="token operator">=</span> eval_sh<span class="token punctuation">(</span>pc<span class="token punctuation">.</span>active_sh_degree<span class="token punctuation">,</span> shs_view<span class="token punctuation">,</span> dir_pp_normalized<span class="token punctuation">)</span>    <span class="token comment"># 将RGB颜色的范围限制在0到1之间</span>    colors_precomp <span class="token operator">=</span> torch<span class="token punctuation">.</span>clamp_min<span class="token punctuation">(</span>sh2rgb <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相关的几个函数为：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_features</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>    features_dc <span class="token operator">=</span> self<span class="token punctuation">.</span>_features_dc    features_rest <span class="token operator">=</span> self<span class="token punctuation">.</span>_features_rest    <span class="token keyword">return</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">(</span>features_dc<span class="token punctuation">,</span> features_rest<span class="token punctuation">)</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">eval_sh</span><span class="token punctuation">(</span>deg<span class="token punctuation">,</span> sh<span class="token punctuation">,</span> dirs<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    Evaluate spherical harmonics at unit directions    using hardcoded SH polynomials.    Works with torch/np/jnp.    ... Can be 0 or more batch dimensions.    Args:        deg: int SH deg. Currently, 0-3 supported        sh: jnp.ndarray SH coeffs [..., C, (deg + 1) ** 2]        dirs: jnp.ndarray unit directions [..., 3]    Returns:        [..., C]    """</span>    <span class="token keyword">assert</span> deg <span class="token operator">&lt;=</span> <span class="token number">4</span> <span class="token keyword">and</span> deg <span class="token operator">&gt;=</span> <span class="token number">0</span>    coeff <span class="token operator">=</span> <span class="token punctuation">(</span>deg <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span>    <span class="token keyword">assert</span> sh<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;=</span> coeff    result <span class="token operator">=</span> C0 <span class="token operator">*</span> sh<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">if</span> deg <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>        x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z <span class="token operator">=</span> dirs<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dirs<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dirs<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>        result <span class="token operator">=</span> <span class="token punctuation">(</span>result <span class="token operator">-</span>                  C1 <span class="token operator">*</span> y <span class="token operator">*</span> sh<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span>                  C1 <span class="token operator">*</span> z <span class="token operator">*</span> sh<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span>                  C1 <span class="token operator">*</span> x <span class="token operator">*</span> sh<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> deg <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">:</span>            xx<span class="token punctuation">,</span> yy<span class="token punctuation">,</span> zz <span class="token operator">=</span> x <span class="token operator">*</span> x<span class="token punctuation">,</span> y <span class="token operator">*</span> y<span class="token punctuation">,</span> z <span class="token operator">*</span> z            xy<span class="token punctuation">,</span> yz<span class="token punctuation">,</span> xz <span class="token operator">=</span> x <span class="token operator">*</span> y<span class="token punctuation">,</span> y <span class="token operator">*</span> z<span class="token punctuation">,</span> x <span class="token operator">*</span> z            result <span class="token operator">=</span> <span class="token punctuation">(</span>result <span class="token operator">+</span>                      C2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> xy <span class="token operator">*</span> sh<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">+</span>                      C2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> yz <span class="token operator">*</span> sh<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">+</span>                      C2<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">2.0</span> <span class="token operator">*</span> zz <span class="token operator">-</span> xx <span class="token operator">-</span> yy<span class="token punctuation">)</span> <span class="token operator">*</span> sh<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">+</span>                      C2<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">*</span> xz <span class="token operator">*</span> sh<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">+</span>                      C2<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>xx <span class="token operator">-</span> yy<span class="token punctuation">)</span> <span class="token operator">*</span> sh<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> deg <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token punctuation">:</span>                result <span class="token operator">=</span> <span class="token punctuation">(</span>result <span class="token operator">+</span>                          C3<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> y <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> xx <span class="token operator">-</span> yy<span class="token punctuation">)</span> <span class="token operator">*</span> sh<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">+</span>                          C3<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> xy <span class="token operator">*</span> z <span class="token operator">*</span> sh<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">+</span>                          C3<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">*</span> y <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">*</span> zz <span class="token operator">-</span> xx <span class="token operator">-</span> yy<span class="token punctuation">)</span> <span class="token operator">*</span> sh<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span> <span class="token operator">+</span>                          C3<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">*</span> z <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> zz <span class="token operator">-</span> <span class="token number">3</span> <span class="token operator">*</span> xx <span class="token operator">-</span> <span class="token number">3</span> <span class="token operator">*</span> yy<span class="token punctuation">)</span> <span class="token operator">*</span> sh<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">+</span>                          C3<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">*</span> x <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">*</span> zz <span class="token operator">-</span> xx <span class="token operator">-</span> yy<span class="token punctuation">)</span> <span class="token operator">*</span> sh<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">]</span> <span class="token operator">+</span>                          C3<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">*</span> z <span class="token operator">*</span> <span class="token punctuation">(</span>xx <span class="token operator">-</span> yy<span class="token punctuation">)</span> <span class="token operator">*</span> sh<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">]</span> <span class="token operator">+</span>                          C3<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">*</span> x <span class="token operator">*</span> <span class="token punctuation">(</span>xx <span class="token operator">-</span> <span class="token number">3</span> <span class="token operator">*</span> yy<span class="token punctuation">)</span> <span class="token operator">*</span> sh<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> deg <span class="token operator">&gt;</span> <span class="token number">3</span><span class="token punctuation">:</span>                    result <span class="token operator">=</span> <span class="token punctuation">(</span>result <span class="token operator">+</span> C4<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> xy <span class="token operator">*</span> <span class="token punctuation">(</span>xx <span class="token operator">-</span> yy<span class="token punctuation">)</span> <span class="token operator">*</span> sh<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">]</span> <span class="token operator">+</span>                              C4<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> yz <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> xx <span class="token operator">-</span> yy<span class="token punctuation">)</span> <span class="token operator">*</span> sh<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">]</span> <span class="token operator">+</span>                              C4<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">*</span> xy <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">7</span> <span class="token operator">*</span> zz <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> sh<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">]</span> <span class="token operator">+</span>                              C4<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">*</span> yz <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">7</span> <span class="token operator">*</span> zz <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">*</span> sh<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">]</span> <span class="token operator">+</span>                              C4<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>zz <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">35</span> <span class="token operator">*</span> zz <span class="token operator">-</span> <span class="token number">30</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">*</span> sh<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">]</span> <span class="token operator">+</span>                              C4<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">*</span> xz <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">7</span> <span class="token operator">*</span> zz <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">*</span> sh<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">]</span> <span class="token operator">+</span>                              C4<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>xx <span class="token operator">-</span> yy<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">7</span> <span class="token operator">*</span> zz <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> sh<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">]</span> <span class="token operator">+</span>                              C4<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">*</span> xz <span class="token operator">*</span> <span class="token punctuation">(</span>xx <span class="token operator">-</span> <span class="token number">3</span> <span class="token operator">*</span> yy<span class="token punctuation">)</span> <span class="token operator">*</span> sh<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">]</span> <span class="token operator">+</span>                              C4<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>xx <span class="token operator">*</span> <span class="token punctuation">(</span>xx <span class="token operator">-</span> <span class="token number">3</span> <span class="token operator">*</span> yy<span class="token punctuation">)</span> <span class="token operator">-</span> yy <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> xx <span class="token operator">-</span> yy<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> sh<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> NeRF&amp;3DGS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式表示 </tag>
            
            <tag> 3D Gaussian Splatting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Colmap和Gaussian Splatting保存出来的ply文件格式解析</title>
      <link href="2024/05/30/3dgs-notes-0/"/>
      <url>2024/05/30/3dgs-notes-0/</url>
      
        <content type="html"><![CDATA[<h1 id="Colmap和Gaussian-Splatting保存出来的ply文件格式解析"><a href="#Colmap和Gaussian-Splatting保存出来的ply文件格式解析" class="headerlink" title="Colmap和Gaussian Splatting保存出来的ply文件格式解析"></a>Colmap和Gaussian Splatting保存出来的ply文件格式解析</h1><h2 id="Colmap"><a href="#Colmap" class="headerlink" title="Colmap"></a>Colmap</h2><p>打印Colmap稀疏重建的点云，前13行是这样的：</p><pre class="line-numbers language-none"><code class="language-none">plyformat binary_little_endian 1.0element vertex 100267property float xproperty float yproperty float zproperty float nxproperty float nyproperty float nzproperty uchar redproperty uchar greenproperty uchar blueend_header<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应的数据是这样的：</p><pre class="line-numbers language-none"><code class="language-none">-0.520981 4.31948 -0.425874 0 0 0 127 194 178<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其实可以发现稀疏重建的点云，并没有计算每个点的法向，只是保存的ply文件有这些数据。</p><h2 id="Gaussian-Splatting"><a href="#Gaussian-Splatting" class="headerlink" title="Gaussian Splatting"></a>Gaussian Splatting</h2><p>对于sh_degree设置为3的Gaussian，每个Gaussian有62个参数（不看法向，<strong>实际上只有59个</strong>），前66行是这样的：</p><pre class="line-numbers language-none"><code class="language-none">plyformat binary_little_endian 1.0element vertex 407216property float xproperty float yproperty float zproperty float nxproperty float nyproperty float nzproperty float f_dc_0property float f_dc_1property float f_dc_2property float f_rest_0property float f_rest_1property float f_rest_2property float f_rest_3property float f_rest_4property float f_rest_5property float f_rest_6property float f_rest_7property float f_rest_8property float f_rest_9property float f_rest_10property float f_rest_11property float f_rest_12property float f_rest_13property float f_rest_14property float f_rest_15property float f_rest_16property float f_rest_17property float f_rest_18property float f_rest_19property float f_rest_20property float f_rest_21property float f_rest_22property float f_rest_23property float f_rest_24property float f_rest_25property float f_rest_26property float f_rest_27property float f_rest_28property float f_rest_29property float f_rest_30property float f_rest_31property float f_rest_32property float f_rest_33property float f_rest_34property float f_rest_35property float f_rest_36property float f_rest_37property float f_rest_38property float f_rest_39property float f_rest_40property float f_rest_41property float f_rest_42property float f_rest_43property float f_rest_44property float opacityproperty float scale_0property float scale_1property float scale_2property float rot_0property float rot_1property float rot_2property float rot_3end_header<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应的数据是这样的：</p><pre class="line-numbers language-none"><code class="language-none">2.1896963119506836 0.5654028058052063 1.664149284362793 0.0 0.0 0.0 0.5147678256034851 0.2996779680252075 -0.03710278868675232 0.02432778663933277 0.02444857358932495 0.02761399932205677 -0.009275455959141254 -0.07312484085559845 -0.07785580307245255 0.00238581420853734 0.059049881994724274 -0.00435364106670022 -0.00045146566117182374 0.028354087844491005 -0.08165063709020615 -0.044504206627607346 0.03321271389722824 0.02827625349164009 0.0210369061678648 0.029464859515428543 0.012756595388054848 0.0032518154475837946 -0.06004106625914574 -0.03746717795729637 0.014808553270995617 0.05368928611278534 -0.007978635840117931 -0.04243125021457672 0.002324196044355631 -0.05169673264026642 -0.08004658669233322 0.02979198843240738 0.05964512750506401 -0.022210335358977318 -0.03916030004620552 -0.007248427718877792 0.021033495664596558 0.02982276864349842 -0.004562453832477331 0.029783839359879494 0.003827654290944338 0.01913684606552124 -0.04349766671657562 -0.11221770942211151 -0.0740458145737648 -0.03573375567793846 0.08243989944458008 0.05897160992026329 -1.6227161884307861 -10.401392936706543 -3.377558946609497 -5.4260053634643555 0.9305478930473328 0.17775008082389832 -0.052619289606809616 -0.04175473749637604 2.176823616027832<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于sh_degree设置为0的Gaussian，每个Gaussian有17个参数（不看法向，<strong>实际上只有14个</strong>），前21行是这样的：</p><pre class="line-numbers language-none"><code class="language-none">plyformat binary_little_endian 1.0element vertex 1809737property float xproperty float yproperty float zproperty float nxproperty float nyproperty float nzproperty float f_dc_0property float f_dc_1property float f_dc_2property float opacityproperty float scale_0property float scale_1property float scale_2property float rot_0property float rot_1property float rot_2property float rot_3end_header<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应的数据是这样的：</p><pre class="line-numbers language-none"><code class="language-none">-0.4938425123691559 4.382840156555176 -0.4051733613014221 0.0 0.0 0.0 0.18498234450817108 1.119383692741394 0.8595899343490601 -2.0330333709716797 -3.6038339138031006 -3.884824752807617 -3.724702835083008 0.8671903610229492 0.17955081164836884 -0.04104405641555786 -0.1000492125749588<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="转换代码参考"><a href="#转换代码参考" class="headerlink" title="转换代码参考"></a>转换代码参考</h2><h3 id="Colmap二进制点云转ascii点云"><a href="#Colmap二进制点云转ascii点云" class="headerlink" title="Colmap二进制点云转ascii点云"></a>Colmap二进制点云转ascii点云</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> open3d <span class="token keyword">as</span> o3d<span class="token keyword">import</span> argparse<span class="token keyword">def</span> <span class="token function">convert_ply</span><span class="token punctuation">(</span>input_file<span class="token punctuation">,</span> output_file<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 读取二进制格式的PLY文件</span>    pcd <span class="token operator">=</span> o3d<span class="token punctuation">.</span>io<span class="token punctuation">.</span>read_point_cloud<span class="token punctuation">(</span>input_file<span class="token punctuation">)</span>    <span class="token comment"># 将PLY数据保存为文本格式的PLY文件</span>    o3d<span class="token punctuation">.</span>io<span class="token punctuation">.</span>write_point_cloud<span class="token punctuation">(</span>output_file<span class="token punctuation">,</span> pcd<span class="token punctuation">,</span> write_ascii<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    parser <span class="token operator">=</span> argparse<span class="token punctuation">.</span>ArgumentParser<span class="token punctuation">(</span>description<span class="token operator">=</span><span class="token string">'Convert binary PLY to ASCII PLY.'</span><span class="token punctuation">)</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'input_file'</span><span class="token punctuation">,</span> <span class="token builtin">type</span><span class="token operator">=</span><span class="token builtin">str</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">'Path to the input binary PLY file'</span><span class="token punctuation">)</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'output_file'</span><span class="token punctuation">,</span> <span class="token builtin">type</span><span class="token operator">=</span><span class="token builtin">str</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">'Path to the output ASCII PLY file'</span><span class="token punctuation">)</span>    args <span class="token operator">=</span> parser<span class="token punctuation">.</span>parse_args<span class="token punctuation">(</span><span class="token punctuation">)</span>    convert_ply<span class="token punctuation">(</span>args<span class="token punctuation">.</span>input_file<span class="token punctuation">,</span> args<span class="token punctuation">.</span>output_file<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Gaussian-Splatting二进制点云转ascii点云"><a href="#Gaussian-Splatting二进制点云转ascii点云" class="headerlink" title="Gaussian Splatting二进制点云转ascii点云"></a>Gaussian Splatting二进制点云转ascii点云</h3><p>对于<code>sh_degree=3</code>的情况：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> argparse<span class="token keyword">import</span> struct<span class="token keyword">def</span> <span class="token function">convert_ply</span><span class="token punctuation">(</span>input_file<span class="token punctuation">,</span> output_file<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>input_file<span class="token punctuation">,</span> <span class="token string">'rb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>        binary_data <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 找到头部结束的位置</span>    header_end <span class="token operator">=</span> binary_data<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">b'end_header\n'</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token builtin">len</span><span class="token punctuation">(</span><span class="token string">b'end_header\n'</span><span class="token punctuation">)</span>    header <span class="token operator">=</span> binary_data<span class="token punctuation">[</span><span class="token punctuation">:</span>header_end<span class="token punctuation">]</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>    body <span class="token operator">=</span> binary_data<span class="token punctuation">[</span>header_end<span class="token punctuation">:</span><span class="token punctuation">]</span>    <span class="token comment"># 生成新的 ASCII 头部</span>    ascii_header <span class="token operator">=</span> header<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'binary_little_endian'</span><span class="token punctuation">,</span> <span class="token string">'ascii'</span><span class="token punctuation">)</span>    <span class="token comment"># 写入新的 ASCII 文件</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>output_file<span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>ascii_header<span class="token punctuation">)</span>        <span class="token comment"># 解析每个顶点的数据</span>        offset <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment"># 确定每个顶点的格式和大小</span>        vertex_format <span class="token operator">=</span> <span class="token string">'&lt;3f3f3f1f45f1f3f4f'</span>  <span class="token comment"># x, y, z, nx, ny, nz, f_dc_0, f_dc_1, f_dc_2, f_rest_0 to f_rest_44, opacity, scale_0, scale_1, scale_2, rot_0, rot_1, rot_2, rot_3</span>        vertex_size <span class="token operator">=</span> struct<span class="token punctuation">.</span>calcsize<span class="token punctuation">(</span>vertex_format<span class="token punctuation">)</span>        vertex_count <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>header<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'element vertex '</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>vertex_count<span class="token punctuation">)</span><span class="token punctuation">:</span>            vertex_data <span class="token operator">=</span> struct<span class="token punctuation">.</span>unpack_from<span class="token punctuation">(</span>vertex_format<span class="token punctuation">,</span> body<span class="token punctuation">,</span> offset<span class="token punctuation">)</span>            f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">,</span> vertex_data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'\n'</span><span class="token punctuation">)</span>            offset <span class="token operator">+=</span> vertex_size<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    parser <span class="token operator">=</span> argparse<span class="token punctuation">.</span>ArgumentParser<span class="token punctuation">(</span>description<span class="token operator">=</span><span class="token string">'Convert binary PLY to ASCII PLY.'</span><span class="token punctuation">)</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'input_file'</span><span class="token punctuation">,</span> <span class="token builtin">type</span><span class="token operator">=</span><span class="token builtin">str</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">'Path to the input binary PLY file'</span><span class="token punctuation">)</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'output_file'</span><span class="token punctuation">,</span> <span class="token builtin">type</span><span class="token operator">=</span><span class="token builtin">str</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">'Path to the output ASCII PLY file'</span><span class="token punctuation">)</span>    args <span class="token operator">=</span> parser<span class="token punctuation">.</span>parse_args<span class="token punctuation">(</span><span class="token punctuation">)</span>    convert_ply<span class="token punctuation">(</span>args<span class="token punctuation">.</span>input_file<span class="token punctuation">,</span> args<span class="token punctuation">.</span>output_file<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于<code>sh_degree=0</code>的情况：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> argparse<span class="token keyword">import</span> struct<span class="token keyword">def</span> <span class="token function">convert_ply</span><span class="token punctuation">(</span>input_file<span class="token punctuation">,</span> output_file<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>input_file<span class="token punctuation">,</span> <span class="token string">'rb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>        binary_data <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 找到头部结束的位置</span>    header_end <span class="token operator">=</span> binary_data<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">b'end_header\n'</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token builtin">len</span><span class="token punctuation">(</span><span class="token string">b'end_header\n'</span><span class="token punctuation">)</span>    header <span class="token operator">=</span> binary_data<span class="token punctuation">[</span><span class="token punctuation">:</span>header_end<span class="token punctuation">]</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>    body <span class="token operator">=</span> binary_data<span class="token punctuation">[</span>header_end<span class="token punctuation">:</span><span class="token punctuation">]</span>    <span class="token comment"># 生成新的 ASCII 头部</span>    ascii_header <span class="token operator">=</span> header<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'binary_little_endian'</span><span class="token punctuation">,</span> <span class="token string">'ascii'</span><span class="token punctuation">)</span>    <span class="token comment"># 写入新的 ASCII 文件</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>output_file<span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>ascii_header<span class="token punctuation">)</span>        <span class="token comment"># 解析每个顶点的数据</span>        offset <span class="token operator">=</span> <span class="token number">0</span>        vertex_format <span class="token operator">=</span> <span class="token string">'&lt;3f3f3f1f3f4f'</span>  <span class="token comment"># x, y, z, nx, ny, nz, f_dc_0, f_dc_1, f_dc_2, opacity, scale_0, scale_1, scale_2, rot_0, rot_1, rot_2, rot_3</span>        vertex_size <span class="token operator">=</span> struct<span class="token punctuation">.</span>calcsize<span class="token punctuation">(</span>vertex_format<span class="token punctuation">)</span>        vertex_count <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>header<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'element vertex '</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>vertex_count<span class="token punctuation">)</span><span class="token punctuation">:</span>            vertex_data <span class="token operator">=</span> struct<span class="token punctuation">.</span>unpack_from<span class="token punctuation">(</span>vertex_format<span class="token punctuation">,</span> body<span class="token punctuation">,</span> offset<span class="token punctuation">)</span>            f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">,</span> vertex_data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'\n'</span><span class="token punctuation">)</span>            offset <span class="token operator">+=</span> vertex_size<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    parser <span class="token operator">=</span> argparse<span class="token punctuation">.</span>ArgumentParser<span class="token punctuation">(</span>description<span class="token operator">=</span><span class="token string">'Convert binary PLY to ASCII PLY.'</span><span class="token punctuation">)</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'input_file'</span><span class="token punctuation">,</span> <span class="token builtin">type</span><span class="token operator">=</span><span class="token builtin">str</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">'Path to the input binary PLY file'</span><span class="token punctuation">)</span>    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'output_file'</span><span class="token punctuation">,</span> <span class="token builtin">type</span><span class="token operator">=</span><span class="token builtin">str</span><span class="token punctuation">,</span> <span class="token builtin">help</span><span class="token operator">=</span><span class="token string">'Path to the output ASCII PLY file'</span><span class="token punctuation">)</span>    args <span class="token operator">=</span> parser<span class="token punctuation">.</span>parse_args<span class="token punctuation">(</span><span class="token punctuation">)</span>    convert_ply<span class="token punctuation">(</span>args<span class="token punctuation">.</span>input_file<span class="token punctuation">,</span> args<span class="token punctuation">.</span>output_file<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> NeRF&amp;3DGS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式表示 </tag>
            
            <tag> 3D Gaussian Splatting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Compact 3DGS代码阅读</title>
      <link href="2024/05/25/code-reading-compact-3dgs/"/>
      <url>2024/05/25/code-reading-compact-3dgs/</url>
      
        <content type="html"><![CDATA[<h1 id="Compact-3DGS代码阅读"><a href="#Compact-3DGS代码阅读" class="headerlink" title="Compact 3DGS代码阅读"></a>Compact 3DGS代码阅读</h1><h2 id="Gaussian-Volume-Mask"><a href="#Gaussian-Volume-Mask" class="headerlink" title="Gaussian Volume Mask"></a>Gaussian Volume Mask</h2><blockquote><p>learn-able mask，用可以学习的掩膜去mask掉冗余的部分高斯函数</p></blockquote><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><code>gaussian_model.py</code>中<code>def __init__()</code>定义了learn-able mask</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> model<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 与原始3dgs相比，下面两个参数不见了</span>    <span class="token comment"># self._features_dc</span>    <span class="token comment"># self._features_rest</span>    <span class="token comment"># 省略......</span>    self<span class="token punctuation">.</span>_mask <span class="token operator">=</span> torch<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment"># learn-able mask</span>    <span class="token comment"># 省略......</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>``gaussian_model.py<code>中</code>def create_from_pcd()`初始化了learn-able mask</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">create_from_pcd</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pcd<span class="token punctuation">:</span> BasicPointCloud<span class="token punctuation">,</span> spatial_lr_scale<span class="token punctuation">:</span> <span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 省略......</span>    <span class="token comment"># 这里的mask对应了论文中的Gaussian Volume Mask，即learn-able mask，用可以学习的掩膜去mask掉冗余的部分高斯函数</span>    self<span class="token punctuation">.</span>_mask <span class="token operator">=</span> nn<span class="token punctuation">.</span>Parameter<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span>fused_point_cloud<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> device<span class="token operator">=</span><span class="token string">"cuda"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>requires_grad_<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 省略......</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如论文3.1节最后讲的一样“Once training is completed, the mask parameter m does not need to be stored since we re moved the masked Gaussians.”``gaussian_model.py<code>中并没有保存这个mask，因此在</code>def load_model()`函数中也没有加载mask的过程。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>``gaussian_model.py`中通过Adam优化器优化learn-able mask</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">l <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span><span class="token string">'params'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>self<span class="token punctuation">.</span>_xyz<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'lr'</span><span class="token punctuation">:</span> training_args<span class="token punctuation">.</span>position_lr_init <span class="token operator">*</span> self<span class="token punctuation">.</span>spatial_lr_scale<span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"xyz"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">'params'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>self<span class="token punctuation">.</span>_opacity<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'lr'</span><span class="token punctuation">:</span> training_args<span class="token punctuation">.</span>opacity_lr<span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"opacity"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">'params'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>self<span class="token punctuation">.</span>_scaling<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'lr'</span><span class="token punctuation">:</span> training_args<span class="token punctuation">.</span>scaling_lr<span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"scaling"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">'params'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>self<span class="token punctuation">.</span>_rotation<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'lr'</span><span class="token punctuation">:</span> training_args<span class="token punctuation">.</span>rotation_lr<span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"rotation"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">'params'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>self<span class="token punctuation">.</span>_mask<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'lr'</span><span class="token punctuation">:</span> training_args<span class="token punctuation">.</span>mask_lr<span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"mask"</span><span class="token punctuation">}</span><span class="token punctuation">]</span>self<span class="token punctuation">.</span>optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>l<span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.0</span><span class="token punctuation">,</span> eps<span class="token operator">=</span><span class="token number">1e-15</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>论文中的损失函数如下，最小化这个损失函数，会尽可能多的mask掉场景中的高斯。</p><p><img src="/images/code-reading-Compact-3DGS/image-20240524204127934.png"></p><p>但是这个损失函数不是单独使用的，上面定义优化器的时候，就把mask和其它参数放到一起了，说明它会作为一个总的loss的一部分使用。这样，在给定的权重，和其他loss的共同作用下，它会像论文提的那样“We balance the accurate rendering and the number of Gaussians eliminated during training by adding masking loss”。</p><p>在论文的公式中，也体现了这一点，如下所示。</p><p><img src="/images/code-reading-Compact-3DGS/image-20240524204355835.png"></p><p>对应到代码中，是<code>train.py</code>中<code>def training()</code>函数如下的部分：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Loss</span>gt_image <span class="token operator">=</span> viewpoint_cam<span class="token punctuation">.</span>original_image<span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span>Ll1 <span class="token operator">=</span> l1_loss<span class="token punctuation">(</span>image<span class="token punctuation">,</span> gt_image<span class="token punctuation">)</span><span class="token comment"># 与3dgs相比，其实只多了一个mask相关的损失</span>loss <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">-</span> opt<span class="token punctuation">.</span>lambda_dssim<span class="token punctuation">)</span> <span class="token operator">*</span> Ll1 <span class="token operator">+</span> opt<span class="token punctuation">.</span>lambda_dssim <span class="token operator">*</span> <span class="token punctuation">(</span>        <span class="token number">1.0</span> <span class="token operator">-</span> ssim<span class="token punctuation">(</span>image<span class="token punctuation">,</span> gt_image<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> opt<span class="token punctuation">.</span>lambda_mask <span class="token operator">*</span> torch<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>sigmoid<span class="token punctuation">(</span>gaussians<span class="token punctuation">.</span>_mask<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="过滤冗余高斯"><a href="#过滤冗余高斯" class="headerlink" title="过滤冗余高斯"></a>过滤冗余高斯</h3><p>在论文中，learn-able mask的公式如下所示。论文写的比较严谨，把stop grad的操作也放到公式里了，看着似乎很复杂。</p><p>实际上，公式（1）的意思就是如果$\sigma(m_n)&gt;\epsilon$，对应的$M_n=1$，否则对应的$M_n=0$。</p><p><img src="/images/code-reading-Compact-3DGS/image-20240524205034954.png"></p><p>实际实现中有多处用到了learn-able mask，这些用法都包含在<code>gaussian_model.py</code>中。核心其实就是一行代码：<code>torch.sigmoid(self._mask) &lt;= 0.01</code>。</p><p><strong>第一处：</strong>对3D高斯模型进行致密化或者剪枝操作时使用。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 对3D高斯分布进行密集化和修剪的操作</span><span class="token keyword">def</span> <span class="token function">densify_and_prune</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> max_grad<span class="token punctuation">,</span> min_opacity<span class="token punctuation">,</span> extent<span class="token punctuation">,</span> max_screen_size<span class="token punctuation">)</span><span class="token punctuation">:</span>    grads <span class="token operator">=</span> self<span class="token punctuation">.</span>xyz_gradient_accum <span class="token operator">/</span> self<span class="token punctuation">.</span>denom    grads<span class="token punctuation">[</span>grads<span class="token punctuation">.</span>isnan<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0.0</span>    self<span class="token punctuation">.</span>densify_and_clone<span class="token punctuation">(</span>grads<span class="token punctuation">,</span> max_grad<span class="token punctuation">,</span> extent<span class="token punctuation">)</span>    self<span class="token punctuation">.</span>densify_and_split<span class="token punctuation">(</span>grads<span class="token punctuation">,</span> max_grad<span class="token punctuation">,</span> extent<span class="token punctuation">)</span>    <span class="token comment"># 与3dgs相比，这里考虑了self._mask</span>    <span class="token comment"># 对于每个3dgs，如果对应的sigmoid(mask)&lt;=0.01 或 opacity&lt;min_opacity就会被剪枝</span>    <span class="token comment"># 这部分是在no_grad下进行的，对应了论文中的公式1</span>    prune_mask <span class="token operator">=</span> torch<span class="token punctuation">.</span>logical_or<span class="token punctuation">(</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>sigmoid<span class="token punctuation">(</span>self<span class="token punctuation">.</span>_mask<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0.01</span><span class="token punctuation">)</span><span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                  <span class="token punctuation">(</span>self<span class="token punctuation">.</span>get_opacity <span class="token operator">&lt;</span> min_opacity<span class="token punctuation">)</span><span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> max_screen_size<span class="token punctuation">:</span>        big_points_vs <span class="token operator">=</span> self<span class="token punctuation">.</span>max_radii2D <span class="token operator">&gt;</span> max_screen_size        big_points_ws <span class="token operator">=</span> self<span class="token punctuation">.</span>get_scaling<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>values <span class="token operator">&gt;</span> <span class="token number">0.1</span> <span class="token operator">*</span> extent        prune_mask <span class="token operator">=</span> torch<span class="token punctuation">.</span>logical_or<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>logical_or<span class="token punctuation">(</span>prune_mask<span class="token punctuation">,</span> big_points_vs<span class="token punctuation">)</span><span class="token punctuation">,</span> big_points_ws<span class="token punctuation">)</span>    self<span class="token punctuation">.</span>prune_points<span class="token punctuation">(</span>prune_mask<span class="token punctuation">)</span>    torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>empty_cache<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应<code>train.py</code>下面的内容。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Densification</span><span class="token keyword">if</span> iteration <span class="token operator">&lt;</span> opt<span class="token punctuation">.</span>densify_until_iter<span class="token punctuation">:</span>    <span class="token comment"># Keep track of max radii in image-space for pruning</span>    gaussians<span class="token punctuation">.</span>max_radii2D<span class="token punctuation">[</span>visibility_filter<span class="token punctuation">]</span> <span class="token operator">=</span> torch<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>gaussians<span class="token punctuation">.</span>max_radii2D<span class="token punctuation">[</span>visibility_filter<span class="token punctuation">]</span><span class="token punctuation">,</span>                                                         radii<span class="token punctuation">[</span>visibility_filter<span class="token punctuation">]</span><span class="token punctuation">)</span>    gaussians<span class="token punctuation">.</span>add_densification_stats<span class="token punctuation">(</span>viewspace_point_tensor<span class="token punctuation">,</span> visibility_filter<span class="token punctuation">)</span>    <span class="token keyword">if</span> iteration <span class="token operator">&gt;</span> opt<span class="token punctuation">.</span>densify_from_iter <span class="token keyword">and</span> iteration <span class="token operator">%</span> opt<span class="token punctuation">.</span>densification_interval <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        size_threshold <span class="token operator">=</span> <span class="token number">20</span> <span class="token keyword">if</span> iteration <span class="token operator">&gt;</span> opt<span class="token punctuation">.</span>opacity_reset_interval <span class="token keyword">else</span> <span class="token boolean">None</span>        <span class="token comment"># ============= 在这里调用 =============</span>        gaussians<span class="token punctuation">.</span>densify_and_prune<span class="token punctuation">(</span>opt<span class="token punctuation">.</span>densify_grad_threshold<span class="token punctuation">,</span> <span class="token number">0.005</span><span class="token punctuation">,</span> scene<span class="token punctuation">.</span>cameras_extent<span class="token punctuation">,</span> size_threshold<span class="token punctuation">)</span>    <span class="token keyword">if</span> iteration <span class="token operator">%</span> opt<span class="token punctuation">.</span>opacity_reset_interval <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">or</span> <span class="token punctuation">(</span>            dataset<span class="token punctuation">.</span>white_background <span class="token keyword">and</span> iteration <span class="token operator">==</span> opt<span class="token punctuation">.</span>densify_from_iter<span class="token punctuation">)</span><span class="token punctuation">:</span>        gaussians<span class="token punctuation">.</span>reset_opacity<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>  <span class="token comment"># 新增内容，间隔一定次数通过可学习的mask筛选一遍高斯</span>    <span class="token keyword">if</span> iteration <span class="token operator">%</span> opt<span class="token punctuation">.</span>mask_prune_iter <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        gaussians<span class="token punctuation">.</span>mask_prune<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>第二处：</strong>如果不进行致密化或剪枝，但迭代了一定次数之后，会执行<code>def mask_prune()</code>过滤掉冗余高斯。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">mask_prune</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 这部分是在no_grad下进行的，对应了论文中的公式1</span>    prune_mask <span class="token operator">=</span> <span class="token punctuation">(</span>torch<span class="token punctuation">.</span>sigmoid<span class="token punctuation">(</span>self<span class="token punctuation">.</span>_mask<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0.01</span><span class="token punctuation">)</span><span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token punctuation">)</span>    self<span class="token punctuation">.</span>prune_points<span class="token punctuation">(</span>prune_mask<span class="token punctuation">)</span>    torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>empty_cache<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应<code>train.py</code>下面的内容。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Densification</span><span class="token keyword">if</span> iteration <span class="token operator">&lt;</span> opt<span class="token punctuation">.</span>densify_until_iter<span class="token punctuation">:</span>    <span class="token comment"># Keep track of max radii in image-space for pruning</span>    gaussians<span class="token punctuation">.</span>max_radii2D<span class="token punctuation">[</span>visibility_filter<span class="token punctuation">]</span> <span class="token operator">=</span> torch<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>gaussians<span class="token punctuation">.</span>max_radii2D<span class="token punctuation">[</span>visibility_filter<span class="token punctuation">]</span><span class="token punctuation">,</span>                                                         radii<span class="token punctuation">[</span>visibility_filter<span class="token punctuation">]</span><span class="token punctuation">)</span>    gaussians<span class="token punctuation">.</span>add_densification_stats<span class="token punctuation">(</span>viewspace_point_tensor<span class="token punctuation">,</span> visibility_filter<span class="token punctuation">)</span>    <span class="token keyword">if</span> iteration <span class="token operator">&gt;</span> opt<span class="token punctuation">.</span>densify_from_iter <span class="token keyword">and</span> iteration <span class="token operator">%</span> opt<span class="token punctuation">.</span>densification_interval <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        size_threshold <span class="token operator">=</span> <span class="token number">20</span> <span class="token keyword">if</span> iteration <span class="token operator">&gt;</span> opt<span class="token punctuation">.</span>opacity_reset_interval <span class="token keyword">else</span> <span class="token boolean">None</span>        gaussians<span class="token punctuation">.</span>densify_and_prune<span class="token punctuation">(</span>opt<span class="token punctuation">.</span>densify_grad_threshold<span class="token punctuation">,</span> <span class="token number">0.005</span><span class="token punctuation">,</span> scene<span class="token punctuation">.</span>cameras_extent<span class="token punctuation">,</span> size_threshold<span class="token punctuation">)</span>    <span class="token keyword">if</span> iteration <span class="token operator">%</span> opt<span class="token punctuation">.</span>opacity_reset_interval <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">or</span> <span class="token punctuation">(</span>            dataset<span class="token punctuation">.</span>white_background <span class="token keyword">and</span> iteration <span class="token operator">==</span> opt<span class="token punctuation">.</span>densify_from_iter<span class="token punctuation">)</span><span class="token punctuation">:</span>        gaussians<span class="token punctuation">.</span>reset_opacity<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>  <span class="token comment"># 新增内容，间隔一定次数通过可学习的mask筛选一遍高斯</span>    <span class="token keyword">if</span> iteration <span class="token operator">%</span> opt<span class="token punctuation">.</span>mask_prune_iter <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token comment"># ============= 在这里调用 =============</span>        gaussians<span class="token punctuation">.</span>mask_prune<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>第三处：</strong>最终训练结束，准备导出3D高斯模型的时候使用。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">final_prune</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> compress<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 这部分是在no_grad下进行的，对应了论文中的公式1</span>    prune_mask <span class="token operator">=</span> <span class="token punctuation">(</span>torch<span class="token punctuation">.</span>sigmoid<span class="token punctuation">(</span>self<span class="token punctuation">.</span>_mask<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0.01</span><span class="token punctuation">)</span><span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token punctuation">)</span>    self<span class="token punctuation">.</span>prune_points<span class="token punctuation">(</span>prune_mask<span class="token punctuation">)</span>    <span class="token comment"># 省略。。。。。。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应<code>train.py</code>下面的内容。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> iteration <span class="token operator">==</span> opt<span class="token punctuation">.</span>iterations<span class="token punctuation">:</span>    <span class="token comment"># 完成迭代之后保存结果，保存的结果要进行一次最终的剪枝</span>    storage <span class="token operator">=</span> gaussians<span class="token punctuation">.</span>final_prune<span class="token punctuation">(</span>compress<span class="token operator">=</span>comp<span class="token punctuation">)</span>    <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>args<span class="token punctuation">.</span>model_path<span class="token punctuation">,</span> <span class="token string">"storage"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> c<span class="token punctuation">:</span>        c<span class="token punctuation">.</span>write<span class="token punctuation">(</span>storage<span class="token punctuation">)</span>    <span class="token comment"># TODO 这里在做什么？</span>    gaussians<span class="token punctuation">.</span>precompute<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Geometry-Codebook"><a href="#Geometry-Codebook" class="headerlink" title="Geometry Codebook"></a>Geometry Codebook</h2><blockquote><p>应用了R-VQ来归并那些形状、旋转很相似的高斯</p></blockquote><h3 id="定义-amp-初始化"><a href="#定义-amp-初始化" class="headerlink" title="定义&amp;初始化"></a>定义&amp;初始化</h3><p><code>gaussian_model.py</code>中<code>def __init__()</code>定义了R-VQ</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># ====================== 新增内容 ======================</span><span class="token comment"># 对应论文中的Geometry Codebook</span><span class="token comment"># 应用R-VQ来归并那些尺度scale、旋转rot很相似的高斯，下面这个RVQ甚至还是现成的</span><span class="token comment"># 只看这个文件，RVQ似乎只对最后导出npz或ply的时候有用，过程中似乎没有办法降低高斯的内存占用？？？毕竟尺度和旋转这两个向量还在这里放着？？？</span><span class="token comment"># TODO：可以用相同的数据集，对比一下3dgs和compact 3dgs内存的占用情况！</span><span class="token comment"># 初始化一个用于ResidualVQ（矢量量化）对象，并设置特定的超参数。</span>self<span class="token punctuation">.</span>vq_scale <span class="token operator">=</span> ResidualVQ<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>  <span class="token comment"># 量化器输入的维度</span>                           codebook_size<span class="token operator">=</span>model<span class="token punctuation">.</span>rvq_size<span class="token punctuation">,</span>  <span class="token comment"># codebook的大小，从模型的 rvq_size 中获取</span>                           num_quantizers<span class="token operator">=</span>model<span class="token punctuation">.</span>rvq_num<span class="token punctuation">,</span>  <span class="token comment"># 量化器的数量，从模型的 rvq_num 中获取</span>                           commitment_weight<span class="token operator">=</span><span class="token number">0.</span><span class="token punctuation">,</span>  <span class="token comment"># 承诺损失的权重</span>                           kmeans_init<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>  <span class="token comment"># 布尔值，指示是否使用 k-means 初始化</span>                           kmeans_iters<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>  <span class="token comment"># 初始化的迭代次数</span>                           ema_update<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>  <span class="token comment"># 是否使用指数移动平均更新</span>                           learnable_codebook<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>  <span class="token comment"># 布尔值，指示coodbook是否可学习</span>                           in_place_codebook_optimizer<span class="token operator">=</span><span class="token keyword">lambda</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">:</span>  <span class="token comment"># 创建学习率为 0.0001 的 Adam 优化器</span>                           torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.0001</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 移动到 GPU 上</span>self<span class="token punctuation">.</span>vq_rot <span class="token operator">=</span> ResidualVQ<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span>                         codebook_size<span class="token operator">=</span>model<span class="token punctuation">.</span>rvq_size<span class="token punctuation">,</span>                         num_quantizers<span class="token operator">=</span>model<span class="token punctuation">.</span>rvq_num<span class="token punctuation">,</span>                         commitment_weight<span class="token operator">=</span><span class="token number">0.</span><span class="token punctuation">,</span>                         kmeans_init<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>                         kmeans_iters<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>                         ema_update<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>                         learnable_codebook<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>                         in_place_codebook_optimizer<span class="token operator">=</span><span class="token keyword">lambda</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">:</span>                         torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">,</span> lr<span class="token operator">=</span><span class="token number">0.0001</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 通过取codebook大小的以2为底的对数，计算表示码书索引所需的比特数。这个参数只用在计算内存大小上了。</span>self<span class="token punctuation">.</span>rvq_bit <span class="token operator">=</span> math<span class="token punctuation">.</span>log2<span class="token punctuation">(</span>model<span class="token punctuation">.</span>rvq_size<span class="token punctuation">)</span><span class="token comment"># 存储模型中的量化器数量，以备后用。这个参数也是只用在计算内存大小上了。</span>self<span class="token punctuation">.</span>rvq_num <span class="token operator">=</span> model<span class="token punctuation">.</span>rvq_num<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="关于ResidualVQ"><a href="#关于ResidualVQ" class="headerlink" title="关于ResidualVQ"></a>关于ResidualVQ</h3><p>这部分实现对应的仓库为：<a href="https://github.com/lucidrains/vector-quantize-pytorch">https://github.com/lucidrains/vector-quantize-pytorch</a></p><p>更详细的用法也可以参考这个仓库。</p><p><img src="/images/code-reading-Compact-3DGS/vq.png"></p><h3 id="优化更新？"><a href="#优化更新？" class="headerlink" title="优化更新？"></a>优化更新？</h3><p>很奇怪，我查找了文件，但是没有找到更新的地方。可能还得去上面的仓库里面学习一下。。。</p><p><img src="/images/code-reading-Compact-3DGS/image-20240524215047795.png"></p><p>我猜测，每次使用RVQ，它就会迭代更新一次，毕竟初始化的时候就给定了优化器。而且看起来，每次渲染的时候才有可能会进行一次更新。</p><p>这样的话，我还是感觉RVQ的作用只是保存结果的时候，让存储空间的占用更小，训练过程中没办法让显存占用变小？？？</p><h3 id="归并形状、旋转相似的高斯？"><a href="#归并形状、旋转相似的高斯？" class="headerlink" title="归并形状、旋转相似的高斯？"></a>归并形状、旋转相似的高斯？</h3><p>似乎只有渲染、最终保存的时候，会进行。</p><h2 id="Compact-View-dependent-Color"><a href="#Compact-View-dependent-Color" class="headerlink" title="Compact View-dependent Color"></a>Compact View-dependent Color</h2><blockquote><p>不使用3DGS的球谐去表示视图相关的颜色了，而是用了类似instant-ngp的方法去表示视图相关的颜色</p></blockquote><p>略，暂时没去看~</p>]]></content>
      
      
      <categories>
          
          <category> NeRF&amp;3DGS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式表示 </tag>
            
            <tag> 3D Gaussian Splatting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读《Compact 3D Gaussian Representation for Radiance Field》</title>
      <link href="2024/05/21/paper-reading-compact-3dgs/"/>
      <url>2024/05/21/paper-reading-compact-3dgs/</url>
      
        <content type="html"><![CDATA[<h1 id="论文阅读《Compact-3D-Gaussian-Representation-for-Radiance-Field》"><a href="#论文阅读《Compact-3D-Gaussian-Representation-for-Radiance-Field》" class="headerlink" title="论文阅读《Compact 3D Gaussian Representation for Radiance Field》"></a>论文阅读《Compact 3D Gaussian Representation for Radiance Field》</h1><p>问题：3DGS需要大量的3D高斯来保持渲染图像的高保真度，这需要大量的内存和存储空间。</p><p>解决方案：</p><ul><li>为了解决3DGS中关键的大内存和存储问题，我们提出了一个紧凑的3D高斯表示框架。该方法显著提高了内存和存储效率，同时具有高质量的重构、快速的训练速度和实时的渲染效果，如图1所示。我们特别强调两个关键目标。首先，我们的目标是在不牺牲性能的情况下减少场景表示所需的高斯点数量。高斯函数的数量随着由克隆和分裂高斯函数组成的规则致密化过程的增加而增加，它是表示场景精细细节的关键组成部分。然而，我们观察到，目前的致密化算法产生了许多冗余和不必要的高斯分布，导致内存和存储需求高。<strong>我们引入了一种新的基于体积的掩蔽策略，该策略可以识别和去除对整体性能影响最小的非必要高斯值。</strong>利用所提出的掩蔽方法，我们学会了在训练过程中减少高斯数的同时获得高性能。除了有效的内存和存储使用，我们可以实现更快的渲染速度，因为计算复杂度与高斯数成线性比例。</li><li>其次，<strong>我们提出压缩高斯属性，如视图相关的颜色和协方差。</strong>在原始的3DGS中，每个高斯函数都有自己的属性，并且没有利用空间冗余，这在各种类型的信号压缩中得到了广泛的应用。例如，相邻的高斯函数可能具有相似的颜色属性，我们可以重用相邻高斯函数的相似颜色。考虑到这个动机，我们结合了一个基于网格的神经场来有效地表示与视图相关的颜色，而不是使用每个高斯颜色属性。当提供查询高斯点时，我们从紧凑的网格表示中提取颜色属性，避免了为每个高斯单独存储颜色属性的需要。对于我们最初的方法，由于其紧凑性和快速的处理速度，我们从几个候选中选择了基于哈希的网格表示(Instant NGP[30])。这种选择大大降低了3DGS的空间复杂性。</li><li>与颜色属性相反，大多数高斯函数具有相似的几何形状，在尺度和旋转属性上具有有限的变化。3DGS代表了一个由无数小高斯元集合而成的场景，每个高斯原语都不期望表现出很高的多样性。<strong>因此，我们引入了一种基于码本的方法来建模高斯函数的几何形状。</strong>它学习寻找在每个场景中共享的相似模式或几何形状，并且只存储每个高斯的码本索引，从而产生非常紧凑的表示。此外，由于码本的大小可能非常小，因此训练期间的空间和计算开销并不显著。</li></ul><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>建立在3DGS的基础上，Each Gaussian represents 3D position, opacity, geometry (3D scale and 3D rotation represented as a quaternion), and spherical harmonics (SH) for view-dependent color.</p><blockquote><p>看起来就是经典的3DGS</p></blockquote><h3 id="Overall-architecture"><a href="#Overall-architecture" class="headerlink" title="Overall architecture"></a>Overall architecture</h3><p>我们的主要目标是1)减少高斯函数的数量，2)在保持原始性能的同时紧凑地表示属性。为此，在优化过程中，我们屏蔽掉对性能影响最小的高斯函数，并通过码本表示几何属性，如图2所示。我们使用基于网格的神经场来表示颜色属性，而不是在每个高斯分布中直接存储它们。对于几何属性，如尺度和旋转，我们建议使用基于码本的方法，可以充分利用这些属性的有限变化。最后，在随后的渲染步骤中使用少量具有紧凑属性的高斯函数，包括投影和栅格化来渲染图像。</p><p><img src="/images/paper-reading-Compact-3DGS/image-20240514154353045.png"></p><h3 id="Gaussian-Volume-Mask"><a href="#Gaussian-Volume-Mask" class="headerlink" title="Gaussian Volume Mask"></a>Gaussian Volume Mask</h3><p>The scale attribute of each Gaussian determines its 3D volume, which is then reflected in the rendering process. <strong>Small-sized Gaussians, due to their minimal volume, have a negligible contribution to the overall rendering quality, often to the point where their effect is essentially imperceptible.</strong> In such cases, it becomes highly beneficial to identify and remove such unessential Gaussians.</p><blockquote><p>这里认为小尺寸的高斯，因为体积很小，对渲染的贡献可以忽略不计，可以识别和去除他们。</p></blockquote><p>这里就提出了一个用来处理尺度、透明度的learn-able mask，学习的向量是$m_n$，最终的mask是$M_n$，如下公式所示：</p><p><img src="/images/paper-reading-Compact-3DGS/image-20240514160440341.png"></p><p>通过添加掩蔽损失Lm来平衡准确渲染和训练过程中消除的高斯数：</p><p><img src="/images/paper-reading-Compact-3DGS/image-20240514160648730.png"></p><blockquote><p>与Compact GSSLAM相同的疑问：为什么要使用这个损失函数？</p><p>看这个损失函数的意思，它想要mask掉所有东西啊，这样肯定有问题吧？？？</p><p>感觉，这个L_m不是单独使用的，给个权重，放到一个大的loss function里。</p></blockquote><p>在每一次致密化中，我们根据二值掩模消除高斯分布。此外，与原始3DGS在训练中间停止致密化并保留高斯数直至结束不同，我们在整个训练过程中始终保持掩码，有效地减少了不必要的高斯数，并确保在整个训练阶段使用低GPU内存进行高效计算(图3)。一旦训练完成，由于我们删除了掩码高斯数，因此不需要存储掩码参数m。</p><h3 id="Geometry-Codebook"><a href="#Geometry-Codebook" class="headerlink" title="Geometry Codebook"></a>Geometry Codebook</h3><blockquote><p><strong>参考资料：</strong></p><p>关于VQ</p><ul><li><a href="https://zhuanlan.zhihu.com/p/603387650">https://zhuanlan.zhihu.com/p/603387650</a></li></ul><p>关于VAE</p><ul><li><a href="https://zhuanlan.zhihu.com/p/34998569">https://zhuanlan.zhihu.com/p/34998569</a></li></ul><p>关于VQ-VAE</p><ul><li><a href="https://zhuanlan.zhihu.com/p/388299884">https://zhuanlan.zhihu.com/p/388299884</a></li></ul><p>R-VQ</p><ul><li><a href="https://zhuanlan.zhihu.com/p/688229464">https://zhuanlan.zhihu.com/p/688229464</a></li><li><a href="https://zhuanlan.zhihu.com/p/676754766">https://zhuanlan.zhihu.com/p/676754766</a></li><li><a href="https://www.assemblyai.com/blog/what-is-residual-vector-quantization/">https://www.assemblyai.com/blog/what-is-residual-vector-quantization/</a></li><li><a href="https://drscotthawley.github.io/blog/posts/2023-06-12-RVQ.html">https://drscotthawley.github.io/blog/posts/2023-06-12-RVQ.html</a></li></ul></blockquote><p>论文说他们观察到，大多数高斯的几何形状是非常相似的，显示只有微小的差异在规模和旋转特性。此外，一个场景是由许多小高斯组成的，并且每个高斯原语都不期望表现出广泛的多样性。因此他们想到了使用R-VQ：</p><p><img src="/images/paper-reading-Compact-3DGS/image-20240514213043223.png"></p><p><img src="/images/paper-reading-Compact-3DGS/image-20240514202806984.png"></p><blockquote><p>我找到一个算法框图，写的很简单很清楚：</p><p><img src="/images/paper-reading-Compact-3DGS/soundstream_alg1.png"></p></blockquote><p>这个codebook也是需要训练的，对应的损失函数如下：</p><p><img src="/images/paper-reading-Compact-3DGS/image-20240514210618885.png"></p><blockquote><p>如果考虑论文里面提到的公式4、5，主要是公式5，这个损失函数还挺好理解的，就是希望每一个阶段的残差和对应的codebook的欧氏距离最小。</p></blockquote><h3 id="Compact-View-dependent-Color"><a href="#Compact-View-dependent-Color" class="headerlink" title="Compact View-dependent Color"></a>Compact View-dependent Color</h3><p>这里说3DGS的每个高斯总共有59个参数，其中48个用来表示SH（max 3 degrees）。论文认为用基于网格的神经辐射场方法表示每个高斯视图相关的颜色会比较好：</p><p><img src="/images/paper-reading-Compact-3DGS/image-20240514213832546.png"></p><h3 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h3><p><img src="/images/paper-reading-Compact-3DGS/image-20240514215106098.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章应该算看懂了。他就做了三个东西：<br>1、【Gaussian Volume Mask】，就是learn-able mask，用可以学习的掩膜去mask掉冗余的部分高斯函数<br>2、【Geometry Codebook】，就是应用了R-VQ来归并那些形状、旋转很相似的高斯<br>3、【Compact View-dependent Color】，就是不使用3DGS的球谐去表示视图相关的颜色了，而是用了类似instant-ngp的方法去表示视图相关的颜色</p>]]></content>
      
      
      <categories>
          
          <category> NeRF&amp;3DGS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式表示 </tag>
            
            <tag> 3D Gaussian Splatting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读《Efficient Dense RGB-D SLAM in a Consistent Uncertainty-aware 3D Gaussian Field》</title>
      <link href="2024/05/19/paper-reading-cg-slam/"/>
      <url>2024/05/19/paper-reading-cg-slam/</url>
      
        <content type="html"><![CDATA[<p><strong>项目主页：</strong><a href="https://zju3dv.github.io/cg-slam/">https://zju3dv.github.io/cg-slam/</a></p><h1 id="论文阅读《Efficient-Dense-RGB-D-SLAM-in-a-Consistent-Uncertainty-aware-3D-Gaussian-Field》"><a href="#论文阅读《Efficient-Dense-RGB-D-SLAM-in-a-Consistent-Uncertainty-aware-3D-Gaussian-Field》" class="headerlink" title="论文阅读《Efficient Dense RGB-D SLAM in a Consistent Uncertainty-aware 3D Gaussian Field》"></a>论文阅读《Efficient Dense RGB-D SLAM in a Consistent Uncertainty-aware 3D Gaussian Field》</h1><p>本文介绍了一种基于高一致性和几何稳定性的新型三维高斯场的实时高斯溅射SLAM系统，即CG-SLAM。为此，我们首先对EWA(椭圆加权平均)溅射过程中相机姿态的导数进行了全面的数学分析[60]，并为SLAM任务开发了一个专门的CUDA框架，有效地解耦了跟踪和映射组件。其次，为了减少固有的过拟合问题，我们提出了一个尺度正则化项，适当地鼓励高斯椭球近似高斯球体，以减少各向异性，并在跟踪精度和渲染真实感之间实现良好的权衡。同时，我们观察到单独使用alpha混合深度不能对高斯基元的位置施加有效的约束。因此，为了实现高质量的映射，我们进一步对齐中值深度和alpha混合深度，以鼓励高斯原语在场景表面上很好地分布，从而促进具有更集中几何密度的一致高斯场。此外，为了进一步提高系统的精度和效率，我们设计了一种新的深度不确定性模型，以指导我们基于高斯的SLAM关注那些稳定且信息丰富的深度不确定性。我们在各种RGB-D数据集上对我们的系统进行了评估，实验结果表明我们的CG-SLAM在跟踪精度、重建质量和运行效率方面具有优越的性能。</p><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p><img src="/images/paper-reading-CG-SLAM/image-20240513111128366.png"></p><h3 id="Preliminary"><a href="#Preliminary" class="headerlink" title="Preliminary"></a>Preliminary</h3><p>基本都是3DGS的内容</p><p>3DGS中3D投影到2D用的是02年的一篇文章，EWA splatting，本文分析了这个EWA splatting，推导了位姿的导数。</p><h3 id="Uncertainty-Modeling"><a href="#Uncertainty-Modeling" class="headerlink" title="Uncertainty Modeling"></a>Uncertainty Modeling</h3><p>参考UncLe-SLAM实现了Uncertainty Modeling</p><blockquote><p>Sandström, E., Ta, K., Van Gool, L., Oswald, M.R.: Uncle-slam: Uncertainty learning for dense neural slam. arXiv preprint arXiv:2306.11048 (2023)</p></blockquote><p>这部分看起来就是希望不确定性尽量小，然后对深度影响最大的高斯尽可能的居中。</p><h3 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h3><p>稀松平常的内容</p><h3 id="Tracking"><a href="#Tracking" class="headerlink" title="Tracking"></a>Tracking</h3><p>稀松平常的内容</p><p>提到了一个Sliding Bundle Adjustment，希望通过这个减小累积误差。</p><p>这里的sliding window没有用基于视锥的方法，而是用NetVLAD预训练模型去处理。</p><p><strong>疑惑：</strong></p><p>这里tracking的内容写的好少，不知道这个导数什么的是怎么弄的啊。。。补充材料没有找到居然。。。</p><p>又去找了一下，没找到，那只能等了。。。这篇文章虽然是章国峰组的，但是其实也没看到很突出的地方。。。</p>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式表示 </tag>
            
            <tag> 3D Gaussian Splatting </tag>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读《Compact 3D Gaussian Splatting For Dense Visual SLAM》</title>
      <link href="2024/05/14/paper-reading-compact-gsslam/"/>
      <url>2024/05/14/paper-reading-compact-gsslam/</url>
      
        <content type="html"><![CDATA[<h1 id="论文阅读《Compact-3D-Gaussian-Splatting-For-Dense-Visual-SLAM》"><a href="#论文阅读《Compact-3D-Gaussian-Splatting-For-Dense-Visual-SLAM》" class="headerlink" title="论文阅读《Compact 3D Gaussian Splatting For Dense Visual SLAM》"></a>论文阅读《Compact 3D Gaussian Splatting For Dense Visual SLAM》</h1><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>论文提到最近的3DGS SLAM都是建立在大量冗余3D高斯椭球上的，导致了高内存占用和存储成本，以及很慢的训练速度。</p><p>为了解决这个问题，他们提出了一种紧凑的3D高斯飞溅SLAM系统，该系统减少了高斯椭球的数量和参数大小。</p><h2 id="Contributions"><a href="#Contributions" class="headerlink" title="Contributions"></a>Contributions</h2><ul><li>我们提出了一种新的基于GS的SLAM系统，该系统具有<strong>紧凑的高斯场景表示</strong>，实现了快速的训练和渲染速度、准确的姿态估计，并显著提高了存储效率。</li><li>提出了一种新的<strong>基于滑动窗口的在线掩蔽方法</strong>，以消除冗余高斯椭球的数量，同时在训练过程中实现高保真度。</li><li>我们<strong>观察并分析了三维高斯椭球的几何相似性</strong>，并提出了一种基于码本的方法来有效地恢复SLAM系统运行过程中每个高斯点的几何。针对摄像机跟踪性能相对较低的问题，提出了一种基于关键帧的全局BA方法，该方法具有重投影损失。</li><li>我们在不同的数据集上进行了全面的实验，渲染速度提高了近176%，内存使用压缩率超过1.97倍。</li></ul><h2 id="System-Pipeline"><a href="#System-Pipeline" class="headerlink" title="System Pipeline"></a>System Pipeline</h2><p><img src="/images/paper-reading-Compact-GSSLAM/image-20240506113119541.png"></p><blockquote><p>乍一看，有点像是SplaTAM的图呢，会不会是在SplaTAM的基础上改进来的？</p></blockquote><h2 id="讨论分析"><a href="#讨论分析" class="headerlink" title="讨论分析"></a>讨论分析</h2><p>看了一下论文写的一些内容，我都不是很理解：</p><p><strong>3.2 Sliding Window-based Mask部分</strong></p><ul><li><p>3.2 Sliding Window-based Mask部分stop gradient operator sg(·)输出的结果是什么？</p><p>根据下面的信息解释这个公式：<br>We introduce a learnable mask parameter $m \in R^N$ and a corresponding binary mask $M \in {0, 1}^N$​, N is the number of Gaussian ellipsoids.<br>$$<br>M_n = sg (\mathbb{I}[Sig(m_n) &gt; \epsilon] - Sig(m_n)) + Sig(m_n)<br>$$<br>where $n$ is the index of the Gaussian ellipsoids, $\epsilon$ denotes the mask threshold. Inspired by [1], we employ the stop gradient operator $sg(·) $to calculate gradients from binary masks. $\mathbb{I}$ and $Sig(·)$ denote the indicator and sigmoid function. This formulation of mask strategy allows us to effectively combine the influence of volume and opacity of Gaussian ellipsoids.</p><p>根据GPT的解释，结论：</p><p>sg()就是停止梯度计算，相当于with_no_grad()。</p><p>这里就是计算一个1-sig+sig=1，或者计算一个0-sig+sig=0</p><p>因为这里不连续所以不计算梯度。</p></li><li><p>3.2 Sliding Window-based Mask部分为什么使用这样的损失函数？</p><p>追问：为什么使用如下的损失函数</p><p>We formulate the loss function $L_m$ of our mask:<br>$$<br>L_m = \frac{1}{N} \sum_{n=1}^{N}Sig(m_n)<br>$$<br>这个损失函数真的非常奇怪，确定不是1-Sig吗？</p><p>这个目的是让所有的mask都变成0啊？？？</p></li></ul><p><strong>3.3 Geometry Codebook</strong></p><ul><li><p>3.3 Geometry Codebook这部分的公式也不是太看得懂，没理解codebook的作用，这里也没有详细介绍。</p><blockquote><p>后续看《Compact 3D Gaussian Representation for Radiance Field》，看明白了。。。</p></blockquote></li></ul><p><strong>评价：</strong></p><p>这篇论文主要是压缩3DGS的大小，<strong>做了两方面的工作，一个是基于可学习的mask和视锥体来过滤高斯，一个是通过codebook压缩相似的高斯。</strong></p><p>其他方面倒是没感觉特别突出，对于Global BA部分，它说维护的关键帧数量比其他GS SLAM大得多，个人觉得这不是优点。比如RGBD GS-ICP SLAM就提到了，关键帧数量越多越容易导致误差累积的问题。</p>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式表示 </tag>
            
            <tag> 3D Gaussian Splatting </tag>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读《RGBD GS-ICP SLAM》</title>
      <link href="2024/05/02/paper-reading-rgbd-gs-icp-slam/"/>
      <url>2024/05/02/paper-reading-rgbd-gs-icp-slam/</url>
      
        <content type="html"><![CDATA[<h1 id="论文阅读《RGBD-GS-ICP-SLAM》"><a href="#论文阅读《RGBD-GS-ICP-SLAM》" class="headerlink" title="论文阅读《RGBD GS-ICP SLAM》"></a>论文阅读《RGBD GS-ICP SLAM》</h1><blockquote><p>从这篇论文的Fig. 1其实可以看出来，Gaussian Splatting SLAM虽然FPS较低，但是PSNR还是很高的。</p></blockquote><h2 id="关键问题"><a href="#关键问题" class="headerlink" title="关键问题"></a>关键问题</h2><ul><li><p>尽管基于3dgs的SLAM方法利用了高速渲染的优势，但它们未能解决根本问题:<strong>无法直接利用3D显式表示和通过2D图像渲染间接跟踪3D空间。</strong></p><blockquote><p>Although 3DGS-based SLAM methods take advantages of the high-speed rendering, they fail to address the fundamental issue: the inability to directly utilize 3D explicit representations and the indirect tracking of 3D space through 2D image rendering.</p></blockquote></li><li><p>尽管解耦方法通过分离映射和跟踪过程在跟踪方面表现出更好的性能，但它们<strong>需要额外的计算资源用于独立阶段。此外，这些方法需要在三维空间中存储特征，与三维GS地图无关。</strong></p><blockquote><p>Although decoupled methods exhibit better performances in tracking by separating mapping and tracking processes, they require additional computational resources for the independent stages. Moreover, these methods need to store features in 3D space, unrelated to the 3D GS map.</p></blockquote></li><li><p>==<strong>G-ICP的方法允许Gaussian这样的表示方法直接用于跟踪。</strong>==</p><blockquote><p>There exists a method that allows Gaussian, an explicit representation, to be directly used for tracking. The well-known Generalized Iterative Closest Point (G-ICP) [17,33] from the 3D scan matching family is simple yet efficient for fast tracking of 3D point clouds. During preprocessing, it only requires computing Gaussians for the current frame and the map. Given that the map in 3DGS utilizes Gaussians as an explicit representation in 3D space, using G-ICP for tracking allows for the direct utilization of the 3DGS map without the need for post-processing. Furthermore, the Gaussians of the current frame computed during tracking with G-ICP can also be directly utilized as an explicit representation in the 3DGS map, without additional computations.</p></blockquote></li></ul><h2 id="Contributions"><a href="#Contributions" class="headerlink" title="Contributions"></a>Contributions</h2><ul><li>结合G-ICP和3DGS的SLAM系统</li><li>通过使用G-ICP进行跟踪，积极利用3D信息，减少了跟踪需要的时间</li><li>通过尺度对齐技术共享了G-ICP和3DGS的协方差，降低了计算成本，并且促进了3DGS的快速收敛。</li></ul><h2 id="System-Overview"><a href="#System-Overview" class="headerlink" title="System Overview"></a>System Overview</h2><p><img src="/images/paper-reading-RGBD-GS-ICP-SLAM/image-20240504162019382.png"></p><blockquote><p>不是很理解下面这段话，我觉得GS中3D点的数量应该是有必要调整的，我在运行这篇工作源码的时候，其实能发现点的分布不是很均匀，帧多的地方点也多。。。</p><p><img src="/images/paper-reading-RGBD-GS-ICP-SLAM/image-20240505112159783.png"></p><p>不过论文后面又说，只有和现在地图不重叠的高斯函数才能被认定是目标高斯函数，从这里看就很合理。但是代码跑的结果确实存在不均匀的地方，还是再好好看看吧。</p></blockquote><h3 id="G-ICP-Tracking"><a href="#G-ICP-Tracking" class="headerlink" title="G-ICP Tracking"></a>G-ICP Tracking</h3><h4 id="Scale-Regularization"><a href="#Scale-Regularization" class="headerlink" title="Scale Regularization"></a>Scale Regularization</h4><blockquote><p>为什么有这个步骤？RGB-D输入的尺度不应该就是固定的吗？</p><p>这里说的尺度应该指的是高斯的大小。</p></blockquote><p>这里貌似是说原始的G-ICP算法是把高斯平面化了的，把每个高斯分布视为类平面的分布。</p><p>然后本文在正则化的同时保留目标高斯函数的原始特征，做了一个椭圆正则化。</p><h4 id="Keyframe-Selection"><a href="#Keyframe-Selection" class="headerlink" title="Keyframe Selection"></a>Keyframe Selection</h4><p>参考了ORB-SLAM和Vins-Mono实现了动态的关键帧选择方法。</p><p>不过这里说分成了tracking keyframe和mapping keyframe。</p><h3 id="GS-Mapping"><a href="#GS-Mapping" class="headerlink" title="GS Mapping"></a>GS Mapping</h3><h4 id="Scale-Aligning"><a href="#Scale-Aligning" class="headerlink" title="Scale Aligning"></a>Scale Aligning</h4><p>这里提到了传感器和场景的距离不同，就算是拿到了深度图，点云的间距也是不一样的，稀疏程度不同。这种情况会导致K近邻计算的协方差尺度也变大。因此论文做了一个尺度归一化的处理。</p><h4 id="Additional-Keyframe-Selection-for-Mapping"><a href="#Additional-Keyframe-Selection-for-Mapping" class="headerlink" title="Additional Keyframe Selection for Mapping"></a>Additional Keyframe Selection for Mapping</h4><p>提到了跟踪期间增加关键帧数量容易导致累积误差。为了缓解这个问题，就实现了这个方法，添加mapping only keyframe。tracking继续从现有跟踪过程中的选定关键帧进行，而mapping利用原始关键帧和附加的仅映射关键帧。</p><blockquote><p>新的问题，tracking keyframe的作用是什么？？？或者说以往SLAM的关键帧的作用是什么？？？</p><p>忘了。。。</p></blockquote><p><img src="/images/paper-reading-RGBD-GS-ICP-SLAM/image-20240505122210749.png"></p><h4 id="Avoiding-Local-Minima-while-Mapping"><a href="#Avoiding-Local-Minima-while-Mapping" class="headerlink" title="Avoiding Local Minima while Mapping"></a>Avoiding Local Minima while Mapping</h4><p>这里提到了我也很认同的一个点，GS SLAM是实时运行的，通常是缺乏对场景的充分观察的。这种情况容易导致局部最优。</p><p>不过本文的解决方案比较简单，就是每次迭代训练从关键帧中随机选一个进行学习。。。</p><blockquote><p>我觉得GS SLAM也存在稀疏视角重建的问题，这里可以好好探究一下怎么解决。</p></blockquote><h2 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h2><p><img src="/images/paper-reading-RGBD-GS-ICP-SLAM/image-20240505122956821.png"></p><p>从这里倒是可以看出，本文的方法在SSIM上不是很好，Point-SLAM和GS-SLAM在这部分表现是非常好的。</p><p><img src="/images/paper-reading-RGBD-GS-ICP-SLAM/image-20240505123102119.png"></p><p>从这里，我有一个推测，因为TUM-RGBD的数据是存在噪声和运动模糊的，所以<strong>本文的方法在存在噪声和运动模糊的情况下，表现不好！！！</strong></p><blockquote><p>这里论文作者狡辩了一下，说“TUM数据集是用老式传感器捕获的，这会导致深度图像中的噪声和大量信息丢失。SplaTAM仅在深度损失明显的区域添加新的高斯函数来处理这些因素，而我们的方法利用了深度图像中的所有结构信息，专注于准确跟踪和快速系统，而不是处理这些因素。”</p></blockquote><p>最后论文总结了一下自己的局限性：该方法仅依赖于三维结构的深度，实现了快速的系统速度。然而，在现实环境中，由于RGB-D传感器固有的深度噪声，重建地图的质量受到限制。由于系统速度已经非常快，因此可以预期，在嘈杂的现实环境中，通过牺牲一点速度来补偿具有相对鲁棒RGB信息的嘈杂深度图像，可以实现稳健的性能。</p>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式表示 </tag>
            
            <tag> 3D Gaussian Splatting </tag>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读《MIPS-Fusion Multi-Implicit-Submaps for Scalable and Robust Online Neural RGB-D 》</title>
      <link href="2024/04/10/paper-reading-mips-fusion/"/>
      <url>2024/04/10/paper-reading-mips-fusion/</url>
      
        <content type="html"><![CDATA[<h1 id="论文阅读《MIPS-Fusion-Multi-Implicit-Submaps-for-Scalable-and-Robust-Online-Neural-RGB-D-》Reconstruction"><a href="#论文阅读《MIPS-Fusion-Multi-Implicit-Submaps-for-Scalable-and-Robust-Online-Neural-RGB-D-》Reconstruction" class="headerlink" title="论文阅读《MIPS-Fusion: Multi-Implicit-Submaps for Scalable and Robust Online Neural RGB-D 》Reconstruction"></a>论文阅读《MIPS-Fusion: Multi-Implicit-Submaps for Scalable and Robust Online Neural RGB-D 》Reconstruction</h1><h3 id="System-Pipeline"><a href="#System-Pipeline" class="headerlink" title="System Pipeline"></a>System Pipeline</h3><img src="/images/paper-reading-MIPS-Fusion/image-20240410131638745.png" style="zoom: 80%;"><h3 id="Multi-Implicit-Submap-Representation"><a href="#Multi-Implicit-Submap-Representation" class="headerlink" title="Multi-Implicit-Submap Representation"></a>Multi-Implicit-Submap Representation</h3><p>对于每一个子地图，表示为：TSDF（MLP分类器）、radiance filed（MLP场景表示or解码器）、第一个关键帧在全局地图中的姿态、关联的关键帧集合、axis-aligned长方体体素。</p><p><strong>这里提到一个观点：</strong>构建子地图比较灵活，每一个子地图都可以作为一个整体进行转换。同时，由于子地图局部坐标分布导致low data bias，这样更容易学习。</p><p><strong>Classification-based neural TSDF</strong></p><p>区域内不重叠的点就直接查询MLP分类器拿到TSDF值了，而对于重叠部分的点，会使用如下公式，根据不确定性计算权重，再求一个加权和：</p><img src="/images/paper-reading-MIPS-Fusion/image-20240410132325671.png" style="zoom:67%;"><p>论文把TSDF值分成了5类，如下：</p><img src="/images/paper-reading-MIPS-Fusion/image-20240410133057662.png" style="zoom:67%;"><p>查询MLP分类器的话，就会得到该点处于这五个类别的概率，然后使用soft argmax函数就能拿到该点的TSDF值。</p><blockquote><p>这一步还挺妙的，用分类器。看论文的Fig.6. 分类器的方法收敛的速度更快。</p><p>好像有一些深度估计的方法也是按照分类器的思路去做的。</p></blockquote><img src="/images/paper-reading-MIPS-Fusion/image-20240410133527668.png" style="zoom: 67%;"><p>这个所谓的soft argmax函数加了一个额外的参数，这个参数论文说是用来调整平滑度和梯度的。</p><p>另外由于用这种分类器的方式，还可以计算出来TSDF的不确定度，而且对类别数量不敏感。下面这张图说明，至少Shannon entropy低的情况下，TSDF error极大概率也很低，所以可以只晒选Shannon entropy低的点。（主要是很多情况下Shannon entropy高，但实际上TSDF error又很低，存在假阳性的情况）</p><img src="/images/paper-reading-MIPS-Fusion/image-20240410134542128.png" style="zoom: 67%;"><p><strong>Neural radiance field</strong></p><p>上面的TSDF分类器表示了场景的几何结构，但是对于外观，这篇论文还是沿用了神经辐射场的方法，这部分看起来是主要参考的iMAP，省略了视线方向的编码。</p><p><strong>Color and depth map rendering</strong></p><p>这部分就是根据TSDF值去计算权重了，权重的计算方法和Co-SLAM比较相似。</p><p>本文的：</p><img src="/images/paper-reading-MIPS-Fusion/image-20240410214104301.png" style="zoom: 67%;"><p>Co-SLAM的：</p><img src="/images/paper-reading-MIPS-Fusion/image-20240410214120538.png" style="zoom:67%;"><p>另外，Co-SLAM应该是沿着射线进行采样了一系列的点；MIPS-Fusion声称他们是截断区域内进行采样。</p><blockquote><p><strong>疑问：如何做到截断区域内进行采样？</strong>应该是NICE-SLAM那种，在深度值前后一定区域进行采样？</p></blockquote><h3 id="Optimization-Losses-for-Mapping-and-Tracking"><a href="#Optimization-Losses-for-Mapping-and-Tracking" class="headerlink" title="Optimization Losses for Mapping and Tracking"></a>Optimization Losses for Mapping and Tracking</h3><p>包括四种损失：</p><ul><li>depth to TSDT loss，d2t</li><li>TSDF truncation-region loss，tr</li><li>TSDF free-space loss，fs</li><li>RGB rendering loss，rgb</li></ul><p>d2t用于tracking（RO和GO），tr、fs、rgb用于mapping和GO-based pose optimization</p><blockquote><p><strong>疑问：RO和GO是什么，暂时没看到论文提及</strong></p><p>RO指的是随即优化，randomized optimization</p><p>GO指的是gradient-based optimization</p><p>后面三种loss近期的工作经常使用，而d2t本文声称是highly effective and efficient for tracking optimization</p><p>另外，本文没有使用常见的depth rendering loss，因为tr和fs已经覆盖depth rendering loss了</p></blockquote><p><strong>Depth-to-TSDF loss</strong>    we define a frame-to-model error metric to measure <strong>the fitness of how well 𝐷𝑡 “fits into” the TSDF under pose</strong></p><p>大概意思就是，在这个pose下，对于某个像素p，根据观测的深度值计算出它世界坐标系下的坐标，再拿到在当前子图的坐标，去查询子图下定义的TSDF，如果pose正确的话，这个点到曲面的距离应该为0，即TSDF应该为0</p><img src="/images/paper-reading-MIPS-Fusion/image-20240411102301885.png" style="zoom:67%;"><p><strong>TSDF truncation-region loss</strong>    The truncation-region loss is devised to <strong>supervise the MLP to output correct SDF values for points within the truncation region</strong></p><p>大概意思就是，根据传感器观测深度和采样深度计算一个SDF值，然后和网络预测的值做差，看看对不对。</p><img src="/images/paper-reading-MIPS-Fusion/image-20240411104211489.png" style="zoom:67%;"><p><strong>TSDF free-space loss</strong>    The free-space loss directs the neural map to output a value equal to the truncation value 𝜏 for the empty region in the visible side of the viewing frustum</p><p>这里应该是希望TSDF MLP能够准确表示free space，即相机到物体表面的视锥内，TSDF值应该为1，对应的，网络的输出也应该尽可能地接近截断距离。这样设计有助于提高三维重建的质量和精度。</p><img src="/images/paper-reading-MIPS-Fusion/image-20240411111210362.png" style="zoom:67%;"><p><strong>RGB rendering loss</strong>    非常常规的损失函数了</p><img src="/images/paper-reading-MIPS-Fusion/image-20240411112422189.png" style="zoom:67%;"><h3 id="Tracking-with-Hybrid-Optimization"><a href="#Tracking-with-Hybrid-Optimization" class="headerlink" title="Tracking with Hybrid Optimization"></a>Tracking with Hybrid Optimization</h3><p>这里的Hybrid Optimization指的是结合了随即优化（RO）和基于梯度的优化（GO）。在固定次数的 RO 迭代之后，针对另外固定次数的迭代的两个损失调用 GO。</p><p><strong>关于RO：</strong>Randomized pose optimization</p><p>是比较新鲜的东西，很遗憾我不会，需要再好好了解一下！</p><p>看起来是只围绕d2t这个loss的优化。</p><p><strong>疑问：</strong>这里提到的particle filter optimization（PFO）、Particle Swarm Template（PST）等优化方法不是很了解。</p><p><strong>关于GO：</strong>Gradient-based pose optimization</p><p>和NICE-SLAM、Co-SLAM等方法一样，很传统的优化方法</p><p>根据公式17，是围绕d2t+rgb的loss优化，而且有权重</p><h3 id="Mapping-of-the-Active-Submap"><a href="#Mapping-of-the-Active-Submap" class="headerlink" title="Mapping of the Active Submap"></a>Mapping of the Active Submap</h3><p>Submap allocation这里提到“the far clipping plane is set to 5m”，这样的话，我觉得可能比较适合室内场景，而且后面也说subvolume的任意一边达到7m的时候，就会停止扩展，那应该就会开始准备开启新的submap了。</p><p>Submap initialization这里提到创建新的submap的话，会使用共享的那个关键帧迭代500轮。</p><blockquote><p>由于这里毕竟是TSDF MLP+NeRF MLP的形式，所以必须迭代了</p><p>如果是point slam或者3dgs based的方法，我认为完全可以用这个关键帧对应的点云</p></blockquote><p>Keyframe selection的选择标准是information gain of a frame。在论文所使用的方法下，基于depth-to-TSDF loss就可以进行过滤了。直接看像素的比例，如果误差小的比例低于某个阈值，就认为可以作为新的关键帧了。论文这里还规定了两个关键帧的最小间距为30帧。</p><blockquote><p>放到3dgs里面的话，我可以做不透明度mask，看看mask掉了多少区域，然后选择一下；</p><p>另外，也可以看视角变换的幅度，比如即使没有mask的区域，视角变化大，也可以作为关键帧。</p></blockquote><p>Active submap optimization这里提到每个帧的优化包括5个不同的帧，包括：当前帧、submap第一个关键帧、随机选择的另外三个关键帧。</p><p>根据下面的损失函数，看起来pose和d2t、rgb关联比较大，而mapping更关心tr与fs。</p><img src="/images/paper-reading-MIPS-Fusion/image-20240411195438087.png" style="zoom:67%;"><h3 id="Back-end-Optimization-and-Loop-Closure"><a href="#Back-end-Optimization-and-Loop-Closure" class="headerlink" title="Back-end Optimization and Loop Closure"></a>Back-end Optimization and Loop Closure</h3><p>开头提到这个工作分成两个线程，一个是tracking and mapping activate submap的，一个是refinement inactive submap的。</p><p>Optimization of inactive submaps这里说，按顺序重复优化每一个inactive submap，对于每一个正在优化的submap，从中随机选择四个关键帧+第一帧进行优化，迭代10次。</p><blockquote><p>这个是因为之前追求效率优化的比较少，所以回头再继续优化优化吗？</p></blockquote><p>Handling pose jump at submap revisiting这里说，当相机移动到inactive submap的subvolume中时，这个inactive submap会被激活。为了避免位姿漂移和错位，先用这个重叠关键帧和其他关键帧对新激活的submap进行local BA，然后再开始新的tracking。</p><blockquote><p>这不就，阻塞住了？不会影响后续帧的tracking嘛？？？</p><p>不过现在的nerf based or 3dgs based slam都是读数据集，不太在乎实时性，这里阻塞了肯定也不会说。。。说到底还是看个平均fps，中间阻塞几下不在乎。</p></blockquote><p>Loop detection and closure这里说论文更关心submap级别的回环检测，并且目前实现的是涉及至少四个submap的loop。论文认为两个连续子地图之间的漂移通常非常小。</p><blockquote><p>论文的方法肯定只能做submap级别的loop closure</p><p><strong>疑问：这个涉及至少四个submap的loop，或许指的是四个以上submap的subvolume重合的时候才回环一次？？？也可能是说相机轨迹跨越了至少四个不同子地图之后，才开始检测闭环？？？</strong></p></blockquote><h3 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h3><p>看论文的消融实验，看起来RO、SR、LC对结果的影响很大。其中如果没有SI、SR、LC，甚至可能会跑不完一个数据集。</p><img src="/images/paper-reading-MIPS-Fusion/image-20240411205041142.png" style="zoom:80%;"><p>另外实验也证明了RO、GO、RO+GO的方法中，RO+GO是最好的。</p><p><strong>看了TUM RGBD数据集的结果，还是有一个问题：</strong>在常见的三个数据集上，MIPS-Fusion没有表现出非常亮眼的效果，可以理解。<strong>但是，为什么不放一些大场景、带回环的数据集的结果呢？？？</strong></p><img src="/images/paper-reading-MIPS-Fusion/image-20240411205441212.png" style="zoom:80%;"><p>不过这里倒是展示了FastCaMo-Large datasets的一些结果，可以看到论文方法的优越性</p><img src="/images/paper-reading-MIPS-Fusion/image-20240411210338298.png" style="zoom:80%;">]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式表示 </tag>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NeRF based SLAM学习笔记（7）：从Point NeRF到Loopy SLAM</title>
      <link href="2024/04/02/nerf-slam-6/"/>
      <url>2024/04/02/nerf-slam-6/</url>
      
        <content type="html"><![CDATA[<h1 id="NeRF-based-SLAM学习笔记（7）：从Point-NeRF到Loopy-SLAM"><a href="#NeRF-based-SLAM学习笔记（7）：从Point-NeRF到Loopy-SLAM" class="headerlink" title="NeRF based SLAM学习笔记（7）：从Point NeRF到Loopy SLAM"></a>NeRF based SLAM学习笔记（7）：从Point NeRF到Loopy SLAM</h1><h2 id="Point-NeRF"><a href="#Point-NeRF" class="headerlink" title="Point NeRF"></a>Point NeRF</h2><h3 id="System-Overview"><a href="#System-Overview" class="headerlink" title="System Overview"></a>System Overview</h3><img src="/images/nerf-slam-6/image-20240402145508974.png" style="zoom:67%;"><h3 id="场景表征"><a href="#场景表征" class="headerlink" title="场景表征"></a>场景表征</h3><p>使用neural point cloud表示场景<br>$$<br>P = {(p_i, f_i, r_i)|i = 1,…,N}<br>$$<br>p表示坐标，f是feature vector，r是scale confidence value，表示位于实际场景表面附近的可能性。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><img src="/images/nerf-slam-6/image-20231220204200344.png" style="zoom:67%;"><img src="/images/nerf-slam-6/image-20231220164344891.png" style="zoom:67%;"><img src="/images/nerf-slam-6/image-20231220164600991.png" style="zoom:67%;"><p><strong>问题：</strong></p><ul><li><p>查询MLP的次数和原版NeRF差不多，拖慢了渲染速度；</p><p>比如，这里可以用上SNeRG[20] Baking Neural Radiance Fields for Real-Time View Synthesis. ICCV 2021. 这样的延迟渲染模型来加速，把一条射线上的采样点的特征融合之后再拿去解码，从而减少MLP查询次数；</p></li><li><p>点云密度和渲染质量之间需要平衡；</p><ul><li>点云密度高，显存占用增加</li><li>降低点云密度，会降低渲染质量</li></ul><p>小模型这样的问题不明显，但是场景扩大就有问题了；</p></li></ul><h2 id="Point-SLAM"><a href="#Point-SLAM" class="headerlink" title="Point SLAM"></a>Point SLAM</h2><h3 id="System-Overview-1"><a href="#System-Overview-1" class="headerlink" title="System Overview"></a>System Overview</h3><img src="/images/nerf-slam-6/image-20240409142122665.png" style="zoom: 67%;"><h3 id="场景表示"><a href="#场景表示" class="headerlink" title="场景表示"></a>场景表示</h3><img src="/images/nerf-slam-6/image-20240409143848241.png" style="zoom:67%;"><p>一系列的点云，每个点包括：位置、geometric特征向量、color特征向量</p><h3 id="Point-Adding-Strategy"><a href="#Point-Adding-Strategy" class="headerlink" title="Point Adding Strategy"></a>Point Adding Strategy</h3><ol><li><strong>采样阶段</strong>：<ul><li>对于每个映射阶段和给定的估计相机姿态，从图像平面均匀采样X个像素和在具有最高颜色梯度幅度的前10Y个像素中采样Y个像素。</li></ul></li><li><strong>像素转换到3D空间</strong>：<ul><li>利用可用的深度信息，将这些像素转换到三维空间。在三维空间中搜索半径为r内的邻居点。</li></ul></li><li><strong>点的添加</strong>：<ul><li>如果在搜索半径r内没有找到邻居点，则沿着光线添加三个神经点。这些点以深度读数D为中心，并且偏移量分别为(1 − ρ)D和(1 + ρ)D，其中ρ ∈ (0, 1)是一个超参数，用于考虑期望深度噪声。</li></ul></li><li><strong>初始化</strong>：<ul><li>使用特征向量的正态分布初始化这些点。这三个点作为有限的更新带，其深度依赖性可用于建模深度相机的常见噪声特性。</li></ul></li><li><strong>点云的增长和收敛</strong>：<ul><li>随着处理更多帧，神经点云逐渐增长以表示场景的探索，但当不再访问新的场景部分时，它会收敛到有限的点集。与许多基于体素的表示不同，不需要在重建之前指定任何场景边界。</li></ul></li></ol><p>该策略的关键思想是在SLAM过程中根据当前相机姿态和深度信息动态地添加特征点，以捕获场景中的重要结构并适应深度相机的噪声。这种方法允许在不提前知道场景边界的情况下进行建图，并且可以在场景探索过程中动态地调整特征点的分布。</p><h3 id="Dynamic-Resolution"><a href="#Dynamic-Resolution" class="headerlink" title="Dynamic Resolution"></a>Dynamic Resolution</h3><p>简单说就是每个区域点的数量、密度都是动态调整的。这样可以在保持建图精度的同时，节省计算和内存资源。</p><p>颜色梯度比较大的地方，可能信息比较丰富，就需要更大的点密度，Point Adding Strategy添加点的半径就可以设置的小一些；</p><p>反过来，颜色梯度非常小的地方，那说明信息很少，可以更低的点密度，Point Adding Strategy添加点的半径可以更大一些。</p><img src="/images/nerf-slam-6/image-20240409150606209.png" style="zoom:67%;"><h3 id="Rendering"><a href="#Rendering" class="headerlink" title="Rendering"></a>Rendering</h3><p>如果像素点有观测深度，就在深度前后采样5个点，按照距离计算权重；如果没有观测深度，就采样25个点，按照占用率计算权重。</p><p>其他的部分比较常见，这里不记录。</p><h3 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h3><p>损失函数很简单，这里有一个细节，对于每个mapping phase，首先只使用深度进行优化，论文认为这样可以更好的初始化颜色的优化过程。</p><blockquote><p>但是最近也有研究深度噪声对重建影响的工作，这里就完全依赖深度了。</p><p>如果给的深度误差比较大，可能对重建的结果有不小的影响。</p></blockquote><h3 id="Tracking"><a href="#Tracking" class="headerlink" title="Tracking"></a>Tracking</h3><p>和NICE-SLAM的Tracking非常相似。</p><h3 id="Exposure-Compensation"><a href="#Exposure-Compensation" class="headerlink" title="Exposure Compensation"></a>Exposure Compensation</h3><p>居然还有exposure MLP来处理不同帧之间曝光变化的问题。</p><h3 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h3><p>主要在Replica、TUM-RGBD和ScanNet上面测试。mesh是通过marching cubes算法获取的。</p><p>提到了对于motion blur和specularities（镜面反射）非常敏感。</p><h2 id="Loopy-SLAM"><a href="#Loopy-SLAM" class="headerlink" title="Loopy SLAM"></a>Loopy SLAM</h2><blockquote><p>还是Point SLAM那个组做的工作</p></blockquote><h3 id="论文的贡献"><a href="#论文的贡献" class="headerlink" title="论文的贡献"></a>论文的贡献</h3><ul><li>我们提出了 Loopy-SLAM，这是一种密集的 RGBD SLAM 方法，它将神经特征锚定在点云子图中，这些子图在场景探索过程中以数据驱动的方式迭代增长。 我们根据相机运动动态创建子图，并逐步在子图关键帧之间构建姿势图。 全局位置识别用于在线检测循环闭合，并直接在场景表示上通过简单有效的刚性校正来全局对齐轨迹和子图。</li><li>我们提出了一种直接实现密集神经 SLAM 闭环的方法，与之前的工作相反，不需要场景表示的任何梯度更新或重新集成策略</li><li><strong>传统上，严格的子图配准可能会在重叠区域中产生可见的接缝。</strong> 我们基于神经点云的方法避免了这种情况，并且我们在轨迹捕获结束时应用颜色和几何的特征细化。 我们进一步引入了重叠区域中子图的特征融合策略，以避免过多的内存使用并提高渲染性能。</li></ul><h3 id="论文提到的观点"><a href="#论文提到的观点" class="headerlink" title="论文提到的观点"></a>论文提到的观点</h3><ul><li><p>作者认为SLAM可以分为耦合的方法和解耦合的方法，其中<strong>耦合的方法指的是使用相同的场景表示来进行tracking和mapping，解耦的方法对每个任务都使用独立的框架</strong>。</p><ul><li><p>目前解耦的方法能够实现更好的跟踪精度，但是会产生不期望的数据冗余和独立性；</p></li><li><p>作者认为tracking和mapping是耦合的任务，可以用相同的场景表示；</p></li></ul><blockquote><p>这里不是很懂，作者提到的解耦的方法我刚好都没有好好的去看过，不过Orbeez-slam是使用传统方法tracking，再用instant-ngp做mapping的。</p><p>作者引用的解耦的方法：</p><ul><li>Orbeez-slam</li><li>Newton: Neural view-centric mapping for on-the-fly large-scale slam.</li><li>NeRF-SLAM: Real-Time Dense Monocular SLAM with Neural Radiance Fields</li><li>Go-slam: Global optimization for consistent 3d instant reconstruction.</li></ul><p>作者引用的耦合的方法：</p><ul><li>Eslam: Efficient dense slam system based on hybrid representation of signed distance fields</li><li>Point-slam: Dense neural point cloud-based slam.</li><li>iMAP: Implicit Mapping and Positioning in Real-Time.</li><li>Co-slam: Joint coordinate and sparse parametric encodings for neural real-time slam</li><li>Vox-fusion: Dense tracking and mapping with voxel-based neural implicit representation.</li><li>Nice-slam: Neural implicit scalable encoding for slam.</li></ul></blockquote></li><li><p><strong>耦合方法中，除了MIPS_Fusion之外，其他所有方法都是实现的frame-to-model tracking，这会导致位姿出现显著的漂移。</strong></p></li><li><p><strong>解耦方法都使用多分辨率哈希网格，这样不容易进行地图校正。而基于点的表示方法特别适合进行地图校正。</strong></p></li></ul><h3 id="对其他回环检测方法的评价"><a href="#对其他回环检测方法的评价" class="headerlink" title="对其他回环检测方法的评价"></a>对其他回环检测方法的评价</h3><p>略，直接看论文的Loop Closure on Dense Maps.部分</p><h3 id="System-Overview-2"><a href="#System-Overview-2" class="headerlink" title="System Overview"></a>System Overview</h3><img src="/images/nerf-slam-6/image-20240409193805630.png" style="zoom:67%;"><p>大部分流程都和Point SLAM一样，需要注意的是<strong>Keyframe Selection and Submap Initialization</strong>部分：论文认为过于频繁的创建子图也会增加姿态漂移，因此他们没有使用固定间隔等方法，而是根据相机运动去动态的创建全局关键帧。然后，在子图构建完成的时候进行闭环检测。</p><p>对于<strong>Building Submaps Progressively</strong>部分，提到了子图的第一帧作为全局关键帧，但是没有具体说明如何创建一个新的子图。。。不过Figure 2下面的描述倒是说创建新的全局关键帧的时候，会开始初始化一个新子图。</p><blockquote><p>那估计这个系统的全局关键帧会挺少的，不然子图会比较多。。。</p></blockquote><h3 id="Loop-Closure-and-Refinement"><a href="#Loop-Closure-and-Refinement" class="headerlink" title="Loop Closure and Refinement"></a>Loop Closure and Refinement</h3><p>与MIPS-Fusion相比的话，这里的loop closure比较功利，每次开始新的submap就检测一次回环，MIPS-Fusion是开启新的submap之后，如果再回到之前submap的subvolume中才会检测，而且还有额外的条件。</p><p><strong>Global Place Recognition</strong>    每个全局关键帧都被添加到Bow数据库中用于位置识别。这里论文cue了一下MIPS-Fusion，认为MIPS-Fusion这种通过重叠的submap去检测回环，只适合较小漂移的校正。</p><blockquote><p>有点像ORB-SLAM的做法，这里我需要再好好了解一下</p><p>但是这里即使全局位置识别做得很好，自己用的还是子地图，而且还是每次开始新的子地图就检测一次回环，真不一定能比过MIPS-Fusion吧。。。</p><p>而且后面的实验也没有和人家MIPS-Fusion用过的数据集比较。。。</p></blockquote><p><strong>Pose Graph Optimization</strong>    下面是GPT的一个总结</p><img src="/images/nerf-slam-6/image-20240412103921609.png" style="zoom: 80%;"><blockquote><p>这部分看不太懂，以后再好好研究一下吧。。。</p></blockquote><p><strong>Loop Edge Constraints</strong>    下面也是GPT的一个介绍</p><img src="/images/nerf-slam-6/image-20240412104304511.png"><p><strong>Feature Fusion and Refinement</strong>    在tracking结束之后才会开始连接所有子图来构成一个全局的神经点云，首先是进行特征融合来压缩模型，由于Loopy SLAM是基于Point SLAM的工作，本质上还是feature point+decoder的结构，这里论文选择的是特征融合之后固定decoder，然后把color 和 geometry feature再进行一个优化。</p><h3 id="实验部分-1"><a href="#实验部分-1" class="headerlink" title="实验部分"></a>实验部分</h3><p>Replica、TUM-RGBD数据集都用了，但是没有专门去找那种大场景、回环的。</p><p>不过论文在ScanNet上做了一些实验，倒是也有说服力的证明了自己的回环是有效果的。</p><blockquote><p>但是我最近看的这些做回环检测的论文，实验都做的不太够。。</p><p>一方面，在经典的几个数据集上比较自己的性能；</p><p>另外一方面，只在某个能体现回环的数据集上证明自己回环有效果。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NeRF </tag>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读《ESLAM Efficient Dense SLAM System Based on Hybrid Representation of Signed Distance Fields》</title>
      <link href="2024/03/15/paper-reading-eslam/"/>
      <url>2024/03/15/paper-reading-eslam/</url>
      
        <content type="html"><![CDATA[<h1 id="论文阅读《ESLAM-Efficient-Dense-SLAM-System-Based-on-Hybrid-Representation-of-Signed-Distance-Fields》"><a href="#论文阅读《ESLAM-Efficient-Dense-SLAM-System-Based-on-Hybrid-Representation-of-Signed-Distance-Fields》" class="headerlink" title="论文阅读《ESLAM: Efficient Dense SLAM System Based on Hybrid Representation of Signed Distance Fields》"></a>论文阅读《ESLAM: Efficient Dense SLAM System Based on Hybrid Representation of Signed Distance Fields》</h1><p>和co-slam同时期的工作，他们都使用了TSDF来表示场景。</p><blockquote><p>似乎E-SLAM不知道有co-slam，但是co-slam知道E-SLAM。</p></blockquote><p>宣称：</p><ul><li>比iMAP和NICE-SLAM准确度高了50%</li><li>比他们快了10倍</li></ul><h3 id="System-Overview"><a href="#System-Overview" class="headerlink" title="System Overview"></a>System Overview</h3><img src="/images/paper-reading-eslam/image-20240303163742495.png" style="zoom:67%;"><h4 id="Axis-Aligned-Feature-Planes"><a href="#Axis-Aligned-Feature-Planes" class="headerlink" title="Axis-Aligned Feature Planes"></a>Axis-Aligned Feature Planes</h4><p>上图左边是他们的<strong>Axis-Aligned Feature Planes</strong>，他们宣称基于体素网格的NeRF能快速收敛，但是对于更大的场景表示还是有困难的，内存消耗会越来越大。而他们这种三平面结构可以环节这样的问题。他们在垂直轴对齐的平面上存储和优化特征。</p><p><strong>feature plane的细节：</strong></p><ul><li><p>coarse to fine</p></li><li><p>单独的feature plane表示几何和外观。考虑到外观（颜色）是经常变化的，而几何体比较稳定，所以把它们分开表示了。</p><blockquote><p>这样的话，又回到了iMAP的问题了，容易遗忘。</p></blockquote></li></ul><p><strong>如何进行采样：</strong></p><ul><li><p>对于空间中某一个点，通过双线性插值获取每个特征平面上的特征</p></li><li><p>对于几何和颜色特征平面，都是：</p><p>coarse平面的三个特征向量求和，fine平面的三个特征向量求和</p><p>最后，coarse和fine求和的特征向量拼接到一起。</p><blockquote><p>求和是不是太简单了？</p></blockquote></li><li><p>通过两层的MLP进行解码，拿到TSDF和颜色</p></li></ul><blockquote><p>根据上面的说法，我猜测特征平面的初始化会比较重要，也比较难处理，容易导致错误的重建。</p><p>在看E-SLAM运行的过程中，发现他对于相机后没有观测到的的部分，会给重建成相机前观察到的部分，比如展示在replica数据集中重建结果时：</p><img src="/images/paper-reading-eslam/image-20240303165343425.png" style="zoom:67%;"></blockquote><h4 id="SDF-Based-Volume-Rendering"><a href="#SDF-Based-Volume-Rendering" class="headerlink" title="SDF-Based Volume Rendering"></a>SDF-Based Volume Rendering</h4><p>与NICE-SLAM几乎一致的流程，不过考虑到了某些像素点不一定有深度信息的情况：</p><ul><li>采样N_start点</li><li>对于有深度信息的，深度前后截断距离T内，采样N_imp个</li><li>对于没有深度信息的，类似iMAP用N_start计算一个权重再采样N_imp个</li></ul><p>对于TSDF值，E-SLAM是将其处理成了体密度，再根据体密度去计算权重等等，其他部分和NICE-SLAM没有区别。</p><blockquote><p>在看了co-slam之后再来看E-SLAM，发现E-SLAM在处理TSDF的时候还是太过于保守了。</p><p>在E-SLAM中，是先将TSDF值转换成体密度，再根据体渲染的公式去计算权重，这样还是太麻烦了；</p><p>而co-slam中，是直接通过sigmoid(tsdf)*sigmoid(-tsdf)拿到权重了。</p><p>个人认为，毕竟我们是在做一个隐式神经表示的SLAM，过程都是可学习的，在权重这个部分，保证越接近表面的点权重越大的趋势就行了，其他的都是可以学习到的。</p></blockquote><h4 id="Loss-Functions"><a href="#Loss-Functions" class="headerlink" title="Loss Functions"></a>Loss Functions</h4><p>除了和NICE-SLAM相似的颜色、深度损失外，由于使用了TSDF，可以考虑采样点的损失：</p><p><strong>free space loss</strong>    鼓励TSDF在free space中具有1的数值，在这个公式中，看起来是鼓励相机中心到物体表面之间被采样的点应当TSDF=1</p><img src="/images/paper-reading-eslam/image-20240303172754222.png" style="zoom: 67%;"><p><strong>signed distance objective</strong>    看起来是希望靠近物体表面的那些被采样的点，能够拥有正确的SDF值。</p><img src="/images/paper-reading-eslam/image-20240303173330015.png" style="zoom:67%;"><blockquote><p>最中心的公式含义为：</p><p>采样点沿射线的深度 + tsdf * 截断距离 - 深度真值</p></blockquote><p>根据距离物体表面的远近，E-SLAM把接近物体表面的点分成了两批去计算损失（方便用不同的权重）</p><img src="/images/paper-reading-eslam/image-20240303173527906.png" style="zoom:67%;"><h4 id="Mapping-and-Tracking"><a href="#Mapping-and-Tracking" class="headerlink" title="Mapping and Tracking"></a>Mapping and Tracking</h4><p>Mapping和NICE-SLAM差不多，特征平面和MLP都是随机初始化的。</p><p>Tracking看起来也没有什么特殊的地方。</p><h4 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h4><p>与NICE-SLAM和iMAP比较，效果确实好一些</p><h4 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h4><p>这部分提到了<strong>E-SLAM接受并处理遗忘问题，以此来换取更小的内存开销</strong>。E-SLAM像iMAP一样，更新特征会影响之前重建的几何形状，因此还需要不断地学习之前的关键帧。如果能够更有效地处理遗忘问题，可以进一步加快运行速度。</p><h4 id="Supplementary-Materials"><a href="#Supplementary-Materials" class="headerlink" title="Supplementary Materials"></a>Supplementary Materials</h4><p>这里提到E-SLAM使用marching cubes算法获取mesh，并且没有进行任何的后处理。</p>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式表示 </tag>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3DGS SLAM泛读（一）</title>
      <link href="2024/03/06/paper-reading-3dgs-slam-1/"/>
      <url>2024/03/06/paper-reading-3dgs-slam-1/</url>
      
        <content type="html"><![CDATA[<h1 id="3DGS-SLAM泛读（一）"><a href="#3DGS-SLAM泛读（一）" class="headerlink" title="3DGS SLAM泛读（一）"></a>3DGS SLAM泛读（一）</h1><h2 id="GS-SLAM"><a href="#GS-SLAM" class="headerlink" title="GS-SLAM"></a>GS-SLAM</h2><p><strong>贡献：</strong></p><ul><li>第一个3D高斯的稠密RGB-D SLAM方法</li><li>自适应3D高斯扩展策略，coarse to fine的选择可靠的3D高斯</li><li>8FPS的速度，平衡效率与精度</li></ul><p><strong>Overview：</strong></p><img src="/images/3dgs-slam-1/image-20240306193920492.png" style="zoom:67%;"><p><strong>场景表示：</strong></p><p>与3dgs一模一样的表示方法</p><img src="/images/3dgs-slam-1/image-20240315150752115.png" style="zoom:67%;"><p><strong>个人观点：</strong></p><p>做的比较粗糙，没有特别亮眼的地方，感觉就是按照之前NeRF SLAM的思路，简单的用3DGS又做了一遍。不过可以基于这篇论文，了解一下3DGS SLAM应该是怎么样去做的，这篇论文比较好理解。</p><p>实验部分能看到受益于3DGS，渲染做得很好、速度也很快，但是跟踪和建图的精度以及速度却和之前NeRF SLAM的方法却差距不大（甚至不如ESLAM和COSLAM），这里个人感觉是有问题的。</p><h2 id="Gaussian-SLAM"><a href="#Gaussian-SLAM" class="headerlink" title="Gaussian-SLAM"></a>Gaussian-SLAM</h2><p><strong>贡献：</strong></p><ul><li>3D高斯表示场景的RGB-D SLAM方法</li><li>扩展了Gaussian splatting，更好的编码几何形状</li><li>高斯分布的在线学习策略，将场景分成很多子场景，并且引入了seeding和优化的策略</li><li>通过最小化光度误差，实现了frame-to-model的tracking，并且和现有的frame-to-frame的方法作了比较</li></ul><p><strong>Limitations of Gaussian Splatting for SLAM：</strong></p><p>这篇论文讲了Gaussian Splatting运用到SLAM算法中的局限性，个人认为是比较值得参考的。这里讲了几点问题：</p><ul><li><p><strong>Seeding strategy for online SLAM</strong></p><p>原始3DGS的自适应密度控制策略是iterative dynamic behavior的，可能会导致mapping的迭代和计算时间发生剧烈的变化，这种方式不适合SLAM。</p><blockquote><p>因为SLAM既要建图又要跟踪吧，如果建图时间过长，或者地图更新太大，会对跟踪造成很不好的影响</p></blockquote></li><li><p><strong>Online optimization</strong></p><p>对于较长的序列来说，在线优化所有帧太慢了</p><blockquote><p>这个，就好像sfm和slam</p></blockquote></li><li><p><strong>Catastrophic forgetting in online optimization</strong></p><p>为了避免每个新帧带来地图的线性增长，一种候选的方案是使用当前帧去优化高斯场景表示。但是这种方法会导致之前mapped views严重退化。</p><blockquote><p>这里我不理解，为什么会导致之前优化的结果严重退化？</p><p>是因为当前帧和前面的帧有重复的内容，而这个候选的方案只考虑当前帧，优化之后的3D高斯只能和当前帧“合得来”，而和之前的帧就“合不来”了？</p></blockquote></li><li><p><strong>Highly randomized solutions</strong></p><p>提到了splatting优化的结果高度依赖于高斯的初始化。并且优化过程中，会受到相邻高斯的影响，高斯可能会向不同的方向增长。</p><p>3D高斯固有的对称性导致了不影响损失函数（损失不变）的情况下，3D高斯的参数可以被改动，就是说存在不唯一的解，而这种情况是优化过程不希望出现的。</p><blockquote><p>这可能会导致有时候优化了，损失函数没有被改变？</p></blockquote></li><li><p><strong>Poor extrapolation capabilities</strong></p><p>高斯函数经常不受控制的生长到未观察到的区域。原始3DGS的方法因为良好的视图覆盖，可以约束大多数高斯模型；但是稀疏视图的SLAM中，新视图往往包含由于先前约束不足的高斯模型产生的伪影，这对于model-based tracking影响很致命。</p><blockquote><p>因为存在伪影，使用color或者depth计算的损失都会有一些影响？</p></blockquote></li><li><p><strong>Limited geometric accuracy</strong></p><p>单目的情况下，3DGS不擅长编码精确的几何形状。</p></li></ul><blockquote><p>其实根据这里所讲的几个问题，我认为对于3D高斯来说，SLAM似乎是这样的一个问题：稀疏视角（我们可能不会mapping每一帧，每次对于新的观测区域也都可以算是稀疏视角的）、位姿未知（需要tracking每一帧）、在线（数据是一帧一帧来的，不是一次性给到位的）的重建问题</p><p>另外，这篇论文是我见过，提出问题最多的论文。</p></blockquote><p><strong>Overview：</strong></p><img src="/images/3dgs-slam-1/image-20240306205206830.png" style="zoom:67%;"><blockquote><p>看起来是借鉴了ORB-SLAM3的思路，用sub-map的方式去尝试解决3DGS在SLAM中的一些问题。</p></blockquote><p><strong>场景表示：</strong></p><p>看起来也是用的原版的3dgs，没有做什么改动？？？</p><p><strong>实验部分：</strong></p><img src="/images/3dgs-slam-1/image-20240306215736766.png" style="zoom:67%;"><blockquote><p>实验部分很有意思，展示了一个比较关键的问题：<strong>纯3DGS的tracking性能不好，加入pre-mapped效果会好很多</strong></p><p>但是也反映了一个和GS-SLAM一样存在的问题：<strong>Rendering的速度很快，但Mapping的速度并不快</strong></p></blockquote><p><strong>个人观点：</strong></p><p>对于3DGS应用到SLAM中可能存在的问题，做了一个很好的介绍，很有参考价值。</p><p>实验中体现了两个值得关注的问题：</p><ul><li>纯粹的依靠3DGS的tracking，性能不好，但是加入pre-mapped之后效果会好很多；</li><li>目前的3DGS SLAM，Rendering速度都很快，但是Mapping和Tracking的速度普遍与之前NeRF-SLAM的方法差距不大。</li></ul><h2 id="SplaTAM"><a href="#SplaTAM" class="headerlink" title="SplaTAM"></a>SplaTAM</h2><p><strong>贡献：</strong></p><p>SplaTAM解决了之前基于辐射场表示的局限性，包括：快速渲染和优化、<strong>确定区域先前是否已建图的能力、通过添加更多高斯函数进行结构化地图扩展</strong>。</p><p><strong>对显示3D Gaussian用于SLAM的优点做了分析：</strong></p><ul><li><p>Fast rendering and rich optimization</p><blockquote><p>能够实时使用dense photometric loss进行SLAM</p></blockquote></li><li><p>具有明确空间范围的地图，可以轻松控制现有地图的边界</p><blockquote><p>但是我认为它主要是和用MLP表示场景的方法相比，而feature grid+mlp的方法其实已经可以控制地图的边界了，不过也没有3dgs这么灵活。</p></blockquote></li><li><p>显示的地图</p><blockquote><p>目前来看，显示的地图更好编辑和增加容量</p></blockquote></li><li><p>到参数的直接梯度流</p><blockquote><p>不太懂这个。。。</p></blockquote></li></ul><p><strong>SLAM System</strong></p><img src="/images/3dgs-slam-1/image-20240315152612755.png" style="zoom:67%;"><img src="/images/3dgs-slam-1/image-20240315151501208.png" style="zoom:67%;"><ul><li><p><strong>Initialization</strong></p><img src="/images/3dgs-slam-1/image-20240315160040041.png" style="zoom:67%;"></li><li><p><strong>Tracking</strong></p><img src="/images/3dgs-slam-1/image-20240315160108994.png" style="zoom:67%;"><img src="/images/3dgs-slam-1/image-20240315160120508.png" style="zoom:67%;"></li><li><p><strong>Gaussian Densification</strong></p><img src="/images/3dgs-slam-1/image-20240315160207865.png" style="zoom:67%;"></li><li><p><strong>Gaussian Map Updating</strong></p><img src="/images/3dgs-slam-1/image-20240315160237644.png" style="zoom:67%;"></li></ul><p><strong>场景表示：</strong></p><p>与原始的3dgs相比，使用了与视图无关的颜色，强制高斯分布为各向同性。</p><blockquote><p>与视图无关的颜色指的是没有用球谐函数了？？？从论文的说法看确实是这样的</p></blockquote><p>每个高斯对应了8个值：颜色R、G、B，中心位置x、y、z，半径r，不透明度o</p><p><strong>实验部分：</strong></p><p>这里我主要关注耗时，SplaTAM其实并没有在Tracking和Mapping的耗时上彻底优于之前基于NeRF的SLAM方法，只能说在渲染的速率上快了很多。</p><img src="/images/3dgs-slam-1/image-20240315160602090.png" style="zoom: 67%;"><p><strong>Limitations and Future Work</strong></p><img src="/images/3dgs-slam-1/image-20240315160722944.png" style="zoom:67%;"><p><strong>个人观点：</strong></p><p>感觉不是非常有特色，和其他3dgs slam相比，最大的不同可能只是场景的表示不一样了，放弃了球谐函数，每个3dgs都只有8个参数。有一个博士评价这个工作拼凑感太强。</p><p>不过这篇论文是第一个开源的，而且也把工作的流程讲的很清楚，可以拿来好好学习。</p><h2 id="Gaussian-Splatting-SLAM"><a href="#Gaussian-Splatting-SLAM" class="headerlink" title="Gaussian Splatting SLAM"></a>Gaussian Splatting SLAM</h2><p><strong>贡献：</strong></p><img src="/images/3dgs-slam-1/image-20240310145931259.png" style="zoom:67%;"><p><strong>论文提及的一些观点：</strong></p><ul><li>NeRF近期的发展都引入了显示的体积结构，从这些工作中可以推断出：<strong>高质量新视图合成的关键不是神经网络，而是可微分体积渲染</strong>。以Plenoxels为例，可以避免使用MLP就实现与NeRF相当的渲染质量。</li></ul><p><strong>场景表示：</strong></p><p>anisotropic（各向异性）的3DGS，但是省略了球谐函数相关的部分</p><img src="/images/3dgs-slam-1/image-20240319153804529.png" style="zoom: 67%;"><p><strong>部分公式推导、理解</strong></p><img src="/images/3dgs-slam-1/image-20240320171441720.png" style="zoom: 67%;"><p>公式3：回顾《视觉SLAM十四讲》，可以比较简单的推导出来。但是对于这里面表示反对称的符号为什么有两种，个人不太理解。</p><p>公式4：我好像对雅可比矩阵等内容非常不熟悉，还需要好好了解一下才能继续写这部分！！！</p><p><strong>System Overview</strong></p><img src="/images/3dgs-slam-1/image-20240320180342588.png" style="zoom:67%;"><p>Tracking部分还是老样子的感觉，毕竟无论NeRF SLAM还是3DGS SLAM基本都是用frame-to-model优化位姿，玩不出新花样来。</p><p>Keyframing有点传统slam的意思了，通过共视关系选择关键帧，并且使用DSO的方式管理关键帧。同时3DGS也遵循可见性排序，考虑Gaussian Covisibility又进一步简化了关键帧的选择与管理。另外，看起来3DGS场景也只能由keyframe去加入点，同时也会看这些高斯函数是否被其他关键帧看到，没看到就会被修剪掉。</p><blockquote><p>关键帧选择对mono slam来说应该是很重要的，因为只有只有multiple-view observations才能够决定场景的几何结构！</p></blockquote><p>Mapping部分之前的工作我也没好好了解，但是这部分其实才是3dgs slam中最重要的部分。这里详细记录一下：</p><ul><li><p>基于共视关系选择一系列的关键帧，用于优化当前的可见区域；</p><p>另外每次迭代优化都随机选择两个过往关键帧，防止遗忘全局地图。</p><blockquote><p>3dgs这种表示为什么会担心遗忘全局地图呢？</p><p>最近刚好自己写了一个简单的3dgs slam，一帧进来优化位姿、优化场景，这种的最后也就学出来了一个几何结构，但是颜色、视图很差，我这里用的RGB各16维的球谐系数，不过场景是各向同性的3dgs，我认为是球谐函数被影响的问题。</p><p>但是放到这里，mono GS放弃了球谐函数，但是选择了各向异性的3dgs，会不会是各向异性的问题？</p></blockquote></li><li><p>引入了一个各向同性正则化，减少伪影，方便SLAM的tracking</p><blockquote><p>为什么不干脆用各向同性的3dgs呢？？？</p></blockquote></li></ul><p><strong>实验部分</strong></p><p>略，懒得记了，到时候直接看论文！</p><h2 id="Photo-SLAM"><a href="#Photo-SLAM" class="headerlink" title="Photo-SLAM"></a>Photo-SLAM</h2><p><strong>Motivation：</strong>Our proposed Photo-SLAM seeks to recover a concise representation of the observed environment <strong>for immersive exploration rather than reconstructing a dense mesh</strong>.</p><p><strong>贡献：</strong></p><img src="/images/3dgs-slam-1/image-20240326153452403.png" style="zoom:67%;"><p><strong>Overview：</strong></p><img src="/images/3dgs-slam-1/image-20240326154856204.png" style="zoom: 80%;"><p>根据论文的描述，photo-SLAM包括：localization、geometry mapping、photorealistic mapping、loop closure，并且每一个组件都有一个单独的线程，而且他们共同维护了一个hyper primitives map。</p><blockquote><p>ORB-SLAM3分为tracking、local mapping、loop and map merging这三个线程</p><p>ORB-SLAM2分为tracking、local mapping、loop closing这三个线程</p><p>个人感觉photo slam是基于orb slam2或3的工作，在上面加了一个3DGS的photorealistic mapping线程。</p></blockquote><p><strong>Hyper Primitives Map</strong>【场景表征】</p><p>Hyper Primitives由一系列的点云组成，而这些点云包括了：ORB特征、旋转、缩放、密度、球谐系数</p><blockquote><p>point cloud: 3维</p><p>ORB features: 256维</p><p>rotation: 3维, SO(3)</p><p>scaling: 3维</p><p>density: 1维</p><p>SH: 16维</p><p>个人观点：在原始的3DGS上加入了ORB特征，而3DGS点云的添加来自于ORB-SLAM产生的地图点（ORB特征点），<strong>ORB特征用传统方法得到，而其他的都是原汁原味的3DGS</strong></p><p>这样做对于传统SLAM方法而言，还是非常自然的，但是photorealistic mapping真的能够实时运行吗？</p></blockquote><p><strong>Localization and Geometry Mapping</strong></p><p>作用：实时的位姿估计、稀疏的3D点云，创建所谓的Hyper Primitives</p><blockquote><p>感觉很经典，，，先不仔细看，后面和ORB-SLAM比较一下</p></blockquote><p><strong>Photorealisitc Mapping</strong></p><p>作用：负责优化geometry mapping thread线程创建的Hyper Primitives</p><blockquote><p> 这部分就放了个损失函数欸</p></blockquote><p><strong>Geometry-based Densification</strong></p><p>这部分说为了保证实时性，只生成了稀疏的Hyper Primitives，后面还需要致密化。他们额外设计了一个基于几何结构的致密化方法。</p><p>他们做的实验表明：只有不到30%的特征点是active的并且有对应的3D点。而他们认为2D几何特征点的分布表示这些区域有更复杂的纹理，因此需要更多的Hyper Primitives，他们会把inactive的特征点主动创建成额外的临时Hyper Primitives。</p><img src="/images/3dgs-slam-1/image-20240329154831969.png" style="zoom:80%;"><blockquote><p>这个也不太像是基于几何结构的致密化方法，感觉做的很简单。</p><p>不过思路很不错，特征点多的区域确实是纹理复杂的区域，但是如果我想重建场景的话，特征点少的区域、纹理弱的区域也是很重要的，这部分应该怎么去处理呢？</p><p>是不是可以特征点多、纹理丰富的区域做一种处理方法，多放小的3DGS点；</p><p>在特征点少、纹理弱的区域另外处理，比如放一些大的3DGS点</p></blockquote><p><strong>Gaussian-Pyramid-Based Learning</strong></p><p><img src="/images/3dgs-slam-1/image-20240329154856803.png"></p><p>论文在这里介绍了一些Progressive training的方法，比如NSVF、NVGO是训练中逐步增加特征网格的分辨率，较低分辨率的decoder用来初始化较高分辨率的decoder；NGLoD是逐步训练多个MLP做编码器解码器，最后只保留最终的那个解码器；Neuralangelo是在训练过程中只保持一个MLP；BungeeNeRF是用不同模型处理不同分辨率的图像，算是一种显示的方法。</p><p>论文提出的方法是基于高斯金字塔的学习方法，分辨率逐渐增加。</p><img src="/images/3dgs-slam-1/image-20240329154905950.png" style="zoom:67%;"><blockquote><p>看起来其实也是很好地利用了ORB-SLAM提供的一些东西</p></blockquote><p><strong>Loop Closure</strong></p><p>论文这里写的很简洁，个人认为就是套用ORB-SLAM的回环检测。</p><p>这里只是提到了检测到闭环之后，通过相似变换矫正关键帧和Hyper Primitives，然后还需要优化来消除一些重影。</p><p><strong>实验部分</strong></p><p>论文提到Photo-SLAM是用C++和CUDA写的，使用了ORB-SLAM3、3D Gaussian Splatting和LibTorch的框架。</p><p>实验部分略过，但是有一个很大的疑惑：既然说了用了英伟达的Jetson平台，为什么没有指明到底用的什么平台？而且看Table 1，这种方法即使在Jetson上也需要4GB的显存，Laptop也是4GB，然后桌面端显存需要6GB。这个Jetson跑的效果也还行，渲染速率也是100fps左右。</p>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式表示 </tag>
            
            <tag> 3D Gaussian Splatting </tag>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NeRF based SLAM学习笔记（6）：关于co-slam中提到的one-blob编码</title>
      <link href="2024/03/01/nerf-slam-5/"/>
      <url>2024/03/01/nerf-slam-5/</url>
      
        <content type="html"><![CDATA[<h1 id="NeRF-based-SLAM学习笔记（6）：关于co-slam中提到的one-blob编码"><a href="#NeRF-based-SLAM学习笔记（6）：关于co-slam中提到的one-blob编码" class="headerlink" title="NeRF based SLAM学习笔记（6）：关于co-slam中提到的one-blob编码"></a>NeRF based SLAM学习笔记（6）：关于co-slam中提到的one-blob编码</h1><p><strong>one-blob编码对应的论文链接为：</strong><a href="https://arxiv.org/pdf/1808.03856.pdf">https://arxiv.org/pdf/1808.03856.pdf</a></p><p><img src="/images/nerf-slam-5/image-20240301204831569.png"></p><p><strong>GPT4对one-blob编码的总结：</strong></p><p>以下是对 “one-blob encoding” 的一个总结：</p><p>“One-blob encoding” 是一种连续输入数据的编码方法，它是 one-hot encoding 的一个泛化。在标准的 one-hot encoding 中，一个分类变量的每个可能值都被映射到一个独立的维度，并在相应维度的位置标记为 1，其他所有位置都是 0。这种编码是离散的、无上下文的，并且很“尖锐”，因为它不表达值之间的任何邻近关系或连续性。</p><p>与之相对的 “one-blob encoding”，在某个标量值 s 的位置放置一个 kernel——在这个案例中，是高斯核——然后将这个 kernel 离散化到一个单位区间内的 k 个 bin 上。这种方法不仅在 s 对应的 bin 上激活值，还根据高斯核的形状在相邻的 bin 中产生较小的激活。标准差 σ 控制了这种激活的扩散程度。</p><p>总的来说，“one-blob encoding”：</p><ol><li>提供了一种连续的、非二值的表示方式，可以捕捉相邻值之间的关系。</li><li>保持了某种形式的稀疏性，因为只有 kernel 覆盖的小区域内的 bin 会被激活。</li><li>允许神经网络利用输入数据的连续性和上下文信息，提高了模型处理连续输入的灵活性和精度。</li><li>通过变化的输入激活，可以影响网络的线性路径，允许网络专门化处理输入的不同子域。<br>具体到那篇论文的应用背景，“one-blob encoding” 用于提升光线追踪中重要性采样的精度，通过提供一种更精细的输入数据表示方法，改进神经网络对场景中不同区域光照分布的学习和预测。</li></ol><p><strong>one-blob编码与原始NeRF位置编码的区别：</strong></p><p>在神经辐射场（Neural Radiance Fields，简称NeRF）的上下文中，输入的坐标通常会通过位置编码(Positional Encoding)进行处理，从而允许模型可以学习到场景中高频的细节。位置编码的目的是允许模型在低维输入空间中捕捉和表达复杂的、高频的函数。</p><p>NeRF 的位置编码通常通过一系列正弦和余弦函数来编码坐标，这些函数具有不同的频率。这种编码方式有效增加了输入坐标的维度，从而帮助模型捕获和表示复杂的几何结构和纹理细节。</p><p>如果在 NeRF 中使用 “one-blob encoding” 替代标准的正弦余弦位置编码，则可以预期以下几点变化：</p><ol><li><p>缓和的空间变化：由于 “one-blob encoding” 倾向于在给定位置周围的邻近区域产生激活，它可能会引入更缓和的表示，相比于正弦余弦编码，对于高频变化可能不那么敏感。</p></li><li><p>神经网络结构调整：“one-blob encoding” 能够启用或关闭网络中特定路径的概念说明了，如果使用这种编码，可能需要对神经网络的结构进行调整来适应这种新的输入表示方式。</p></li><li><p>潜在的泛化改进：理论上，“one-blob encoding” 可能有助于提高模型泛化能力，因为它会在输入编码中引入更连续的特性。</p></li><li><p>纹理和细节的表达：由于 “one-blob encoding” 没有位置编码那样的高频振荡模式，它可能导致纹理和细节的表示能力下降，特别是如果场景依赖于捕捉细微的空间变化。</p></li></ol><p>综上所述，虽然 “one-blob encoding” 提供了一种不同于位置编码的视角，并可能在特定条件下有所帮助，但也有可能不适用于需求捕捉高频细节的 NeRF 场景。在任何情况下，理论推测都需要通过实验来验证其影响。在实际应用中，可能需要对 “one-blob encoding” 加以修改或与其他技术结合以优化 NeRF 的性能。</p>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NeRF </tag>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3D Gaussian Splatting学习笔记</title>
      <link href="2023/12/21/paper-reading-3d-gaussian-splatting/"/>
      <url>2023/12/21/paper-reading-3d-gaussian-splatting/</url>
      
        <content type="html"><![CDATA[<h1 id="3D-Gaussian-Splatting学习笔记"><a href="#3D-Gaussian-Splatting学习笔记" class="headerlink" title="3D Gaussian Splatting学习笔记"></a>3D Gaussian Splatting学习笔记</h1><h2 id="视频笔记：Point-based-NeRF"><a href="#视频笔记：Point-based-NeRF" class="headerlink" title="视频笔记：Point-based NeRF"></a>视频笔记：Point-based NeRF</h2><blockquote><p>【【综述】基于点的神经辐射场，用点云实现真实的新视角渲染】 <a href="https://www.bilibili.com/video/BV1LX4y1H7a1/?share_source=copy_web&amp;vd_source=5040c17d0665f566f786d3874bbfd13d">https://www.bilibili.com/video/BV1LX4y1H7a1/?share_source=copy_web&amp;vd_source=5040c17d0665f566f786d3874bbfd13d</a></p></blockquote><p><strong>PCD to NeRF：</strong></p><p><img src="/images/paper-reading-3d-gaussian-splatting.assets/image-20231220162009917.png"></p><p><strong>NeRF to PCD：</strong></p><p><img src="/images/paper-reading-3d-gaussian-splatting.assets/image-20231220162628110.png"></p><blockquote><p>弹幕讨论：这里说的点云更容易接入SLAM的优势不成立，现在很多SLAM的前端也都是基于2D Image来估计位姿的</p></blockquote><p><strong>相关工作：</strong></p><blockquote><p>我觉得这里面最重要的是Plenoxels和Point-NeRF，这两个工作后面还需要好好了解。</p></blockquote><p><img src="/images/paper-reading-3d-gaussian-splatting.assets/image-20231220204222632.png"></p><p><img src="/images/paper-reading-3d-gaussian-splatting.assets/image-20231220204200344.png"></p><p><img src="/images/paper-reading-3d-gaussian-splatting.assets/image-20231220164344891.png"></p><blockquote><p>感觉就像是，把feature grid换成了点云，取采样点一定半径内的点云特征向量进行插值，再用小MLP解码。</p></blockquote><p><img src="/images/paper-reading-3d-gaussian-splatting.assets/image-20231220164600991.png"></p><blockquote><p>问题：</p><ul><li><p>查询MLP的次数和原版NeRF差不多，拖慢了渲染速度；</p><p>比如，这里可以用上SNeRG[20] Baking Neural Radiance Fields for Real-Time View Synthesis. ICCV 2021. 这样的延迟渲染模型来加速，把一条射线上的采样点的特征融合之后再拿去解码，从而减少MLP查询次数；</p></li><li><p>点云密度和渲染质量之间需要平衡；</p><ul><li>点云密度高，显存占用增加</li><li>降低点云密度，会降低渲染质量</li></ul><p>小模型这样的问题不明显，但是场景扩大就有问题了；</p></li></ul></blockquote><p><img src="/images/paper-reading-3d-gaussian-splatting.assets/image-20231220165848975.png"></p><blockquote><p>随着地图的扩展，需要合适的策略平滑点云的密度，并且自适应的对点云分布进行调整；</p><p>Point-NeRF里面有对点云的生长和修建，但这是为了补全模型、剔除外点，而且效率并不高，因为点的变动就意味着这个局部位置相关的神经描述子都得再次优化。</p><p>Point-SLAM的遗憾：</p><ul><li>没有针对Point-NeRF的问题做些什么；</li><li>没有用上基于特征点的视觉里程计来进行位姿估计，后端已经是点云估计模型了，而前端还在用基于优化的这种很低效的方法</li><li>不过使用视觉里程计前端，那么前端的几何特征怎么和后端的神经描述子相统一或融合，也是值得研究的问题</li></ul></blockquote><p><img src="/images/paper-reading-3d-gaussian-splatting.assets/image-20231220170921117.png"></p><blockquote><p>用CG的很多成熟的工具加速了Point-NeRF的很多流程，非常讨巧</p></blockquote><p><strong>总结：</strong></p><p><img src="/images/paper-reading-3d-gaussian-splatting.assets/image-20231220171425698.png"></p><blockquote><p>我发现如果结合点云的话，CG里面有很多现成的工具可以用，点云是一个把CG和CV结合起来的桥梁。</p></blockquote><h2 id="视频笔记：3D-Gaussian-Splatting"><a href="#视频笔记：3D-Gaussian-Splatting" class="headerlink" title="视频笔记：3D Gaussian Splatting"></a>视频笔记：3D Gaussian Splatting</h2><blockquote><p>【【论文讲解】用点云结合3D高斯构建辐射场，成为快速训练、实时渲染的新SOTA！】 <a href="https://www.bilibili.com/video/BV1uV4y1Y7cA/?share_source=copy_web&amp;vd_source=5040c17d0665f566f786d3874bbfd13d">https://www.bilibili.com/video/BV1uV4y1Y7cA/?share_source=copy_web&amp;vd_source=5040c17d0665f566f786d3874bbfd13d</a></p></blockquote><p>这个视频讲的比较简单，主要着力于公式推导方面，所以笔记就不做了。后面加到论文阅读笔记里面。</p><h2 id="论文阅读笔记"><a href="#论文阅读笔记" class="headerlink" title="论文阅读笔记"></a>论文阅读笔记</h2><blockquote><p>主要是梳理整篇论文的结构，对一些细节的讨论不会展开。</p><blockquote><p>第7部分由于我没有做过相关的实验，所以暂时只对Limitations感兴趣，只整理这部分的笔记；</p><p>附录的公式推导感觉也很常规，不太需要做什么笔记整理。</p></blockquote><p>后续可能会针对某些部分写新的文章进行讨论，并且会整理需要了解的一些相关工作。</p></blockquote><h3 id="0-ABSTRACT-amp-1-INTRODUCTION"><a href="#0-ABSTRACT-amp-1-INTRODUCTION" class="headerlink" title="0 ABSTRACT&amp; 1 INTRODUCTION"></a>0 ABSTRACT&amp; 1 INTRODUCTION</h3><p><strong>Background</strong></p><p>论文指出，常见的3D场景表示方法，mesh和point都是显示的，并且非常适合fast GPU/CUDA-based rasterization。而NeRF的方法建立在连续场景表示的基础上，通常通过对体积射线行进的多层感知器（MLP）进行优化，以实现对捕捉场景的新视图合成，但是这些方法在渲染过程中需要进行的随机采样成本昂贵，可能导致图像中的噪声。</p><p><strong>Motivation</strong></p><p>论文发现了以下三个问题：</p><ol><li><strong>高成本的训练和渲染：</strong> 传统的Radiance Field方法通常需要昂贵的训练和渲染成本，限制了其在实际应用中的可行性。</li><li><strong>速度与质量的权衡：</strong> 最近的更快方法通常在速度和合成质量之间做出权衡，难以在实时性和高质量之间找到平衡。</li><li><strong>对于无边界和完整场景的实时显示：</strong> 针对无边界和完整场景的合成，特别是在高分辨率（1080p）下，目前的方法无法实现实时显示。</li></ol><p><strong>Goal</strong></p><p>对此，论文提出了本文的目标：在Radiance Field方法中提出一种综合的解决方案，以克服传统方法中存在的训练和渲染成本高昂、速度与质量之间的权衡问题，实现对捕获场景的实时高质量新视角合成。</p><p><strong>Solutions</strong></p><ol><li><strong>3D Gaussians作为场景表示：</strong> 论文的第一组成部分引入了3D Gaussians作为一种灵活而富有表现力的场景表示方法。作者首先使用与以前的NeRF-like方法相同的输入，即通过结构从运动（Structure-from-Motion，SfM）[Snavely等人，2006]进行校准的相机，并使用SfM过程中产生的稀疏点云初始化了3D Gaussians集合。与大多数基于点的解决方案需要多视图立体匹配（Multi-View Stereo，MVS）数据不同，作者仅使用SfM点作为输入，就能够获得高质量的结果。作者强调3D Gaussians的优越性，因为它们是可微的体积表示，但也可以通过投影到2D并应用标准的 𝛼-混合（alpha-blending）非常高效地光栅化，使用与NeRF相同的等效图像形成模型。</li><li><strong>3D Gaussians属性优化和密度控制：</strong> 该方法的第二个组成部分涉及对3D Gaussians的属性进行优化，包括3D位置、不透明度𝛼、各向异性协方差和球谐（Spherical Harmonic，SH）系数。这些优化与自适应密度控制步骤交替进行，其中在优化过程中添加和偶尔删除3D Gaussians。这一优化过程产生了场景的合理紧凑、非结构化和精确表示（在测试的所有场景中，1-5百万个高斯函数）。</li><li><strong>实时渲染解决方案：</strong> 该方法的第三个和最后一个元素是实时渲染解决方案，使用快速GPU排序算法，灵感来自基于瓦片的光栅化的最新工作[Lassner和Zollhofer，2021]。由于采用了3D Gaussians表示，作者能够执行各向异性喷溅，通过排序和𝛼混合来保持可见性顺序，并通过跟踪所需的已排序喷溅的遍历来实现快速且准确的反向传播。这一部分的设计使得论文的方法能够实现对多个先前发布数据集的SOTA质量的实时渲染，尤其是在1080p分辨率下。</li></ol><p>总体来说，这三个组成部分共同构成了一种新颖而高效的方法，通过综合运用3D Gaussians表示、属性优化与密度控制，以及实时渲染解决方案，成功地解决了现有方法在速度和质量之间的权衡问题。</p><p><strong>Contributions</strong></p><ol><li><strong>引入各向异性的3D Gaussians：</strong> 论文首次引入了各向异性的3D Gaussians，作为对辐射场的高质量、非结构化的表示。这种表示方法具有灵活性和表现力，为场景提供了一种新的、优越的建模方式。</li><li><strong>3D Gaussians属性优化和自适应密度控制：</strong> 论文提供了一种优化3D Gaussians属性的方法，与自适应密度控制相互交替，从而创建了对捕获场景的高质量表示。这一优化过程确保了对场景的紧凑、非结构化和准确的建模，同时在训练过程中具有竞争力的时间成本。</li><li><strong>快速、可微的GPU渲染方法：</strong> 论文提供了一种快速的、可微的GPU渲染方法，该方法具有视觉感知性，允许各向异性的喷溅，并通过快速的反向传播实现了高质量的新视图合成。这一渲染方法对GPU进行了优化，能够在实时性和视觉质量之间找到平衡，实现了对1080p分辨率下的多个数据集的先进质量的实时渲染。</li></ol><h3 id="2-RELATED-WORK"><a href="#2-RELATED-WORK" class="headerlink" title="2 RELATED WORK"></a>2 RELATED WORK</h3><blockquote><p>据说这篇论文Related Work写的很好，我结合Chart GPT把这部分总结一下。</p></blockquote><h4 id="2-1-Traditional-Scene-Reconstruction-and-Rendering"><a href="#2-1-Traditional-Scene-Reconstruction-and-Rendering" class="headerlink" title="2.1 Traditional Scene Reconstruction and Rendering"></a>2.1 Traditional Scene Reconstruction and Rendering</h4><p>在这个部分，作者首先回顾了传统的场景重建和渲染方法：</p><ol><li><strong>基于光场的方法：</strong> 早期的新视角合成方法基于光场，首先是对光场进行密集采样[Gortler等人，1996；Levoy和Hanrahan，1996]，然后发展到允许非结构化捕获[Buehler等人，2001]。这一方法的进展使得对场景的不同角度的合成变得可能。</li><li><strong>结构运动（Structure-from-Motion，SfM）的出现：</strong> SfM的出现开创了一个全新的领域，其中可以使用一系列照片来合成新的视图[Snavely等人，2006]。在相机校准期间，SfM估计了一个稀疏点云，最初用于简单的三维空间可视化。</li><li><strong>多视图立体匹配（Multi-View Stereo，MVS）：</strong> 随后的多视图立体匹配（MVS）算法在多年内产生了引人注目的全三维重建算法[Goesele等人，2007]，为多种视图合成算法的发展提供了基础[Chaurasia等人，2013；Eisemann等人，2008；Hedman等人，2018；Kopanas等人，2021]。这些方法通过将输入图像重新投影并混合到新视图相机中，并利用几何信息来引导这一重新投影。尽管这些方法在许多情况下产生了出色的结果，但通常无法完全恢复未重建区域，或者无法处理MVS生成虚构几何的“过度重建”。</li><li><strong>最近的神经渲染算法：</strong> 近期的神经渲染算法[Tewari等人，2022]在很大程度上减少了这些伪影，并避免了在GPU上存储所有输入图像的巨大成本，从而在大多数方面优于传统方法。</li></ol><p>这一部分提供了关于传统场景重建和渲染方法的概述，强调了SfM和MVS的作用，并引入了最近的神经渲染算法，为读者提供了背景知识，以便更好地理解接下来讨论的新方法。</p><h4 id="2-2-Neural-Rendering-and-Radiance-Fields"><a href="#2-2-Neural-Rendering-and-Radiance-Fields" class="headerlink" title="2.2 Neural Rendering and Radiance Fields"></a>2.2 Neural Rendering and Radiance Fields</h4><p>首先讨论深度学习技术在新视角合成方面的早期应用，以及一些问题和限制，这为引入Radiance Fields方法提供了一个背景，强调了Radiance Fields方法旨在克服这些问题：</p><ol><li><strong>早期深度学习在新视角合成中的应用：</strong> 作者指出，深度学习技术早期就被用于新视角合成[Flynn等人，2016；Zhou等人，2016]。具体而言，卷积神经网络（CNNs）被用于估计混合权重[Hedman等人，2018]，或者用于纹理空间的解决方案[Riegler和Koltun，2020；Thies等人，2019]。</li><li><strong>MVS-based geometry的主要缺陷：</strong> 作者指出，这些方法中大多数采用了基于多视图立体匹配（MVS）的几何信息，但强调了这一方法的一个主要缺陷。具体而言，使用MVS的几何信息可能存在一些问题或限制，尽管这并未在这一段具体阐述。</li><li><strong>CNNs用于最终渲染的潜在问题：</strong> 作者提到，将CNNs用于最终渲染的方法经常导致时间上的闪烁现象（temporal flickering）。这表明在这些方法中，使用深度学习进行最终渲染时可能出现视觉上不稳定的问题。</li></ol><p>接下来，作者讨论了新视角合成中的体积表示方法，特别是涉及到Soft3D、Neural Radiance Fields (NeRFs)以及Mip-NeRF360等方法：</p><ol><li><strong>体积表示的起源：</strong> 作者提到，对于新视角合成的体积表示方法的起源可以追溯到Soft3D[Pennser和Zhang，2017]。Soft3D采用了深度学习技术，并结合了体积射线行进，用一个连续可微的密度场表示几何。</li><li><strong>深度学习与体积射线行进的结合：</strong> 随后，一些研究提出了采用深度学习技术与体积射线行进相结合的方法[Henzler等人，2019；Sitzmann等人，2019]，这些方法基于连续可微的密度场来表示几何形状。然而，使用体积射线行进进行渲染需要大量的样本，因此渲染的成本相当高。</li><li><strong>Neural Radiance Fields (NeRFs)的引入：</strong> Neural Radiance Fields (NeRFs) [Mildenhall等人，2020]引入了重要性采样和位置编码以提高渲染质量，但是采用了大型的多层感知器（Multi-Layer Perceptron），对速度产生了负面影响。</li><li><strong>NeRF方法的影响：</strong> NeRF的成功引发了许多后续方法的出现，这些方法致力于解决质量和速度之间的平衡问题，通常通过引入正则化策略来实现。目前新视角合成中图像质量的最新进展是Mip-NeRF360[Barron等人，2022]。</li><li><strong>质量与速度的平衡：</strong> 作者指出，尽管Mip-NeRF360在渲染质量方面表现出色，但训练和渲染时间仍然非常长。作者声称他们的方法在提供等同或在某些情况下超越Mip-NeRF360的图像质量的同时，实现了快速的训练和实时渲染。</li></ol><p>在这之后，作者探讨了最近的方法在提高训练和/或渲染速度方面的一些设计选择，主要包括利用空间数据结构、不同的编码方式以及多层感知器（MLP）的容量调整。研究者们试图优化现有的方法，以在保持图像质量的同时提高方法的效率。这一多样性反映了领域中不断寻找速度和质量平衡的努力：</p><ol><li><strong>加速训练和渲染的设计选择：</strong> 作者指出，最近的方法在加速训练和渲染方面主要集中在三个设计选择上。这些选择涉及使用空间数据结构来存储（神经）特征，随后在体积射线行进过程中进行插值，采用不同的编码方式，以及调整MLP的容量。</li><li><strong>方法的多样性：</strong> 这些方法包括空间离散化的不同变体[Chen等人，2022b,a；Fridovich-Keil和Yu等人，2022；Garbin等人，2021；Hedman等人，2021；Reiser等人，2021；Takikawa等人，2021；Wu等人，2022；Yu等人，2021]，codebook[ Takikawa等人，2022]以及使用哈希表等编码[Müller等人，2022]的方法，允许使用较小的MLP或完全放弃神经网络[Fridovich-Keil和Yu等人，2022；Sun等人，2022]。</li></ol><p>最后，作者介绍了两个最著名的方法，即InstantNGP和Plenoxels，并对它们的特点进行了讨论：</p><ol><li><strong>InstantNGP：</strong> InstantNGP [Müller等人，2022] 是使用哈希网格和占用网格来加速计算的方法。它采用较小的MLP来表示密度和外观。该方法使用球谐函数（Spherical Harmonics）直接表示方向效应。</li><li><strong>Plenoxels：</strong> Plenoxels [Fridovich-Keil和Yu等人，2022] 则采用了稀疏的体素网格来插值一个连续的密度场，并且可以完全放弃神经网络。Plenoxels 也依赖于球谐函数，前者用于直接表示方向效应，后者用于将输入编码到颜色网络。</li><li><strong>方法的局限性：</strong> 尽管这两种方法提供了出色的结果，但它们仍然可能在有效表示空白空间方面遇到困难，这在一定程度上取决于场景/捕获类型。此外，图像质量很大程度上受限于用于加速的结构化网格的选择，而渲染速度则受到需要查询许多样本以进行给定射线行进步骤的影响。</li><li><strong>作者的方法：</strong> 作者声称，他们所采用的非结构化、明确的GPU友好的3D高斯方法可以在没有神经组件的情况下实现更快的渲染速度和更好的质量。这表明作者的方法旨在解决一些现有方法可能遇到的问题，如空白空间表示和结构化网格对图像质量和渲染速度的影响。</li></ol><h4 id="2-3-Point-Based-Rendering-and-Radiance-Fields"><a href="#2-3-Point-Based-Rendering-and-Radiance-Fields" class="headerlink" title="2.3 Point-Based Rendering and Radiance Fields"></a>2.3 Point-Based Rendering and Radiance Fields</h4><blockquote><p>这部分Chart GPT表现得很差，总结的不太到位。</p></blockquote><p>在这个部分，作者首先介绍了基于点云的渲染方法：</p><ol><li><strong>点云渲染的有效性：</strong> 作者指出，基于点的方法能够高效地渲染断开连接（disconnected）和非结构化的几何样本（unstructured geometry samples），即点云[Gross和Pfister，2011]。</li><li><strong>点采样渲染的简单形式：</strong> 在其最简单的形式中，点采样渲染[Grossman和Dally，1998]会对一组具有固定大小的非结构化点进行光栅化。该过程可能利用图形API本地支持的点类型[Sainz和Pajarola，2004]，也可能在GPU上通过并行软件光栅化[Laine和Karras，2011；Schütz等人，2022]进行。</li><li><strong>点采样渲染的问题：</strong> 尽管点采样渲染在保持底层数据的真实性方面表现出色，但它存在一些问题，包括出现孔洞、导致走样，并且严格是不连续的。</li><li><strong>高质量的点渲染方法：</strong> 为了解决这些问题，关于高质量点渲染的开创性工作采用了一种称为“splatting”的方法，该方法将点原语映射为超过一个像素的范围，例如圆形或椭圆形盘、椭球体或曲面元素[Botsch等人，2005；Pfister等人，2000；Ren等人，2002；Zwicker等人，2001b]。</li></ol><p>之后开始介绍最近对可微分基于点云的渲染技术开展的研究工作：</p><ol><li><strong>可微分的点渲染技术的近期兴趣：</strong> 作者指出了对不同iable point-based rendering techniques（可微分的基于点的渲染技术）的最近兴趣。引文[Wiles等人，2020；Yifan等人，2019]可能是与这一领域相关的最新研究，表明了学术界对这种技术的关注。</li><li><strong>点云增强和神经网络渲染：</strong> 该部分提到了点云被增强为神经特征，并使用卷积神经网络（CNN）进行渲染的技术。引文[Aliev等人，2020；Rückert等人，2022]可能提供了这些技术的实现细节和背后的原理。这些方法可以实现快速甚至实时的视图合成，但仍然依赖于多视图立体匹配（MVS）以获取初始几何信息，因此在一些难以处理的情况下，例如无特征/闪光区域或细小结构中，仍然会受到MVS的影响，尤其是过度或不足的重建。</li><li><strong>依赖MVS的局限性：</strong> 作者强调了这些可微分的点渲染技术的一个局限性，即它们仍然依赖于多视图立体匹配（MVS）来获得初始几何信息。这种依赖可能导致一些问题，特别是在处理一些复杂场景时，如缺乏特征或表面反射光滑的区域，以及细小结构。在这些情况下，MVS可能会产生过度或不足的重建，从而影响最终的渲染效果。</li></ol><p>进行了上面的一些铺垫之后，作者开始指出<strong>基于点云的 𝛼-blending 和 NeRF 风格的体积渲染本质上共享相同的图像形成模型，但是图像的渲染算法却不同</strong>：</p><ul><li>NeRF是一种连续表示，隐式地表示了空/占用的空间，为了渲染图象，需要进行昂贵的随机采样，从而导致噪声和计算开销。</li><li>而点云是一种非结构化、离散的表示，足够灵活，可以允许几何体的创建、销毁和移动。</li></ul><p>之后，作者开始讨论快速渲染相关的工作：</p><ul><li>Pulsar [Lassner and Zollhofer 2021] 实现了快速的球体光栅化，这启发了作者开发瓦片和排序渲染器。在上文的分析基础上，作者决定保持对排序点进行（近似的）传统 𝛼-混合，这一决策旨在保留体积表示的优势。作者的光栅化过程在处理排序后的点时尊重能见度顺序，与 Pulsar 的无序方法形成对比。</li><li>前述提到的其他方法使用卷积神经网络（CNNs）进行渲染，但这可能导致时间上的不稳定性。尽管如此，Pulsar [Lassner and Zollhofer 2021] 和 ADOP [Rückert et al. 2022] 的渲染速度仍然作为激发因素，驱使作者开发出快速渲染解决方案。</li></ul><p>接下来作者讨论了一些相关的工作：</p><ol><li><strong>Neural Point Catacaustics [Kopanas et al. 2022]的特点：</strong><ul><li>该方法专注于处理镜面效果。在扩散点渲染方面，通过使用多层感知器（MLP），该方法克服了渲染过程中的时间不稳定性。然而，仍然需要多视图立体匹配（MVS）几何作为输入。</li></ul></li><li><strong>最新方法 [Zhang et al. 2022] 的特点：</strong><ul><li>在同一类别中，最近的方法[Zhang et al. 2022]不需要 MVS，并使用球谐（SH）来表示方向。然而，该方法只能处理单一物体的场景，并需要蒙版进行初始化。</li><li>尽管在小分辨率和低点数的情况下渲染速度较快，但对于典型数据集的场景如何扩展仍然不明确，特别是在处理典型数据集[Barron et al. 2022; Hedman et al. 2018; Knapitsch et al. 2017]时的表现。、</li></ul></li><li><strong>最新方法 [Xu et al. 2022] 的特点：</strong><ul><li>这一最新的方法使用点来表示一个辐射场，采用径向基函数方法。</li><li>在优化过程中，该方法采用了点修剪和稠密化技术。尽管采取了这些优化措施，但该方法仍然使用体积光线投射（volumetric ray-marching），无法达到实时显示速率。</li></ul></li><li><strong>作者的方法的优势：</strong><ul><li>作者采用了三维高斯分布作为更灵活的场景表示，避免了对MVS几何的需求，并通过瓦片渲染算法实现了对投影高斯分布的实时渲染。这使得他们的方法在实时渲染方面具有优势。</li></ul></li></ol><p>最后作者提到了自己为什么选择选择3D高斯分布：</p><ol><li><strong>在人体性能捕捉领域的应用：</strong><ul><li>3D高斯分布曾被用于表示捕捉到的人体[Rhodin et al. 2015; Stoll et al. 2011]，最近还在视觉任务中与体积光线投射一起使用[Wang et al. 2023]。</li><li>在类似的背景下，一些方法提出了神经体积基元[Lombardi et al. 2021]。这些方法启发了选择3D高斯分布作为场景表示的决策。</li></ul></li><li><strong>对比与其他方法的区别：</strong><ul><li>虽然这些方法启发了选择3D高斯分布，但它们主要专注于重建和渲染单个孤立对象（如人体或面部），导致场景具有较小的深度复杂性。</li><li>与之相反，作者的方法通过优化各向异性协方差、交错的优化/密度控制以及有效的深度排序渲染，使其能够处理完整、复杂的场景，包括室内外背景，并具有较大的深度复杂性。</li></ul></li></ol><h3 id="3-OVERVIEW"><a href="#3-OVERVIEW" class="headerlink" title="3 OVERVIEW"></a>3 OVERVIEW</h3><p><img src="/images/paper-reading-3d-gaussian-splatting.assets/image-20231220230130536.png"></p><ol><li><p><strong>输入：</strong></p><ul><li>方法的输入是一个静态场景的图像集，以及由SfM（Structure from Motion）[Schönberger and Frahm 2016]校准的相应相机，这产生了一个稀疏点云。</li><li>从这些点中，创建了一组3D高斯分布，这些高斯分布由位置（均值）、协方差矩阵和不透明度 𝛼 定义，从而实现了非常灵活的优化过程。</li></ul></li><li><p><strong>场景表示：</strong></p><ul><li>使用3D高斯分布对场景进行表示，包括位置、协方差矩阵和不透明度 𝛼。这使得可以灵活地进行优化，并在一定程度上实现了对3D场景的紧凑表示。</li><li>利用各向异性的体积斑点可以紧凑地表示细小结构。</li></ul></li><li><p><strong>辐射场的方向外观组件：</strong></p><ul><li>辐射场的方向外观组件（颜色）通过球谐函数（SH）表示，符合标准实践[Fridovich-Keil and Yu et al. 2022; Müller et al. 2022]。</li></ul></li><li><p><strong>辐射场表示的创建：</strong></p><ul><li>算法通过一系列对3D高斯分布参数的优化步骤进行辐射场表示的创建，包括位置、协方差、𝛼和SH系数的交替操作，以及用于自适应控制高斯密度的操作。</li></ul></li><li><p><strong>方法的效率关键：</strong></p><ul><li>方法的效率关键在于其基于瓦片的光栅化器，它允许各向异性斑点的 𝛼-混合，并通过快速排序实现了对可见性顺序的尊重。</li><li>快速光栅化器还包括一个快速的反向传递过程，通过跟踪累积的 𝛼 值，而不限制可以接收梯度的高斯分布的数量。</li></ul></li><li><p><strong>方法概览：</strong></p><p><strong>优化起点：</strong>优化的起点是稀疏的SfM点云，该点云通过优化生成一组3D高斯分布。</p><p><strong>密度自适应控制：</strong>对这组高斯分布进行密度的优化和自适应控制。</p><p><strong>光栅化器的运用：</strong>在优化过程中，使用了快速基于瓦片的渲染器，使得训练时间与当前领先的快速辐射场方法相比具有竞争力。</p><p><strong>训练后的渲染器：</strong>训练完成后，该渲染器能够实现对各种场景的实时导航，为用户提供高效的渲染性能。</p></li></ol><h3 id="4-DIFFERENTIABLE-3D-GAUSSIAN-SPLATTING"><a href="#4-DIFFERENTIABLE-3D-GAUSSIAN-SPLATTING" class="headerlink" title="4 DIFFERENTIABLE 3D GAUSSIAN SPLATTING"></a>4 DIFFERENTIABLE 3D GAUSSIAN SPLATTING</h3><blockquote><p>和GPT聊一聊$\exp\left(-\frac{1}{2} \mathbf{x}^T \boldsymbol{\Sigma}^{-1} \mathbf{x}\right)$，并且指定$\Sigma=RSS^TR^T$的情况下会发生什么。</p><p>链接：<a href="https://chat.openai.com/share/0cfb56e4-30a5-4bd8-9c23-89aa36660d7f">https://chat.openai.com/share/0cfb56e4-30a5-4bd8-9c23-89aa36660d7f</a></p><p>下面是聊的内容。</p></blockquote><ul><li><p>三维高斯分布的公式是什么？</p><p><img src="/images/paper-reading-3d-gaussian-splatting.assets/image-20231222145534792.png"></p></li><li><p>假设$\mu=0$，忽略掉除了exp()之外的东西，写出这个表达式</p><p><img src="/images/paper-reading-3d-gaussian-splatting.assets/image-20231222145611221.png"></p></li><li><p>忽略掉前面我们交流的内容，我们现在只看这个表达式： $\exp\left(-\frac{1}{2} \mathbf{x}^T \boldsymbol{\Sigma}^{-1} \mathbf{x}\right)$，请注意$x$是三维向量。这个表达式的几何意义是什么呢？</p><p><img src="/images/paper-reading-3d-gaussian-splatting.assets/image-20231222145651137.png"></p></li><li><p>为了继续讨论，接下来我们定义旋转矩阵$R$，缩放矩阵$S$，请注意我们讨论的都是在三维空间下。</p><p><img src="/images/paper-reading-3d-gaussian-splatting.assets/image-20231222150037855.png"></p></li><li><p>如果我令$\Sigma=RSS^TR^T$，那么此时的$\Sigma$对于高斯分布$\exp\left(-\frac{1}{2} \mathbf{x}^T \boldsymbol{\Sigma}^{-1} \mathbf{x}\right)$起了什么样的作用？</p><p><img src="/images/paper-reading-3d-gaussian-splatting.assets/image-20231222150124805.png"></p></li><li><p>具体来说不同的$R$和$S$将如何影响这个高斯分布？</p><p><img src="/images/paper-reading-3d-gaussian-splatting.assets/image-20231222150148188.png"></p></li><li><p>向量$x$对高斯分布有什么样的影响？</p><p><img src="/images/paper-reading-3d-gaussian-splatting.assets/image-20231222150219404.png"></p></li><li><p>那么，再给定$\Sigma=RSS^TR^T$的前提下，$\exp\left(-\frac{1}{2} \mathbf{x}^T \boldsymbol{\Sigma}^{-1} \mathbf{x}\right)$其实就是表示了在位置$\mathbf{x}$处的一个高斯分布，而且这个高斯分布接近一个椭球，椭球的形状受到了旋转矩阵R和缩放矩阵S的影响，我这样理解对吗？</p><p><img src="/images/paper-reading-3d-gaussian-splatting.assets/image-20231222150244397.png"></p></li></ul><h3 id="5-OPTIMIZATION-WITH-ADAPTIVE-DENSITY-CONTROL-OF-3D-GAUSSIANS"><a href="#5-OPTIMIZATION-WITH-ADAPTIVE-DENSITY-CONTROL-OF-3D-GAUSSIANS" class="headerlink" title="5 OPTIMIZATION WITH ADAPTIVE DENSITY CONTROL OF 3D GAUSSIANS"></a>5 OPTIMIZATION WITH ADAPTIVE DENSITY CONTROL OF 3D GAUSSIANS</h3><ol><li><strong>优化步骤核心</strong>：<ul><li>论文方法的核心在于优化步骤，其目标是创建一个密集的3D高斯集合，以准确表示用于自由视角合成的场景。</li></ul></li><li><strong>参数优化</strong>：<ul><li>优化的参数包括位置 (𝑝)、方向 (𝛼) 和协方差 (Σ)。</li><li>此外，还对代表每个高斯颜色 (𝑐) 的球谐系数（SH coefficients）进行优化，以正确捕捉场景的视角相关外观。</li></ul></li><li><strong>步骤交织</strong>：<ul><li>这些参数的优化过程与控制高斯密度的步骤交织在一起。</li><li>通过这种方式，实现对高斯密度的精细控制，以更好地表示场景。</li></ul></li></ol><h4 id="5-1-Optimization"><a href="#5-1-Optimization" class="headerlink" title="5.1 Optimization"></a>5.1 Optimization</h4><ol><li><strong>基于迭代的优化过程</strong>：<ul><li>优化的核心在于通过渲染和比较生成的图像与训练数据集中的视图进行迭代。</li><li>由于3D到2D投影的不确定性，可能导致几何元素被错误放置。</li><li>优化过程需要能够创建、破坏或移动几何元素，以纠正错误的位置。</li><li>3D高斯的协方差参数质量对表示的紧凑性至关重要，因为少量大型各向异性高斯可以捕捉大块均匀区域。</li></ul></li><li><strong>使用随机梯度下降的优化技术</strong>：<ul><li>采用随机梯度下降技术，充分利用GPU加速框架和自定义CUDA内核。</li><li>快速光栅化是优化过程的主要计算瓶颈。</li></ul></li><li><strong>激活函数的选择</strong>：<ul><li>对于方向𝛼，采用sigmoid激活函数，将其限制在 [0, 1) 范围内，并获得平滑的梯度。</li><li>对于协方差尺度，选择指数激活函数，同样是为了获得平滑的梯度。</li></ul></li><li><strong>初始协方差矩阵的估计和损失函数设计</strong>：<ul><li>估计初始协方差矩阵时，采用各向同性高斯，其轴长度由到最近的三个点的距离均值确定。</li><li>使用标准的指数衰减调度技术，但仅用于位置参数。</li><li>损失函数包括L1损失和D-SSIM项的组合，通过权衡参数𝜆 = 0.2进行组合。</li><li>有关学习调度和其他细节，详细信息可在第7.1节中找到。</li></ul></li></ol><p>通过以上步骤，优化过程能够克服3D到2D投影的不确定性，通过迭代优化提高场景表示的准确性，并通过自适应密度控制的手段灵活处理几何元素的位置，以实现更精确的场景合成。</p><h4 id="5-2-Adaptive-Control-of-Gaussians"><a href="#5-2-Adaptive-Control-of-Gaussians" class="headerlink" title="5.2 Adaptive Control of Gaussians"></a>5.2 Adaptive Control of Gaussians</h4><ol><li><p><strong>初始步骤</strong>：</p><ul><li>从Structure from Motion（SfM）获取初始稀疏点集。</li><li>通过自适应控制，调整高斯的数量和密度，从初始的稀疏高斯集合过渡到更密集的集合。</li></ul></li><li><p><strong>重点区域的控制</strong>：</p><p>自适应控制着眼于两种关键区域：</p><ul><li>“under-reconstruction”区域，即缺乏几何特征的区域。<ul><li>针对这些区域，自适应控制通过克隆操作调整高斯，以覆盖新创建的几何，确保这些区域能够得到更好的表示。</li></ul></li><li>“over-reconstruction”区域，即高斯覆盖大面积的区域。<ul><li>针对这些区域，通过分割操作将大的高斯替换为两个较小的高斯，以更好地适应场景中的细节和变化。</li></ul></li></ul><p>在这两种情况下，区域的视角空间位置梯度被用来指导高斯的调整，因为这些区域可能是场景中尚未充分重建或者已经过度重建的部分。</p></li><li><p><strong>密集化操作的条件</strong>：</p><ul><li>高斯密集化的条件是，具有视角空间位置梯度的平均幅度超过阈值 𝜏pos。</li><li>阈值设置为0.0002。</li></ul></li><li><p><strong>高斯调整的具体步骤</strong>：</p><ul><li>对于小高斯，位于“under-reconstructed”区域，通过克隆操作覆盖新创建的几何。</li><li>对于大高斯，位于高方差区域，通过分割操作替换为两个新的高斯，同时将它们的尺度缩小一个经验确定的因子 𝜙 = 1.6。</li></ul></li><li><p><strong>对高斯数量的控制</strong>：</p><ul><li>处理两种情况：一种增加系统总体积和高斯数量，另一种保持总体积不变但增加高斯数量。</li><li>避免浮点数接近输入相机时导致高斯密度不合理地增加的问题。</li><li>通过每3000次迭代将 𝛼 值设置接近零，然后根据需要增加 𝛼 值，并通过裁剪方法删除 𝛼 值小于 𝜖𝛼 的高斯。</li><li>定期删除在世界空间中非常大或在视图空间中占据大面积的高斯，以有效控制总高斯数量。</li></ul></li><li><p><strong>高斯的基本性质</strong>：</p><ul><li>高斯在Euclidean空间中保持为基元，不需要采用复杂的空间压缩、变形或投影策略。</li><li>与其他方法不同，该模型不要求对远距离或大型高斯采取额外处理的方法，保持了高斯在欧几里得空间中的基本特性。</li><li>这一特点使得模型更加直观和可理解，同时简化了整个处理流程，避免了复杂的空间变换对场景表示的不必要干预。</li></ul></li></ol><p>通过这一自适应控制的过程，能够更好地适应场景的几何特征，同时有效地控制高斯的数量和密度，确保了场景表示的准确性。</p><h3 id="6-FAST-DIFFERENTIABLE-RASTERIZER-FOR-GAUSSIANS"><a href="#6-FAST-DIFFERENTIABLE-RASTERIZER-FOR-GAUSSIANS" class="headerlink" title="6 FAST DIFFERENTIABLE RASTERIZER FOR GAUSSIANS"></a>6 FAST DIFFERENTIABLE RASTERIZER FOR GAUSSIANS</h3><ol><li><strong>设计目标和渲染流程概述</strong>：<ul><li>设计目标：实现快速渲染和排序，支持 𝛼 混合和各向异性斑点。</li><li>提出瓦片光栅化器，避免每像素排序的开销。</li><li>允许处理任意深度复杂度的场景，无需特定超参数调整。</li></ul></li><li><strong>瓦片光栅化流程</strong>：<ul><li>屏幕划分为16×16瓦片，3D Gaussians剔除和实例化。</li><li>利用GPU Radix排序，避免额外的每像素排序。</li><li>混合基于初始排序，无额外每像素排序，提高效率。</li></ul></li><li><strong>优化和并行处理</strong>：<ul><li>利用瓦片列表生成，线程块协同加载数据包。</li><li>并行处理数据加载/共享和处理，周期性检查线程和像素饱和，终止瓦片处理。</li><li>详细优化：<ul><li>利用共享内存协同加载数据包，提高数据加载效率。</li><li>定期检查线程和像素饱和，提前终止瓦片处理，节省计算资源。</li></ul></li></ul></li><li><strong>处理深度复杂度</strong>：<ul><li>允许任意深度复杂度的场景，无需特定超参数调整。</li><li>反向传播中通过遍历瓦片列表处理混合点序列，增加模型灵活性。</li><li>详细处理：<ul><li>反向传播期间，通过遍历瓦片列表处理混合点序列，适应不同深度复杂度的场景。</li></ul></li></ul></li><li><strong>高效的反向传播</strong>：<ul><li>从最后影响像素的点开始遍历，协同加载数据到共享内存。</li><li>优化：像素只处理深度低于或等于正向传播期间为其颜色做出贡献的最后一个点。</li><li>通过存储正向传播结束时的总累积不透明度，恢复中间不透明度，减少计算复杂性。</li><li>详细反向传播优化：<ul><li>从最后影响像素的点开始遍历，协同加载数据到共享内存，提高效率。</li><li>优化像素处理，只处理正向传播期间对颜色有贡献的点。</li><li>存储总累积不透明度，通过反向遍历计算中间不透明度，降低计算复杂性。</li></ul></li></ul></li></ol><h3 id="7-Limitations"><a href="#7-Limitations" class="headerlink" title="7 Limitations"></a>7 Limitations</h3><ol><li><strong>有限观测区域的问题</strong>：<ul><li>在场景观测不充分的区域可能出现伪影。</li><li>其他方法在类似情况下也存在困难，例如Mip-NeRF360的情况。</li></ul></li><li><strong>各向异性高斯的缺陷</strong>：<ul><li>各向异性高斯在某些情况下可能生成细长伪影或“斑点状”高斯。</li><li>先前的方法在类似情况下也存在困难。</li></ul></li><li><strong>大高斯生成的爆裂伪影</strong>：<ul><li>在创建大高斯时，可能偶尔出现“爆裂”伪影，尤其是在具有视角相关外观的区域。</li><li>爆裂伪影的一个原因是在光栅化器中通过防护带微不足道地拒绝高斯，引入更有原则的剔除方法可能有助于减轻这些伪影。</li><li>另一个因素是简单的可见性算法，可能导致高斯突然切换深度/混合顺序，这可以通过引入抗锯齿技术解决，但这是留作未来工作的。</li></ul></li><li><strong>缺乏优化的正则化</strong>：<ul><li>目前的优化过程没有应用任何正则化，这可能有助于处理未观测区域和爆裂伪影。</li><li>引入正则化被提出作为解决方案，有望改善这些问题。</li></ul></li><li><strong>同一超参数的使用</strong>：<ul><li>尽管在完整评估中使用了相同的超参数，早期实验表明，在非常大的场景（如城市数据集）中，减小位置学习速率可能是为了收敛而必要的。</li></ul></li><li><strong>相对紧凑但内存消耗较高</strong>：<ul><li>尽管与之前的基于点的方法相比，方法相对紧凑，但内存消耗明显高于NeRF等基于神经场景的解决方案。</li><li>优化逻辑的低级实现可能显著减少内存消耗。</li></ul></li><li><strong>训练和渲染的内存需求</strong>：<ul><li>渲染经过训练的场景需要足够的GPU内存来存储完整模型，以及额外的内存用于光栅化器。</li><li>存在许多降低内存消耗的机会，包括点云的压缩技术，这个领域是一个研究方向。</li></ul></li></ol><h3 id="8-DISCUSSION-AND-CONCLUSIONS"><a href="#8-DISCUSSION-AND-CONCLUSIONS" class="headerlink" title="8 DISCUSSION AND CONCLUSIONS"></a>8 DISCUSSION AND CONCLUSIONS</h3><ol><li><strong>创新性贡献</strong>：<ul><li>提出了首个真正允许在各种场景和捕捉风格中进行实时、高质量辐射场渲染的方法。</li><li>选择了3D高斯原语，既保留了优化的体积渲染特性，又直接实现了快速的基于splat的光栅化。</li></ul></li><li><strong>培训时间和性能</strong>：<ul><li>在培训时间方面与先前最快的方法相竞争，证明了方法的高效性。</li><li>大约80%的培训时间用于Python代码，为了方便其他人使用，方法构建在PyTorch上。</li><li>只有光栅化例程实现为优化的CUDA核。将其余优化完全移植到CUDA可能会在对性能要求很高的应用中实现显著的加速，例如InstantNGP。</li></ul></li><li><strong>实时渲染原则</strong>：<ul><li>展示了建立在实时渲染原则之上的重要性，充分利用GPU的性能和软件光栅化管线架构的速度。</li><li>这些设计选择是培训和实时渲染性能的关键，相对于先前的体积射线行进提供了竞争优势。</li></ul></li><li><strong>未来研究方向</strong>：<ul><li>探讨了高斯是否可用于执行捕捉场景的网格重建，以更好地了解方法在体积和表面表示之间的确切位置。</li><li>强调了对于网格的广泛使用，这可能具有实际意义。</li></ul></li><li><strong>结论</strong>：<ul><li>提出了首个实时辐射场渲染解决方案，其渲染质量与昂贵的先前方法相匹配，培训时间与最快的现有解决方案相竞争。</li></ul></li></ol><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>下面是一些可能有用的链接：</p><ul><li><p>3D Gaussian Splatting中的数学推导 - 八氨合氯化钙的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/666465701">https://zhuanlan.zhihu.com/p/666465701</a></p><blockquote><p>这篇文章非常不错，基本所有需要的公式推导都在这里了</p></blockquote></li><li><p>[NeRF坑浮沉记]3D Gaussian Splatting入门：如何表达几何 - 御币Soft的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/661569671">https://zhuanlan.zhihu.com/p/661569671</a></p><blockquote><p>这篇文章提到了一个以椭球为基础元素的游戏，很直观的感受了一下用椭球表达场景是什么样子</p></blockquote></li><li><p>Splatting 抛雪球法简介 - bo233的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/660512916">https://zhuanlan.zhihu.com/p/660512916</a></p><blockquote><p>3D Gaussian Splatting这篇论文的公式是真的少，Splatting这部分可以借助这篇文章了解一下</p></blockquote></li><li><p>《3D Gaussian Splatting for Real-Time Radiance Field Rendering》3D高斯的理论理解 - 剪月光者的文章 - 知乎<br><a href="https://zhuanlan.zhihu.com/p/664725693">https://zhuanlan.zhihu.com/p/664725693</a></p><blockquote><p>可以作为前面对3D Gaussian的补充</p></blockquote></li><li><p>A beginner friendly introduction to 3D Gaussian Splats and tutorial on how to train them</p><p><a href="https://www.reshot.ai/3d-gaussian-splatting">https://www.reshot.ai/3d-gaussian-splatting</a></p><blockquote><p>一个很详细的教程，虽然3D Gaussian Splatting的README写的也很详细</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> NeRF&amp;3DGS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式表示 </tag>
            
            <tag> 3D Gaussian Splatting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NeRF based SLAM学习笔记（5）：NICE-SLAM源码阅读笔记（1）</title>
      <link href="2023/08/16/nerf-slam-4/"/>
      <url>2023/08/16/nerf-slam-4/</url>
      
        <content type="html"><![CDATA[<p><strong>内容：</strong></p><ul><li>系统架构：NICE-SLAM是如何运行的</li><li>网络模型：网络是如何具体实现的</li><li>渲染：网络输出是怎么渲染得到图像和深度图的</li></ul><p><strong>代码：</strong><code>NICE-SLAM.py</code>、<code>decoder.py</code>、<code>Renderer.py</code>、<code>common.py</code></p><h1 id="NeRF-based-SLAM学习笔记（5）：NICE-SLAM源码阅读笔记（1）"><a href="#NeRF-based-SLAM学习笔记（5）：NICE-SLAM源码阅读笔记（1）" class="headerlink" title="NeRF based SLAM学习笔记（5）：NICE-SLAM源码阅读笔记（1）"></a>NeRF based SLAM学习笔记（5）：NICE-SLAM源码阅读笔记（1）</h1><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p><img src="/images/nerf-slam-4/image-20230801210340053-1691895051979-1.png"></p><p><strong>演示</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 展示训练的运行效果（Demo数据集，服务器）</span>python <span class="token parameter variable">-W</span> ignore run.py configs/Demo/demo.yaml<span class="token comment"># 展示可视化的运行效果（Apartment数据集，本机）</span>python visualizer.py configs/Apartment/apartment.yaml <span class="token parameter variable">--output</span> output/vis/Apartment<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="函数def-grid-init-self-cfg"><a href="#函数def-grid-init-self-cfg" class="headerlink" title="函数def grid_init(self, cfg)"></a>函数<code>def grid_init(self, cfg)</code></h4><p><strong>论文对应部分</strong>：附录A.2. Hierarchical Feature Grid Initialization</p><ul><li><p><strong>Coarse-level Feature Grid：</strong>随机初始化；</p></li><li><p><strong>Mid-level Feature Grid：</strong>也是随机初始化的，经验表明随机初始化具有更好的收敛性；</p></li><li><p><strong>Fine-level Feature Grid：</strong>需要初始化到fine-level的decoder输出为0，毕竟这里给出来的是残差，初始化的残差肯定要是0。这样才能够保证从coarse-to-fine的优化过程中，能量是平稳过渡的。论文也提到，在对fine-level对应的decoder进行预训练的时候，增加了额外的正则化损失，保证如果fine-level的特征为0，那么无论mid-level的特征如何，输出的残差都应该为0。这样能够允许NICE-SLAM在运行的时候对fine-level的特征网格进行零初始化。</p></li></ul><p><strong>演示</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment"># 加载bound</span>bound<span class="token operator">=</span>torch<span class="token punctuation">.</span>from_numpy<span class="token punctuation">(</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">5.8</span><span class="token punctuation">,</span><span class="token number">11.3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">4.0</span><span class="token punctuation">,</span><span class="token number">4.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">7.9</span><span class="token punctuation">,</span><span class="token number">4.9</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token comment"># 分别计算xyz轴的长度</span>xyz_len <span class="token operator">=</span> bound<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> bound<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token comment"># ============ 初始化一个特征网格 ============</span><span class="token comment"># coarse要特别注意一下，有一个enlarge</span><span class="token comment"># val_shape=list(map(int, (np.array(xyz_len * 2 / 3).tolist())))</span><span class="token comment"># middle、fine、color</span>val_shape<span class="token operator">=</span><span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5.6</span><span class="token punctuation">,</span><span class="token number">7.5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">0.16</span><span class="token punctuation">)</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 交换XZ轴数据</span>val_shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> val_shape<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> val_shape<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> val_shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token comment"># 定义特征网格的shape，即BCDHW</span>grid_val_shape <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token operator">*</span>val_shape<span class="token punctuation">]</span><span class="token comment"># 初始化特征网格</span>feature_grid<span class="token operator">=</span>torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>grid_val_shape<span class="token punctuation">)</span><span class="token punctuation">.</span>normal_<span class="token punctuation">(</span>mean<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> std<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">)</span><span class="token comment"># 对于fine-level，特征尽量接近0</span><span class="token comment"># feature_grid=torch.zeros(grid_val_shape).normal_(mean=0, std=0.0001)</span><span class="token comment"># ============ 演示特征网格的使用 ============ </span><span class="token comment"># 初始化特征网格</span>feature_grid<span class="token operator">=</span>torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>normal_<span class="token punctuation">(</span>mean<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> std<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">)</span><span class="token comment"># 提取某个点的特征</span>feature<span class="token operator">=</span>feature_grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><h4 id="类class-NICE-nn-Module"><a href="#类class-NICE-nn-Module" class="headerlink" title="类class NICE(nn.Module)"></a>类<code>class NICE(nn.Module)</code></h4><p><strong>论文对应部分：</strong>3.1. Hierarchical Scene Representation</p><img src="/images/nerf-slam-4/2023-08-13 12-01-49 的屏幕截图.png" style="zoom:50%;"><p><strong>对<code>def forward(self, p, c_grid, stage='middle', **kwargs)</code>的理解：</strong></p><p>这部分主要服务于论文介绍的<strong>3.3. Mapping and Tracking</strong>，每个stage应该是和优化相关的，而不是和论文里提到的middle-leve、fine-level的输出相关。</p><p>下面是论文提到的Mapping阶段的三阶段优化：</p><img src="/images/nerf-slam-4/2023-08-13 12-06-56 的屏幕截图.png" alt="2023-08-13 12-06-56 的屏幕截图" style="zoom: 50%;"><p><strong>演示</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torchraw <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token punctuation">)</span>raw<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0.5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="类class-MLP-nn-Module-和类class-MLP-no-xyz-nn-Module"><a href="#类class-MLP-nn-Module-和类class-MLP-no-xyz-nn-Module" class="headerlink" title="类class MLP(nn.Module)和类class MLP_no_xyz(nn.Module)"></a>类<code>class MLP(nn.Module)</code>和类<code>class MLP_no_xyz(nn.Module)</code></h4><blockquote><p>可以把nerf-pytorch的代码拿过来简单对比一下</p></blockquote><p><strong>相关链接：</strong></p><ul><li>ConvONet论文：<a href="https://arxiv.org/pdf/2003.04618.pdf">https://arxiv.org/pdf/2003.04618.pdf</a></li><li>ConvONet代码：<a href="https://github.com/autonomousvision/convolutional_occupancy_networks/blob/master/src/conv_onet/models/decoder.py">https://github.com/autonomousvision/convolutional_occupancy_networks/blob/master/src/conv_onet/models/decoder.py</a></li><li>类<code>GaussianFourierFeatureTransform</code>对应的论文：<a href="https://arxiv.org/abs/2006.10739">https://arxiv.org/abs/2006.10739</a></li></ul><p><strong>演示“sample_grid_feature”的过程</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>functional <span class="token keyword">as</span> Fp_nor<span class="token operator">=</span>torch<span class="token punctuation">.</span>from_numpy<span class="token punctuation">(</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>    <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">0.</span> <span class="token punctuation">,</span>  <span class="token number">0.</span> <span class="token punctuation">,</span>  <span class="token number">0.</span> <span class="token punctuation">]</span><span class="token punctuation">,</span>     <span class="token punctuation">[</span> <span class="token number">0.1</span><span class="token punctuation">,</span>  <span class="token number">0.2</span><span class="token punctuation">,</span>  <span class="token number">0.3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>     <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.6</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.7</span><span class="token punctuation">]</span><span class="token punctuation">,</span>     <span class="token punctuation">[</span> <span class="token number">1.</span> <span class="token punctuation">,</span>  <span class="token number">0.</span> <span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>unsqueeze<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment"># [1, 4, 3] </span><span class="token comment"># [1,point_num,3]</span>vgrid <span class="token operator">=</span> p_nor<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># [1, 4, 1, 1, 3] </span><span class="token comment"># [1,point_num,1,1,3]</span>feature_grid<span class="token operator">=</span>torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>normal_<span class="token punctuation">(</span>mean<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> std<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">)</span><span class="token comment"># [1,8,2,3,4]</span><span class="token comment"># [1,c_dim,D,H,W]</span>c <span class="token operator">=</span> F<span class="token punctuation">.</span>grid_sample<span class="token punctuation">(</span>feature_grid<span class="token punctuation">,</span> vgrid<span class="token punctuation">,</span> padding_mode<span class="token operator">=</span><span class="token string">'border'</span><span class="token punctuation">,</span> align_corners<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'bilinear'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment"># [1,8,4]</span><span class="token comment"># [1,c_dim,point_num]</span>c <span class="token operator">=</span> c<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment"># [point_num,c_dim]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><h4 id="函数render-batch-ray"><a href="#函数render-batch-ray" class="headerlink" title="函数render_batch_ray"></a>函数<code>render_batch_ray</code></h4><p>near和far可以参考NeRF论文这个部分：</p><p>![](/images/nerf-slam-4/2023-08-13 17-12-46 的屏幕截图.png)</p><p>z_vals_surface可以参考NICE-SLAM论文<strong>3.2. Depth and Color Rendering</strong></p><p>![](/images/nerf-slam-4/2023-08-13 17-57-52 的屏幕截图.png)</p><p><strong>演示near的获取</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token comment"># 假设只有三条射线，然后采样的数量N_samples=10</span>gt_depth<span class="token operator">=</span>torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>gt_depth <span class="token operator">=</span> gt_depth<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 展开成向量</span>gt_depth_samples <span class="token operator">=</span> gt_depth<span class="token punctuation">.</span>repeat<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>near <span class="token operator">=</span> gt_depth_samples <span class="token operator">*</span> <span class="token number">0.01</span>  <span class="token comment"># 每条射线的near根据这条射线对应的深度确定</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>演示far_bb的获取</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token comment"># bound</span>bound<span class="token operator">=</span>torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># 假设只有两条射线</span><span class="token comment"># det_rays_o</span>det_rays_o<span class="token operator">=</span>torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># det_rays_d</span>det_rays_d<span class="token operator">=</span>torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0.1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># t的计算</span>t <span class="token operator">=</span> <span class="token punctuation">(</span>bound <span class="token operator">-</span> det_rays_o<span class="token punctuation">)</span>t <span class="token operator">=</span> t <span class="token operator">/</span> det_rays_d<span class="token comment"># far_bb的计算</span>torch<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>torch<span class="token punctuation">.</span><span class="token builtin">min</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>演示z_vals_surface的获取</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token comment"># ========== 有深度区域 ==========</span><span class="token comment"># 假设只有五条射线，其中两条条射线没有深度，表面附近采样的数量N_surface=10</span>gt_depth<span class="token operator">=</span>torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># 拿到有深度的部分</span>gt_none_zero_mask <span class="token operator">=</span> gt_depth <span class="token operator">&gt;</span> <span class="token number">0</span>gt_none_zero <span class="token operator">=</span> gt_depth<span class="token punctuation">[</span>gt_none_zero_mask<span class="token punctuation">]</span>gt_none_zero <span class="token operator">=</span> gt_none_zero<span class="token punctuation">.</span>unsqueeze<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment"># 每个采样点所属射线对应的深度</span>gt_depth_surface <span class="token operator">=</span> gt_none_zero<span class="token punctuation">.</span>repeat<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token comment"># 间隔</span>t_vals_surface <span class="token operator">=</span> torch<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0.</span><span class="token punctuation">,</span> <span class="token number">1.</span><span class="token punctuation">,</span> steps<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span>double<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 在Depth+-0.05Depth的区域进行采样</span>z_vals_surface_depth_none_zero <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0.95</span> <span class="token operator">*</span> gt_depth_surface <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1.</span> <span class="token operator">-</span> t_vals_surface<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1.05</span> <span class="token operator">*</span> gt_depth_surface <span class="token operator">*</span> <span class="token punctuation">(</span>t_vals_surface<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 保存结果到最终的z_vals_surface中</span>z_vals_surface <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>gt_depth<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span>double<span class="token punctuation">(</span><span class="token punctuation">)</span>gt_none_zero_mask <span class="token operator">=</span> gt_none_zero_mask<span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>z_vals_surface<span class="token punctuation">[</span>gt_none_zero_mask<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> z_vals_surface_depth_none_zero<span class="token comment"># ========== 无深度区域 ==========</span>near_surface <span class="token operator">=</span> <span class="token number">0.001</span>far_surface <span class="token operator">=</span> torch<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>gt_depth<span class="token punctuation">)</span>z_vals_surface_depth_zero <span class="token operator">=</span> <span class="token punctuation">(</span>near_surface <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1.</span> <span class="token operator">-</span> t_vals_surface<span class="token punctuation">)</span> <span class="token operator">+</span> far_surface <span class="token operator">*</span> <span class="token punctuation">(</span>t_vals_surface<span class="token punctuation">)</span><span class="token punctuation">)</span>z_vals_surface_depth_zero<span class="token punctuation">.</span>unsqueeze<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>repeat<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">~</span>gt_none_zero_mask<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment"># 保存结果到最终的z_vals_surface中</span>z_vals_surface<span class="token punctuation">[</span><span class="token operator">~</span>gt_none_zero_mask<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> z_vals_surface_depth_zero<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>演示z_vals的获取</strong></p><img src="/images/nerf-slam-4/IMG_2305.PNG" style="zoom: 25%;"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torchnear<span class="token operator">=</span><span class="token number">0.01</span>far<span class="token operator">=</span><span class="token number">3</span><span class="token comment"># 假设采样5个点</span>t_vals <span class="token operator">=</span> torch<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0.</span><span class="token punctuation">,</span> <span class="token number">1.</span><span class="token punctuation">,</span> steps<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token comment"># 根据深度采样（均匀的）</span>z_vals <span class="token operator">=</span> near <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1.</span> <span class="token operator">-</span> t_vals<span class="token punctuation">)</span> <span class="token operator">+</span> far <span class="token operator">*</span> <span class="token punctuation">(</span>t_vals<span class="token punctuation">)</span><span class="token comment"># 每个间隔内随机采样（随机的）</span>mids <span class="token operator">=</span> <span class="token number">.5</span> <span class="token operator">*</span> <span class="token punctuation">(</span>z_vals<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">+</span> z_vals<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>upper <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">[</span>mids<span class="token punctuation">,</span> z_vals<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>lower <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">[</span>z_vals<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> mids<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>t_rand <span class="token operator">=</span> torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span>z_vals<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>z_vals <span class="token operator">=</span> lower <span class="token operator">+</span> <span class="token punctuation">(</span>upper <span class="token operator">-</span> lower<span class="token punctuation">)</span> <span class="token operator">*</span> t_rand<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>演示采样点的计算</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token comment"># 假设只有两条射线</span><span class="token comment"># det_rays_o</span>rays_o<span class="token operator">=</span>torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># det_rays_d</span>rays_d<span class="token operator">=</span>torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0.1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># 假设采样10+5个点，N_samples=5，N_surface=3</span>z_vals<span class="token operator">=</span>torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.0100</span><span class="token punctuation">,</span> <span class="token number">0.3837</span><span class="token punctuation">,</span> <span class="token number">1.1313</span><span class="token punctuation">,</span> <span class="token number">1.8788</span><span class="token punctuation">,</span> <span class="token number">2.6263</span><span class="token punctuation">]</span><span class="token punctuation">)</span>z_vals_surface<span class="token operator">=</span>torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1.000</span><span class="token punctuation">,</span> <span class="token number">1.1086</span><span class="token punctuation">,</span> <span class="token number">1.2122</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment"># 合并N_samples和N_surface，再从小到大排序</span>z_vals<span class="token punctuation">,</span> _ <span class="token operator">=</span> torch<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">[</span>z_vals<span class="token punctuation">,</span> z_vals_surface<span class="token punctuation">.</span>double<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment"># 得到最后的采样点</span>pts <span class="token operator">=</span> rays_o<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">+</span> rays_d<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">*</span> z_vals<span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span>pointsf <span class="token operator">=</span> pts<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NeRF </tag>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NeRF based SLAM学习笔记（4）：Nice-SLAM（2）</title>
      <link href="2023/08/10/nerf-slam-3/"/>
      <url>2023/08/10/nerf-slam-3/</url>
      
        <content type="html"><![CDATA[<h1 id="NeRF-based-SLAM学习笔记（4）：Nice-SLAM（2）"><a href="#NeRF-based-SLAM学习笔记（4）：Nice-SLAM（2）" class="headerlink" title="NeRF based SLAM学习笔记（4）：Nice-SLAM（2）"></a>NeRF based SLAM学习笔记（4）：Nice-SLAM（2）</h1><p>分享我在参加计算机视觉life的NeRF SLAM学习小组时做的ppt。</p><p>学习小组相关的资料已经开源，如下：</p><blockquote><p><a href="https://github.com/electech6/NeRF-Based-SLAM-Incredible-Insights">NeRF-Based-SLAM-Incredible-Insights</a></p><p>Welcome to the <strong>“NeRF-Based-SLAM-Incredible-Insights”</strong> repository. This project aims to provide comprehensive insights into various NeRF (Neural Radiance Fields) based Slam (Simultaneous Localization and Mapping) algorithms. If you’re enthusiastic about NeRF-based Slam algorithms and wish to delve deep into their functionality and codebase, you’re in the right place.</p><p>If you find this repository useful, please consider <strong><a href="https://github.com/electech6/NeRF-Based-SLAM-Incredible-Insights#citation">CITING</a> and STARING</strong> this project. Feel free to share this project with others!</p></blockquote><object data="/pdf/NICE-SLAM论文讲解.pdf" type="application/pdf" width="100%" height="1000"></object>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NeRF </tag>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NeRF based SLAM学习笔记（3）：Nice-SLAM（1）</title>
      <link href="2023/08/02/nerf-slam-2/"/>
      <url>2023/08/02/nerf-slam-2/</url>
      
        <content type="html"><![CDATA[<h1 id="NeRF-based-SLAM学习笔记（3）：Nice-SLAM（1）"><a href="#NeRF-based-SLAM学习笔记（3）：Nice-SLAM（1）" class="headerlink" title="NeRF based SLAM学习笔记（3）：Nice-SLAM（1）"></a>NeRF based SLAM学习笔记（3）：Nice-SLAM（1）</h1><h2 id="Contributions"><a href="#Contributions" class="headerlink" title="Contributions"></a>Contributions</h2><ul><li>提出了NICE-SLAM，一个密集的RGB-D SLAM系统，具有实时性、可扩展性、预测性和对各种具有挑战性的场景的鲁棒性。</li><li>NICE-SLAM的核心是基于网格的分层神经隐式编码。与全局神经场景编码相比，这种表示方式允许局部更新，这是大场景方法的先决条件。</li><li>在各种数据集上做了广泛的评估，展示了NICE-SLAM在定位和建图方面的优势。</li></ul><h2 id="论文提及的观点"><a href="#论文提及的观点" class="headerlink" title="论文提及的观点"></a>论文提及的观点</h2><h3 id="abstract-amp-introduction部分"><a href="#abstract-amp-introduction部分" class="headerlink" title="abstract&amp;introduction部分"></a>abstract&amp;introduction部分</h3><ul><li><p>现有方法对场景的重建过于平滑，并且难以扩展到更大的场景；这些限制主要是使用了简单的全连接网络架构，并且does not incorporate local information in the observations.</p><blockquote><p>这里的局部信息是什么意思呢，说的是高频的、比较细节的东西吗？</p></blockquote></li><li><p>NICE-SLAM作者认为，SLAM系统需要具备以下条件：</p><ul><li>实时</li><li>能对没观测到的区域进行合理预测</li><li>扩展到大型场景</li><li>足够鲁棒，容忍噪声或者遗漏的观测</li></ul></li><li><p>NICE-SLAM作者认为：</p><ul><li>传统SLAM方法满足实时性、适用于大场景，但是unable to make plausible geometry estimation</li><li>基于学习的SLAM方法有一定程度预测能力，需要在特定任务的数据集上训练，更倾向于处理噪声和异常值，只适用于有多个对象的小场景。</li><li>近期的工作iMAP在面对更大的场景时，重建精度和跟踪精度显著下降。其中作者认为iMAP的关键限制因素是使用单一的MLP表示场景。</li><li>近期的一些工作（Convolutional occupancy networks，Neuralrecon: Real-time coherent 3d reconstruction from monocular video.）发现建立多层次的基于网格的特征可以帮助保留几何细节、重建复杂场景。但是这些方法是离线的，不具备实时性。</li></ul></li><li><p>NICE-SLAM结合了分层场景表示和隐式神经表示，利用层次特征网格表示场景的几何形状和外观，结合不同空间分辨率下预训练的神经隐式解码器的归纳偏差，利用occupancy和color decoder输出渲染的深度和彩色图像。通过最小化re-rendering loss来优化特征网络。</p></li></ul><h3 id="related-work部分"><a href="#related-work部分" class="headerlink" title="related work部分"></a>related work部分</h3><h4 id="Dense-Visual-SLAM"><a href="#Dense-Visual-SLAM" class="headerlink" title="Dense Visual SLAM"></a>Dense Visual SLAM</h4><ul><li><p>NICE-SLAM把地图表示分为两大类：</p><blockquote><p>第一次见，很新奇</p></blockquote><ul><li>3D几何图形锚定到关键帧上，说白了就是深度图，比如DTAM、DSO、TANDEM、DROID-SLAM等工作；</li><li>3D几何图形锚定到统一的世界坐标中，说白了就是surfels或者voxel grids，里面存储的是occupancies后者TSDF values，比如KinectFusion等作品。</li></ul></li><li><p>NICE-SLAM同样采用体素网格表示，但是存储的是几何图形的隐式编码，在mapping的过程中直接对其优进行优化。</p><p>这种方式允许NICE-SLAM在较低的网格分辨率下实现更精确的几何图形。</p></li></ul><h4 id="Neural-Implicit-Representations"><a href="#Neural-Implicit-Representations" class="headerlink" title="Neural Implicit Representations"></a>Neural Implicit Representations</h4><ul><li><p>简单罗列了各方面近期的一些工作，并且也说了用RGB-D训练NeRF，但需要位姿，或者解决相机位姿优化问题的工作，但是提到了这样的工作优化时间很长，不能够实时应用；</p></li><li><p>再一次说iMAP只使用一个MLP表示场景，容量有限，无法表示详细的场景几何形状，无法做到精确的相机跟踪。</p></li><li><p>NICE-SLAM将可学习的潜在嵌入向量（embeddings）与一个预先训练的连续隐式解码器相结合。这样可以重建复杂的几何结构和预测更大的室内场景的细节纹理，同时保持更少的计算量和更快的收敛速度。</p><blockquote><p>这里究竟是为什么呢？？？</p><p>不过这里说Local implicit grid representations for 3d scenes和Convolutional occupancy networks也是将传统的网络结构和学习到的特征表示相结合，或许我可以从这里寻找答案？</p></blockquote></li></ul><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p><img src="/images/nerf-slam-2/image-20230801210340053.png"></p><h3 id="Hierarchical-Scene-Representation"><a href="#Hierarchical-Scene-Representation" class="headerlink" title="Hierarchical Scene Representation"></a>Hierarchical Scene Representation</h3><p>将多级网格特征和预训练的解码器相结合，用于预测occupancy，对应下面这个区域</p><img src="/images/nerf-slam-2/image-20230802221834666.png" style="zoom:50%;"><p>需要注意的是，Color Level的解码器是没有预训练的，需要参与优化！这里的公式，<strong>带$\theta$的是几何相关的待优化参数，带$\omega$的是颜色相关的待优化参数</strong>。很明显颜色相关的解码器是$g_w$，很显然需要进行优化。</p><h4 id="Mid-amp-Fine-level-Geometric-Representation"><a href="#Mid-amp-Fine-level-Geometric-Representation" class="headerlink" title="Mid-&amp;Fine-level Geometric Representation"></a>Mid-&amp;Fine-level Geometric Representation</h4><p>文章说观测到的场景用mid-和fine-level的特征网格进行表示。然后重建过程中，先优化mid-level的特征网格，再利用fine-level的特征网格进行细化。</p><blockquote><p>所以fine-level也是被优化了？（肯定要优化啊！！！）</p></blockquote><p><strong>具体实现：</strong></p><ul><li><p>通常，mid-level的体素网格长度为32cm，fine-level的体素网格长度为16cm</p><p>在TUM RGBD数据集上则为16cm、8cm，看起来大概保持了一个2比1的比例</p></li><li><p>对于mid-level，直接用关联的MLP（从上往下数第二个）将特征解码得到occupancy，这里网络的输入是点p的positional encoding和在mid-level feature grid中通过三线性插值得到的点p处的feature。</p></li><li><p>为了学习到更高频的细节，NICE-SLAM用残差的方式添加了fine-level的特征。如从上往下数第三个MLP所示，该网络输入点p的positional encoding、点p在mid-level通过三线性插值得到的feature、点p在fine-level通过三线性插值得到的feature，输出mid-level的occupancy偏移量（offset）</p></li><li><p>有个非常需要注意的地方，解码器是预训练好的，被固定了。所以<strong>整个优化过程中，只对Feature Grid1&amp;2进行了优化。</strong>NICE-SLAM说这有助于稳定优化过程、保证几何的一致性。</p></li></ul><h4 id="Coarse-level-Geometric-Representation"><a href="#Coarse-level-Geometric-Representation" class="headerlink" title="Coarse-level Geometric Representation"></a>Coarse-level Geometric Representation</h4><p>coarse-level feature grid的目的是捕捉场景中的high-level几何信息，比如墙壁、地板等，并且coarse-level是独立优化的。它的目标是预测观察到的几何形状之外的近似occupancy。</p><blockquote><p>意思是mid-和fine-level是同时一起优化的？</p></blockquote><p><strong>具体实现：</strong></p><ul><li>边长2m</li><li>与mid-level一样的处理过程，得到occupancy</li><li>在Tracking过程中，coarse-level occupancy只用于预测没有观测到的部分场景，这种方式可以保证即使新的一帧很大一部分内容都看不见，但是也能保证Tracking成功。</li></ul><h4 id="Pre-training-Feature-Decoders"><a href="#Pre-training-Feature-Decoders" class="headerlink" title="Pre-training Feature Decoders"></a>Pre-training Feature Decoders</h4><ul><li><p>使用3个预训练的MLP网络进行解码，将网格特征解码为occupancy</p></li><li><p>其中，coarse-level和mid-level的decoder是作为ConvONet的一部分进行训练的（ConvONet由CNN编码器和MLP解码器组成）。</p><p>使用预测值与ground-truth之间的binary cross-entropy loss来训练encoder和decoder，这个过程和ConvONet是一样的。训练好之后只使用decoder的部分，这部分被固定住放到NICE-SLAM框架中，NICE-SLAM通过不断的训练feature grid来适应这个decoder。</p><p>通过上面这样的方式，可以在解码优化的特征时，预训练好的decoder可以利用从训练集学习到的特定分辨率先验。</p><blockquote><p>这里到底是如何使用的？怎么利用的？？？</p><p>训练好的decoder怎么包含进来先验信息的？？？</p></blockquote></li><li><p>对于fine-level，使用了和上面同样的预训练过程，但是在输入到decoder之前，会简单的将mid-level和fine-level的特征进行一个拼接。</p></li></ul><h4 id="Color-Representation"><a href="#Color-Representation" class="headerlink" title="Color Representation"></a>Color Representation</h4><p>从这里的描述大概能看出，NICE-SLAM主要还是关注深度，或者说更关注场景的几何形状，主要靠深度进行Tracking和Mapping，这里仅仅提了一句对颜色信息进行编码，可以给Tracking提供额外的信号。</p><p>这里的特征网格和解码器都是需要优化的，看他们的符号就知道了。</p><p>NICE-SLAM的作者说联合优化颜色特征网格和对应的解码器可以改善跟踪的性能，但是也提到这可能会导致遗忘的问题，因为颜色只具有局部一致性。如果想要可视化整个场景的颜色，可以把这里作为一个后处理的步骤进行全局优化。</p><blockquote><p>前半段大概懂他的意思，后半段不太懂怎么进行一个全局优化。</p></blockquote><h4 id="Network-Design"><a href="#Network-Design" class="headerlink" title="Network Design"></a>Network Design</h4><p>对于所有的MLP解码器，使用了宽度32、全连接层数为5的MLP网络。</p><p>除了coarse-level，其他地方都采用了可学习的高斯位置编码，这能让NICE-SLAM学习到高频的细节和外观。</p><blockquote><p>coarse-level确实不需要，不过什么是可学习的高斯位置编码？？？</p></blockquote><h3 id="Depth-and-Color-Rendering"><a href="#Depth-and-Color-Rendering" class="headerlink" title="Depth and Color Rendering"></a>Depth and Color Rendering</h3><p>这里用的和NeRF很接近的采样和渲染策略。</p><p>大概就是，沿着某条射线采样，先类似NeRF的分层采样，之后再在该点的深度附近进行均匀采样。</p><p>具体的看原论文就行，这部分内容很少。</p><h3 id="Mapping-and-Tracking"><a href="#Mapping-and-Tracking" class="headerlink" title="Mapping and Tracking"></a>Mapping and Tracking</h3><p>一个线程用于coarse-level的优化</p><p>一个线程用于mid-level和fine-level的优化和颜色的优化</p><p>一个线程用于Tracking</p><h4 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h4><ul><li><p>从当前帧和选定的关键帧中统一采样一定数量的像素点，以分段方式进行优化来最小化几何和光度损失。</p><ul><li><p>首先利用几何误差优化mid-level的特征网格；</p></li><li><p>之后利用fine-level的几何误差联合优化mid-level和fine-level的特征网格；</p></li><li><p>最后进行一个local BA共同优化所选择的K个关键帧的各个级别的特征网格、颜色解码器和位姿；</p></li></ul></li><li><p>这种多阶段优化方式能够更好的收敛，因为更高分辨率的外观和精细的特征可以依赖来自mid-level已经优化好的几何信息。</p></li></ul><h4 id="Tracking"><a href="#Tracking" class="headerlink" title="Tracking"></a>Tracking</h4><ul><li><p>使用了和Mapping一样的光度损失；</p></li><li><p>使用了修改的几何损失，这里和Mapping略有区别。这里的目的是降低几何结构中某些区域的权重，比如物体边缘的权重。</p><blockquote><p>意思就是让Tracking更关心图像中心部分的信息</p></blockquote></li><li><p>NICE-SLAM在这里提到coarse-level的短期预测能力能够让NICE-SLAM在丢帧或者快速相机运动的情况下表现得更加鲁棒，这部分他们也做了实验。</p></li></ul><h4 id="Robustness-to-Dynamic-Objects"><a href="#Robustness-to-Dynamic-Objects" class="headerlink" title="Robustness to Dynamic Objects"></a>Robustness to Dynamic Objects</h4><p>NICE-SLAM提到为了在Tracking过程中对动态物体更鲁棒，他们对深度or颜色重渲染损失较大的像素点进行了过滤，当损失超过了中值的10倍时会被剔除。</p><p>另外，NICE-SLAM说在动态环境下，联合优化相机位姿和场景表示是非常有意义的工作，是未来的一个研究方向。</p><h3 id="Keyframe-Selection"><a href="#Keyframe-Selection" class="headerlink" title="Keyframe Selection"></a>Keyframe Selection</h3><p>类似iMAP的方法维护一个全局的关键帧列表，在这个列表中也根据信息增益添加新的关键帧。但是与iMAP不同的是，iMAP用MLP网络表示场景，所以不得不从所有的关键帧中进行选择和优化；而NICE-SLAM这里是使用网格对场景进行表示的，所以优化场景的几何结构时，是需要包含当前帧和与当前帧有视觉重叠的关键帧。NICE-SLAM这样的方式也避免了iMAP所面对的遗忘问题。这种关键帧选择策略不仅确保了当前视图之外的几何图形保持静态，并且只需要优化必要的参数，非常高效。</p><p><strong>具体实现：</strong></p><ul><li><p>首先随机采样一定数量的像素点；</p></li><li><p>使用优化后的相机位姿反向投影，拿到这些点的深度；</p><blockquote><p>这里就得到点云了</p></blockquote></li><li><p>将点云再投影到全局关键帧列表中的每一个关键帧；</p><blockquote><p>有点像重投影误差</p></blockquote></li><li><p>从有投影点的关键帧中随机选择K-2个关键帧，再选择最近的关键帧和当前帧，所以总共有K个活动帧。</p></li></ul><h2 id="实验与总结"><a href="#实验与总结" class="headerlink" title="实验与总结"></a>实验与总结</h2><ul><li>实验部分，介绍Geometry Forecast and Hole Filling时，NICE-SLAM提了一句iMAP中没有编码任何场景的先验知识，反过来NICE-SLAM是因为预训练了decoder，所以它的coarse才拥有这样的能力的？</li><li>总结部分，NICE-SLAM说自己的预测能力仅限于coarse-level，另外不能够进行loop closures，这也是一个未来的研究方向。</li><li>NICE-SLAM与传统方法相比缺乏特性，与学习方法相比存在性能差距。</li></ul><h2 id="补充材料"><a href="#补充材料" class="headerlink" title="补充材料"></a>补充材料</h2><h3 id="Frustum-Feature-Selection"><a href="#Frustum-Feature-Selection" class="headerlink" title="Frustum Feature Selection"></a>Frustum Feature Selection</h3><p>基于网格的表示可以只用优化当前视图截锥的几何形状，但是由于三线性插值本身，对所有体素的简单优化会影响到视图截锥之外的特征</p><blockquote><p>毕竟来自关键帧的一些射线上需要采样的点并没有老老实实呆在这个视锥之内，而视锥之外采样的点肯定要通过三线性插值从有可能在视锥之外的特征网格处取值，一优化就改变视锥之外的特征了。</p></blockquote><p>解决的办法也很简单，在优化过程中只更新在当前视图截锥内部的全部特征，这样可以保持之前重建的几何形状，又可以大大减少优化过程中的参数数量</p><blockquote><p>我的理解就是，视锥之外的特征还是被拿过去做三线性插值去采样了，这里计算了损失，但是更新参数的时候，视锥之外的就不动了，只更新视锥内部的。</p><p>不过这样会不会在某些情况下导致重建的场景存在明显的锯齿？？？</p><p>但是我看后面的实验，居然是只更新视锥内部的才没有锯齿？！！</p></blockquote><h3 id="Hierarchical-Feature-Grid-Initialization"><a href="#Hierarchical-Feature-Grid-Initialization" class="headerlink" title="Hierarchical Feature Grid Initialization"></a>Hierarchical Feature Grid Initialization</h3><ul><li><p><strong>Coarse-level Feature Grid：</strong>随机初始化；</p></li><li><p><strong>Mid-level Feature Grid：</strong>也是随机初始化的，经验表明随机初始化具有更好的收敛性；</p></li><li><p><strong>Fine-level Feature Grid：</strong>需要初始化到fine-level的decoder输出为0，毕竟这里给出来的是残差，初始化的残差肯定要是0。</p><p>这样才能够保证从coarse-to-fine的优化过程中，能量是平稳过渡的。论文也提到，在对fine-level对应的decoder进行预训练的时候，增加了额外的正则化损失，保证如果fine-level的特征为0，那么无论mid-level的特征如何，输出的残差都应该为0。这样能够允许NICE-SLAM在运行的时候对fine-level的特征网格进行零初始化。</p></li></ul><h3 id="Justification-for-Design-Choices"><a href="#Justification-for-Design-Choices" class="headerlink" title="Justification for Design Choices"></a>Justification for Design Choices</h3><ul><li><p><strong>Why 3-level Feature Grids?</strong></p><p>分层网格可以带来更好的收敛性，3-level可以保证质量、实时性能、内存消耗之间的平衡。这里论文有进行实验证明这一点；</p></li><li><p><strong>Why is the Mid-level Output not a Residual to the Coarse-level Output?</strong></p><p>在设计的过程中，Coarse-level的体素尺寸明显大于mid-level和fine-level，而且Coarse-level更新会影响较大的区域。为了保证小的局部收敛效率，NICE-SLAM断开了coarse与mid、fine之间的连接，只使用coarse进行预测。</p></li></ul><h3 id="Mesh-Visualization"><a href="#Mesh-Visualization" class="headerlink" title="Mesh Visualization"></a>Mesh Visualization</h3><p>这里提到重建的场景采用分层特征网格隐式表示。NICE-SLAM使用marching cube算法创建了一个用于可视化的网格。对于每个观察点，我们使用精细级解码器和颜色解码器预测其占用值。对于预测区域中那些看不见的点(即粗网格中有部分观测的体素)，我们从粗解码器中预测占用率，并将颜色设置为青色进行可视化。</p><blockquote><p>这里我感觉coarse的预测会不会单纯的是因为糊了？</p><p>比如一张峡谷的高清图，很明显能看到峡谷，但是降低分辨率之后因为很模糊，峡谷可能就变成平地了？？？</p></blockquote><h3 id="Decoder-Pretraining"><a href="#Decoder-Pretraining" class="headerlink" title="Decoder Pretraining"></a>Decoder Pretraining</h3><p>NICE-SLAM使用了ConvONet提供的合成室内场景数据集对encoder-decoder预训练。这里NICE-SLAM使用的是Point Cloud Encoder而不是Voxel Encoder。所有的级别都是再ConvONet中使用room_grid64的设置进行训练的，所有特征网格的特征维度都是32。其他超参数采用了与ConvONet一样的设定。</p><blockquote><p>所以我的疑惑很大，为什么这里会想到用ConvONet的decoder来做NICE-SLAM的decoder？？？不过ConvONet是他家的工作，说不定知道一些什么吧。。。。</p></blockquote><h2 id="相关工作和基础知识"><a href="#相关工作和基础知识" class="headerlink" title="相关工作和基础知识"></a>相关工作和基础知识</h2><ul><li>DTAM，这是2011年的一个工作，NICE-SLAM作者说最近很多基于学习的SLAM系统都是从这个上面修改的，因为DTAM足够简单。比如Deeptam: Deep tracking and mapping</li><li>CodeSLAM、SceneCode、NodeSLAM等优化了解码到关键帧或对象深度图的表示，这三个工作经常有看到提，可以看一看。</li><li>==DI-Fusion==（对比实验的常客）</li><li>==TSDF-Fusion==（对比实验的常客）</li><li>==Local implicit grid representations for 3d scenes==</li><li>==<strong>Convolutional occupancy networks</strong>==</li><li>Neuralrecon: Real-time coherent 3d reconstruction from monocular video</li><li>三线性插值提取Geometry是什么情况？三线性插值好耳熟，是啥来着？？？</li><li>==ConvONet==，这是NICE-SLAM的解码器，需要好好的看一看！！！</li><li>==<strong>learnable Gaussian positional encoding</strong>==是什么？（NICE-SLAM论文提到iMAP和==Fourier features let networks learn high frequency functions in low dimensional domains==都用了，我对后者很有印象，看起来后面这篇论文必须要看了。）</li><li>对NeRF相关的改进工作，特别是有feature grid这种的，非常的疑惑，需要好好了解一下！</li></ul><h2 id="想法-amp-疑问"><a href="#想法-amp-疑问" class="headerlink" title="想法&amp;疑问"></a>想法&amp;疑问</h2><ul><li>NICE-SLAM用了四个特征网格和对应的解码器（但是我看Hierarchical Feature Grid只有三个）表示场景的几何形状和外观，这里是因为color和fine是共用一个Feature Grid吗？</li><li>NICE-SLAM看起来是只对feature grid进行了优化，我记得instant-ngp似乎也是类似的，这里还是要好好了解、对比一下！！！</li><li>为什么预训练了decoder，在解码的时候就可以利用从预训练集中学习到的特定分辨率的先验信息？这里是不是因为decoder引导了feature grid的优化过程？？？</li><li>看到Color Representation部分的时候，这里我发现虽然System Overview展示的pipeline只有3个Hierarchical Feature Grid，但是确实有四个对应的符号，它这个部分介绍的时候说，使用了特征网格$\psi_w$，而前面几个都是$\phi_0,\phi_1,\phi_2$这样的。所以是只有3个Grid但有四个函数，然后最开始才说用了四个特征网格？</li><li>感觉NICE-SLAM的论文写得特别好，中间很多东西讲的特别特别清楚，附录里面也详细解释了为什么用3-level等问题，并且做了充足的实验证明自己工作的有效性。这种写作的方式可以好好的学习！</li></ul>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NeRF </tag>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NeRF based SLAM学习笔记（2）：NeRF与iMap</title>
      <link href="2023/07/30/nerf-slam-1/"/>
      <url>2023/07/30/nerf-slam-1/</url>
      
        <content type="html"><![CDATA[<h2 id="NeRF-based-SLAM学习笔记（2）：NeRF与iMap"><a href="#NeRF-based-SLAM学习笔记（2）：NeRF与iMap" class="headerlink" title="NeRF based SLAM学习笔记（2）：NeRF与iMap"></a>NeRF based SLAM学习笔记（2）：NeRF与iMap</h2><h2 id="NeRF"><a href="#NeRF" class="headerlink" title="NeRF"></a>NeRF</h2><h3 id="相关工作与基础知识"><a href="#相关工作与基础知识" class="headerlink" title="相关工作与基础知识"></a>相关工作与基础知识</h3><ul><li><p>==volume rendering==</p></li><li><p>voxel grids</p></li><li><p>PDF（NeRF里面提到的PDF）</p></li><li><p>==normalized device coordinate (NDC) space==</p><blockquote><p>之前在考虑相机内参对NeRF有什么影响，不过论文附录里面说把光线从相机空间映射到了NDC空间。这部分附录的内容对应的代码之前也没太看懂，还需要再好好理解一下！</p><p>NeRF里面对near和far的处理非常非常关键，这部分的附录也需要再看看。</p></blockquote></li><li><p>神经渲染这边有两篇综述，可以一并看了</p></li><li><p>Transformer工作里面有一个position encoding，需要好好了解一下！</p></li><li><p>==SDF相关的工作==</p></li><li><p>==Occupancy Networks相关的工作==</p></li></ul><h3 id="其他想法"><a href="#其他想法" class="headerlink" title="其他想法"></a>其他想法</h3><ul><li><p>之前听co-SLAM的时候，作者就提到了如何更公平更有效地评估自己的工作。</p><p>这里NeRF其实是更之前的东西，这里实验部分也好好讲了用什么指标、如何评估等，以及为什么和xx工作比较、为什么不和xx工作比较、在哪些数据集下比较、定性的比较和定量的比较都有。</p><p>另外，这里NeRF还有很详细的消融实验。</p></li><li><p>疑问：为什么需要一个粗网络+一个细网络，为什么不能只使用同一个网络，然后粗采样+细采样呢？</p></li></ul><h2 id="iMAP"><a href="#iMAP" class="headerlink" title="iMAP"></a>iMAP</h2><h3 id="相关工作与基础知识-1"><a href="#相关工作与基础知识-1" class="headerlink" title="相关工作与基础知识"></a>相关工作与基础知识</h3><ul><li>传统SLAM里面的一些东西，比如滑动窗口</li><li>之前一直没弄懂的几个小点：<ul><li>voxel grid，和其中的occupancy values</li><li>matching cubes（这好像是个很熟悉的算法emmm）</li></ul></li><li>==Code-SLAM==，iMAP对这个工作的描述：“Machine learning can discover low-dimensional embeddings of dense structure which enable efficient, jointly optimisable representation. CodeSLAM [1] is one example, but using a depth-map view representation rather than full volumetric 3D. Learning techniques have also been used to improve dense reconstruction but require an existing scan [5] or previous training data [21, 36, 2].”</li><li>==TSDF fusion/TSDF fusion Kintinuous==（很多NeRF based SLAM的工作都和这个比较）</li><li>==Fourier features let networks learn high frequency functions in low dimensional domains. Neural Information Processing Systems (NIPS), 2020==</li></ul><h3 id="iMAP论文提到的观点"><a href="#iMAP论文提到的观点" class="headerlink" title="iMAP论文提到的观点"></a>iMAP论文提到的观点</h3><ul><li><p>实现的系统运行的效果是：Tracking 10Hz，Mapping 2Hz</p></li><li><p>隐式神经表示的优势：</p><p>原文：The advantages ofan implicit MLP over standard dense SLAM techniques include efficient geometry representation with automatic detail control and smooth, plausible filling-in of unobserved regions such as the back surfaces ofobjects.</p><ul><li>可调整分辨率的几何表示 efficient geometry representation with automatic detail control</li><li>对物体背面等未观测区域进行平滑、似是而非的填充 smooth, plausible filling-in of unobserved regions such as the back surfaces ofobjects.</li></ul></li><li><p>iMAP作者将SLAM视为一个持续学习的问题</p></li><li><p>当深度图可用时，引导稀疏采样进行渲染和训练可以用到实时的SLAM系统中</p></li><li><p>持续学习的系统应该有两方面的能力：</p><ul><li>可塑性：获取新知识的能力</li><li>稳定性：保留旧知识的能力</li></ul><p>遗忘旧知识是持续学习的神经网络需要面对的问题，避免新的经历覆盖记忆很重要。</p></li><li><p>iMAP的作者面对如何解决持续学习的神经网络遗忘旧知识提到的解决办法：</p><ul><li>通过相对权重保护避免新数据的影响，类似SLAM中的滤波方法，可以进一步研究；</li><li>而冻结或者固定自网络的方法对SLAM系统来说过于简单和离散；</li><li>iMAP在这个问题上，主要实现了基于回放的持续学习方法，用回放的方式避免遗忘（利用关键帧来进行回放）</li></ul><blockquote><p>所以如果我后面看NICE-SLAM的时候，可以再回到iMAP上面来。</p></blockquote></li></ul><h3 id="iMAP具体实现"><a href="#iMAP具体实现" class="headerlink" title="iMAP具体实现"></a>iMAP具体实现</h3><ul><li><p>输入的是稀疏的主动采样结果，说明对于每张图像，可能只会选择其中的一部分像素点进行训练，这应该是为了保证实时性</p></li><li><p>网络结构：</p><ul><li>4层隐藏层，每一层的大小为256；</li><li>2个输出层，一个是color，一个是density value；</li><li>不考虑观察方向，因此输入的位置仅仅是x,y,z</li><li>位置编码：<ul><li>应用傅里叶特征网络（Fourier features let networks learn high frequency functions in low dimensional domains. Neural Information Processing Systems (NIPS), 2020）中提到的高斯位置嵌入，对输入的位置进行升维；</li><li>上面的结果也连接到了网络的第二个激活层</li></ul></li></ul></li><li><p>深度和颜色的渲染：</p><p>这里也提到了归一化视角（normalised viewing direction），其他地方和NeRF基本一致</p></li><li><p>联合优化部分：</p><ul><li><p>设定一组关键帧集合，每个关键帧保存了图像的颜色和深度，以及网络估计的姿态；</p></li><li><p>联合优化这部分都是基于关键帧进行处理的，而Tracking则是针对每一帧做的优化；</p></li><li><p>固定场景网络，通过Tracking以计算最新帧的位姿；</p></li><li><p>联合优化这部分我认为重点还是优化网络的参数，也可以说重点是建图，不过这里也还是优化了位姿的。</p><p>更新的网络参数继续用于下一轮联合优化期间的Tracking。</p></li></ul></li><li><p>关键帧选择：</p><ul><li><p>第一帧用于初始化网络并且固定世界坐标系；</p><blockquote><p>类似于传统SLAM的第一个关键帧，ORB-SLAM2第一个关键帧就是第一帧</p></blockquote></li><li><p>使用信息增益的方法选择关键帧：</p><ul><li><p>每次添加一个新关键帧，就保存当前网络参数为一个副本；</p><blockquote><p>联合优化都是基于关键帧处理的，应该没必要保存副本？</p></blockquote></li><li><p>在保存的副本上面检查新的帧，如果遇到一个明显的新区域，就把这一帧选择为新关键帧；论文公式（6）定义了判断某一帧对于网络来说是否为新区域的标准，大概就是对于某一帧，选中其中的部分像素进行渲染，然后计算一个平均的深度误差，看目前的网络对于这一帧包含的信息，到底学习到了多少。</p><blockquote><p>这里还提了一句距离物体越近的时候关键帧添加越频繁。</p><p>很类似ORB-SLAM2，近点变动大的时候也会添加关键帧，因为利用远点计算的位姿不准确；而这里的话就是考虑距离物体越近，细节越多，需要学习表示的也越多。</p></blockquote></li></ul></li><li><p>另外论文里面提到“mapping过程中接收的每一帧都会被用于一定迭代的联合优化，这样的话关键帧集合就是由选择的关键帧和最新的一些帧组成”。</p><blockquote><p>这里说明，mapping还是考虑了非关键帧，然后选择了学习的不好的一些帧作为关键帧？？？</p><p>这样的话，上面保存网络参数为副本也可以理解了</p></blockquote></li></ul></li><li><p>主动采样：</p><ul><li><p>Image Activate Sampling</p><p>每张图像只渲染其中200个像素点，利用渲染的损失引导系统对损失较大、不够精确的地方进行主动采样。</p><ul><li>先把图像分成8x8的网格；</li><li>在每个网格里面均匀采样，计算损失；</li><li>在损失较大的区域重新采样一组新的数据；</li></ul><p>主动采样只使用在联合优化部分，而相机跟踪还是用的均匀采样。</p></li><li><p>Keyframe Activate Sampling</p><p>类似Image Activate Sampling，损失较大的关键帧多采样。</p></li><li><p>Bounded Keyframe Selection</p><blockquote><p>听说这个类似VINS里面的滑动窗口？</p></blockquote><p>联合优化的过程中，会根据Keyframe Activate Sampling选择3个关键帧，并且再纳入最后一个关键帧和当前的实时帧进行优化。这里就组成了一个W=5的关键帧有界窗口，窗口中的关键帧会根据时间不断变化。</p></li></ul></li></ul><h3 id="其他的想法"><a href="#其他的想法" class="headerlink" title="其他的想法"></a>其他的想法</h3><ul><li><p>实验部分说“We recover mesh reconstructions if needed by querying occupancy values from the network in a uniform voxel grid and then running marching cubes. Meshing is for visualisation and evaluation purposes and does not form part of our SLAM system.”</p><p>前半段没太弄懂，但是这里应该是为了方便转化成mesh，用来评估和可视化？4.2部分也说，精度、完成度、补全率都是要和ground truth的mesh作比较，所以应该是要把NeRF学到的场景转化为mesh的。这种评估方式应该不是很好，但是也没有别的很好评估的方法了，后面的工作NCIE-SLAM、以及更后面的Co-SLAM也提到了这样做的问题，Co-SLAM表示自己尝试构建一个更公平的转化为mesh的方法来做评估。</p></li><li><p>iMAP在实验部分说’使用随机变化的信息进行快速迭代比使用密集和缓慢的迭代更好。”这里指的是每张图像随机采样一部分像素点吗？？？</p></li><li><p>iMAP这里倒是发现一个问题：一个场景（房间）只需要十几个关键帧就能很好的重建出来，而使用更多的关键帧则无法提高场景的完成率。这个是受到网络大小的限制吗？还是受到了iMAP所使用的Activate Sampling的影响？另外，iMAP也指出自己的模型能够几秒钟得到一个粗糙的重建，但是加入细节信息需要花上几分钟时间，看他的Figure 13就发现了，很快就深度误差只有5cm了，但是从5cm降低到0.75cm就会花费非常长的时间。</p></li><li><p>iMAP论文说未来的研究方向是：更结构化和复合的表示。</p><p>原文：Future directions for iMAP include how to make more structured and compositional representations that reason explicitly about the self similarity in scenes.</p></li><li><p>iMAP在深度和颜色渲染这部分也提到了归一化视角（normalised viewing direction），这个和NeRF的NDC应该是一样的？但是这里的目的是什么呢？</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NeRF </tag>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NeRF based SLAM学习笔记（1）：相关工作整理</title>
      <link href="2023/07/26/nerf-slam-0/"/>
      <url>2023/07/26/nerf-slam-0/</url>
      
        <content type="html"><![CDATA[<h1 id="NeRF-based-SLAM学习笔记（1）：相关工作整理"><a href="#NeRF-based-SLAM学习笔记（1）：相关工作整理" class="headerlink" title="NeRF based SLAM学习笔记（1）：相关工作整理"></a>NeRF based SLAM学习笔记（1）：相关工作整理</h1><p><strong>NeRF</strong></p><ul><li><strong>论文链接</strong>：<a href="https://arxiv.org/abs/2003.08934">https://arxiv.org/abs/2003.08934</a></li><li><strong>项目主页</strong>：<a href="https://www.matthewtancik.com/nerf">https://www.matthewtancik.com/nerf</a></li><li><strong>开源代码</strong>：<a href="https://github.com/bmild/nerf">https://github.com/bmild/nerf</a></li><li><strong>演示视频</strong>：<a href="https://www.youtube.com/watch?v=JuH79E8rdKc">https://www.youtube.com/watch?v=JuH79E8rdKc</a></li></ul><p><strong>iMAP</strong></p><ul><li><strong>论文链接</strong>：<a href="http://arxiv.org/abs/2103.12352">http://arxiv.org/abs/2103.12352</a></li><li><strong>项目主页</strong>：<a href="https://edgarsucar.github.io/iMAP">https://edgarsucar.github.io/iMAP</a></li><li><strong>演示视频</strong>：<a href="https://www.youtube.com/watch?v=c-zkKGArl5Y">https://www.youtube.com/watch?v=c-zkKGArl5Y</a></li></ul><p><strong>NICE-SLAM</strong></p><ul><li><strong>论文链接</strong>：<a href="https://arxiv.org/abs/2112.12130">https://arxiv.org/abs/2112.12130</a></li><li><strong>项目主页</strong>：<a href="https://pengsongyou.github.io/nice-slam">https://pengsongyou.github.io/nice-slam</a></li><li><strong>开源代码</strong>：<a href="https://github.com/cvg/nice-slam">https://github.com/cvg/nice-slam</a></li><li><strong>演示视频</strong>：<a href="https://www.youtube.com/watch?v=V5hYTz5os0M">https://www.youtube.com/watch?v=V5hYTz5os0M</a></li></ul><p><strong>Co-SLAM</strong></p><ul><li><strong>论文链接</strong>：<a href="https://arxiv.org/abs/2304.14377">https://arxiv.org/abs/2304.14377</a></li><li><strong>项目主页</strong>：<a href="https://hengyiwang.github.io/projects/CoSLAM">https://hengyiwang.github.io/projects/CoSLAM</a></li><li><strong>开源代码</strong>：<a href="https://github.com/HengyiWang/Co-SLAM">https://github.com/HengyiWang/Co-SLAM</a></li><li><strong>演示视频</strong>：<a href="https://www.youtube.com/watch?v=DJ3RkNiZQZE&amp;feature=youtu.be">https://www.youtube.com/watch?v=DJ3RkNiZQZE&amp;feature=youtu.be</a></li></ul><p><strong>相关工作</strong></p><p><strong>Convolutional Occupancy Networks</strong></p><ul><li><strong>论文链接</strong>：<a href="https://www.cvlibs.net/publications/Peng2020ECCV.pdf">https://www.cvlibs.net/publications/Peng2020ECCV.pdf</a></li><li><strong>项目主页</strong>：<a href="https://pengsongyou.github.io/conv_onet">https://pengsongyou.github.io/conv_onet</a></li><li><strong>开源代码</strong>：<a href="https://github.com/autonomousvision/convolutional_occupancy_networks">https://github.com/autonomousvision/convolutional_occupancy_networks</a></li><li><strong>演示视频</strong>：<a href="https://www.youtube.com/watch?v=EmauovgrDSM">https://www.youtube.com/watch?v=EmauovgrDSM</a></li></ul><p><font color="red"><strong>Instant Neural Graphics Primitives with a Multiresolution Hash Encoding</strong></font></p><ul><li><strong>论文链接</strong>：<a href="https://nvlabs.github.io/instant-ngp/assets/mueller2022instant.pdf">https://nvlabs.github.io/instant-ngp/assets/mueller2022instant.pdf</a></li><li><strong>项目主页</strong>：<a href="https://nvlabs.github.io/instant-ngp/">https://nvlabs.github.io/instant-ngp/</a></li><li><strong>开源代码</strong>：<a href="https://github.com/NVlabs/instant-ngp">https://github.com/NVlabs/instant-ngp</a></li><li><strong>演示视频</strong>：<a href="https://nvlabs.github.io/instant-ngp/assets/mueller2022instant.mp4">https://nvlabs.github.io/instant-ngp/assets/mueller2022instant.mp4</a></li></ul><p><font color="red"><strong>3D Gaussian Splatting for Real-Time Radiance Field Rendering</strong></font></p><ul><li><strong>论文链接</strong>：<a href="https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/3d_gaussian_splatting_low.pdf">https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/3d_gaussian_splatting_low.pdf</a></li><li><strong>项目主页</strong>：<a href="https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/">https://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/</a></li><li><strong>开源代码</strong>：<a href="https://github.com/graphdeco-inria/gaussian-splatting">https://github.com/graphdeco-inria/gaussian-splatting</a></li><li><strong>演示视频</strong>：<a href="https://youtu.be/T_kXY43VZnk">https://youtu.be/T_kXY43VZnk</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NeRF </tag>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neural Implicit Representations in SLAM</title>
      <link href="2023/07/15/meeting-5/"/>
      <url>2023/07/15/meeting-5/</url>
      
        <content type="html"><![CDATA[<h1 id="Neural-Implicit-Representations-in-SLAM"><a href="#Neural-Implicit-Representations-in-SLAM" class="headerlink" title="Neural Implicit Representations in SLAM"></a>Neural Implicit Representations in SLAM</h1><blockquote><p>神经隐式表征在SLAM中的应用探索</p><p>讲座链接：<a href="https://www.shenlanxueyuan.com/open/course/194">https://www.shenlanxueyuan.com/open/course/194</a></p></blockquote><h2 id="背景和基础知识介绍"><a href="#背景和基础知识介绍" class="headerlink" title="背景和基础知识介绍"></a>背景和基础知识介绍</h2><h3 id="经典场景表征"><a href="#经典场景表征" class="headerlink" title="经典场景表征"></a>经典场景表征</h3><img src="/images/meeting-5/image-20230715155411762.png" style="zoom:67%;"><p><strong>点云：</strong>简单直观，但缺少点之间的拓扑关系。</p><p><strong>体素：</strong>很适合用卷积神经网络处理，但是复杂度很高，为N的3次方。</p><p><strong>网格：</strong>存起来很简单，有拓扑信息，但不适合实时在线的编辑，在SLAM中很少有用网格这种数据结构。</p><p><strong>SDF：</strong>隐式表征。</p><h3 id="神经隐式表征的早期工作"><a href="#神经隐式表征的早期工作" class="headerlink" title="神经隐式表征的早期工作"></a>神经隐式表征的早期工作</h3><h4 id="DeepSDF"><a href="#DeepSDF" class="headerlink" title="DeepSDF"></a>DeepSDF</h4><img src="/images/meeting-5/image-20230715160423239.png" style="zoom:67%;"><p><strong>核心思想：</strong>直接用一个神经网络表示一个场景或者物体的SDF，输入坐标xyz，输出SDF的数值。</p><p><strong>缺点：</strong>必须从三维的数据中训练，而NeRF可以从2D的观测数据中训练。当时的人们更关注给很好的三维数据，然后从中学习场景的表征，之后用于生成方面的工作。</p><p>DeepSDF很适合做物体级别的重建。为了用一个MLP表示很多类型的物体，DeepSDF提出了auto-decoder的方法。</p><h4 id="Neural-Radiance-Field-NeRF"><a href="#Neural-Radiance-Field-NeRF" class="headerlink" title="Neural Radiance Field(NeRF)"></a>Neural Radiance Field(NeRF)</h4><img src="/images/meeting-5/image-20230715161043828.png" style="zoom:67%;"><img src="/images/meeting-5/image-20230715161248791.png" style="zoom:67%;"><h2 id="基于NeRF的RGB-D-SLAM"><a href="#基于NeRF的RGB-D-SLAM" class="headerlink" title="基于NeRF的RGB-D SLAM"></a>基于NeRF的RGB-D SLAM</h2><h3 id="iMAP"><a href="#iMAP" class="headerlink" title="iMAP"></a>iMAP</h3><h4 id="Contributions"><a href="#Contributions" class="headerlink" title="Contributions"></a>Contributions</h4><img src="/images/meeting-5/image-20230715161737290.png" style="zoom:67%;"><p>从SLAM的角度来说，iMAP提出了一种新的范式，它直接用神经隐式表征来表示场景，把建图的过程定义为一个优化的问题，通过优化场景表征，使其最符合系统的2D观测，即图像和深度。</p><p>从NeRF的角度来说，iMAP第一次用增量式、在线的方法来训练NeRF。增量式的训练会遇到一些问题，特别是遗忘的问题，iMAP从关键帧选取和active sampling来尝试缓解这个问题。</p><h4 id="Volume-Rendering-Pipeline"><a href="#Volume-Rendering-Pipeline" class="headerlink" title="Volume Rendering Pipeline"></a>Volume Rendering Pipeline</h4><img src="/images/meeting-5/image-20230715162309104.png" style="zoom:67%;"><h4 id="Tracking-and-Mapping-Losses"><a href="#Tracking-and-Mapping-Losses" class="headerlink" title="Tracking and Mapping Losses"></a>Tracking and Mapping Losses</h4><img src="/images/meeting-5/image-20230715162356818.png" style="zoom:67%;"><h4 id="System-Overview"><a href="#System-Overview" class="headerlink" title="System Overview"></a>System Overview</h4><img src="/images/meeting-5/image-20230715162414261.png" style="zoom:67%;"><h4 id="KeyFrame-Selection"><a href="#KeyFrame-Selection" class="headerlink" title="KeyFrame Selection"></a>KeyFrame Selection</h4><img src="/images/meeting-5/image-20230715162553506.png" style="zoom:67%;"><h4 id="Image-Active-Sampling"><a href="#Image-Active-Sampling" class="headerlink" title="Image Active Sampling"></a>Image Active Sampling</h4><img src="/images/meeting-5/image-20230715162609710.png" style="zoom:67%;"><p>从重投影误差大的地方来选取，使得场景在优化的时候更关注它不能够很好解释的部分，可以缓解遗忘的问题。  </p><h3 id="NICE-SLAM"><a href="#NICE-SLAM" class="headerlink" title="NICE-SLAM"></a>NICE-SLAM</h3><h4 id="Contributions-1"><a href="#Contributions-1" class="headerlink" title="Contributions"></a>Contributions</h4><img src="/images/meeting-5/image-20230715165501941.png" style="zoom: 67%;"><h4 id="tiny-MLPs"><a href="#tiny-MLPs" class="headerlink" title="tiny MLPs"></a>tiny MLPs</h4><p><img src="/images/meeting-5/image-20230715170209338.png"></p><h4 id="Scene-Representation"><a href="#Scene-Representation" class="headerlink" title="Scene Representation"></a>Scene Representation</h4><p><img src="/images/meeting-5/image-20230715170316451.png"></p><img src="/images/meeting-5/image-20230715170429824.png" style="zoom: 67%;"><h3 id="Co-SLAM"><a href="#Co-SLAM" class="headerlink" title="Co-SLAM"></a>Co-SLAM</h3><h4 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h4><p><img src="/images/meeting-5/image-20230715170737316.png"></p><p><img src="/images/meeting-5/image-20230715170915010.png"></p><h4 id="System-Overview-1"><a href="#System-Overview-1" class="headerlink" title="System Overview"></a>System Overview</h4><p><img src="/images/meeting-5/image-20230715171425426.png"></p><img src="/images/meeting-5/image-20230715171958318.png" style="zoom: 67%;"><h4 id="Volume-Rendering-and-Loss"><a href="#Volume-Rendering-and-Loss" class="headerlink" title="Volume Rendering and Loss"></a>Volume Rendering and Loss</h4><p><img src="/images/meeting-5/image-20230715171553825.png"></p>]]></content>
      
      
      <categories>
          
          <category> NeRF&amp;3DGS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NeRF </tag>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SEAMLESS MAP MERGING in ORBSLAM-Atlas</title>
      <link href="2023/05/27/paper-reading-orbslam-atlas/"/>
      <url>2023/05/27/paper-reading-orbslam-atlas/</url>
      
        <content type="html"><![CDATA[<h1 id="SEAMLESS-MAP-MERGING-in-ORBSLAM-Atlas"><a href="#SEAMLESS-MAP-MERGING-in-ORBSLAM-Atlas" class="headerlink" title="SEAMLESS MAP MERGING in ORBSLAM-Atlas"></a>SEAMLESS MAP MERGING in ORBSLAM-Atlas</h1><p>为了检测地图的合并，我们使用ORBSLAM的place recognition阶段。它对由共视图连接的三个关键帧进行重复的位置识别，以减少错误检测的风险。</p><p>下面介绍SEAMLESS MAP MERGING的流程，我们使用a、s、m三个子索引分别指代活动的（active）、被吞噬的（swallowed ）和合并的（merged ）地图。</p><ol><li><strong>检测两张地图之间的共同区域</strong>。place recognition提供了两个匹配的关键帧$K_a$和$K_s$，以及两个地图$M_a$和$M_s$中地图点之间的假定匹配。</li><li><strong>估计两张地图之间的变换矩阵</strong>。在双目模式下需要估计欧式变换矩阵$SE(3)$，而在单目模式需要估计相似变换矩阵$Sim(3)$。我们结合了Horn的方法[1]和RANSAC算法，从地图$M_a$和$M_s$中地图点之间的假定匹配中计算出一个初始估计，我们将估计的变换矩阵应用于关键帧$K_s$的引导性匹配阶段，我们在关键帧$K_s$中匹配地图$M_a$中的点，通过对重投影误差进行非线性优化，最终估计出$T_{W_a,W_s}$。</li><li><strong>融合两张地图</strong>。我们将$T_{W_a,W_s}$应用于所有关键帧和地图$M_S$中的点，然后，我们检测重复的地图点并将其融合，从而得到从地图$M_s$和$M_a$的关键帧观察到的地图点。 之后，我们将地图$M_s$和$M_a$的所有关键帧和地图点合并到地图$M_m$中。此外，我们将地图$M_s$和$M_a$的生成树和共视图合并为地图$M_m$的生成树和共视图。</li><li><strong>在连接区域进行局部BA</strong>。连接区域包括地图$M_m$的共视图中与关键帧$K_a$共视的所有关键帧。为了固定测量的自由度，地图$M_a$中固定的关键帧在局部BA时保持固定，而其余的关键帧在非线性优化过程中被设置为可优化的变量。我们应用第二个重复点检测和融合阶段来更新地图$M_m$的共视图。</li><li><strong>位姿图优化</strong>。最后，我们对地图$M_m$进行了位姿图优化。</li></ol><p>地图合并的线程与跟踪线程、局部建图线程以及全局BA线程并行。在开始合并之前，局部建图线程被停止，以避免在atlas中增加新的关键帧；如果全局BA线程正在运行，它也会被停止，因为生成树在全局BA之后会被改变。跟踪线程在旧的活动地图上保持运行，以保持实时计算位姿。一旦地图合并完成，我们就恢复局部建图线程。全局BA如果已经停止，也将重新启动以处理新数据。</p><p><strong>REFERENCES</strong></p><p>[1] B. K. Horn, “Closed-form solution of absolute orientation using unit quaternions,” JOSA A, vol. 4, no. 4, pp. 629–642, 1987.</p>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Exploring NeRF-My Journey Through Research and Code</title>
      <link href="2023/04/26/meeting-4/"/>
      <url>2023/04/26/meeting-4/</url>
      
        <content type="html"><![CDATA[<h1 id="Exploring-NeRF-My-Journey-Through-Research-and-Code"><a href="#Exploring-NeRF-My-Journey-Through-Research-and-Code" class="headerlink" title="Exploring NeRF: My Journey Through Research and Code"></a>Exploring NeRF: My Journey Through Research and Code</h1><blockquote><h2 id="Taichi-社区分享会-2023-4-26"><a href="#Taichi-社区分享会-2023-4-26" class="headerlink" title="Taichi 社区分享会 2023.4.26"></a>Taichi 社区分享会 2023.4.26</h2></blockquote><h2 id="如何阅读一篇论文"><a href="#如何阅读一篇论文" class="headerlink" title="如何阅读一篇论文"></a>如何阅读一篇论文</h2><h3 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h3><p>对于像我一样的入门学习者，提供一些我学习过程中的经验</p><p>在读论文之前，先梳理一个框架出来，大致包括以下内容：</p><ul><li><p>What: 这篇论文主要做的工作是什么，基于什么背景</p></li><li><p>How: </p><p>这篇论文具体是怎么做的，一般都会有以下部分</p><ul><li>Pipeline</li><li>Cutting-edge 的方法</li><li>Tricks &amp; Optimizations</li></ul></li><li><p>Results: </p><p>这篇论文最后的结果如何，如何衡量效果</p><ul><li>Experiments &amp; Metrics &amp; Demo</li><li>Benchmarks 的适用范围</li></ul></li></ul><p>可以用笔记或者思维导图的形式先梳理一个这样的 backbone，之后在阅读论文的过程中一点一点填进去</p><p><strong>我们以 NeRF 为例来使用一下这个框架</strong></p><ul><li>What:<br>通过稀疏的输入视图优化底层的的连续神经辐射场，实现复杂场景的新视角合成</li><li>How:<ul><li>Pipeline</li><li>Cutting-edge 的方法 : 可微的隐式场景表示</li><li>Tricks &amp; Optimizations<ul><li>位置编码 (Positional encoding)</li><li>分层采样 (Hierarchical volume sampling)</li></ul></li></ul></li><li>Results:<ul><li>PSNR/SSIM/LPIPS/Demo(novel view)</li><li>Benchmarks 的适用范围： llff/blender/deepvoxels/LINEMOD</li></ul></li></ul><h3 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h3><p>关注论文中的图，论文中的图可以最直观的反映论文里提到的内容</p><p><img src="/images/meeting-4/paper_contents1.png"></p><p><img src="/images/meeting-4/paper_fig3.png"></p><h3 id="Part-3"><a href="#Part-3" class="headerlink" title="Part 3"></a>Part 3</h3><p>关注论文中的公式，这有助于更好地理解算法原理，对于阅读源码也会有所帮助，建议自己手推一遍论文中的公式，相关参考资料可以从论文 reference 中收集</p><p>在 NeRF 的论文中，涉及到了以下几个公式</p><ul><li>透射率</li><li>颜色积分</li><li>分段体积渲染</li><li>NDC 坐标系转换</li></ul><p>公式推导可以参考笔记 ➡️ <a href="http://zicx.top/notebook/paper/nerf/math/">NeRF 公式推导</a></p><h3 id="借助工具"><a href="#借助工具" class="headerlink" title="借助工具"></a>借助工具</h3><p>以下工具可以帮助我们更高效地读取论文，非常值得尝试</p><ul><li><p><a href="https://www.chatpdf.com/">ChatPDF</a>: Chat with any PDF</p></li><li><p><a href="https://github.com/binary-husky/chatgpt_academic">ChatGPT Academic </a>: 科研工作专用 ChatGPT/GLM 拓展</p></li><li><p>New Bing: 选择 Edge 浏览器为 PDF 文件打开方式，可以直接在页面上与 Bing chat 交互</p></li></ul><p><img src="/images/meeting-4/chat_with_bing.png"></p><h2 id="如何学习代码——以NeRF为例"><a href="#如何学习代码——以NeRF为例" class="headerlink" title="如何学习代码——以NeRF为例"></a>如何学习代码——以NeRF为例</h2><h3 id="挑选合适的资源"><a href="#挑选合适的资源" class="headerlink" title="挑选合适的资源"></a>挑选合适的资源</h3><p>NeRF 的代码实现有很多方式，可以从中选取比较熟悉的实现方式</p><ul><li><a href="https://github.com/bmild/nerf">官方的 TensorFlow 实现</a></li><li><a href="https://github.com/yenchenlin/nerf-pytorch">Pytorch 实现</a></li><li><a href="https://github.com/xunull/read-nerf-pytorch">Read NeRF Pytorch </a>: 带注释版本的 nerf-pytorch</li><li><a href="https://github.com/taichi-dev/taichi-nerfs">Taichi + PyTorch </a>: Taichi + Pytorch 实现</li></ul><p>建议学习 Pytorch 相关的实现方式，Pytorch 是现在更加主流的框架</p><h3 id="如何学习源码"><a href="#如何学习源码" class="headerlink" title="如何学习源码"></a>如何学习源码</h3><p>推荐用<strong>模块化</strong>的方式来学习源码，边看源码的结构边<strong>整理框架</strong><br>CV/DL 相关的论文源码一般都会包括以下几部分</p><ul><li>Datasets</li><li>Networks</li><li>Evaluators</li><li>Trainers</li><li>Visualizers(optional)</li></ul><p>对于 NeRF 而言，还会多一个模块 : <code>Renderer</code></p><p>读代码的过程中，也可以多做一些事情</p><ul><li>顺手记录一下用到的<strong>参数</strong>，方便之后复现</li><li>对比论文中的一些算法和细节，弄清楚如何用代码实现的<br>(position encoding/volume rendering etc.)</li></ul><h3 id="动手实践"><a href="#动手实践" class="headerlink" title="动手实践"></a>动手实践</h3><p>一种比较高效的学习源码方式是看代码的同时自己跟着写，慢慢地完善代码的各个部分，最后完全实现</p><p>这个过程也有很多需要注意的地方 :</p><ul><li>自己写很难有和原作者不同的思路和框架，容易变成 C-c + C-v，因此推荐按照之前提到的框架来写</li><li>按照模块化的方式来检验自己写的代码能不能 work，一次性 debug 整个框架会很困难，debug 的过程很<del>痛苦</del>快乐</li><li>学习了源码的实现方式后，提取实现过程中的<strong>重点思想和方法</strong>，然后尝试<strong>不看源码</strong>来实现自己的代码</li></ul><h2 id="如何复现-NeRF"><a href="#如何复现-NeRF" class="headerlink" title="如何复现 NeRF"></a>如何复现 NeRF</h2><h3 id="数据集准备"><a href="#数据集准备" class="headerlink" title="数据集准备"></a>数据集准备</h3><p>Pipeline</p><ul><li>用手机拍摄一段目标物体的多视角视频</li><li>用 ffmpeg 对视频抽帧得到目标物体的多视角图像</li><li>借助 Colmap 标定，获得相机的内参和外参</li><li>整理数据格式，生成 NeRF 对应的数据集 ( 推荐使用 Blender 格式 )</li></ul><p>数据集格式</p><pre class="line-numbers language-none"><code class="language-none">.├── train│   ├── r_0.png│   ├── r_1.png│   └── ...├── ...└── transforms_train.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h3><p>数据集准备完，在之前自己实现的框架上训练模型，为了检验代码是否能 work，可以在训练的过程中关注一些量化的数据，借助 TensorBoard 我们可以可视化训练过程</p><p><img src="/images/meeting-4/image-20230426212323139.png"></p><h3 id="Eval-结果"><a href="#Eval-结果" class="headerlink" title="Eval 结果"></a>Eval 结果</h3><p>模型训练完之后，可以保存模型做 evaluate，通过 novel view 和 metrics 来检验训练结果 (200k iterations)</p><p><img src="/images/meeting-4/image-20230426212837062.png"></p><h3 id="一些-Tips"><a href="#一些-Tips" class="headerlink" title="一些 Tips"></a>一些 Tips</h3><p>关于自己制作数据集，需要注意以下几点</p><ul><li>拍摄场景的光照条件尽可能保持一致</li><li>尽量保持多视角物体在图像中的相对位置不变</li><li>为了获得更精确的相机内参，可以在用 COLMAP 的时候选择<strong>共享内参</strong></li><li>多视角图像的数量保持在 50-100 张比较合适</li></ul><p>训练过程中模型调参</p><ul><li>先根据论文中的参数复现，遇到问题再检查各个模块</li><li>由于拍摄场景的不同，需要调整 scene 的 near 和 far 参数 ( 原先 NeRF 中使用的是 2.0 和 6.0 )</li><li>关注训练过程中 loss 的变化，如果有问题的化可以考虑简化训练过程，只用 coarse model 进行训练，查看结果是否有问题，没问题再加上 fine model</li><li>…</li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于神经网络的三维重建</title>
      <link href="2023/04/25/3d-reconstruction-1/"/>
      <url>2023/04/25/3d-reconstruction-1/</url>
      
        <content type="html"><![CDATA[<h1 id="基于神经网络的三维重建"><a href="#基于神经网络的三维重建" class="headerlink" title="基于神经网络的三维重建"></a>基于神经网络的三维重建</h1><h2 id="1-对NeRF的思考"><a href="#1-对NeRF的思考" class="headerlink" title="1 对NeRF的思考"></a>1 对NeRF的思考</h2><p>NeRF的核心是场景的隐式表示，给定一组影像，网络去学习这个三维场景，然后当指定任意一个位姿的时候，就输出它对应的图片。这其实和传统的SfM的流程是一样的，没什么新鲜的。唯一不同的是SfM构建的是场景的显式表达，而NeRF是通过神经网络进行了表达。现在很多NeRF的宣传都是一张静态图片搭配小幅度移动视角的动图，比如下面这样。</p><p><img src="/images/3D-Reconstruction-1/2022-05-14-44.gif"></p><p>但这样宣传有些误导性。下面简单描述。</p><h3 id="1-1-NeRF并非只利用单张影像"><a href="#1-1-NeRF并非只利用单张影像" class="headerlink" title="1.1 NeRF并非只利用单张影像"></a>1.1 NeRF并非只利用单张影像</h3><p>第一点，NeRF不是由单张影像得到的。上面这样宣传，很容易让人以为是单张图片得到了可以小幅移动视角的三维场景。这是不对的。如果从单张影像生成三维场景，这就是一个玄学问题了。NeRF并不是只利用单张影像估计三维场景。</p><p>我的个人看法是利用单张影像永远也无法恢复出准确的三维场景。这是一个病态问题。就如同单张影像深度估计一样，很多时候都是玄学问题。对于单张影像深度估计，我认为这个问题的核心在于两点：一是这是一个“无中生有”的信息缺失补全问题。如果说可以利用其它模态的数据作为参考，也许是有物理意义的，但仅靠单张图像是站不住脚的。二是深度本身和图像中的纹理、语义等没有明显的关联关系。对于这种没有明显对应关系的两个变量，深度学习能力再强，也很难学到真正有价值的东西。一个简单的例子就是，比如我有一面白墙，拍了一张照片，然后我在墙上挂了一幅山水画，又拍了一张，最后，我关灯了，墙变黑了，我又拍了一张。一共有三张照片。从常识都知道，这三张照片的深度不会有变化(如果考虑画的厚度，反映在深度图上会是一个规则的突出矩形)。但事实上，目前应该鲜有网络能真正准确估计——如果它学到的是和图片位置相关的知识，那么白墙从上到下的深度就不同；如果它学到的是灰度相关的知识，那么它估计的白墙和黑墙的深度就不同；如果它学到的是纹理的知识，那么在山水画上，它就会估计出不同的深度(但显然它只是一幅画而已，我们作为人是不会把它真的有深度的)。</p><p>当然你可能会反驳我，那现在有些单张影像深度估计做的很好的工作啊？难道没有意义吗？我的回答是，在某些特定场景下可能有意义。比如某个深度估计网络，它利用KITTI数据进行训练。由于KITTI数据都是采用同一套传感器在相似场景下拍摄的，它拍摄的所有影像都有相似的内容和深度分布，比如靠近图像下方的都是路面，图像上方中间的一般为天空等。深度网络确实可能学到这些与位置有关的信息(天空纹理较少、路面纹理较多、天空比路面深度更深等)，进而给出深度估计。那么当输入一个和KITTI类似的影像的时候，它也可以估计出一个还不错的深度图。但是如果换了一个配置，比如输入EuRoC的数据，尽管它本身的内容、深度分布和KITTI相差很大，但网络还是按照KITTI的那一套估计深度，结果就显而易见了，所以泛化性较差。因此，在我看来这种数据驱动的方法还是没能从根本上解决这个问题，难以给出令人信服的解释。场景的几何结构是其固有属性，与外界的观测无关，不管你怎么观测，它都不会改变。但深度估计的网络恰恰就是依靠这种不可靠的“观测”学到的。利用缺失的信息是没有办法真正恢复三维场景的，至少说很困难。</p><h3 id="1-2-NeRF并非只能合成特定视角影像"><a href="#1-2-NeRF并非只能合成特定视角影像" class="headerlink" title="1.2 NeRF并非只能合成特定视角影像"></a>1.2 NeRF并非只能合成特定视角影像</h3><p>第二点，NeRF是三维场景的隐式表达，也就是说其包含了完整的三维场景。基于训练好的NeRF，我们有能力合成该场景任意视角的影像，比如360旋转的视角，而非仅仅只是可以小幅度移动视角的模型。所以，个人觉得最正确的NeRF表现形式应该是一堆图片+360旋转视角的动图。</p><h3 id="1-3-没有图片位姿可以训练NeRF吗"><a href="#1-3-没有图片位姿可以训练NeRF吗" class="headerlink" title="1.3 没有图片位姿可以训练NeRF吗"></a>1.3 没有图片位姿可以训练NeRF吗</h3><p>对于一堆原本没有位姿的图片，可以训练NeRF吗？答案是否定的。NeRF的输入必须是影像+位姿。但是，我们可以“曲线救国”——我们可以先用COLMAP等传统的SfM软件对场景进行重建，重建好以后，当然就可以获得每张图片的位姿。事实上，不一定需要COLMAP，只要能输出影像间的相对位姿都可以，所以对于序列影像我们甚至可以拿SLAM来获得位姿。我们拿着这些位姿，配上图像，就可以输入NeRF进行训练了。</p><h3 id="1-4-NeRF不能无中生有"><a href="#1-4-NeRF不能无中生有" class="headerlink" title="1.4 NeRF不能无中生有"></a>1.4 NeRF不能无中生有</h3><p>NeRF还有一个值得注意的地方，就是NeRF作为某个特定场景的隐式表达，我们就可以把它理解为是一个三维模型。所以说，它只能合成出这个场景的不同视角影像，没有办法合成出新的场景的影像。另外，如果拿一张其它场景的影像，它也没有办法去匹配找到正确的位姿(因为就完全不在这个三维模型里)。</p><h3 id="1-5-NeRF的应用场景"><a href="#1-5-NeRF的应用场景" class="headerlink" title="1.5 NeRF的应用场景"></a>1.5 NeRF的应用场景</h3><p>除了上面提到的合成新视角影像、辅助计算机视觉任务等，从某种程度上来说，NeRF可以用于逆向工程。对于一个没有精确三维模型的零部件，我们拍一堆图像(已知位姿)，然后训练一个场景表示，最终把这个场景表示导出成三维模型。当然你可能会问，如果说你都拍了一堆图像(已知位姿)，为什么不用传统的视觉方法重建场景呢？这就是一个典型的SfM问题啊。关于这个问题我也没有答案。是不是NeRF建出的模型更稠密、精度更高呢？</p><blockquote><p>传统的方法重建场景还是比较麻烦的，我理解的狭义的sfm还只是到了稀疏点云的那一步，后续还有稠密重建、点云融合、网格重建、网格优化、纹理贴图这些MVS的步骤才能有一个实质的模型。</p><p>感觉NeRF从效果上讲应该是和后面的MVS作对比，因为他的输入就是稀疏重建的输出（图像位姿和稀疏点云，有些nerf网络好像需要点云这个输入），从方法上来说NeRF更一步到位，从稠密度来说，NeRF更加稠密。</p></blockquote><h3 id="1-6-NeRF与SLAM的结合"><a href="#1-6-NeRF与SLAM的结合" class="headerlink" title="1.6 NeRF与SLAM的结合"></a>1.6 NeRF与SLAM的结合</h3><p>NeRF与SLAM从某些角度上来看具有一定的相似性。可能在地图存储、位姿估计方面有一定的结合点。比如现在的SLAM地图都是显式的存储三维点云，但如果可以用NeRF隐式地存储，也许会有一些新的应用。</p><h2 id="2-Multi-view-Reconstruction-with-SDF"><a href="#2-Multi-view-Reconstruction-with-SDF" class="headerlink" title="2 Multi-view Reconstruction with SDF"></a>2 Multi-view Reconstruction with SDF</h2><h3 id="2-1-什么是SDF"><a href="#2-1-什么是SDF" class="headerlink" title="2.1 什么是SDF"></a>2.1 什么是SDF</h3><p>有向距离场的定义如下</p><p><img src="/images/3D-Reconstruction-1/2022-05-26-23.png"></p><p>简单来说就是，对于空间中的点，计算它距离最近表面的距离。如果在表面内就为负，表面外就为正。需要注意的是SDF它是一种思路与方法，它不仅仅可以用于场景的三维表示，还可以用于字体渲染等领域。</p><p><img src="/images/3D-Reconstruction-1/2022-05-26-24.png"></p><p>在SDF领域，有个DeepSDF的工作，如上图所示。其主要内容就是通过深度网络来给出空间中某个点的SDF的值。NeRF的网络结构设计在一定程度上就是受这个网络的启发。</p><h3 id="2-2-如何用SDF建模"><a href="#2-2-如何用SDF建模" class="headerlink" title="2.2 如何用SDF建模"></a>2.2 如何用SDF建模</h3><p><img src="/images/3D-Reconstruction-1/2022-05-26-25.png"></p><p>上面，我们介绍了什么是SDF，那么如何用SDF来进行重建呢？不妨先回忆一下NeRF的训练过程。我们得到一个密度场和一个颜色场，然后利用渲染方程，得到合成的图像，并将其与真值做Loss，不断迭代，减小误差。这是比较容易理解的。但前面也说了，基于密度场的重建效果是比较差的。进一步，我们能不能把NeRF流程里的密度场替换成SDF场呢？如果可以的话，那么我们就可以基于SDF得到质量较高的三维模型了。这样想法没错。但是如果真的这样替换的话又会有新的问题。直观来说，NeRF输出的2D影像就是基于密度和颜色渲染出来的。你现在直接把密度场给丢掉了，还怎么渲染影像呢？能不能把积分公式中的密度换成SDF呢？不行，因为NeRF中对密度进行积分是有物理意义的。所以这个问题的核心是，我们如何找到一种转换，把SDF转换成NeRF中的密度。如果可以的话，就可以继续使用NeRF的框架，并且还可以得到SDF。一个可用的工作就是NeuS，将密度场和有向距离场联系起来，如上图所示。</p><p><img src="/images/3D-Reconstruction-1/2022-05-26-26.png"></p><p>首先，我们可以模仿一下渲染方程里的密度函数σ，我们也找一个概率密度函数把SDF表示起来。在论文中，作者选用了一个Logistic的分布函数，它是Sigmoid函数的导数。事实上，我们可以选择不同的概率密度函数，只要它是单峰的、且以0为中心就可以了。进一步，对于体积渲染方程，我们可以简化成上图中最下面公式的样子。把T(t)和σ(r(t))变成一个权重w(t)。这样的意义就是，我们把某个像素最终的渲染结果看做是由某条光线上所有采样点的颜色加权求和得到(这里我们把密度作为权重的一部分了)。进一步我们思考这个权重应该具备什么性质？至少有两个：第一是无偏的。无偏是指在最合适的地方有最合适的值。举个例子，某条光线穿过一个表面。那么这个像素的颜色应该由在这个表面的那一点的颜色决定，权重最高。但如果还没到表面点的时候，权重就很大了，这显然就是不合适的。第二是可以反应遮挡的。举个例子，空间中有一个球体，一条光线穿过它，显然会有两个点(入射点和出射点)。从SDF而言，这两个点的SDF值都为0。但从渲染的角度，显然是里我们最近的那个点应该具有最大的权重，而不是远处的那个点，或者两个点等权。</p><p><img src="/images/3D-Reconstruction-1/2022-05-26-27.png"></p><p>基于上面提到的两点，我们寻找最优的权重的表示，如上图所示。一个简单的想法是，我们把SDF外面套一个Logistic分布，就可以得到新的σ(t)。然后以此组成新的权重w(t)。这样其实得到的是有偏的权重，如右图左边部分所示。蓝色表示SDF函数，在物体表面时，SDF=0。由于我们选用的又是Logistic分布，所以概率密度应该如红色曲线所示。看起来还不错。但如果我们把这个σ(t)函数积分出来，就会发现这个权重在还没有到达表面的时候就已经到达了峰值。这显然就是有偏的。所以在NeuS工作中，首先将Logistic积到了Sigmoid函数，然后利用它作为权重。如上图中右边所示。可以看到，当在物体表面的时候，w(t)有最大值，也就是最大权重，这是一个无偏的表示。进一步，可以对比NeRF和NeuS的渲染方程如下。</p><p><img src="/images/3D-Reconstruction-1/2022-05-26-28.png"></p><p>NeuS采用的Loss如下。</p><p><img src="/images/3D-Reconstruction-1/2022-05-26-29.png"></p><p>此外，上图中可以看到NeuS和NeRF的对比。NeuS比NeRF更加光滑、干净的三维结果。事实上，上面说的这些，核心的思路还是寻找密度和SDF之间的关联，找到这种关联以后，就可以把SDF应用到NeRF的框架中去。所以，NeuS是一种办法，当然也会有其它办法，如下图所示。</p><p><img src="/images/3D-Reconstruction-1/2022-05-26-30.png"></p><p>比如VolSDF利用拉普拉斯分布表示密度和SDF之间的变换。Unisurf则是采用Occupancy Field，而不是SDF。此外，除了关注前景，我们还可以同时关注背景，这方面的工作是NeRF++。通过将前景放到圆里，背景放到圆外，分别训练两个模型来分别合成。</p><h2 id="3-场景三维重建"><a href="#3-场景三维重建" class="headerlink" title="3 场景三维重建"></a>3 场景三维重建</h2><h3 id="3-1-传统COLMAP"><a href="#3-1-传统COLMAP" class="headerlink" title="3.1 传统COLMAP"></a>3.1 传统COLMAP</h3><p><img src="/images/3D-Reconstruction-1/2022-05-27-03.png"></p><p>如上图所示，展示了COLMAP进行三维场景重建的步骤。简单来说就是首先对输入的影像进行特征提取与匹配等操作，找到对应关系，得到相机的位姿。然后在此基础上进行增量式重建。当然这个过程不可避免地会引入一些误差，所以会用BA等进行优化。上面提到的是用COLMAP进行三维重建的流程。如果用NeRF进行三维重建，应该有什么样的流程呢？</p><h3 id="3-2-NeRF"><a href="#3-2-NeRF" class="headerlink" title="3.2 NeRF"></a>3.2 NeRF</h3><p><img src="/images/3D-Reconstruction-1/2022-05-27-04.png"></p><p>利用NeRF进行三维重建，首先要有一堆拍摄的影像。然后我们还要有对应的每一张影像的位姿。这个位姿可以是通过SfM的方法获得，也可以通过SLAM获得，或者说外部直接测量提供都可以。然后将影像+位姿输入NeRF进行训练。训练好以后，给定一个位置和视角，网络就可以给出密度场和颜色场，基于此就可以渲染出合成视角影像。那么相比于传统COLMAP，NeRF有什么优劣呢？主要体现在两个方面：第一，NeRF的重建结果相比于COLMAP而言是更加稠密的；第二，根据上面的介绍也可以看出，NeRF相比于传统方法，流程会更加简单。一句话概括就是：用更简单的流程获得了更稠密的重建。</p><h2 id="4-场景重建中的挑战"><a href="#4-场景重建中的挑战" class="headerlink" title="4 场景重建中的挑战"></a>4 场景重建中的挑战</h2><p><img src="/images/3D-Reconstruction-1/2022-05-27-10.png"></p><p>毫无疑问，NeRF跟传统重建技术的区别主要还是在于NeRF可以隐式地学习体素的表示。通过带有位姿的多视影像，NeRF可以学习到场景的表达，最终合成新视角影像。进一步，我们分析各个步骤，如下。</p><p><img src="/images/3D-Reconstruction-1/2022-05-27-11.png"></p><p>首先，我们的网络在训练阶段对于输入是有一定要求的。首先是相机位姿，我们需要输入的相机位姿是非常准确的，不然训练的网络效果不会很好。另外一个输入是多视影像，我们自然希望是要有稳定、统一的光照。不然就如同RGB-D SLAM一样，建出的图颜色不均匀。第二个是自然希望场景中没有运动物体，不然这种不统一的运动会给位姿估计带来影响。最后，可能出现真实的大场景，如何平衡性能，进行优化也是值得思考的问题。所以之后的内容主要围绕输入影像、输入位姿以及大场景这三个方面介绍。</p><h2 id="5-Neural-Approach-to-Scene-Reconstruction"><a href="#5-Neural-Approach-to-Scene-Reconstruction" class="headerlink" title="5 Neural Approach to Scene Reconstruction"></a>5 Neural Approach to Scene Reconstruction</h2><h3 id="5-1-位姿优化"><a href="#5-1-位姿优化" class="headerlink" title="5.1 位姿优化"></a>5.1 位姿优化</h3><p><img src="/images/3D-Reconstruction-1/2022-05-27-13.png"></p><p>前面说了，NeRF的输入之一是相机的位姿，除了物理意义上通过外部测量直接获得位姿真值，我们也可以通过各种手段去算位姿：</p><ul><li>第一种方法是，我们可以用各种标定板，如Chessboard、AprilTag、ArUco board等，通过特殊的算法，就可以求得相机相对于标定板的位姿；</li><li>第二种方法是使用各种SLAM方法进行位姿估计；</li><li>第三种方法是使用SfM方法，如COLMAP等；</li><li>第四种方法是基于NeRF，比如之前提到的iNeRF工作，通过给定一个影像，得到该影像相对于场景的相对位姿。</li></ul><p>这四种方法各有千秋：</p><ul><li>对于基于标定板的方法，显然只适合于小场景，对于室外等大场景就比较无能为力；</li><li>对于SLAM方法，其本身没有场景大小的限制。但是由于其更关注于实时性，在一定程度上牺牲了一定的精度，导致其估计的位姿相比于SfM方法精度要差一些。</li><li>对于SfM方法，相比于SLAM方法则是相反，其更关注于精度，但是运行效率会差一些，更加耗时，只能离线处理。</li></ul><p>因此，我们也就进一步回答了之前“没有图片位姿可以训练NeRF吗”。但显然的，除非是非常高精度设备测量的位姿，否则算出来的位姿或多或少都会有点噪声或者说不准确。所以我们就想，能不能让网络有一定的噪声容忍能力，所以BARF就出现了，来自于CMU，如下：</p><p><img src="/images/3D-Reconstruction-1/2022-05-27-14.png"></p><p>在这个工作中，作者利用传统SLAM中的BA方法优化影像位姿，如上图所示。一般NeRF需要精确的位姿，但是BARF输入的位姿可以是有误差的，通过他们的方法可以调整这种误差，最终得到和NeRF相同的效果。</p><p>一些基本的三维重建坐标系介绍如下，此处不再赘述</p><p><img src="/images/3D-Reconstruction-1/2022-05-27-15.png"></p><p>在BARF中是怎么做呢？如下图所示。</p><p><img src="/images/3D-Reconstruction-1/2022-05-27-16.png"></p><p>我们做一个帧间BA，使得重投影误差最小。当然学过SLAM的应该知道，这一块理论推导还是挺难的，如果从实际应用的角度，可能会简单一些，因为很多东西已经写好了，我们只需要拿来用就可以了，如下。</p><p><img src="/images/3D-Reconstruction-1/2022-05-27-17.png"></p><p>但还有个问题，那就是我们前面提到过的NeRF中的positional encoding。我们利用这种手段使得网络有能力感知到影像中的低频和高频信息，而不是简单的x、y、z坐标。但这确实会给位姿优化带来困难。</p><p><img src="/images/3D-Reconstruction-1/2022-05-27-18.png"></p><p>我们如果对positional encoding求导，就会得到左下角的式子，可以看到有个比例系数。而且这个系数与层级有关，层级越高，代表频率越高，但是权重越大。这样的结果就是对于高频和低频的信息表达是不均衡的，网络更容易学到一些高频的部分。</p><p>因此，BARF提供了一种新的机制，如下。</p><p><img src="/images/3D-Reconstruction-1/2022-05-27-19.png"></p><p>可以看到，BARF采用了退火机制。本质上来说就是对positional encoding增加了一个权重。简单来说就是，在网络刚开始训练的时候，只开放了低频的响应，而随着训练次数的增加，逐渐开放高频部分。这也是一种由粗到细的策略，可以保证网络在一开始的时候就不会学到什么奇奇怪怪的东西。</p><p>下图是BARF的效果展示。</p><p><img src="/images/3D-Reconstruction-1/2022-05-27-20.png"></p><p>可以看到，加了BARF以后，场景的细节恢复地非常好。然后，另一个工作iNeRF，如下所示。</p><p><img src="/images/3D-Reconstruction-1/2022-05-27-21.png"></p><p>在有了一个训练好的NeRF以后，我们可以实现基于影像的定位。</p><h3 id="5-2-影像优化"><a href="#5-2-影像优化" class="headerlink" title="5.2 影像优化"></a>5.2 影像优化</h3><p>在处理完了位姿不准的问题以后，另一个问题就是要对图像进行优化，如上面描述，又主要分为光照变化和动态物体两个方面，下面分别介绍。</p><h4 id="5-2-1-光照变化"><a href="#5-2-1-光照变化" class="headerlink" title="5.2.1 光照变化"></a>5.2.1 光照变化</h4><p><img src="/images/3D-Reconstruction-1/2022-05-27-22.png"></p><p>这个问题的核心在于，我们输入NeRF的影像自然是希望每张影像光照都比较均匀，变化较小。这在光照条件控制较好的室内或者小场景中还比较容易，但是对于室外等大场景几乎是不可能的。如何对这些不均匀的光照进行优化，是这部分要讨论的问题。</p><p><img src="/images/3D-Reconstruction-1/2022-05-27-23.png"></p><p>一种解决策略是在RGB域建模，通过设置某个可调整的参数，使得网络具备调整影像的能力。另一种是在第一种的基础上更进一步，把ISP处理pipeline中的步骤同样进行建模，让网络学习。最后一种是直接对传感器直出的RAW数据进行训练，得到NeRF。</p><p>这方面的第一个工作是NeRF in the Wild，如下。</p><p><img src="/images/3D-Reconstruction-1/2022-05-27-24.png"></p><p>左侧为原始NeRF的流程。右侧作者增加了appearance embedding和transient embedding这两个变量来学习颜色的变化。结果如下。</p><p><img src="/images/3D-Reconstruction-1/2022-05-27-25.png"></p><p>进一步，我们如果考虑ISP处理的一些步骤，也可以对其进行建模。这是ADOP的工作，如下。</p><p><img src="/images/3D-Reconstruction-1/2022-05-27-26.png"></p><p>可以看到，网络有能力学习到场景的一些本征的颜色。比如黄色的沙发因为逆光在真实影像中偏暗，但是在合成的影像中，就被恢复的比较好了。</p><p><img src="/images/3D-Reconstruction-1/2022-05-27-27.png"></p><p>最后一种思路是在Raw数据上做NeRF，这是NeRF in the dark的工作，如下。</p><p><img src="/images/3D-Reconstruction-1/2022-05-27-28.png"></p><p>其实想法也比较简单。常规的NeRF拿到的影像是经过ISP处理以后的影像，这种处理引入了各种非线性变换，那么网络去拟合这种变换其实是比较困难的事情。另外，在处理的过程中，也会压缩位宽，导致一些信息损失。所以作者就直接在RAW数据上训练NeRF。</p><h4 id="5-2-2-动态物体"><a href="#5-2-2-动态物体" class="headerlink" title="5.2.2 动态物体"></a>5.2.2 动态物体</h4><p>在处理了光照不均衡的情况以后，影像相关的另一个挑战就是动态物体。</p><p><img src="/images/3D-Reconstruction-1/2022-05-27-29.png"></p><p>解决这个问题一般来说有两种做法，如下。</p><p><img src="/images/3D-Reconstruction-1/2022-05-27-30.png"></p><p>一个简单的想法就是，利用语义信息识别出一些可能运动的物体，然后把它们忽略掉(上图左边)。但这样有个潜在的问题，如果被擦除的物体在其它视角下也没见过，那么就会产生空洞。另一种办法就是，真正的对动态物体的重建完成，具体可以通过光线变换来重建动态物体(上图右边)。</p><p>一个工作Neural Scene Graphs就是这样一个工作，如下图所示。</p><p><img src="/images/3D-Reconstruction-1/2022-05-27-31.png"></p><p>作者通过场景图将场景和运动目标分割开，如上图所示。各个节点之间的关系是通过相对变换得到的。在训练过程中，背景单独用NeRF训练。而对于前景目标，有两种不同的做法，如下图所示。</p><p><img src="/images/3D-Reconstruction-1/2022-05-27-32.png"></p><p>一种方法是，我们可以对每一个运动物体单独用一个很小的NLP来学习，通过多个NLP最终对每个运动目标进行恢复。另一种则是，对于一类物体，共享一个大的NLP，通过学习latent code来区分不同的实例。这两种方式需要根据具体场景决定。当场景中车辆很多的时候，前者的参数量或者学习难度是随着数量而线性增长的，而后者因为共享参数则不会有明显的增长。但如果我们需要对每个车进行精细的建模，那么显然前者更加合适一些。实际渲染过程与结果如下图所示。</p><p><img src="/images/3D-Reconstruction-1/2022-05-27-33.png"></p><h3 id="5-3-大场景挑战"><a href="#5-3-大场景挑战" class="headerlink" title="5.3 大场景挑战"></a>5.3 大场景挑战</h3><p>最后一部分是NeRF在大场景中的挑战，如何平衡性能与精度等问题，如下所示。</p><p><img src="/images/3D-Reconstruction-1/2022-05-27-34.png"></p><p>如上图所示，对于一些较小的场景，观测一般都是由外向内进行聚合的。这样我们很容易得到被摄物体的三维包围框。但在室外等大场景中，很难有一个三维的包围框可以把整个场景包含在里面。另外，对于室外的场景，还不可避免的有“天空”问题。在采集过程中，很多视角都会采集到天空的像素，但事实上这些像素是我们重建中不需要考虑(简单的方法是增加mask)。此外还有远处场景的细节优化问题等。对于大场景的建模，还是相对复杂的。</p><p><img src="/images/3D-Reconstruction-1/2022-05-27-35.png"></p><p>如上图所示，在最左边的图中，我们给远处分配较大权重，那么近处就会相对模糊。反之，近处权重高以后，远处又会变模糊。所以其实是比较难的问题。在KITTI数据上也是一样，远处的树木可能发生一些偏移。所以总结起来就是，我们没有办法通过有限的资源来掌握场景中的所有细节。尽管很困难，但还是有相关工作，如下。</p><p><img src="/images/3D-Reconstruction-1/2022-05-27-36.png"></p><p>Block NeRF主要是针对街景数据的处理，通过对场景进行分块，并保证各个块之间有重叠，实现多个NeRF的联合。Mega NeRF主要是针对无人机数据的处理。它的思路和Instant NGP和KiloNeRF有一定的相似之处。下图展示了Block NeRF更细节的内容。</p><p><img src="/images/3D-Reconstruction-1/2022-05-27-37.png"></p><p>这里还引入了Visibility概念。简单来说就是，如果我们要渲染某个位置的影像，理论上来说我们要查询所有的NeRF网络，找到那些和当前视角相关的进行渲染。但这样每个NeRF网络都查询，显然是非常耗时的。所以作者又训练了一个小网络。这个网络的作用是判断某个位置是否在当前NeRF的场景中。这样只需要查询相关的NeRF网络就可以，而不需要每个都遍历，提升了效率。</p><h2 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6 参考资料"></a>6 参考资料</h2><ol><li><a href="https://zhaoxuhui.top/blog/2022/05/14/megvii-cv-master-nerf-note-1.html">旷视CV Master基于神经网络的3D重建训练营课程笔记1</a></li><li><a href="https://zhaoxuhui.top/blog/2022/05/26/megvii-cv-master-nerf-note-2.html">旷视CV Master基于神经网络的3D重建训练营课程笔记2</a></li><li><a href="https://zhaoxuhui.top/blog/2022/05/27/megvii-cv-master-nerf-note-3.html">旷视CV Master基于神经网络的3D重建训练营课程笔记3</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> NeRF&amp;3DGS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NeRF </tag>
            
            <tag> 三维重建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读博的选择、过程、出路</title>
      <link href="2023/04/06/meeting-3/"/>
      <url>2023/04/06/meeting-3/</url>
      
        <content type="html"><![CDATA[<h1 id="读博的选择、过程、出路"><a href="#读博的选择、过程、出路" class="headerlink" title="读博的选择、过程、出路"></a>读博的选择、过程、出路</h1><blockquote><p>中科院博士，程小六</p></blockquote><p><strong>为什么读博？</strong></p><img src="/images/meeting-3/image-20230406155514725.png" style="zoom:50%;"><ul><li><p>去高校、研究所、企业的研究院，必须要读博，这是个门槛</p></li><li><p>海归，特别是知名学校，优势非常大</p></li><li><p>需要做博后，去好几个地方做博后，去积累一些人脉、项目、经验，最后才能去当一个老师</p><p>读博28，博士后30，可能稳定下来都是30以上了</p></li></ul><p><strong>选老师：</strong></p><img src="/images/meeting-3/image-20230406160242078.png" style="zoom:50%;"><p>导师、团队都很重要：导师基本决定了读博期间能干出什么事。</p><p>尽量选择年轻有冲劲的导师：</p><ul><li>比如张富，短短几年时间，从领域内没人知道，到整个领域内都知道。</li><li>老师都非常拼，年轻老师要打响自己的名声。</li><li>老师本身能力也很强，知名实验室出来的。</li><li>指导非常多，对第一个学生基本是手把手指导，也非常push。</li></ul><p>挂名巨佬导师：</p><ul><li>很多都不带学生，都是做行政的</li><li>很有可能小老师带学生，甚至是组里面的师兄带</li><li>可能已经躺平了，自己啥都有了，不会那么负责了</li></ul><p><strong>读博的过程：</strong></p><img src="/images/meeting-3/image-20230406153243562.png" style="zoom:50%;"><ul><li><p>第一年基本是看论文找思路。</p><p>看领域内比较新的，学校比较好的硕博论文，会看比较久；</p><p>多看英文文献，越看越多的时候，直接就看懂。</p></li><li><p>写代码对SLAM方向是非常重要的；（读代码，给开源的代码写注释也是很重要的，复现代码更重要）</p><p>新手写论文的时候，可能发现很多的东西都没办法写成公式，但实际上很多理论需要用数学公式去表达，一个是没有歧义，一个是数学公式是相通的，大家一看公式就知道作者的水平怎么样。一篇小论文里面没什么公式，大概率也会被拒。</p><blockquote><p>推公式指的是把自己做的工作变成公式的能力，或者说是对自己具体的工作抽象表达的能力</p></blockquote></li><li><p>期刊投稿可能要半年多，长的有一年，要给自己留好足够的时间！</p></li><li><p>学术交流会议，能去的尽量去，争取在上面作报告。</p><p>交流非常重要，比如问一问别人的思路是怎么来的。</p></li><li><p>读博的时候要把事情尽早搞定，不要去拖，包括结婚、找工作、发论文等等。</p></li></ul><p><strong>最后，最重要的一点：</strong></p><p>如果博士期间没有做出什么成果，不要想着博士毕业后能做出什么学术成果，这些大牛基本都是博士期间做出了非常厉害的成果。如果博士期间非常平庸，等毕业之后想一飞冲天，基本没有可能。</p><p>博士期间真的是在给自己干，大家都是为了毕业、拿论文、找更好的工作、去更好的学校，都是在给自己拼命。等毕业之后，自己的身份已经变了，去高校是普通老师，去企业是员工，动力不一样了、氛围也不一样了。</p><p>读书的时候可以一心一意研究这个东西，而到了公司到了学校到了社会上之后，会有各种乱七八糟的事情。</p><p>想做成什么事情，最好的其实就是读书的这几年，这几年的环境是最理想的。</p><blockquote><p>博士是你脱产搞科研的时间，这时候你的脑力已经使用到了极限。将来你要养家糊口带小孩，又要教书做项目甚至兼职行政，更没有时间和精力去搞学问。</p><p>十成力都做不成的事，不要相信靠七成力能成功！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SLAM论文从零到一</title>
      <link href="2023/03/26/meeting-2/"/>
      <url>2023/03/26/meeting-2/</url>
      
        <content type="html"><![CDATA[<h1 id="SLAM论文从零到一"><a href="#SLAM论文从零到一" class="headerlink" title="SLAM论文从零到一"></a>SLAM论文从零到一</h1><blockquote><p>对2023年3月26日微信公众号《计算机视觉life》直播的一个总结</p></blockquote><p><strong>主讲人的经历：</strong></p><ul><li><p><strong>主讲人情况：</strong></p><p>博⼀开始入门，经历了⼀年多发了第⼀篇论文（顶会）；</p><p>实验室没有足够的积淀，缺乏指导；目前发表了RAL、ICRA等。</p></li><li><p><strong>开始的问题：</strong></p><p>没有正面反馈；不知道怎么选题；不知道怎么看论文和代码；一直在入门，从来没进门。</p></li><li><p><strong>转变的契机：</strong></p><p>加入了星球，然后开始和别人交流，交流是非常重要的。</p><blockquote><p>我觉得最重要的契机还是第一篇论文想法的提出，有想法了工作才有明确的方向，各种正面的反馈才会到来。</p></blockquote></li><li><p><strong>开始做研究：</strong></p><p>行动写代码，做实验，思考结论，反复做实验；投稿；修稿，回复审稿人。</p><ul><li><p>ORB-SLAM3有个突出的贡献，即多地图，而主讲人学习ORB-SLAM3的同时在做无共同视野的多相机之间的标定项目，这两个东西突然产生了共鸣；</p></li><li><p>之后提出了“尝试多相机分别运行ORB-SLAM3建图， 然后建图之后利用每个相机的地图来计算标定参数”的想法；</p></li><li><p>开始在ORB-SLAM3的基础上改代码，集中看某些部分的代码，写了两个月的代码，做了实验，然后这个相机标定的精度是OK的；</p></li><li><p>在前一步的基础上开始思考为什么有的场景效果不太好，如何改进，如何选择特征点，如何消除ORB-SLAM3的累积误差等；</p></li><li><p>最终做完实验，第⼀次正式写小论文，投了RAL，过了两个月收到 review，然后给了⼀个月改稿时间，根据审稿人意见补充实验，改进方案，和审稿人解释自己的工作，最后成功被接收。</p></li><li><p>在发了第⼀篇论文之后就不焦虑了，生活状态也好起来了，发论文基本的流程都熟悉过⼀遍，可以更快地发出新的论文了。</p></li></ul></li><li><p><strong>论文从一到多：</strong></p><p>没有山顶上的指导，就站在山腰上指路。所以作为站在山腰上的人，开始帮助四个师弟学习，帮助他们入门，以输出的方式进行思考。</p></li></ul><p><strong>学习建议：</strong></p><ul><li>单打独斗不可取，一定要找组织，多交流，保持输出；</li><li>保证一定量的输入，有输入才能有产出；<ul><li>比如直接看代码，ORB-SLAM、VINS的代码，但是一定要明白自己看代码的目的是什么，要带着问题去看；</li><li>工作的创新点一定会在论文里面体现出来，而代码是具体的实现细节，对不感兴趣的点，可以把这些代码当作工具来使用。</li><li>可以组建一个学习小组，两三个人，每天看点论文，然后看到感兴趣的论文，可以对这篇论文进行一个复现。</li></ul></li><li>抓住一个模块做，站在巨人的肩膀上（比如前面，把开源代码当作工具来使用）；</li><li>有目的性的学习，一定要知道自己学习是为了什么；</li><li>定一个能有反馈的目标很重要，包括长远规划和短期目标。</li></ul>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几种关键帧选择方案</title>
      <link href="2023/03/25/slam-learning-5/"/>
      <url>2023/03/25/slam-learning-5/</url>
      
        <content type="html"><![CDATA[<h1 id="几种关键帧选择方案"><a href="#几种关键帧选择方案" class="headerlink" title="几种关键帧选择方案"></a>几种关键帧选择方案</h1><h2 id="ORB-SLAM"><a href="#ORB-SLAM" class="headerlink" title="ORB-SLAM"></a>ORB-SLAM</h2><p>插入关键帧的条件即是必须满足条件1以及满足2.1-2.3中任意一个条件。</p><p><strong>必须满足的条件：</strong></p><p><strong>1.</strong> 内点数必须超过设定的最小阈值，并且重叠度不能太大；</p><p><strong>原因：</strong>保证关键帧跟踪的质量，同时，避免引入过多的信息冗余。</p><p><strong>三选一的条件：</strong></p><p><strong>2.1</strong> 距离上次插入关键帧已经过去MAX帧，MAX是ORB-SLAM2预设的最大值；</p><p><strong>原因：</strong>防止过去太多帧，跟踪丢失。</p><p><strong>2.2</strong> 距离上次插入关键帧至少过去MIN帧，且局部建图线程处于空闲状态，MIN是ORB-SLAM2预设的最小值；</p><p><strong>原因：</strong>防止图像重叠度太高，并且局部建图线程有空闲处理新的关键帧。</p><p><strong>2.3</strong> 局部建图线程中关键帧队列的关键帧数量不超过3个；</p><p><strong>原因：</strong>主要也是考虑局部建图线程的处理能力，以及信息的冗余度问题吧。</p><h2 id="VOLDOR-SLAM"><a href="#VOLDOR-SLAM" class="headerlink" title="VOLDOR-SLAM"></a>VOLDOR-SLAM</h2><p>使用可见性覆盖率（Visibility-Coverage）指标选择关键帧。</p><p>VC指标定义在已知姿态的帧$I_1,I_2$上，其中只有$I_1$可能具有深度图。VC指标低于设定阈值的第一帧将被选择为下一批的参考帧，而当前批次的参考帧和最新关键帧之间的VC指标低于设定阈值，讲当前批次的参考帧注册为关键帧。<br>$$<br>VC=\frac{2}{Visibility^{-1}+Coverage^{-1}}<br>$$<br>其中$Visibility$是$I_1$中投影到$I_2$内的深度像素比例；$Coverage$是$I_2$中图像区域被$I_1$中深度像素投影所覆盖的比例。</p><h2 id="VINS-Mono"><a href="#VINS-Mono" class="headerlink" title="VINS-Mono"></a>VINS-Mono</h2><p>VINS-Mono有两个用于选择关键帧的条件，满足一个即可。</p><p><strong>1.</strong> 与前一个关键帧的平均视差；</p><p>当前帧和最新关键帧之间跟踪特征的平均视差超过一定阈值，将当前帧帧视为新关键帧。由于平移和旋转都会导致视差，而纯旋转运动不能够对特征进行三角测量，所以在计算视差时vins-mono还使用陀螺仪测量的短期积分来补偿旋转。</p><p><strong>2.</strong> 跟踪质量；</p><p>如果跟踪特征的数量低于某个阈值，将此帧视为新的关键帧，这样是为了避免完全丢失特征轨迹。</p><h2 id="LSD-SLAM"><a href="#LSD-SLAM" class="headerlink" title="LSD-SLAM"></a>LSD-SLAM</h2><p>如果相机距离现有地图太远，则会根据最近跟踪的图像创建一个新的关键帧。</p><p>对当前关键帧的相对距离和角度的加权组合进行阈值处理：<br>$$<br>dist(\xi_{ji}):=\xi_{ji}^T\mathrm{W}\xi_{ji}<br>$$<br>其中，$\mathrm{W}$是包含权重的对角矩阵，而$\xi_{ji}$是两帧之间的相似变换矩阵。</p><h2 id="BAD-SLAM"><a href="#BAD-SLAM" class="headerlink" title="BAD SLAM"></a>BAD SLAM</h2><p>没有作严格的筛选，而是每10秒取一帧为关键帧。</p>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视觉里程计总结</title>
      <link href="2023/03/24/slam-learning-4/"/>
      <url>2023/03/24/slam-learning-4/</url>
      
        <content type="html"><![CDATA[<h1 id="视觉里程计总结"><a href="#视觉里程计总结" class="headerlink" title="视觉里程计总结"></a>视觉里程计总结</h1><h2 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h2><p>《视觉SLAM十四讲》里面介绍到视觉里程计的任务是：</p><ol><li>估算相邻图像间相机的运动</li><li>估计局部地图</li></ol><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><p>视觉里程计常用的方法是特征点法、光流法、直接法。</p><p>笔者认为这几种方法最根本的区别在误差函数上，所以这里不再从最最基础的fast角点、ORB特征点、灰度不变假设等开始介绍，这些内容可以阅读《视觉SLAM十四讲》。下面本文将站在误差函数的角度对这几种方法进行介绍。</p><h3 id="特征点法"><a href="#特征点法" class="headerlink" title="特征点法"></a>特征点法</h3><p>特征点法的目标是最小化重投影误差，即投影坐标和观测坐标（根据观测的位姿做投影）的差。</p><p>比如，在PnP问题中，重投影误差为3D点的投影位置与观测位置的差，可以用下面的公式进行表述：<br>$$<br>\min_{T} \frac{1}{2} \sum^n_{i-1} |u_i - \frac{1}{s_i}KTP_i|^2_2<br>$$<br>其中，$T$是相机的位姿，$P_i$是某个空间点的坐标（在世界坐标系下），而$u_i$是该点投影的像素坐标，$s_i$为该点的深度（在当前相机坐标系下），$K$为相机内参。</p><p>而在ICP问题中，处理的都是3D点，不再有相机内参，重投影误差表现为下面的形式：<br>$$<br>\min_{R,t} \frac{1}{2} \sum^n_{i-1} | (p_i - (Rp_i’+t)) |^2_2<br>$$<br>其中，$R,t$为相机位姿，$p_i$和$p_i’$为配对好的3D点（在不同帧的相机坐标系下）。</p><p>特征点法的普遍流程为：</p><ul><li>提取图像特征点</li><li>计算特征点的描述子</li><li>通过描述子匹配特征点</li><li>利用三角测量、对极几何、PnP、ICP等算法估计相机运动</li></ul><h3 id="光流法"><a href="#光流法" class="headerlink" title="光流法"></a>光流法</h3><p>光流求解的是最小化光度误差，目的是跟踪特征点的运动。</p><p>最小化光度误差可以表述为下面的形式：<br>$$<br>\min_{\Delta x,\Delta y} | I_1(x,y)-I_2(x+\Delta x,y+\Delta y) |^2_2<br>$$<br>其中$I_1(x,y)$为第一张图象在像素坐标$(x,y)$处的像素值，$I_2(x+\Delta x,y+\Delta y)$为第二张图象在像素坐标$(x+\Delta x,y+\Delta y)$处的像素值。</p><p>光流法的普遍流程为：</p><ul><li>提取图像特征点</li><li>根据光流跟踪特征点的运动，避免了计算和匹配描述子的过程</li><li>利用三角测量、对极几何、PnP、ICP等算法估计相机运动</li></ul><h3 id="直接法"><a href="#直接法" class="headerlink" title="直接法"></a>直接法</h3><p>直接法的优化目标为最小化光度误差，具体的公式如下：<br>$$<br>\min_{T} J(T)=e_i^Te_i, \quad e_i=I_1(p_{1,i})-I_2(p_{2,i}).<br>$$<br>其中，$T$为相机位姿，$I_1(p_{1,i})$为第1张图片上点$p_{1,i}$处的像素值，$I_2(p_{2,i})$同理。</p><p>需要注意，点$p_{1,i}$和点$p_{2,i}$的关系为：<br>$$<br>\begin{align}<br>p_{1,i}=&amp;\frac{1}{Z_1}KP_i, \\<br>p_{2,i}=&amp;\frac{1}{Z_2}K(RP_i+t)= \frac{1}{Z_2}K(TP)_{1:3}<br>\end{align}<br>$$<br>这里$K$为相机位姿，$P_i$为对应的3D点坐标（在第一帧相机坐标系下），$R,t$（对应李群为$T$）为第二帧时相机的旋转和平移，$Z_1$为点$P_i$在第一帧相机坐标系下的深度，$Z_2$同理。</p><p>直接法的普遍流程为：</p><ul><li>提取关键点或者直接产生随机点</li><li>考虑空间点在两帧中的像素位置</li><li>建立误差模型，通过计算最小光度误差来优化相机运动</li></ul><h2 id="代表工作"><a href="#代表工作" class="headerlink" title="代表工作"></a>代表工作</h2><table><thead><tr><th>方法</th><th>代表工作</th><th>备注</th></tr></thead><tbody><tr><td>特征点法</td><td>ORB-SLAM</td><td></td></tr><tr><td>光流法</td><td>VOLDOR-SLAM、FlowFusion、VINS-Mono</td><td>光流似乎主要用在动态场景下，或者和深度学习结合起来</td></tr><tr><td>直接法</td><td>LSD-SLAM、DSO、SVO、BAD-SLAM</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读《DENSE RGB SLAM WITH NEURAL IMPLICIT MAPS》</title>
      <link href="2023/03/19/paper-reading-dim-slam/"/>
      <url>2023/03/19/paper-reading-dim-slam/</url>
      
        <content type="html"><![CDATA[<h1 id="论文阅读《DENSE-RGB-SLAM-WITH-NEURAL-IMPLICIT-MAPS》"><a href="#论文阅读《DENSE-RGB-SLAM-WITH-NEURAL-IMPLICIT-MAPS》" class="headerlink" title="论文阅读《DENSE RGB SLAM WITH NEURAL IMPLICIT MAPS》"></a>论文阅读《DENSE RGB SLAM WITH NEURAL IMPLICIT MAPS》</h1><p>本论文提出了一种具有神经隐式映射表示的稠密RGB SLAM。该方案不需要深度输入，并且不需要任何预训练模型。为了实现这一目标，本文引入了一个分层的特征体积来辅助隐式地图解码器，有效地融合不同尺度的形状线索以促进地图重建。同时，通过匹配渲染和输入视频帧来同时解决相机运动和神经隐式地图。为了更好地约束相机姿态和场景几何，本文进一步在损失函数中应用了光度曲翘损失（sophisticated warping loss）。</p><p><strong>本文亮点如下：</strong></p><ol><li>第一个使用神经隐式表达实现了稠密重建的RGB-SLAM系统</li><li>不需要任何预训练模型，如单目深度估计和光流，就能同时优化场景和相机位姿。</li><li>相机位姿的准确度超过了以前的方法并且甚至超过了一些最新的RGB-D SLAM方法。</li></ol><h2 id="系统概述"><a href="#系统概述" class="headerlink" title="系统概述"></a>系统概述</h2><p><img src="/images/paper-reading-dim-slam/image-20230310220512566.png"></p><p>给定RGB视频作为输入，本文的方法旨在同时恢复3D场景图和相机运动。通过具有可学习的多分辨率特征体积的神经隐式函数来表示场景图。通过沿着视图光线从体积网格中采样特征，并使用MLP解码器查询采样特征，可以在给定估计的相机参数的情况下渲染每个像素的深度和颜色。由于此渲染过程是可区分的，因此可以通过最小化在光度渲染损失和翘曲损失上定义的目标函数来同时优化神经隐式贴图以及相机姿势。</p><h3 id="IMPLICIT-MAP-REPRESENTATION"><a href="#IMPLICIT-MAP-REPRESENTATION" class="headerlink" title="IMPLICIT MAP REPRESENTATION"></a>IMPLICIT MAP REPRESENTATION</h3><p>这部分和NICE-SLAM差不多，省略了。</p><h3 id="JOINT-OPTIMIZATION"><a href="#JOINT-OPTIMIZATION" class="headerlink" title="JOINT OPTIMIZATION"></a>JOINT OPTIMIZATION</h3><blockquote><p>这里应该是这个工作最关键的地方</p><p>本文用的损失函数和单目深度估计的一些工作比较相似</p></blockquote><p>本文所使用的损失函数由三种损失构成：</p><ul><li><p>Photometric Rendering Loss：</p><p><img src="/images/paper-reading-dim-slam/image-20230319161744607.png"></p></li><li><p>PhotometricWarping Loss：</p><p><img src="/images/paper-reading-dim-slam/image-20230319162048410.png"></p></li><li><p>Regularization Loss：</p><p><img src="/images/paper-reading-dim-slam/image-20230319162109708-16792140906562.png"></p></li></ul><p>最终要优化的目标函数为：</p><p><img src="/images/paper-reading-dim-slam/image-20230319162157530.png"></p><h3 id="System"><a href="#System" class="headerlink" title="System"></a>System</h3><p>本节介绍了构建完整的视觉SLAM系统的几个关键组件。</p><p><strong>初始化</strong>    当收集到一小组帧（在本文所有的实验中为 13 帧）时执行初始化。 第一帧的姿势设置为单位矩阵。 然后剩余帧的姿势从 Ni 迭代的目标函数中优化。 初始化后，第一帧被添加到全局关键帧集中并固定。 MLP 解码器的参数在初始化后也是固定的。</p><blockquote><p>初始化这一步应该类似传统的单目SLAM，目的是得到尺度和世界坐标系？</p><p>另外，解码器是MLP网络，而编码器是Nerf里那种Positional encoding？</p></blockquote><p><strong>窗口优化</strong>    在摄像机跟踪期间，本文的方法始终保持活动帧的窗口（在本文的所有实验中为 21 帧）。 活动帧包括两种不同类型：局部窗口帧和全局关键帧。 对于帧 k，本文将索引从 k − 5 到 k + 5 的帧视为局部窗口帧。 本文进一步从全局关键帧集中采样 10 个关键帧。 具体来说，本文在帧 k 上随机绘制 100 个像素，并使用估计的相机位姿 P 和深度 D 将它们投影到所有关键帧。 然后，本文通过计算投影在这些关键帧边界内的像素的百分比来评估视图重叠率。 之后，本文从重叠率超过 70% 的关键帧中随机选择 10 个关键帧来构成全局关键帧集。 然后，所有这些活动帧都用于优化隐式场景表示和 N_w 次迭代的姿势。 窗口优化后，最旧的局部帧 k-5 被删除，一个新的具有等速运动模型的 k+6 帧被添加到局部窗口帧的集合中。在跟踪期间，所有全局关键帧的相机姿势都是固定的。请参阅附录中有关窗口优化的两个线程情况下的映射。</p><blockquote><p>应该是比较常见的方法</p></blockquote><p><strong>关键帧选择</strong>    遵循类似于iMAP和NICE-SLAM的简单关键帧选择机制。具体来说，如果视野发生显著变化，则会添加一个新的关键帧。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p><strong>Q1：训练Nerf需要的输入是什么？需要深度吗？</strong></p><p>训练NeRF的输入数据是：从不同位置拍摄同一场景的图片，拍摄这些图片的相机位姿、相机内参，以及场景的范围。若图像数据集缺少相机参数真值，作者便使用经典SfM重建解决方案<a href="https://colmap.github.io/">COLMAP</a>估计了需要的参数，当作真值使用。</p><p><strong>Q2：Nerf的流程是什么？</strong></p><p>NeRF里的五维向量（位置+视角）是指从相机原点出发的一条射线上的点和射线的方向（变换到世界坐标系）？如果是的话，NeRF整个流程应该是下面这样：</p><ul><li>数据预处理：根据所有图像数据，得到相机内参（焦距，1个参数）、相机位姿（坐标变换，12个参数）和稀疏3D点（推理物体离相机最近和最远距离，2个参数），给每张图像赋予17个参数（1+12+2+2，其中最后一个2为图像的长宽）</li><li>训练：准备好图像（用于提供real像素值）和17个参数，根据相机位姿和相机焦距得到成像平面，并根据图像的长宽限制成像范围。取成像平面中某一位置（对应的real像素值是已知的），与相机位置的连线构成一条射线，得到二维的视角参数，在最近和最远距离内采样 n 个点，得到三维的位置参数，构成n个五维向量。然后根据相机位姿参数转化到世界坐标系，送入MLP中，预测每个点的rgb和sigma，此时并不会直接对采样点进行监督，而是根据体渲染得到fake像素值，通过real和fake之间的误差来监督训练。</li><li>测试：只要事先确定17个参数，其他步骤和训练类似。</li></ul><p>需要注意的是，原始的nerf代码假设光心偏移量是H/2, W/2。另外，实际代码实现的时候，视角用的是三维的方向向量表示。</p><p><strong>Q3：Nerf、iMAP、NICE-SLAM、DIM-SLAM在损失函数上的区别</strong></p><p><strong>Nerf：</strong>损失函数是粗略和精细渲染的渲染像素颜色和真实像素颜色之间的总平方误差。</p><p><img src="/images/paper-reading-dim-slam/image-20220819213135323.png"></p><p><strong>iMAP：</strong>光度损失是渲染和测量颜色值之间的L1范数；</p><p><img src="/images/paper-reading-dim-slam/image-20220830225657705.png"></p><p>几何损失测量深度差异，另外还使用深度方差作为归一化因子，在对象边界等不确定区域降低损失。</p><p><img src="/images/paper-reading-dim-slam/image-20220830225809862.png"></p><p>最终优化的目标函数是这两个损失的加权和：</p><p><img src="/images/paper-reading-dim-slam/image-20220830225854970.png"></p><p><strong>NICE-SLAM：</strong>几何损失只是在粗糙层和精细层上观测深度和预测深度之间的L1损失；</p><p><img src="/images/paper-reading-dim-slam/image-20220830110038114.png"></p><p>光度损失是M个采样像素点上渲染颜色和观测颜色值之间的一个L1损失。</p><p><img src="/images/paper-reading-dim-slam/image-20220830110106917.png"></p><p>最终优化的目标函数为：</p><p><img src="/images/paper-reading-dim-slam/image-20220830110419117.png"></p><p><strong>DIM-SLAM：</strong>见本文的[JOINT OPTIMIZATION](#JOINT OPTIMIZATION)部分。</p><p><strong>Q4：NICE-SLAM、Nerf等工作是如何沿着相机射线进行采样的，深度d要如何确定？</strong></p><p>TODO，这里完全不了解。。。</p><hr><p>分享两篇文章：</p><ul><li>深度学习之单目深度估计 (Chapter.1)：基础篇 - 桔子毛的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/29864012">https://zhuanlan.zhihu.com/p/29864012</a></li><li>深度学习之单目深度估计 (Chapter.2)：无监督学习篇 - 桔子毛的文章 - 知乎 <a href="https://zhuanlan.zhihu.com/p/29968267">https://zhuanlan.zhihu.com/p/29968267</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式表示 </tag>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读《ORB-SLAM2：an Open-Source SLAM System for Monocular, Stereo and RGB-D Cameras》</title>
      <link href="2023/03/07/paper-reading-orb-slam2/"/>
      <url>2023/03/07/paper-reading-orb-slam2/</url>
      
        <content type="html"><![CDATA[<h1 id="论文阅读《ORB-SLAM2-an-Open-Source-SLAM-System-for-Monocular-Stereo-and-RGB-D-Cameras》"><a href="#论文阅读《ORB-SLAM2-an-Open-Source-SLAM-System-for-Monocular-Stereo-and-RGB-D-Cameras》" class="headerlink" title="论文阅读《ORB-SLAM2: an Open-Source SLAM System for Monocular, Stereo and RGB-D Cameras》"></a>论文阅读《ORB-SLAM2: an Open-Source SLAM System for Monocular, Stereo and RGB-D Cameras》</h1><p>本文提出了ORB-SLAM2，它是基于单目、双目或RGB-D相机的一个完整的SLAM系统，其中包括地图重用、回环检测和重定位功能。</p><h2 id="前置工作ORB-SLAM"><a href="#前置工作ORB-SLAM" class="headerlink" title="前置工作ORB-SLAM"></a>前置工作ORB-SLAM</h2><p>基于双目和RGB-D相机的ORB-SLAM2是建立在基于特征的单目ORB-SLAM的基础上的。所以，这里首先回顾一下前置工作 ORB-SLAM。</p><img src="/images/paper-reading-orb-slam2/orb-slam.png" style="zoom: 50%;"><p>ORB-SLAM系统概述，显示了跟踪，局部建图和回环检测这三个线程执行的所有步骤。还显示了地点识别模块和地图的主要组件。</p><ul><li><p>跟踪</p><p>负责对每一帧摄像机进行定位，并决定何时插入一个新的关键帧。首先与前一帧进行初始特征匹配，并使用纯运动的BA优化姿势。如果跟踪丢失（例如由于遮挡或突然的移动），则使用地点识别模块来进行全局重新定位。一旦有了对摄像机姿势和特征匹配的初步估计，就会使用系统维护的关键帧的共存图来检索局部可见图。然后，通过重新投影寻找与本地地图点的匹配，并通过所有的匹配再次优化摄像机的姿势。最后，跟踪线程决定是否插入一个新的关键帧。</p></li><li><p>局部建图</p><p>处理新的关键帧并执行局部BA，以在相机姿态的周围环境中实现最佳重建。新关键帧中未匹配ORB的新对应关系在共视性图中的连接关键帧中搜索，以三角化新点。创建后一段时间，基于跟踪期间收集的信息，应用紧急点剔除策略，以便仅保留高质量点。局部映射还负责剔除冗余关键帧。</p></li><li><p>回环检测</p><p>在每个新的关键帧中搜索回环。如果检测到一个回环，就计算一个相似性变换，得到回环中积累的漂移。然后，回环的两边被对齐，重复的点被融合。最后，对相似性约束进行姿势图优化，以实现全局一致性。主要的创新之处在于，我们在基本图上进行优化，这是一个更稀疏的共存图子图。</p></li></ul><blockquote><p>orb-slam更具体的细节还是看论文和代码，论文把这个工作讲得特别详细！！！</p><p>阅读orb-slam2的代码有问题时，也可以再回来看这两篇论文，帮助挺大的。</p></blockquote><h2 id="ORB-SLAM2的系统架构"><a href="#ORB-SLAM2的系统架构" class="headerlink" title="ORB-SLAM2的系统架构"></a>ORB-SLAM2的系统架构</h2><p><img src="/images/paper-reading-orb-slam2/orb-slam2.png"></p><p>ORB-SLAM2由三个主要的并行线程组成：跟踪、局部建图和回环检测。在回环检测后会执行第四个线程，进行全局BA。跟踪线程会对双目和RGB-D输入进行预处理，从而使得系统其它部分可以独立于输入传感器运行。虽然这张图没有展示，但ORB-SLAM2也可以基于单目输入运行。</p><p>该系统具有三个主要的并行线程：</p><p>1）跟踪线程是用来在每一帧中定位相机的位置，通过匹配特征和局部地图并且进行运动BA（motion-only BA）最小化重投影误差；</p><p>2）局部建图线程是用来管理和优化局部地图；</p><p>3）回环检测线程是用来检测大回环，并通过执行位姿图优化来修正累积误差。该线程在位姿图优化后会启动第四个线程来执行全局BA，计算最优的结构和运动结果。</p><p>该系统嵌入了一个基于DBoW2 的位置识别模块，在发生跟踪失败（例如：碰撞）或者在建好图的场景中重新初始化时用来进行重定位，以及用来进行回环检测。该系统维护了一个关联可见地图（convisible map），此地图将每两个观察到相同地图点的关键帧连接到一起；同时该系统也维护了一个最小生成树，它连接了所有的关键帧。这种地图结构实现了对于关键帧局部窗的检索，因此跟踪线程和局部建图线程可以局部地运行，使其可以在大场景中工作；同时该结构在回环闭合进行位姿图优化时，也可作为优化的图结构。</p><h2 id="基于ORB-SLAM进行的工作"><a href="#基于ORB-SLAM进行的工作" class="headerlink" title="基于ORB-SLAM进行的工作"></a>基于ORB-SLAM进行的工作</h2><p>这篇论文后面主要介绍在ORB-SLAM基础上进行的工作，即如何使用双目/深度信息，以及系统的哪些部分将会被影响。</p><p><strong>TRACKING部分</strong></p><p>ORB-SLAM在初始化的时候是计算两帧之间的相对pose，然后用三角测量的方式初始化地图点集，它同时计算了两个模型（一个基础矩阵F，一个单应矩阵H），最后选择一个更好的模型来求解SFM问题。</p><p>ORB-SLAM2多了一个预处理的部分，把RGB-D输入或者双目的输入处理成为单目特征点和这些特征点对应的深度，之后系统的全部运算就基于这些特征，而输入的图像就被丢弃了。</p><blockquote><p>ORB-SLAM应该也是基于这些特征做运算？</p></blockquote><p>其中，RGB-D输入也被他们处理成类似双目的输入了，他们为RGB-D图像中提取的特征点计算了一个虚拟的右图坐标，这样就可以统一的进行处理。这里他们是把特征点划分为近处点和远处点，近处特征点可以被安全地三角化，深度能被精确估计，而远处特征点提供了精确地旋转信息，不过无法提供精确的尺度和平移信息，只有远处特征点在多个视图中存在的时候才会被三角化。</p><p>因为双目或者RGB-D能够直接从单帧图像获取深度信息，所以第一帧设置为关键帧，其位姿设置为初始姿态，并且根据所有的立体关键点来建立一个初始地图。</p><p><strong>FULL BA部分</strong></p><p>ORB-SLAM的论文里在讲初始化（IV. AUTOMATIC MAP INITIALIZATION ）的时候提到初始化过程的最后会执行一个全局的BA来完善初始化的重建。</p><p>而ORB-SLAM2这里是在位姿图优化后，再采用全局BA优化来得到最优解。这个优化过程可能开销会很大，所以被放在一个独立的线程中，从而使得系统可以持续建立地图、检测回环。</p><p>但这样会导致BA输出与当前地图状态之间进行融合产生困难。如果在优化运行的同时发现了新的回环，ORB-SLAM2就停止优化，转而去闭合回环，这将再次启动全局BA优化。当全局BA完成时，就需要将全局BA优化更新后的关键帧和点的集合，与在优化过程中插入的未更新的关键帧和点，进行融合。这通过将更新的关键帧的修正（未优化位姿至优化位姿的变换）沿生成树传递至未更新的关键帧来完成。未更新的点依据它们的参考帧的修正来进行变换。</p>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读《Feature-Realistic Neural Fusion for Real-Time, Open Set Scene Understanding》</title>
      <link href="2023/03/06/paper-reading-feature-realistic-neural-fusion-for-real-time-open-set-scene-understanding/"/>
      <url>2023/03/06/paper-reading-feature-realistic-neural-fusion-for-real-time-open-set-scene-understanding/</url>
      
        <content type="html"><![CDATA[<h1 id="Feature-Realistic-Neural-Fusion-for-Real-Time-Open-Set-Scene-Understanding"><a href="#Feature-Realistic-Neural-Fusion-for-Real-Time-Open-Set-Scene-Understanding" class="headerlink" title="Feature-Realistic Neural Fusion for Real-Time, Open Set Scene Understanding"></a>Feature-Realistic Neural Fusion for Real-Time, Open Set Scene Understanding</h1><h2 id="回顾iMAP"><a href="#回顾iMAP" class="headerlink" title="回顾iMAP"></a>回顾iMAP</h2><blockquote><p>这篇工作很大部分都基于iMAP，去年暑假我<a href="https://immortalqx.github.io/2022/08/31/paper-reading-imap/">翻译了这篇论文</a></p></blockquote><ul><li><p>使用隐式神经场景表示并能够联合优化完整 3D 地图和相机姿势的稠密实时 SLAM 系统。（使用多层感知器 (MLP) 作为手持 RGB-D 相机的实时 SLAM 系统中唯一的场景表示）</p></li><li><p>iMAP系统框架</p><p><img src="/images/paper-reading-feature-realistic-neural-fusion-for-real-time-open-set-scene-understanding/image-20220830225347891.png"></p><blockquote><p>大概是这么运行的，个人猜测</p></blockquote><ul><li><p><strong>Implicit Scene Neural Network</strong></p><p>MLP的作用是保存3D场景，输入一个3D坐标经过处理可以查询到这个点的颜色和体积密度值；</p><p>通过查询的结果可以渲染出该点的深度和颜色。</p></li><li><p><strong>Depth and Colour Rendering</strong></p><p>根据当前的相机位姿和某些关键点的像素坐标，反投影得到这些关键点的世界坐标；</p><p>通过MLP查询这些世界坐标的颜色和体积密度值；</p><p>根据颜色和体积密度值进行深度和颜色的渲染；</p><p>将渲染的颜色图和深度图与当前相机真正看到的图作比较，计算误差；</p><p>根据误差进行优化，更新了？（更新的是相机位姿？还是网络参数？这两个怎么处理？）</p></li><li><p><strong>Joint optimisation</strong></p><p>根据误差进行联合优化，更新网络参数和相机位姿；（光度损失和几何损失表面上是和位姿有关的，但是渲染是通过网络渲染的，所以应该就可以联合优化，但具体怎么做我不清楚。。。）</p><p>这里损失函数专门赋予光度误差权重，应该是要减轻光照的影响。</p></li><li><p><strong>Keyframe Selection</strong></p><p>根据稀疏的关键帧来进行联合优化。其中，第一个关键帧用于初始化网络和固定世界坐标系。</p><p>这篇工作关键帧选择的方案是：</p><p>检测新区域的显著性（新区域是不是非常新？非常新就加入关键帧！）</p><p>这里似乎是用深度误差来判断的，判断一个新区域里面已经被解释的帧的比例。</p></li><li><p>Active Sampling</p><p>略。这里印象中不重要，并且nice-slam里面似乎说这部分对性能提升的影响非常有限。</p></li></ul></li></ul><h2 id="主要工作"><a href="#主要工作" class="headerlink" title="主要工作"></a>主要工作</h2><p>提出了一种算法，该算法将来自标准预训练网络的一般学习特征融合为实时SLAM期间高效的3D几何神经场表示。融合的3D特征图继承了神经场几何表示的一致性。这意味着在运行时交互的微小数量的人类标签使对象甚至对象的一部分能够以开放集的方式被稳健地准确地分割。</p><blockquote><p>把iMAP和预训练特征融合起来了？</p></blockquote><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><img src="/images/paper-reading-feature-realistic-neural-fusion-for-real-time-open-set-scene-understanding/image-20230306160434854.png"></p><p>该系统主要由两个部分组成：</p><ul><li><p>预训练的2D图像特征提取器</p><blockquote><p>被冻结了，指的是网络参数不会被改动？所以输入的图像特征就是固定不变的了，相当于相机的参数被固定了？</p></blockquote></li><li><p>类似iMAP的SLAM系统，即SLAM后端</p></li></ul><p>本文的一般方法是<strong>通过体积渲染来近似一组特征图</strong>，这些特征图是用特征提取器 F 从一组图像中获得的。这里放弃了对颜色和依赖视图（view-dependant）的效果进行建模，以缓解场景MLP的问题。</p><h3 id="A-Scene-Network"><a href="#A-Scene-Network" class="headerlink" title="A. Scene Network"></a>A. Scene Network</h3><p><img src="/images/paper-reading-feature-realistic-neural-fusion-for-real-time-open-set-scene-understanding/image-20230306160449588.png"></p><ul><li><p>该场景表示网络由两个部分组成：</p><p>左边是类似Nerf的MLP，用于表示整个场景，即三维神经场；</p><p>右边是单层感知器，根据2D渲染的结果得到最终的特征图。</p></li><li><p>MLP网络：</p><p>输入三维坐标，输出体积密度、特征向量、语义对数。</p><p>在进入MLP网络之前，有一个Positional Encoding过程，这里目的是确保拟合高频特征映射的表示能力</p><blockquote><p>nerf里面有一个差不多的过程，见<a href="https://immortalqx.github.io/2022/08/19/nerf-notes-1/#5-1-Positional-encoding">NeRF学习笔记（一）：论文翻译</a></p></blockquote></li><li><p>根据MLP输出的体积密度计算了体积渲染权重，然后根据这个权重计算深度、特征、语义逻辑。</p><blockquote><p>这里的“语义逻辑”有什么用处？这是每个特征的标签吗？</p><p>这部分，前两个公式和iMAP基本一样，w的意义也一样</p></blockquote><p><img src="/images/paper-reading-feature-realistic-neural-fusion-for-real-time-open-set-scene-understanding/image-20230306214201812.png"></p></li><li><p>关键帧选用与iMAP一样，根据深度渲染的误差来选择。</p></li></ul><h3 id="B-Latent-Feature-Rendering"><a href="#B-Latent-Feature-Rendering" class="headerlink" title="B. Latent Feature Rendering"></a>B. Latent Feature Rendering</h3><p>这里主要介绍前面讲的一种潜在的特征渲染方法。</p><p>本文没有使用之前Nerf那种的渲染方法，而是使用了感知器来解决渲染问题。</p><blockquote><p>看起来是只有一个感知器，然后渲染了每个点的特征？</p></blockquote><p><img src="/images/paper-reading-feature-realistic-neural-fusion-for-real-time-open-set-scene-understanding/image-20230306214238132.png"></p><h3 id="C-Feature-Extractors"><a href="#C-Feature-Extractors" class="headerlink" title="C. Feature Extractors"></a>C. Feature Extractors</h3><p>这里就提了一句本文构建的系统对2D前端是不可知的，大概用什么样的特征提取器提取特征都可以，但是这个系统还是能够融合这些提取出来的特征。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据目前我理解的内容，本文的系统框架应该是下面这样的：</p><p><img src="/images/paper-reading-feature-realistic-neural-fusion-for-real-time-open-set-scene-understanding/image-20230306213537354.png"></p><p>和iMAP不一样的地方是：</p><ul><li>输入：对输入的RGB图像做了一个特征提取，将原本的{I,D}输入变成了{F,D}；</li><li>网络部分：都是输入三维点坐标，iMAP网络输出颜色和体积密度值，而本文是特征、体积密度和语义（多了一个语义）；</li><li>渲染部分：本文和iMAP的公式基本一样，但本文把渲染后的特征又用感知器进行了一遍处理。</li></ul>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式表示 </tag>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS231A Lecture 9：Fitting and Matching</title>
      <link href="2022/11/23/cs231a-lecture9/"/>
      <url>2022/11/23/cs231a-lecture9/</url>
      
        <content type="html"><![CDATA[<h1 id="CS231A-Lecture-9：Fitting-and-Matching"><a href="#CS231A-Lecture-9：Fitting-and-Matching" class="headerlink" title="CS231A Lecture 9：Fitting and Matching"></a>CS231A Lecture 9：Fitting and Matching</h1><blockquote><p>lecture 9 也没什么内容，不过还是好好记一下，霍夫变换之前不太了解。。。</p></blockquote><blockquote><p><strong>Reading:</strong> </p><p>[HZ] Chapter: 4 “Estimation – 2D projective transformation”</p><p>[HZ] Chapter: 11 “Computation of the fundamental matrix F”</p><p>[FP] Chapter:10 “Grouping and model fitting”</p></blockquote><h2 id="Problem-formulation"><a href="#Problem-formulation" class="headerlink" title="Problem formulation"></a>Problem formulation</h2><p><strong>Fitting (拟合)</strong></p><img src="/images/cs231a-lecture9/image-20221123153930630.png" style="zoom:50%;"><img src="/images/cs231a-lecture9/image-20221123155619402.png" style="zoom:50%;"><h2 id="Least-square-methods"><a href="#Least-square-methods" class="headerlink" title="Least square methods"></a>Least square methods</h2><blockquote><p>最小二乘法</p></blockquote><img src="/images/cs231a-lecture9/image-20221123160115372.png" style="zoom:50%;"><img src="/images/cs231a-lecture9/image-20221123161648007.png" style="zoom:50%;"><img src="/images/cs231a-lecture9/image-20221123161702037.png" style="zoom:50%;"><img src="/images/cs231a-lecture9/image-20221123161719516.png" style="zoom:50%;"><img src="/images/cs231a-lecture9/image-20221123161806523.png" style="zoom:50%;"><p><font color="red"><strong>CONCLUSION</strong></font>: Least square is not robust w.r.t. outliers</p><h2 id="RANSAC"><a href="#RANSAC" class="headerlink" title="RANSAC"></a>RANSAC</h2><blockquote><p>见：<a href="https://immortalqx.github.io/2021/11/28/ransac/#%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%E5%92%8C%E6%B5%81%E7%A8%8B">使用RANSAC算法拟合点云中的平面</a></p><p>这里仅补充几个需要关注的地方。</p></blockquote><p><strong>RANSAC的两个基本假设</strong></p><img src="/images/cs231a-lecture9/image-20221123162611114.png" style="zoom:50%;"><p><strong>How many samples?</strong></p><img src="/images/cs231a-lecture9/image-20221123163159911.png" style="zoom:50%;"><img src="/images/cs231a-lecture9/image-20221123163143006.png" style="zoom:50%;"><p><strong>Conclusions</strong></p><img src="/images/cs231a-lecture9/image-20221123163314947.png" style="zoom:50%;"><h2 id="Hough-transforms"><a href="#Hough-transforms" class="headerlink" title="Hough transforms"></a>Hough transforms</h2><blockquote><p>P.V.C. Hough, <em>Machine Analysis of Bubble Chamber Pictures,</em> Proc. Int. Conf. High Energy Accelerators and Instrumentation, 1959 </p></blockquote><img src="/images/cs231a-lecture9/image-20221123165028131.png" style="zoom:50%;"><img src="/images/cs231a-lecture9/image-20221123165105277.png" style="zoom:50%;"><img src="/images/cs231a-lecture9/image-20221123165756572.png" style="zoom:50%;"><img src="/images/cs231a-lecture9/image-20221123172108198.png" style="zoom:50%;"><p><strong>Conclusions</strong></p><img src="/images/cs231a-lecture9/image-20221123172156915.png" style="zoom:50%;"><p><strong>Generalized Hough transform</strong></p><blockquote><p>D. Ballard, Generalizing the Hough Transform to Detect Arbitrary Shapes, Pattern Recognition 13(2), 1981</p></blockquote><img src="/images/cs231a-lecture9/image-20221123172828867.png" style="zoom:50%;"><p><strong>思考：</strong></p><p>课件里面霍夫变换讲的并不清楚，这里补充一些内容：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/47649796">霍夫变换——神奇的特征提取算法</a></li><li><a href="https://jishuin.proginn.com/p/763bfbd6c025">史上最全霍夫变换详解（含源码）</a></li><li><a href="https://zhuanlan.zhihu.com/p/448935812">霍夫圆检测原理</a></li></ul><h2 id="Multi-model-fitting"><a href="#Multi-model-fitting" class="headerlink" title="Multi-model fitting"></a>Multi-model fitting</h2><p><strong>Fitting multiple models</strong></p><img src="/images/cs231a-lecture9/image-20221123201037831.png" style="zoom:50%;"><p><strong>Incremental line fitting</strong></p><img src="/images/cs231a-lecture9/image-20221123201124279-16692064695511.png" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> 三维视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS231A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS231A Lecture 7：Multi-view geometry (2)</title>
      <link href="2022/11/21/cs231a-lecture7-2/"/>
      <url>2022/11/21/cs231a-lecture7-2/</url>
      
        <content type="html"><![CDATA[<h1 id="CS231A-Lecture-7：Multi-view-geometry-2"><a href="#CS231A-Lecture-7：Multi-view-geometry-2" class="headerlink" title="CS231A Lecture 7：Multi-view geometry (2)"></a>CS231A Lecture 7：Multi-view geometry (2)</h1><blockquote><p><strong>Reading:</strong> </p><p>[HZ] Chapter 10 “3D reconstruction of cameras and structure”</p><p>[HZ] Chapter 18 “N-view computational methods”</p><p>[HZ] Chapter 19 “Auto-calibration”</p><p>[FP] Chapter 13 “projective structure from motion”</p><p>[Szelisky] Chapter 7 “Structure from motion”</p></blockquote><h2 id="Perspective-SFM"><a href="#Perspective-SFM" class="headerlink" title="Perspective SFM"></a>Perspective SFM</h2><blockquote><p>复习：<a href="https://immortalqx.github.io/2022/10/28/cs231a-lecture4/">Single View Metrology</a></p></blockquote><h3 id="Structure-from-motion-problem"><a href="#Structure-from-motion-problem" class="headerlink" title="Structure from motion problem"></a>Structure from motion problem</h3><img src="/images/cs231a-lecture7-2/image-20221120212756627.png" style="zoom:50%;"><img src="/images/cs231a-lecture7-2/image-20221120213038698.png" style="zoom:50%;"><h4 id="Structure-from-Motion-Ambiguities"><a href="#Structure-from-Motion-Ambiguities" class="headerlink" title="Structure from Motion Ambiguities"></a>Structure from Motion Ambiguities</h4><img src="/images/cs231a-lecture7-2/image-20221120213631419.png" style="zoom:50%;"><p> <strong>ambiguities for 3D reconstruction：</strong></p><img src="/images/cs231a-lecture7-2/image-20221121153226261.png" style="zoom:50%;"><h4 id="The-Structure-from-Motion-Problem"><a href="#The-Structure-from-Motion-Problem" class="headerlink" title="The Structure-from-Motion Problem"></a>The Structure-from-Motion Problem</h4><img src="/images/cs231a-lecture7-2/image-20221120213648334.png" style="zoom:50%;"><h4 id="Projective-Ambiguity"><a href="#Projective-Ambiguity" class="headerlink" title="Projective Ambiguity"></a>Projective Ambiguity</h4><img src="/images/cs231a-lecture7-2/image-20221121175914571.png" style="zoom:50%;"><h4 id="Metric-reconstruction-upgrade"><a href="#Metric-reconstruction-upgrade" class="headerlink" title="Metric reconstruction (upgrade)"></a>Metric reconstruction (upgrade)</h4><img src="/images/cs231a-lecture7-2/image-20221121175949492.png" style="zoom:50%;"><h4 id="Structure-from-Motion-methods"><a href="#Structure-from-Motion-methods" class="headerlink" title="Structure from Motion methods"></a>Structure from Motion methods</h4><ol><li><strong>Recovering structure and motion up to perspective ambiguity</strong><ul><li>Algebraic approach (by fundamental matrix)</li><li>Factorization method (by SVD)</li><li>Bundle adjustment</li></ul></li><li><strong>Resolving the perspective ambiguity</strong></li></ol><p><strong>疑问</strong></p><p><strong>Q：如何理解“If the cameras are not calibrated, cameras and points can only be recovered up to a 4x4 projective (where the 4x4 projective is defined up to scale)”</strong></p><p><strong>A：</strong>感觉这里说的是，因为不知道相机的内参，缺少了约束条件，最终恢复的场景和实际的场景差了一个投影变换。比如，实际的motion应该是刚性变换，但我们因为不知道相机内参，只能恢复成投影变换，就像”Projective Ambiguity“这个部分一样。但为什么知道相机内参之后能够恢复到刚性变换呢？</p><p>这里应该是知道内参之后可以把$M$求出来，这样$X$也确定了，就消除歧义了。</p><p><strong>Q：这里的未知量数目为$11m+3n-15$，其中的$-15$是怎么来的？</strong></p><p><strong>A：</strong>TODO（我发现，在cs231a winter1415的课程中，ppt说这里的未知数是$11m+3n-16$，我猜这个应该是和projective transformation有关系，它刚好16个数，然后15个未知量；可能这个值在这里求不出，或者在这里不用求，然后只能用其他手段求解，比如self calibration？）</p><h3 id="Recovering-structure-and-motion-up-to-perspective-ambiguity"><a href="#Recovering-structure-and-motion-up-to-perspective-ambiguity" class="headerlink" title="Recovering structure and motion up to perspective ambiguity"></a>Recovering structure and motion up to perspective ambiguity</h3><h4 id="Algebraic-approach-2-view-case"><a href="#Algebraic-approach-2-view-case" class="headerlink" title="Algebraic approach (2-view case)"></a>Algebraic approach (2-view case)</h4><h5 id="Compute-the-fundamental-matrix-F-from-two-views"><a href="#Compute-the-fundamental-matrix-F-from-two-views" class="headerlink" title="Compute the fundamental matrix F from two views"></a>Compute the fundamental matrix F from two views</h5><img src="/images/cs231a-lecture7-2/image-20221121202801817.png" style="zoom:50%;"><h5 id="Use-F-to-estimate-projective-cameras"><a href="#Use-F-to-estimate-projective-cameras" class="headerlink" title="Use F to estimate projective cameras"></a>Use F to estimate projective cameras</h5><img src="/images/cs231a-lecture7-2/image-20221121203938026.png" style="zoom:50%;"><img src="/images/cs231a-lecture7-2/image-20221121204500893.png" style="zoom:50%;"><p><strong>Cross product as matrix multiplication</strong></p><img src="/images/cs231a-lecture7-2/image-20221121204654529.png" style="zoom:33%;"><img src="/images/cs231a-lecture7-2/image-20221121204803490.png" style="zoom:33%;"><p><strong>Compute cameras</strong></p><img src="/images/cs231a-lecture7-2/image-20221121204855976.png" style="zoom:50%;"><img src="/images/cs231a-lecture7-2/image-20221121205610397.png" style="zoom:50%;"><p><strong>Interpretation of b</strong> </p><p>回顾lecture5介绍的Epipolar Constraint</p><img src="/images/cs231a-lecture7-2/image-20221121210121660.png" style="zoom:50%;"><img src="/images/cs231a-lecture7-2/image-20221121210150661.png" style="zoom:50%;"><h5 id="Use-these-cameras-to-triangulate-and-estimate-points-in-3D"><a href="#Use-these-cameras-to-triangulate-and-estimate-points-in-3D" class="headerlink" title="Use these cameras to triangulate and estimate points in 3D"></a>Use these cameras to triangulate and estimate points in 3D</h5><p><strong>Triangulation</strong></p><img src="/images/cs231a-lecture7-2/image-20221121210326543.png" style="zoom:50%;"><h4 id="Algebraic-approach-the-N-views-case"><a href="#Algebraic-approach-the-N-views-case" class="headerlink" title="Algebraic approach: the N-views case"></a>Algebraic approach: the N-views case</h4><img src="/images/cs231a-lecture7-2/image-20221121210541009.png" style="zoom:50%;"><h4 id="Bundle-adjustment"><a href="#Bundle-adjustment" class="headerlink" title="Bundle adjustment"></a>Bundle adjustment</h4><h5 id="Limitations-of-the-approaches-so-far"><a href="#Limitations-of-the-approaches-so-far" class="headerlink" title="Limitations of the approaches so far"></a>Limitations of the approaches so far</h5><img src="/images/cs231a-lecture7-2/image-20221121210840225.png" style="zoom:50%;"><h5 id="About-BA"><a href="#About-BA" class="headerlink" title="About BA"></a>About BA</h5><img src="/images/cs231a-lecture7-2/image-20221121211920908.png" style="zoom:50%;"><h5 id="General-Calibration-Problem"><a href="#General-Calibration-Problem" class="headerlink" title="General Calibration Problem"></a>General Calibration Problem</h5><img src="/images/cs231a-lecture7-2/image-20221121212715597.png" style="zoom:50%;"><h5 id="Advantages-amp-Limitations"><a href="#Advantages-amp-Limitations" class="headerlink" title="Advantages &amp; Limitations"></a>Advantages &amp; Limitations</h5><img src="/images/cs231a-lecture7-2/image-20221121212749032.png" style="zoom:50%;"><h3 id="Resolving-the-perspective-ambiguity-Self-calibration"><a href="#Resolving-the-perspective-ambiguity-Self-calibration" class="headerlink" title="Resolving the perspective ambiguity: Self-calibration"></a>Resolving the perspective ambiguity: Self-calibration</h3><h4 id="About-Self-calibration"><a href="#About-Self-calibration" class="headerlink" title="About Self-calibration"></a>About Self-calibration</h4><img src="/images/cs231a-lecture7-2/image-20221121213019969.png" style="zoom:50%;"><h4 id="Several-approaches"><a href="#Several-approaches" class="headerlink" title="Several approaches"></a>Several approaches</h4><blockquote><p>复习：<a href="https://immortalqx.github.io/2022/10/28/cs231a-lecture4/#Estimating-geometry-from-a-single-image">Estimating geometry from a single image</a></p></blockquote><img src="/images/cs231a-lecture7-2/image-20221121213459393.png" style="zoom:50%;"><h5 id="Direct-approach"><a href="#Direct-approach" class="headerlink" title="Direct approach"></a>Direct approach</h5><img src="/images/cs231a-lecture7-2/image-20221121214257946.png" style="zoom:50%;"><p><strong>Projections of conics across views</strong></p><img src="/images/cs231a-lecture7-2/image-20221121214350159.png" style="zoom:50%;"><p><strong>Projection of absolute conics across views</strong></p><blockquote><p>From lecture 4, [HZ] page 210, sec. 8.5.1</p></blockquote><img src="/images/cs231a-lecture7-2/image-20221121214501672.png" style="zoom:50%;"><p><strong>Kruppa equations</strong></p><blockquote><p>[Faugeras et al. 92] From [HZ] page 471 </p></blockquote><img src="/images/cs231a-lecture7-2/image-20221121214622506.png" style="zoom:50%;"><img src="/images/cs231a-lecture7-2/image-20221121214643244.png" style="zoom:50%;"><p><strong>Advantages &amp; Limitations</strong></p><img src="/images/cs231a-lecture7-2/image-20221121214702464.png" style="zoom:50%;"><p><strong>疑问</strong></p><p><strong>Q：这里的矩阵$F$表示什么？</strong></p><p><strong>A：</strong>TODO</p><h5 id="Algebraic-approach-Multi-view-approach"><a href="#Algebraic-approach-Multi-view-approach" class="headerlink" title="Algebraic approach (Multi-view approach)"></a>Algebraic approach (Multi-view approach)</h5><img src="/images/cs231a-lecture7-2/image-20221121214849946.png" style="zoom:50%;"><img src="/images/cs231a-lecture7-2/image-20221121214940374.png" style="zoom:50%;"><p><strong>Art of self-calibration:</strong> </p><img src="/images/cs231a-lecture7-2/image-20221121215039297.png" style="zoom:50%;"><h4 id="Inject-information-about-the-camera-during-the-bundle-adjustment-optimization"><a href="#Inject-information-about-the-camera-during-the-bundle-adjustment-optimization" class="headerlink" title="Inject information about the camera during the bundle adjustment optimization"></a>Inject information about the camera during the bundle adjustment optimization</h4><img src="/images/cs231a-lecture7-2/image-20221121213524460.png" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> 三维视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS231A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS231A Lecture 7：Multi-view geometry (1)</title>
      <link href="2022/11/12/cs231a-lecture7-1/"/>
      <url>2022/11/12/cs231a-lecture7-1/</url>
      
        <content type="html"><![CDATA[<h1 id="CS231A-Lecture-7：Multi-view-geometry-1"><a href="#CS231A-Lecture-7：Multi-view-geometry-1" class="headerlink" title="CS231A Lecture 7：Multi-view geometry (1)"></a>CS231A Lecture 7：Multi-view geometry (1)</h1><blockquote><p><strong>Reading:</strong> </p><p>[HZ] Chapter 10 “3D reconstruction of cameras and structure”</p><p>[HZ] Chapter 18 “N-view computational methods”</p><p>[HZ] Chapter 19 “Auto-calibration”</p><p>[FP] Chapter 13 “projective structure from motion”</p><p>[Szelisky] Chapter 7 “Structure from motion”</p></blockquote><h2 id="The-SFM-problem"><a href="#The-SFM-problem" class="headerlink" title="The SFM problem"></a>The SFM problem</h2><img src="/images/cs231a-lecture7-1/image-20221105194801806.png" style="zoom:50%;"><img src="/images/cs231a-lecture7-1/image-20221105194811248.png" style="zoom:50%;"><img src="/images/cs231a-lecture7-1/image-20221105194828131.png" style="zoom:50%;"><h2 id="Affine-SFM"><a href="#Affine-SFM" class="headerlink" title="Affine SFM"></a>Affine SFM</h2><h3 id="Affine-structure-from-motion-simpler-problem"><a href="#Affine-structure-from-motion-simpler-problem" class="headerlink" title="Affine structure from motion(simpler problem)"></a>Affine structure from motion(simpler problem)</h3><img src="/images/cs231a-lecture7-1/image-20221105194851562.png" style="zoom:50%;"><img src="/images/cs231a-lecture7-1/image-20221105194901691.png" style="zoom:50%;"><p><strong>Perspective vs Affine</strong></p><p>复习：<a href="https://immortalqx.github.io/2022/10/28/cs231a-lecture4/#2D-transformations">2D transformations</a></p><img src="/images/cs231a-lecture7-1/image-20221105194956531.png" style="zoom: 50%;"><p><strong>Affine cameras</strong></p><img src="/images/cs231a-lecture7-1/image-20221105195029644.png" style="zoom:50%;"><p><strong>The Affine Structure-from-Motion Problem</strong></p><img src="/images/cs231a-lecture7-1/image-20221120121639627.png" style="zoom:50%;"><img src="/images/cs231a-lecture7-1/image-20221105195107859.png" style="zoom:50%;"><p><strong>思考：</strong></p><p>这里乍一看是只知道$x_{ij}$，要求等式右边的三个未知量，看起来解不出来。</p><p>不过把这里的对应关系理清楚就可以理解了，$x_{ij}$是$X_j$在第$i$张图上的投影，而$A_i$和$b_i$是构成对应第$i$张图的投影矩阵$M_i$。</p><p>并且，这里每一个$x_{ij}$能提供2个等式，即$\begin{cases} &amp;m_1X_j = x_{ij}[0] \\ &amp;m_2X_j=x_{ij}[1] \end{cases}$，总共可以有$2m\times n$个等式；</p><p>而$M_i$有8个未知量，而$X_j$有3个未知量，总共要求解的未知量数目为$8m+3n-8$个。</p><p>因此，这个等式在一定情况下是可以求解的。</p><p><strong>疑问</strong></p><p><strong>Q：为什么未知量的数目是$8m+3n-8$呢？这个$-8$是如何来的？</strong></p><p><strong>A：</strong>我认为这里应该是有一帧图像的投影矩阵是已知的，比如假定第一帧图象是在世界坐标系原点拍摄的，或者假定已知世界坐标系与相机坐标系在某一帧下的关系，就可以得到这帧的投影矩阵；不然的话，可能找不出一个合适的初始值来求解这个方程组，或者可能这个方程组有无穷个解，而我们需要的只是一个有现实意义（比如指定了世界坐标系）的解。</p><h3 id="A-factorization-method-–Tomasi-amp-Kanade-algorithm"><a href="#A-factorization-method-–Tomasi-amp-Kanade-algorithm" class="headerlink" title="A factorization method –Tomasi &amp; Kanade algorithm"></a>A factorization method –Tomasi &amp; Kanade algorithm</h3><blockquote><p>C. Tomasi and T. KanadeShape and motion from image streams under orthography: A factorization </p><p>method. <em>IJCV</em>, 9(2):137-154, November 1992. </p></blockquote><h4 id="Data-centering"><a href="#Data-centering" class="headerlink" title="Data centering"></a>Data centering</h4><p><strong>Centering:</strong> subtract the centroid of the image points</p><img src="/images/cs231a-lecture7-1/image-20221105203438027.png" style="zoom:50%;"><img src="/images/cs231a-lecture7-1/image-20221105203500148.png" style="zoom:50%;"><img src="/images/cs231a-lecture7-1/image-20221105203515533.png" style="zoom:50%;"><p>Thus, after centering, each <strong>normalize</strong>d observed point is related to the 3D point by</p><img src="/images/cs231a-lecture7-1/image-20221106145308078.png" style="zoom:50%;"><p>If the centroid of points in 3D = center of the world reference system</p><img src="/images/cs231a-lecture7-1/image-20221106145352145.png" style="zoom:50%;"><p><strong>思考：</strong></p><p>这里的几何意义应该是，本来这一组$X_j$投影到图像$i$中，还需要平移$b_i$才能够与图中的$x_{ij}$对应上；而normalize之后，平移量$b_i$就被抵消了。</p><h4 id="Factorization"><a href="#Factorization" class="headerlink" title="Factorization"></a>Factorization</h4><blockquote><p>复习：线性代数</p></blockquote><img src="/images/cs231a-lecture7-1/image-20221120163624398.png" style="zoom:50%;"><p><strong>Factorizing the Measurement Matrix</strong></p><img src="/images/cs231a-lecture7-1/image-20221106150020351.png" style="zoom:50%;"><img src="/images/cs231a-lecture7-1/image-20221106150042818.png" style="zoom:50%;"><img src="/images/cs231a-lecture7-1/image-20221106151035346.png" style="zoom:50%;"><img src="/images/cs231a-lecture7-1/image-20221106151141903.png" style="zoom:50%;"><img src="/images/cs231a-lecture7-1/image-20221106151234386.png" style="zoom:50%;"><p><strong>疑问</strong></p><p><strong>Q：什么是奇异值分解？</strong></p><p><strong>A：</strong>见<a href="https://zh.m.wikipedia.org/zh-hans/%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3">奇异值分解-维基百科</a>和<a href="https://www.cnblogs.com/pinard/p/6251584.html">奇异值分解(SVD)原理与在降维中的应用</a>。</p><p><strong>Q：这里的$W_3$指的是$W$中前3个奇异值吗？$W$中的奇异值是按照大小排序的吗？</strong></p><p><strong>A：</strong>从网上查到的结果是<strong>可以随意排列，奇异值与奇异向量对应上就行</strong>；不过<strong>常见的做法是将奇异值由大而小排列，如此$W$便能由$D$唯一确定了</strong>（但是$U$和$V$仍然不能确定）。这里$W$的奇异值应该是按大小排序的，$W_3$就是前3个奇异值，也是最大的3个奇异值（上面也说了$D$的秩为3，只应该存在3个非零奇异值，更小的奇异值可能就是噪声了，近似的效果也不好）。</p><p><strong>Q：关于SVD分解的唯一性讨论</strong></p><p><strong>A：</strong>该部分参考网址：<a href="http://amsword.is-programmer.com/posts/35966.html">对SVD唯一性的理解</a></p><p><strong>回顾SVD分解的定义：</strong></p><p>对于任何一个$m \times n$的矩阵$A$，都存在这样一个分解<br>$$<br>A=U\Sigma V^T<br>$$<br>其中$U$是$m \times m$的酉矩阵，也就是$UU^* = I$；$V$是一个$n \times n$的酉矩阵；$\Sigma$是一个$m \times n$的矩阵，非对角上的元素都是0，对角线上的元素都是非负的实数，不管$A$是实数矩阵，还是酉空间中的矩阵，或者说有虚数元素。</p><p><strong>先讨论$\Sigma$的唯一性：</strong></p><p>假设有一个置换矩阵$J$（左乘它是做行交换，右乘它是做列交换，而且$JJ^T=I$，$J_m$表示矩阵大小为$m \times m$），那么仍然有下面的式子成立：<br>$$<br>A=(UJ_m)(J_m\Sigma J_n)(VJ_n)^T<br>$$<br>这说明，<strong>SVD分解是不唯一的</strong>。但是注意到$\Sigma$是对角矩阵，对角线上的元素（奇异值）是由矩阵$A$唯一确定的，上面的变换仅仅是将它对角线上的元素进行了一个重新的排列，我们可以<strong>固定$\Sigma$中元素的排列（比如从大到小排序），这样就可以唯一确定$\Sigma$矩阵。</strong></p><p><strong>再讨论$\Sigma$确定时，$U$与$V$的唯一性：</strong></p><p>假设有一个对角方阵$K$（对角线上元素具有$e^{i\phi}$的形式，且$\phi$互不相同，$KK^*=I$，$K_m$表示矩阵大小为$m \times m$），那么仍然有下面的式子成立：<br>$$<br>A = U K_m K_m^* \Sigma K_n (  V K_n^* )^T<br>$$<br>当$K_m$对角线上第$i$个元素和$K_n$对角线上第$i$个元素相同时，有$K_m^*\Sigma K_n = \Sigma$</p><p>这说明，<strong>在$\Sigma$确定时，SVD分解得到的$U$与$V$也不是唯一的。</strong></p><h3 id="Affine-Ambiguity"><a href="#Affine-Ambiguity" class="headerlink" title="Affine Ambiguity"></a>Affine Ambiguity</h3><p>我们在上面把Affine SFM问题描述成$D=MS$，其中$D$是$2m \times n$个二维点$x_{ij}$构成的矩阵，$M$是$m$张图像的$A_i$矩阵构成的矩阵，而$S$则是$n$个三维点$X_j$构成的矩阵。</p><p>通过对矩阵$D$做SVD分解，我们可以得到$\begin{cases} &amp;M &amp;\approx U_3 \\ &amp;S &amp;\approx W_3V_3^T \end{cases}$</p><img src="/images/cs231a-lecture7-1/image-20221106151611906.png" style="zoom:50%;"><p>但分解的结果不是唯一的，如下所示。</p><img src="/images/cs231a-lecture7-1/image-20221106151623116.png" style="zoom:50%;"><img src="/images/cs231a-lecture7-1/image-20221106151712582.png" style="zoom:50%;"><p><strong>疑问</strong></p><p><strong>Q：这部分说的“分解的结果不唯一”指的是SVD分解结果不唯一，还是指对$M$与$S$进行一些变换可以得到同样的结果？</strong></p><p><strong>A：</strong>我觉得是后一种，指的是可能SVD分解的结果和实际的情况差了一个仿射变换。</p><h3 id="Similarity-Ambiguity"><a href="#Similarity-Ambiguity" class="headerlink" title="Similarity Ambiguity"></a>Similarity Ambiguity</h3><img src="/images/cs231a-lecture7-1/image-20221106153553521.png" style="zoom:50%;"><img src="/images/cs231a-lecture7-1/image-20221106153640184.png" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> 三维视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS231A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS231A Lecture 6：Stereo Systems</title>
      <link href="2022/11/05/cs231a-lecture6/"/>
      <url>2022/11/05/cs231a-lecture6/</url>
      
        <content type="html"><![CDATA[<h1 id="CS231A-Lecture-6：Stereo-Systems"><a href="#CS231A-Lecture-6：Stereo-Systems" class="headerlink" title="CS231A Lecture 6：Stereo Systems"></a>CS231A Lecture 6：Stereo Systems</h1><blockquote><p><strong>Reading:</strong> </p><p>[HZ] Chapter: 9 “Epip. Geom. and the Fundam. Matrix Transf.”</p><p>[HZ] Chapter: 18 “N view computational methods”</p><p>[FP] Chapters: 7 “Stereopsis”</p><p>[FP] Chapters: 8 “Structure from Motion”</p></blockquote><h2 id="Rectification"><a href="#Rectification" class="headerlink" title="Rectification"></a>Rectification</h2><h3 id="Epipolar-geometry"><a href="#Epipolar-geometry" class="headerlink" title="Epipolar geometry"></a>Epipolar geometry</h3><img src="/images/cs231a-lecture6/image-20221030213010701.png" style="zoom:50%;"><h3 id="Epipolar-Constraint"><a href="#Epipolar-Constraint" class="headerlink" title="Epipolar Constraint"></a>Epipolar Constraint</h3><img src="/images/cs231a-lecture6/image-20221030213032834.png" style="zoom:50%;"><img src="/images/cs231a-lecture6/image-20221030213049192.png" style="zoom:50%;"><h3 id="Parallel-image-planes"><a href="#Parallel-image-planes" class="headerlink" title="Parallel image planes"></a>Parallel image planes</h3><img src="/images/cs231a-lecture6/image-20221030213159214.png" style="zoom:50%;"><img src="/images/cs231a-lecture6/image-20221030213211904.png" style="zoom:50%;"><p><strong>Essential matrix for parallel images</strong></p><img src="/images/cs231a-lecture6/image-20221030213231412.png" style="zoom:50%;"><p><strong>What are the directions of epipolar lines?</strong></p><img src="/images/cs231a-lecture6/image-20221030214447727.png" style="zoom:50%;"><p><strong>How are p and p’ related?</strong></p><img src="/images/cs231a-lecture6/image-20221030214512860.png" style="zoom:50%;"><h3 id="Rectification-making-two-images-“parallel”"><a href="#Rectification-making-two-images-“parallel”" class="headerlink" title="Rectification: making two images “parallel”"></a>Rectification: making two images “parallel”</h3><p><strong>Rectification</strong></p><img src="/images/cs231a-lecture6/image-20221105160019522.png" style="zoom:50%;"><p><strong>Example</strong></p><img src="/images/cs231a-lecture6/image-20221105155837863.png" style="zoom:50%;"><p><strong>Why it is useful?</strong> </p><ul><li>Epipolar constraint $\rightarrow v = v’$</li><li>New views can be synthesized by linear interpolation</li></ul><p><strong>Why are parallel images useful?</strong></p><ul><li><p><strong>Makes triangulation easy</strong></p><img src="/images/cs231a-lecture6/image-20221105160513904.png" style="zoom:50%;"><p>这里有点类似双目相机的模型了。</p></li><li><p><strong>Makes the correspondence problem easier</strong></p></li></ul><h2 id="Correspondence-problem"><a href="#Correspondence-problem" class="headerlink" title="Correspondence problem"></a>Correspondence problem</h2><img src="/images/cs231a-lecture6/image-20221105162100749.png" style="zoom:50%;"><img src="/images/cs231a-lecture6/image-20221105162432580.png" style="zoom:50%;"><h3 id="Correlation-Methods"><a href="#Correlation-Methods" class="headerlink" title="Correlation Methods"></a>Correlation Methods</h3><h4 id="A-Simple-Idea"><a href="#A-Simple-Idea" class="headerlink" title="A Simple Idea"></a>A Simple Idea</h4><img src="/images/cs231a-lecture6/image-20221105163330962.png" style="zoom:50%;"><img src="/images/cs231a-lecture6/image-20221105163341560.png" style="zoom:50%;"><p><strong>思考：</strong></p><p>这里的问题是，只检查一个像素点，没有考虑到像素值相同的点可能比较多，很容易导致错误匹配。</p><h4 id="Window-based-correlation"><a href="#Window-based-correlation" class="headerlink" title="Window-based correlation"></a>Window-based correlation</h4><img src="/images/cs231a-lecture6/image-20221105163409282.png" style="zoom:50%;"><img src="/images/cs231a-lecture6/image-20221105164001164.png" style="zoom:50%;"><p><strong>思考：</strong></p><p>这里的问题是，只计算两个矩阵的点乘，并且认为最大值是匹配的最好的。</p><p>这样处理很容易受到光照或者曝光的影响，如下所示。</p><p><strong>Changes of brightness/exposure</strong></p><img src="/images/cs231a-lecture6/image-20221105164148204.png" style="zoom:50%;"><h4 id="Normalized-cross-correlation"><a href="#Normalized-cross-correlation" class="headerlink" title="Normalized cross-correlation"></a>Normalized cross-correlation</h4><img src="/images/cs231a-lecture6/image-20221105165228121.png" style="zoom:50%;"><h4 id="Effect-of-the-window’s-size"><a href="#Effect-of-the-window’s-size" class="headerlink" title="Effect of the window’s size"></a>Effect of the window’s size</h4><img src="/images/cs231a-lecture6/image-20221105165302206.png" style="zoom:50%;"><h4 id="Issues"><a href="#Issues" class="headerlink" title="Issues"></a>Issues</h4><ul><li><p><strong>Fore shortening effect</strong></p><img src="/images/cs231a-lecture6/image-20221105171518156.png" style="zoom:50%;"><p>这个网站把<em>Fore shortening effect</em>介绍的非常清楚：<a href="https://drawpaintacademy.com/foreshortening/">Foreshortening – What It Means and How to Paint It</a></p><p>从上图中也可以看出，左边相机拍摄的物体很长，而右边因为距离较远就缩短了。前面几种算法在这里容易出问题，他们都是在一条水平线上查找固定大小的window，但是利用图像金字塔应该可以处理这种问题。</p></li><li><p><strong>Occlusions</strong></p><img src="/images/cs231a-lecture6/image-20221105171537076.png" style="zoom:50%;"><p>因为遮挡导致两个相机观察的内容不一样。</p></li><li><p><strong>Base line trade-off</strong></p><img src="/images/cs231a-lecture6/image-20221105171610154.png" style="zoom:50%;"></li><li><p><strong>Homogeneous regions</strong> </p><img src="/images/cs231a-lecture6/image-20221105171706388.png" style="zoom:50%;"></li><li><p><strong>Repetitive patterns</strong></p><img src="/images/cs231a-lecture6/image-20221105171730038.png" style="zoom:50%;"></li></ul><p><strong>Correspondence problem is difficult!</strong></p><img src="/images/cs231a-lecture6/image-20221105194244286.png" style="zoom:50%;"><h4 id="Non-local-constraints"><a href="#Non-local-constraints" class="headerlink" title="Non-local constraints"></a>Non-local constraints</h4><img src="/images/cs231a-lecture6/image-20221105194521604-16677155424901.png" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> 三维视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS231A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS231A Lecture 5：Epipolar Geometry</title>
      <link href="2022/11/01/cs231a-lecture5/"/>
      <url>2022/11/01/cs231a-lecture5/</url>
      
        <content type="html"><![CDATA[<h1 id="CS231A-Lecture-5：Epipolar-Geometry"><a href="#CS231A-Lecture-5：Epipolar-Geometry" class="headerlink" title="CS231A Lecture 5：Epipolar Geometry"></a>CS231A Lecture 5：Epipolar Geometry</h1><blockquote><p><strong>Reading:</strong> </p><p>[HZ] Chapter: 4 “Estimation – 2D perspective transformations</p><p>[HZ] Chapter: 9 “Epipolar Geometry and the Fundamental Matrix Transformation”</p><p>[HZ] Chapter: 11 “Computation of the Fundamental Matrix F”</p><p>[FP] Chapter: 7 “Stereopsis”</p><p>[FP] Chapter: 8 “Structure from Motion”</p></blockquote><h2 id="Why-is-stereo-useful"><a href="#Why-is-stereo-useful" class="headerlink" title="Why is stereo useful?"></a>Why is stereo useful?</h2><h3 id="Recovering-structure-from-a-single-view"><a href="#Recovering-structure-from-a-single-view" class="headerlink" title="Recovering structure from a single view"></a>Recovering structure from a single view</h3><img src="/images/cs231a-lecture5/image-20221028213117490.png" style="zoom:50%;"><p><strong>Why is it so difficult?</strong></p><p>Intrinsic ambiguity of the mapping from 3D to image (2D)</p><h3 id="Triangulation"><a href="#Triangulation" class="headerlink" title="Triangulation"></a>Triangulation</h3><img src="/images/cs231a-lecture5/image-20221028213449943.png" style="zoom:50%;"><img src="/images/cs231a-lecture5/image-20221028213838238.png" style="zoom:50%;"><h3 id="Multi-stereo-view-geometry"><a href="#Multi-stereo-view-geometry" class="headerlink" title="Multi (stereo)-view geometry"></a>Multi (stereo)-view geometry</h3><img src="/images/cs231a-lecture5/image-20221030112623694.png" style="zoom:50%;"><h2 id="Epipolar-geometry"><a href="#Epipolar-geometry" class="headerlink" title="Epipolar geometry"></a>Epipolar geometry</h2><img src="/images/cs231a-lecture5/image-20221030113104085.png" style="zoom:50%;"><p><strong>Example: Parallel image planes</strong></p><img src="/images/cs231a-lecture5/image-20221030113159909.png" style="zoom:50%;"><p><strong>Example: Forward translation</strong></p><img src="/images/cs231a-lecture5/image-20221030113222727.png" style="zoom:50%;"><h3 id="Epipolar-constraints"><a href="#Epipolar-constraints" class="headerlink" title="Epipolar constraints"></a>Epipolar constraints</h3><ul><li>Two views of the same object </li><li>Given a point on left image, how can I find the corresponding point on right image?</li></ul><img src="/images/cs231a-lecture5/image-20221030152616682.png" style="zoom:50%;"><h3 id="The-Essential-Matrix"><a href="#The-Essential-Matrix" class="headerlink" title="The Essential Matrix"></a>The Essential Matrix</h3><img src="/images/cs231a-lecture5/image-20221030152708826.png" alt="=" style="zoom:50%;"><img src="/images/cs231a-lecture5/image-20221030153256822.png" style="zoom:50%;"><p><strong>Cross product as matrix multiplication</strong></p><img src="/images/cs231a-lecture5/image-20221030160127533.png" style="zoom: 50%;"><img src="/images/cs231a-lecture5/image-20221030160245903.png" style="zoom:50%;"><img src="/images/cs231a-lecture5/image-20221030160512471.png" style="zoom:50%;"><p><strong>思考：</strong></p><ul><li><p>在这个部分，点$p$和$p’$都是齐次的，是像素点的归一化平面上的坐标，而不是像素点坐标；</p><p>在这种情况下，相机是标准相机，内参$K$为单位矩阵。</p></li><li><p>在《视觉SLAM十四讲》中，使用齐次坐标表示像素点是为了表达一个投影关系，这样的话$s\mathrm p$与$\mathrm p$成投影关系，它们在齐次意义下相等，也可以说在尺度意义下相等；</p><p>这样处理就可以忽略像素点$p$和$p’$的深度（回想一下相机模型），然后去构造一个和上面相同的等式（方法都是相同的，细节有点区别而已。。）</p></li><li><p>本质矩阵$E$是平移和旋转做叉乘得到的，但是由于尺度等价性，它只有5个自由度。</p></li></ul><p><strong>疑问：</strong></p><p><strong>Q：什么是canonical cameras？</strong></p><p><strong>A：</strong>TODO（感觉是一个定义吧，内参已知的相机就可以转化为canonical camera，然后canonical camera的内参矩阵为单位矩阵）</p><h3 id="The-Fundamental-Matrix"><a href="#The-Fundamental-Matrix" class="headerlink" title="The Fundamental Matrix"></a>The Fundamental Matrix</h3><p>​    <img src="/images/cs231a-lecture5/image-20221030161447171.png" style="zoom:50%;"></p><img src="/images/cs231a-lecture5/image-20221030161504159.png" style="zoom:50%;"><img src="/images/cs231a-lecture5/image-20221030161522518.png" alt="=" style="zoom:50%;"><img src="/images/cs231a-lecture5/image-20221030161535301.png" style="zoom:50%;"><p><strong>思考：</strong></p><ul><li>这部分的ppt和<strong>Essential Matrix</strong>非常类似，不过这部分考虑了相机内参$K$，指出了像素点$p$与canonical camera下像素点$p_c$的对应关系。</li><li>在《视觉SLAM十四讲》中，是直接从像素点$p$推导到了最后的一个等式，然后把等式中间的部分记作基础矩阵$F$和本质矩阵$E$（所以讲的没这门课的清楚。。）</li><li>本质矩阵则是基本矩阵的一种特殊情况，是在归一化图像坐标下的基本矩阵。</li></ul><h3 id="Why-F-is-useful"><a href="#Why-F-is-useful" class="headerlink" title="Why F is useful?"></a>Why F is useful?</h3><ul><li>Suppose $F$ is known</li><li>No additional information about the scene and camera is given</li><li>Given a point on left image, we can compute the corresponding epipolar line in the second image</li><li>$F$ captures information about the epipolar geometry of 2 views + camera parameters </li><li><strong>MORE IMPORTANTLY:</strong> $F$ gives constraints on how the scene changes under view point transformation (without reconstructing the scene!)</li><li>Powerful tool in:<ul><li>3D reconstruction</li><li>Multi-view object/scene matching </li></ul></li></ul><h2 id="Estimating-F"><a href="#Estimating-F" class="headerlink" title="Estimating F"></a>Estimating F</h2><h3 id="The-Eight-Point-Algorithm"><a href="#The-Eight-Point-Algorithm" class="headerlink" title="The Eight-Point Algorithm"></a>The Eight-Point Algorithm</h3><img src="/images/cs231a-lecture5/image-20221030162257043.png" style="zoom:50%;"><img src="/images/cs231a-lecture5/image-20221030162313064.png" style="zoom:50%;"><img src="/images/cs231a-lecture5/image-20221030162412915.png" style="zoom:50%;"><img src="/images/cs231a-lecture5/image-20221030182108208.png" style="zoom:50%;"><img src="/images/cs231a-lecture5/image-20221030182119932.png" style="zoom:50%;"><p><strong>Problems with the 8-Point Algorithm</strong></p><img src="/images/cs231a-lecture5/image-20221030182200026.png" style="zoom:50%;"><img src="/images/cs231a-lecture5/image-20221030182212332.png" style="zoom:50%;"><p><strong>思考：</strong></p><p>在《视觉SLAM十四讲》中，主要介绍了八点法求解本质矩阵$E$。</p><p>与上面不同的是，本质矩阵$E$的$\Sigma=diag(\sigma,\sigma,0)$，而基础矩阵$F$的$\Sigma=diag(s_1,s_2,0)$。</p><h3 id="The-Normalized-Eight-Point-Algorithm"><a href="#The-Normalized-Eight-Point-Algorithm" class="headerlink" title="The Normalized Eight-Point Algorithm"></a>The Normalized Eight-Point Algorithm</h3><h4 id="Normalization"><a href="#Normalization" class="headerlink" title="Normalization"></a>Normalization</h4><img src="/images/cs231a-lecture5/image-20221030182450732.png" style="zoom:50%;"><p><strong>Example of normalization</strong></p><img src="/images/cs231a-lecture5/image-20221030182509366.png" style="zoom:50%;"><img src="/images/cs231a-lecture5/image-20221030183453854.png" style="zoom:50%;"><h4 id="The-Normalized-Eight-Point-Algorithm-1"><a href="#The-Normalized-Eight-Point-Algorithm-1" class="headerlink" title="The Normalized Eight-Point Algorithm"></a>The Normalized Eight-Point Algorithm</h4><img src="/images/cs231a-lecture5/image-20221030183527084.png" style="zoom:50%;"><img src="/images/cs231a-lecture5/image-20221030183557170.png" style="zoom:50%;"><p><strong>思考：</strong></p><p>这里的normalize就是用另外的图像坐标系表示匹配的特征点，让特征点更均匀的散布在坐标原点周围。如果特征点散布在同一块地区，彼此非常接近，或者有的特征点的数值非常大，可能会对矩阵$W$带来不好的影响。</p><p>由于更改了图像的坐标系，这里计算出来的基础矩阵$F$还需要再de-normalize一下。</p><p>在course notes 3上有更详细的解读：</p><blockquote><p>The main problem of the standard Eight-Point Algorithm stems from the fact that $W$ is ill-conditioned for SVD. For SVD to work properly, $W$ should have one singular value equal to (or near) zero, with the other singular values being nonzero. However, the correspondences $p_i = (u_i, v_i, 1)$ will often have extremely large values in the first and second coordinates due to the pixel range of a modern camera (i.e. $p_i = (1832, 1023, 1)$). If the image points used to construct $W$ are in a relatively small region of the image, then each of the vectors for $p_i$ and $p′_i$ will generally be very similar. Consequently, the constructed $W$ matrix will have one very large singular value, with the rest relatively small.</p><p>To solve this problem, we will normalize the points in the image before constructing $W$. This means we pre-condition $W$ by applying both a translation and scaling on the image coordinates.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 三维视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS231A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS231A Lecture 4：Single View Metrology</title>
      <link href="2022/10/28/cs231a-lecture4/"/>
      <url>2022/10/28/cs231a-lecture4/</url>
      
        <content type="html"><![CDATA[<h1 id="CS231A-Lecture-4：Single-View-Metrology"><a href="#CS231A-Lecture-4：Single-View-Metrology" class="headerlink" title="CS231A Lecture 4：Single View Metrology"></a>CS231A Lecture 4：Single View Metrology</h1><blockquote><p><strong>Reading:</strong></p><p>[HZ] Chapter 2 “Projective Geometry and Transformation in 2D”</p><p>[HZ] Chapter 3 “Projective Geometry and Transformation in 3D”</p><p>[HZ] Chapter 8 “More Single View Geometry”</p><p>[Hoeim &amp; Savarese] Chapter 2</p></blockquote><h2 id="2D-transformations"><a href="#2D-transformations" class="headerlink" title="2D transformations"></a>2D transformations</h2><p>这部分介绍了四种2D变换：Isometries、Similarities、Affinity、Projective</p><h3 id="Isometries"><a href="#Isometries" class="headerlink" title="Isometries"></a>Isometries</h3><p>等距变换（Isometries），旋转+平移。</p><img src="/images/cs231a-lecture4/image-20221027210229618.png" style="zoom: 50%;"><h3 id="Similarities"><a href="#Similarities" class="headerlink" title="Similarities"></a>Similarities</h3><p>相似变换（Similarities），相当于是等距变换与均匀缩放的结合。</p><img src="/images/cs231a-lecture4/image-20221027210243854.png" style="zoom:50%;"><h3 id="Affinity"><a href="#Affinity" class="headerlink" title="Affinity"></a>Affinity</h3><p>仿射变换（Affine），是一个平移变换与一个非奇异线性变换的结合。</p><p>其中的A矩阵可以理解成旋转与非均匀缩放的结合。</p><img src="/images/cs231a-lecture4/image-20221027210255599.png" style="zoom:50%;"><img src="/images/cs231a-lecture4/image-20221027210325706.png" style="zoom:50%;"><img src="/images/cs231a-lecture4/image-20221027210342130.png" style="zoom:50%;"><h3 id="Projective"><a href="#Projective" class="headerlink" title="Projective"></a>Projective</h3><p>射影变换（Projective），是齐次坐标的一般非奇异线性变换，扩展了仿射变换，是非齐次坐标的一般非奇异线性变换和一个平移的复合。</p><p><strong>定义：</strong>由有限次中心射影的积定义的两条直线间的一一对应变换称为一维射影变换。由有限次中心射影的积定义的两个平面之间的一一对应变换称为二维射影变换。</p><p><strong>性质：</strong>交比不变性</p><p>如果平面上点场的点建立了一个一一对应，并且满足：</p><p>（1）任何共线三点的象仍是共线三点；</p><p>（2）共线四点的交比不变。</p><p>则这个一一对应叫做点场的射影变换，简称射影变换。</p><img src="/images/cs231a-lecture4/image-20221027210358442.png" style="zoom:50%;"><p><strong>The cross ratio：</strong></p><img src="/images/cs231a-lecture4/image-20221027210443284.png" style="zoom:50%;"><p><strong>与其他变换的关系：</strong></p><ul><li><p>$H$矩阵是可逆实矩阵，当$v$等于0则变成了仿射变换；在仿射变换的前提下，左上角的$2 \times 2$矩阵正交时为相似变换；左上角矩阵行列式为1时为等距变换。</p></li><li><p>射影变换可以分解成一串交换链的复合。<br>$$<br>H = H_{S}H_{A}H_{P} =<br>\begin{bmatrix} sR&amp;t \\ 0^{T} &amp; 1 \end{bmatrix}<br>\begin{bmatrix} K&amp;0 \\ 0^{T} &amp; 1 \end{bmatrix}<br>\begin{bmatrix} I&amp;0 \\ V^{T} &amp; v \end{bmatrix} =<br>\begin{bmatrix} A &amp; Vt\\ V^{T} &amp; v \end{bmatrix}<br>$$<br>可以看出上式中，$H_S$表示相似变换，$H_A$表示仿射变换，$H_P$表示射影变换。</p></li></ul><h3 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h3><p><strong>Q：射影变换与仿射变换的根本区别在于射影变换中向量$v$不为0，如何理解？</strong></p><p><strong>A：</strong>对于理想点$(x_{1},x_{2},0)^{T}$在仿射变换与射影变换下面的映射：</p><ul><li><p>在仿射变换下：<br>$$<br>\begin{bmatrix} A &amp;t \\ 0^{T} &amp; 1 \end{bmatrix}<br>\begin{pmatrix} x_{1}\\ x_{2}\\ 0 \end{pmatrix} =<br>\begin{pmatrix} A\begin{pmatrix} x_{1}\\ x_{2} \end{pmatrix} \\ 0 \end{pmatrix}<br>$$</p></li><li><p>在射影变换下：<br>$$<br>\begin{bmatrix} A &amp;t \\ V^{T} &amp; v \end{bmatrix}<br>\begin{pmatrix} x_{1}\\ x_{2}\\ 0 \end{pmatrix} =<br>\begin{pmatrix} A\begin{pmatrix} x_{1}\\ x_{2} \end{pmatrix} \\ v_{1}x_{1}+v_{2}x_{2}<br>\end{pmatrix}<br>$$</p></li></ul><p>可以看出，<strong>对于仿射变换，理想点变换后还是理想点；对于射影变换，理想点被映射到有限点。说明射影变换能对消影点建模</strong>。</p><h2 id="Vanishing-points-and-lines"><a href="#Vanishing-points-and-lines" class="headerlink" title="Vanishing points and lines"></a>Vanishing points and lines</h2><h3 id="Lines-in-a-2D-plane"><a href="#Lines-in-a-2D-plane" class="headerlink" title="Lines in a 2D plane"></a>Lines in a 2D plane</h3><img src="/images/cs231a-lecture4/image-20221028161446651.png" style="zoom:50%;"><h4 id="Intersecting-lines"><a href="#Intersecting-lines" class="headerlink" title="Intersecting lines"></a>Intersecting lines</h4><img src="/images/cs231a-lecture4/image-20221028161704759.png" style="zoom:50%;"><h4 id="2D-Points-at-infinity-ideal-points"><a href="#2D-Points-at-infinity-ideal-points" class="headerlink" title="2D Points at infinity (ideal points)"></a>2D Points at infinity (ideal points)</h4><img src="/images/cs231a-lecture4/image-20221028162147134.png" style="zoom:50%;"><img src="/images/cs231a-lecture4/image-20221028162226539.png" style="zoom:50%;"><h4 id="Lines-infinity-l-infty"><a href="#Lines-infinity-l-infty" class="headerlink" title="Lines infinity $l_\infty$"></a>Lines infinity $l_\infty$</h4><img src="/images/cs231a-lecture4/image-20221028162718069.png" style="zoom:50%;"><h4 id="Projective-transformation"><a href="#Projective-transformation" class="headerlink" title="Projective transformation"></a>Projective transformation</h4><p>这部分和2D transformations-Questions是对应的。</p><h5 id="a-point-at-infinity"><a href="#a-point-at-infinity" class="headerlink" title="a point at infinity"></a>a point at infinity</h5><img src="/images/cs231a-lecture4/image-20221028163811252.png" style="zoom:50%;"><h5 id="a-line-in-2D"><a href="#a-line-in-2D" class="headerlink" title="a line (in 2D)"></a>a line (in 2D)</h5><img src="/images/cs231a-lecture4/image-20221028163842739.png" style="zoom:50%;"><h3 id="Points-and-planes-in-3D"><a href="#Points-and-planes-in-3D" class="headerlink" title="Points and planes in 3D"></a>Points and planes in 3D</h3><p><strong>3D空间中的点与平面：</strong></p><img src="/images/cs231a-lecture4/image-20221028164728893.png" style="zoom:50%;"><p><strong>3D空间中的直线：</strong></p><img src="/images/cs231a-lecture4/image-20221028164740978.png" style="zoom:50%;"><p><img src="/images/cs231a-lecture4/image-20221028165448251.png"></p><p><strong>Points at infinity in 3D</strong></p><img src="/images/cs231a-lecture4/image-20221028164857067.png" style="zoom:50%;"><h4 id="Vanishing-points"><a href="#Vanishing-points" class="headerlink" title="Vanishing points"></a>Vanishing points</h4><img src="/images/cs231a-lecture4/image-20221028164924250.png" style="zoom:50%;"><h4 id="Vanishing-points-and-directions"><a href="#Vanishing-points-and-directions" class="headerlink" title="Vanishing points and directions"></a>Vanishing points and directions</h4><img src="/images/cs231a-lecture4/image-20221028174039533.png" style="zoom:50%;"><h4 id="Vanishing-horizon-line"><a href="#Vanishing-horizon-line" class="headerlink" title="Vanishing (horizon) line"></a>Vanishing (horizon) line</h4><img src="/images/cs231a-lecture4/image-20221028173200919.png" style="zoom:50%;"><p><strong>Example: Are these two lines parallel or not?</strong></p><img src="/images/cs231a-lecture4/image-20221028174055129.png" style="zoom:50%;"><h4 id="Vanishing-points-and-planes"><a href="#Vanishing-points-and-planes" class="headerlink" title="Vanishing points and planes"></a>Vanishing points and planes</h4><p>Furthermore, the horizon line allows us to compute useful properties about the world. For example, we can derive an interesting relationship between the the normal n of a plane in 3D with the corresponding horizon line $l_{horiz}$ in an image:</p><img src="/images/cs231a-lecture4/image-20221028174710565.png" style="zoom:50%;"><p>This means that if we can recognize the horizon line associated with a plane, and if our camera is calibrated, then we can estimate the orientation of that plane.</p><h4 id="Planes-at-infinity"><a href="#Planes-at-infinity" class="headerlink" title="Planes at infinity"></a>Planes at infinity</h4><img src="/images/cs231a-lecture4/image-20221028174817317.png" style="zoom:50%;"><h4 id="Angle-between-2-vanishing-points"><a href="#Angle-between-2-vanishing-points" class="headerlink" title="Angle between 2 vanishing points"></a>Angle between 2 vanishing points</h4><img src="/images/cs231a-lecture4/image-20221028174939830.png" style="zoom:50%;"><h4 id="Properties-of-omega"><a href="#Properties-of-omega" class="headerlink" title="Properties of $\omega$"></a>Properties of $\omega$</h4><img src="/images/cs231a-lecture4/image-20221028175128501.png" style="zoom:50%;"><h4 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h4><img src="/images/cs231a-lecture4/image-20221028175208575.png" style="zoom:50%;"><h3 id="Questions-1"><a href="#Questions-1" class="headerlink" title="Questions"></a>Questions</h3><p><strong>Q：为什么无穷远处的线$l_\infty=\begin{bmatrix} 0 \\ 0 \\ 1 \end{bmatrix}$</strong></p><p><strong>A：</strong>有穷点显然不在$l_\infty$上，因此$\begin{bmatrix} x \\ y \\ 1 \end{bmatrix} l_\infty \neq 0$；无穷点显然应该在$l_\infty$上，因此$\begin{bmatrix} x \\ y \\ 0 \end{bmatrix} l_\infty = 0$。</p><p><strong>Q：为什么3D中两条平行直线的交点与直线的方向向量是相同的</strong></p><p><strong>A：</strong>TODO（不过把两条直线的一般方程摆出来，确实就应该是直线的方向向量才满足条件）</p><h2 id="Estimating-geometry-from-a-single-image"><a href="#Estimating-geometry-from-a-single-image" class="headerlink" title="Estimating geometry from a single image"></a>Estimating geometry from a single image</h2><h3 id="Single-view-calibration-example"><a href="#Single-view-calibration-example" class="headerlink" title="Single view calibration - example"></a>Single view calibration - example</h3><img src="/images/cs231a-lecture4/image-20221028175618266.png" style="zoom:50%;"><img src="/images/cs231a-lecture4/image-20221028175656737.png" style="zoom:50%;"><img src="/images/cs231a-lecture4/image-20221028175725632.png" style="zoom:50%;"><img src="/images/cs231a-lecture4/image-20221028175740607.png" style="zoom:50%;"><img src="/images/cs231a-lecture4/image-20221028175753728.png" style="zoom:50%;"><h3 id="Single-view-reconstruction-example"><a href="#Single-view-reconstruction-example" class="headerlink" title="Single view reconstruction - example"></a>Single view reconstruction - example</h3><img src="/images/cs231a-lecture4/image-20221028175836046.png" style="zoom:50%;"><img src="/images/cs231a-lecture4/image-20221028175847411.png" style="zoom:50%;"><h3 id="Single-view-reconstruction-drawbacks"><a href="#Single-view-reconstruction-drawbacks" class="headerlink" title="Single view reconstruction - drawbacks"></a>Single view reconstruction - drawbacks</h3><img src="/images/cs231a-lecture4/image-20221028175939406-16677053070291.png" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> 三维视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS231A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS231A Lecture 3：Camera Calibration</title>
      <link href="2022/10/14/cs231a-lecture3/"/>
      <url>2022/10/14/cs231a-lecture3/</url>
      
        <content type="html"><![CDATA[<h1 id="CS231A-Lecture-3：Camera-Calibration"><a href="#CS231A-Lecture-3：Camera-Calibration" class="headerlink" title="CS231A Lecture 3：Camera Calibration"></a>CS231A Lecture 3：Camera Calibration</h1><blockquote><p>Reading: </p><p>[FP] Chapter 1 “Geometric Camera Calibration”</p><p>[HZ] Chapter 7 “Computation of Camera Matrix P”</p></blockquote><h2 id="Internal-and-External-parameters"><a href="#Internal-and-External-parameters" class="headerlink" title="Internal and External parameters"></a>Internal and External parameters</h2><img src="/images/cs231a-lecture3/image-20221012202055469.png" style="zoom:67%;"><h2 id="Calibration-Problem"><a href="#Calibration-Problem" class="headerlink" title="Calibration Problem"></a>Calibration Problem</h2><h3 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h3><p>Estimate intrinsic and extrinsic parameters from 1 or multiple images</p><h3 id="Mathematical-Expression"><a href="#Mathematical-Expression" class="headerlink" title="Mathematical Expression"></a>Mathematical Expression</h3><img src="/images/cs231a-lecture3/image-20221012203045100.png" style="zoom:67%;"><h3 id="How-many-correspondences-do-we-need"><a href="#How-many-correspondences-do-we-need" class="headerlink" title="How many correspondences do we need?"></a>How many correspondences do we need?</h3><ul><li><p>M has 11 unknowns</p></li><li><p>We need 11 equations</p></li><li><p>6 correspondences would do it</p><p>In practice, using more than 6 correspondences enables more robust results</p></li></ul><h3 id="How-to-list-equations"><a href="#How-to-list-equations" class="headerlink" title="How to list equations?"></a>How to list equations?</h3><img src="/images/cs231a-lecture3/image-20221012204246691.png" style="zoom:67%;"><img src="/images/cs231a-lecture3/image-20221012204259709.png" style="zoom:67%;"><img src="/images/cs231a-lecture3/image-20221012204424235.png" style="zoom:67%;"><img src="/images/cs231a-lecture3/image-20221012204530383.png" style="zoom:67%;"><h2 id="Homogeneous-M-x-N-Linear-Systems"><a href="#Homogeneous-M-x-N-Linear-Systems" class="headerlink" title="Homogeneous M x N Linear Systems"></a>Homogeneous M x N Linear Systems</h2><img src="/images/cs231a-lecture3/image-20221012204646720.png" style="zoom:80%;"><h2 id="Solve-calibration-problem-via-SVD-decomposition"><a href="#Solve-calibration-problem-via-SVD-decomposition" class="headerlink" title="Solve calibration problem via SVD decomposition"></a>Solve calibration problem via SVD decomposition</h2><h3 id="Calibration-Problem-1"><a href="#Calibration-Problem-1" class="headerlink" title="Calibration Problem"></a>Calibration Problem</h3><img src="/images/cs231a-lecture3/image-20221012210709319.png" style="zoom: 67%;"><h3 id="Extracting-camera-parameters"><a href="#Extracting-camera-parameters" class="headerlink" title="Extracting camera parameters"></a>Extracting camera parameters</h3><img src="/images/cs231a-lecture3/image-20221014100728333.png" style="zoom:67%;"><img src="/images/cs231a-lecture3/image-20221014100740977.png" style="zoom:67%;"><img src="/images/cs231a-lecture3/image-20221014100751444.png" style="zoom:67%;"><h3 id="Degenerate-cases"><a href="#Degenerate-cases" class="headerlink" title="Degenerate cases"></a>Degenerate cases</h3><img src="/images/cs231a-lecture3/image-20221014100820747.png" style="zoom:67%;"><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><p><strong>Q：为什么标定相机使用的点不能够在同一个平面或者两个二次曲面的相交曲线上？</strong></p><p><strong>A：</strong>TODO</p><p><strong>Q：常用的棋盘格标定法，使用的点应该是在同一个平面上的？它如何解决这个问题？</strong></p><p><strong>A：</strong>TODO</p><h2 id="Camera-calibration-with-radial-distortion"><a href="#Camera-calibration-with-radial-distortion" class="headerlink" title="Camera calibration with radial distortion"></a>Camera calibration with radial distortion</h2><h3 id="Review-radial-distortion"><a href="#Review-radial-distortion" class="headerlink" title="Review radial distortion"></a>Review radial distortion</h3><img src="/images/cs231a-lecture3/image-20221014104001784.png" style="zoom:67%;"><h3 id="Calibration-Problem-2"><a href="#Calibration-Problem-2" class="headerlink" title="Calibration Problem"></a>Calibration Problem</h3><p>根据上一篇博客提到的径向畸变公式，给出下面的方程。</p><img src="/images/cs231a-lecture3/image-20221014104752131.png" style="zoom:67%;"><img src="/images/cs231a-lecture3/image-20221014104818934.png" style="zoom:67%;"><h3 id="General-Calibration-Problem"><a href="#General-Calibration-Problem" class="headerlink" title="General Calibration Problem"></a>General Calibration Problem</h3><img src="/images/cs231a-lecture3/image-20221014105054200.png" style="zoom:67%;"><img src="/images/cs231a-lecture3/image-20221014105109014.png" style="zoom:67%;"><img src="/images/cs231a-lecture3/image-20221014105124962.png" style="zoom:67%;"><h3 id="Estimate-m1-and-m2-and-ignore-the-radial-distortion"><a href="#Estimate-m1-and-m2-and-ignore-the-radial-distortion" class="headerlink" title="Estimate m1 and m2 and ignore the radial distortion"></a>Estimate m1 and m2 and ignore the radial distortion</h3><img src="/images/cs231a-lecture3/image-20221014110141419.png" style="zoom:67%;"><img src="/images/cs231a-lecture3/image-20221014110231133.png" style="zoom:67%;"><img src="/images/cs231a-lecture3/image-20221014110243031.png" style="zoom:67%;"><h3 id="Question-1"><a href="#Question-1" class="headerlink" title="Question"></a>Question</h3><p><strong>Q：本课程只提到了在考虑径向畸变的情况下进行相机标定，如果把切向畸变也考虑进来，整个过程是什么样的？</strong></p><p><strong>A：</strong>TODO</p>]]></content>
      
      
      <categories>
          
          <category> 三维视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS231A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS231A Lecture 2：Camera Models</title>
      <link href="2022/10/12/cs231a-lecture2/"/>
      <url>2022/10/12/cs231a-lecture2/</url>
      
        <content type="html"><![CDATA[<h1 id="CS231A-Lecture-2-Camera-Models"><a href="#CS231A-Lecture-2-Camera-Models" class="headerlink" title="CS231A Lecture 2: Camera Models"></a>CS231A Lecture 2: Camera Models</h1><blockquote><p>Reading: </p><ul><li><p>[FP] Chapter 1, “Geometric Camera Models”</p></li><li><p>[HZ] Chapter 6 “Camera Models”</p></li></ul></blockquote><h2 id="Pinhole-cameras"><a href="#Pinhole-cameras" class="headerlink" title="Pinhole cameras"></a>Pinhole cameras</h2><h3 id="Pinhole-Perspective"><a href="#Pinhole-Perspective" class="headerlink" title="Pinhole Perspective"></a>Pinhole Perspective</h3><p>下面三张图描述的是：从世界坐标系到像平面坐标系的变换，物体最后投影到物理成像平面（image plane）上。</p><img src="/images/cs231a-lecture2/image-20221009202222922.png" style="zoom: 50%;"><img src="/images/cs231a-lecture2/image-20221009202348197.png" style="zoom:50%;"><img src="/images/cs231a-lecture2/image-20221009202317015.png" style="zoom: 50%;"><p>这种针孔透视有两个特点：a）远处的物体成的像更小；b）位于某平面中的两条平行线的投影似乎会聚在水平线h上，该水平线h是由成像平面与平行于某平面并穿过针孔的平面相交而形成的。注意，某平面中平行于成像平面的线根本没有图像。</p><img src="/images/cs231a-lecture2/image-20221010210150378.png" style="zoom:50%;"><h3 id="Weak-Perspective"><a href="#Weak-Perspective" class="headerlink" title="Weak Perspective"></a>Weak Perspective</h3><p><strong>弱透视投影模型：</strong>针对于针孔成像模型做了进一步简化，<strong>物体投影时各个点与小孔的距离都用物体的平均距离代替</strong>，即不存在近大远小了，因为都是相同距离了。这样成像的大小就是成像平面与针孔距离d，以及物体与针孔距离D之间的比例决定了。这个模型对应的投影过程就称之为弱透视投影。</p><blockquote><p>教材原话：When a scene’s relief is small relative to its average distance from the camera, the magnifification can be taken to be constant. This projection model is called weak perspective, or scaled orthography.</p></blockquote><img src="/images/cs231a-lecture2/image-20221012150049870.png" style="zoom:67%;"><p><strong>perspective与weak perspective的区别：</strong></p><img src="/images/cs231a-lecture2/image-20221012191106409.png" style="zoom:50%;"><img src="/images/cs231a-lecture2/image-20221012191121561.png" style="zoom:50%;"><img src="/images/cs231a-lecture2/image-20221012191136677.png" style="zoom:50%;"><h3 id="Orthographic-projection"><a href="#Orthographic-projection" class="headerlink" title="Orthographic projection"></a>Orthographic projection</h3><p><strong>正交投影成像模型：</strong>在弱透视投影上进一步简化，让弱透视投影中仅存的比例为1，其效果等同于平行光线投射到成像平面上。这个模型对应的投影过程称之为正交投影。正交投影不涉及图像特征的反转，因此，放大倍数为负值，这有点不自然，但简化了投影方程。</p><img src="/images/cs231a-lecture2/image-20221012191159987.png" style="zoom:50%;"><h3 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h3><p><strong>Q：Is the size of the aperture（光圈，孔径） important?</strong> </p><p><strong>A：</strong>光圈越大，成像越模糊；光圈越小，成像越清晰，但会越来越暗，因为透过的光线更少了（还有可能发生衍射）。</p><img src="/images/cs231a-lecture2/image-20221009204048000.png" style="zoom:50%;"><p><strong>Q：如何应对透过光线更少的问题？</strong></p><p><strong>A：</strong>Adding lenses! （通过添加透镜将光线汇聚到胶片上）</p><p><strong>Q：Pros and Cons of These Models</strong></p><p><strong>A：</strong></p><img src="/images/cs231a-lecture2/image-20221012191303069.png" style="zoom: 50%;"><h2 id="Cameras-amp-lenses"><a href="#Cameras-amp-lenses" class="headerlink" title="Cameras &amp; lenses"></a>Cameras &amp; lenses</h2><h3 id="A-lens-focuses-light-onto-the-film"><a href="#A-lens-focuses-light-onto-the-film" class="headerlink" title="A lens focuses light onto the film"></a>A lens focuses light onto the film</h3><img src="/images/cs231a-lecture2/image-20221009204732224.png" style="zoom:50%;"><img src="/images/cs231a-lecture2/image-20221009205952541.png" style="zoom:50%;"><h3 id="Paraxial-refraction-model"><a href="#Paraxial-refraction-model" class="headerlink" title="Paraxial refraction model"></a>Paraxial refraction model</h3><blockquote><h4 id="近轴折射模型"><a href="#近轴折射模型" class="headerlink" title="近轴折射模型"></a>近轴折射模型</h4></blockquote><p>下面的ppt主要表达了一个点，即相机的焦距依然是小孔到成像平面的距离，它和透镜的焦距有区别！（相机焦距还可以计算出来，经典的初中物理题。。。）</p><img src="/images/cs231a-lecture2/image-20221009210115436.png" style="zoom:50%;"><img src="/images/cs231a-lecture2/image-20221009210130425.png" style="zoom:50%;"><h3 id="Questions-1"><a href="#Questions-1" class="headerlink" title="Questions"></a>Questions</h3><p><strong>Q：为什么相机需要装透镜？</strong></p><p><strong>A：</strong>在教材上有这么一句话：“Most real cameras are equipped with lenses. There are two main reasons for this: <strong>The first one is to gather light</strong>, because a single ray of light would otherwise reach each point in the image plane under ideal pinhole projection. Real pinholes have a finite size, of course, so each point in the image plane is illuminated by a cone of light rays subtending a finite solid angle. The larger the hole, the wider the cone and the brighter the image, but a large pinhole gives blurry pictures. Shrinking the pinhole produces sharper images but reduces the amount of light reaching the image plane, and may introduce diffraction effects. <strong>Keeping the picture in sharp focus while gathering light from a large area is the second main reason for using a lens</strong>.”</p><p><strong>Q：透镜是如何聚集光线的？</strong></p><p><strong>A：</strong>如下图所示。</p><img src="/images/cs231a-lecture2/image-20221012150635379.png" style="zoom:67%;"><p><strong>Q：相机的针孔和透镜的关系？有了透镜之后还需要针孔吗？</strong></p><p><strong>A：</strong>我的理解是，透镜中心点O就是所谓的针孔。</p><h2 id="The-geometry-of-pinhole-cameras-Intrinsic"><a href="#The-geometry-of-pinhole-cameras-Intrinsic" class="headerlink" title="The geometry of pinhole cameras-Intrinsic"></a>The geometry of pinhole cameras-Intrinsic</h2><h3 id="Converting-to-pixels"><a href="#Converting-to-pixels" class="headerlink" title="Converting to pixels"></a>Converting to pixels</h3><img src="/images/cs231a-lecture2/image-20221012162653991.png" style="zoom:50%;"><img src="/images/cs231a-lecture2/image-20221012162710839.png" style="zoom:50%;"><img src="/images/cs231a-lecture2/image-20221012161947590.png" style="zoom:50%;"><h3 id="Homogeneous-coordinates"><a href="#Homogeneous-coordinates" class="headerlink" title="Homogeneous coordinates"></a>Homogeneous coordinates</h3><img src="/images/cs231a-lecture2/image-20221012162801639.png" style="zoom: 50%;"><p><strong>Projective transformation in the homogenous coordinate system</strong></p><img src="/images/cs231a-lecture2/image-20221012162845363.png" style="zoom:50%;"><h3 id="The-Camera-Matrix"><a href="#The-Camera-Matrix" class="headerlink" title="The Camera Matrix"></a>The Camera Matrix</h3><img src="/images/cs231a-lecture2/image-20221012163725558.png" style="zoom:50%;"><h3 id="Camera-Skewness"><a href="#Camera-Skewness" class="headerlink" title="Camera Skewness"></a>Camera Skewness</h3><img src="/images/cs231a-lecture2/image-20221012163825727.png" style="zoom:50%;"><p><strong>How many degrees of freedom does K have?</strong></p><p><strong>5 degrees of freedom!</strong></p><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><p><strong>Q：为什么相机内参K有五个自由度？</strong></p><p><strong>A：</strong>矩阵K中有五个互相独立的变量！</p><h2 id="The-geometry-of-pinhole-cameras-Extrinsic"><a href="#The-geometry-of-pinhole-cameras-Extrinsic" class="headerlink" title="The geometry of pinhole cameras-Extrinsic"></a>The geometry of pinhole cameras-Extrinsic</h2><h3 id="2D-Scale-Rotation-Translation"><a href="#2D-Scale-Rotation-Translation" class="headerlink" title="2D Scale + Rotation + Translation"></a>2D Scale + Rotation + Translation</h3><img src="/images/cs231a-lecture2/image-20221012164723567.png" style="zoom: 50%;"><h3 id="3D-Translation-and-Rotation"><a href="#3D-Translation-and-Rotation" class="headerlink" title="3D Translation and Rotation"></a>3D Translation and Rotation</h3><h4 id="3D-Rotation-of-Points"><a href="#3D-Rotation-of-Points" class="headerlink" title="3D Rotation of Points"></a>3D Rotation of Points</h4><img src="/images/cs231a-lecture2/image-20221012164904696.png" style="zoom:50%;"><h4 id="3D-Translation-of-Points"><a href="#3D-Translation-of-Points" class="headerlink" title="3D Translation of Points"></a>3D Translation of Points</h4><img src="/images/cs231a-lecture2/image-20221012164932821.png" style="zoom:50%;"><h4 id="Translation-and-Rotation"><a href="#Translation-and-Rotation" class="headerlink" title="Translation and Rotation"></a>Translation and Rotation</h4><img src="/images/cs231a-lecture2/image-20221012165020769.png" style="zoom:50%;"><h3 id="World-reference-system"><a href="#World-reference-system" class="headerlink" title="World reference system"></a>World reference system</h3><img src="/images/cs231a-lecture2/image-20221012165121998.png" style="zoom:50%;"><h3 id="The-projective-transformation"><a href="#The-projective-transformation" class="headerlink" title="The projective transformation"></a>The projective transformation</h3><img src="/images/cs231a-lecture2/image-20221012165344068.png" style="zoom:50%;"><p><strong>How many degrees of freedom does M have?</strong></p><p><strong>5 + 3 + 3 =11</strong></p><h2 id="Perspective-Projection-Matrices"><a href="#Perspective-Projection-Matrices" class="headerlink" title="Perspective Projection Matrices"></a>Perspective Projection Matrices</h2><p><img src="/images/cs231a-lecture2/image-20221012170926479.png"></p><h2 id="Camera-distortion"><a href="#Camera-distortion" class="headerlink" title="Camera distortion"></a>Camera distortion</h2><blockquote><p>该部分参考：<a href="https://xhy3054.github.io/camera-calibration-undistort">https://xhy3054.github.io/camera-calibration-undistort</a></p></blockquote><p>现代相机为了获得更好的成像效果，相机里一般都加入了透镜。而透镜的加入对成像过程中光线的传播会产生新的影响，进而出现畸变，一般有两种主要的畸变（其实也还有其他的种类的畸变，但是不如这两种明显）：</p><p><img src="/images/cs231a-lecture2/distort0.jpg"></p><h3 id="Radial-Distortion"><a href="#Radial-Distortion" class="headerlink" title="Radial Distortion"></a>Radial Distortion</h3><p><strong>径向畸变：</strong>透镜自身的形状对光线传播会有影响；</p><ul><li>桶形畸变：图像放大率随着与光轴之间的距离增加而减小</li><li>枕形畸变：图像放大率随着与光轴之间的距离增大而增大</li></ul><img src="/images/cs231a-lecture2/image-20221014102255454.png" style="zoom:67%;"><p>一般径向畸变对于二维平面上一个坐标$(x,y)$（如上图畸变最小的点为坐标原点，一般在图像中心，$r$是点到原点的距离）的影响可以使用如下公式表述：<br>$$<br>x_{distorted} = x( 1 + k_1 r^2 + k_2 r^4 + k_3 r^6)<br>\\<br>y_{distorted} = y( 1 + k_1 r^2 + k_2 r^4 + k_3 r^6)<br>$$<br>无论是桶形畸变还是枕形畸变，由于他们都是随着与中心之间的距离增加而增加，因此可以使用一个<strong>多项式函数</strong>来描述畸变前后的像素坐标变化。</p><p>这个公式中，对于畸变较小的图像中心区域，畸变主要是$k_1$在起作用；而对于畸变较大的边缘区域，主要是$k_2$在起作用。一般的普通摄像头用这两个系数就已经可以很好地纠正径向畸变了，但是对于一部分畸变很大的摄像头，比如说鱼眼镜头等，还需要加入$k_3$畸变项才能比较好的表述畸变情况。</p><h3 id="Tangential-distortion"><a href="#Tangential-distortion" class="headerlink" title="Tangential distortion"></a>Tangential distortion</h3><p><strong>切向畸变</strong>：在机械组装过程中，透镜和成像平面不可能完全平行，这也会使得光线穿过透镜投影到成像面时的位置出现变化；</p><p><img src="/images/cs231a-lecture2/distort1.png"></p><p>一般切向畸变对于二维平面上的坐标(x,y)的影响可以使用如下公式进行表述：<br>$$<br>x_{distorted} = x + 2p_1xy + p_2(r^2+2x^2)<br>\\<br>y_{distorted} = y + p_1(r^2+ 2y^2)+ 2p_2xy<br>$$</p><h3 id="Radial-and-tangential-distortion"><a href="#Radial-and-tangential-distortion" class="headerlink" title="Radial and tangential distortion"></a>Radial and tangential distortion</h3><p>结合上面两种径向畸变和切向畸变的公式，可以得到综合的去畸变公式，也就是说我们通过五个畸变系数就可以确定点在像素平面的正确位置。<br>$$<br>x_{distorted} = x( 1 + k_1 r^2 + k_2 r^4 + k_3 r^6) + 2p_1xy + p_2(r^2+2x^2)<br>\\<br>y_{distorted} = y( 1 + k_1 r^2 + k_2 r^4 + k_3 r^6) + p_1(r^2+ 2y^2)+ 2p_2xy<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 三维视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS231A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读《iMAP：Implicit Mapping and Positioning in Real-Time 》</title>
      <link href="2022/08/31/paper-reading-imap/"/>
      <url>2022/08/31/paper-reading-imap/</url>
      
        <content type="html"><![CDATA[<h1 id="论文阅读《iMAP-Implicit-Mapping-and-Positioning-in-Real-Time-》"><a href="#论文阅读《iMAP-Implicit-Mapping-and-Positioning-in-Real-Time-》" class="headerlink" title="论文阅读《iMAP: Implicit Mapping and Positioning in Real-Time 》"></a>论文阅读《iMAP: Implicit Mapping and Positioning in Real-Time 》</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>我们首次展示了多层感知器 (MLP) 可以作为手持 RGB-D 相机的实时 SLAM 系统中唯一的场景表示。 我们的网络在没有先验数据的情况下进行实时操作训练，构建了一个稠密的、特定场景的隐式 3D 占用和颜色模型，该模型也可立即用于跟踪。</p><p>通过针对实时图像流持续训练神经网络来实现实时 SLAM 需要重大创新。 我们的 iMAP 算法使用关键帧结构和多处理计算流程，采用动态信息引导像素采样提高速度，跟踪频率为 10 Hz，全局地图更新频率为 2 Hz。 与标准稠密 SLAM 技术相比，隐式 MLP 的优势包括具有自动细节控制的高效几何表示以及对未观察区域（例如对象的后表面）的平滑、合理填充。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>用于智能体现设备的实时同步定位和映射 (SLAM) 系统必须逐步构建 3D 世界的表示，以实现定位和场景理解。理想的表示应该精确地编码几何图形，但也应该是高效的，可用的内存容量可以根据场景大小和复杂性自适应地使用； 预测性的，能够合理地估计未直接观察到的区域的形状； 灵活，无需大量训练数据或手动调整即可在新场景下运行。</p><p>隐式神经表示是离线重建的一个有前途的最新进展，它使用多层感知器 (MLP) 将 3D 点映射到占用或颜色，并从头开始对其进行优化以适应特定场景。  MLP 是一种通用的隐式函数逼近器，能够用很少的参数表示可变细节并且没有量化伪影。即使没有事先的训练，网络结构中存在的固有先验也允许它从部分数据中做出稠密的几何估计，并合理地完成未观察到的区域。</p><p>在本文中，我们首次展示了 MLP 可以用作使用手持 RGB-D 相机的实时 SLAM 系统中的唯一场景表示。 我们随机初始化的网络是在实时操作中训练的，我们不需要任何先前的训练数据。 我们的 iMAP 系统设计有关键帧结构和多处理计算流程，让人想起 PTAM 。 在以超过 10 Hz 运行的跟踪过程中，我们将实时 RGB-D 观察与来自 MLP 场景地图的渲染深度和颜色预测对齐。 同时，映射过程选择并维护一组视点跨越场景的历史关键帧，并使用这些关键帧不断训练和改进 MLP，同时联合优化关键帧姿势。</p><p>在跟踪和映射中，我们动态地对信息量最大的 RGB-D 像素进行采样，以减少几何不确定性，实现实时速度。 我们的系统在 Python 中运行，所有优化都是通过单个桌面 CPU/GPU 系统上的标准 PyTorch 框架。</p><p>通过将 SLAM 视为一个持续学习问题，我们实现了一种表示，该表示可以有效地表示具有连续和自适应分辨率的场景，并且具有出色的平滑插值能力以实现完整的、无懈可击的重建（图 1）。 使用大约 10~20 个关键帧和一个只有 1 MB 参数的 MLP，我们可以准确地映射整个房间。 我们的场景表示没有固定的分辨率； 关键帧的分布自动实现高效的多尺度映射。</p><p><img src="/images/paper-reading-iMAP/image-20220830223022639.png" alt="图 1：使用 Azure Kinect RGB-D 摄像头从实时 iMAP 重建房间，显示稠密场景模型、摄像头跟踪和自动关键帧集。"></p><p>我们在各种真实世界序列上展示了我们的系统，并对来自房间规模的副本数据集的 8 个场景进行了详尽的评估和烧蚀分析。 我们表明，与标准稠密 SLAM 系统相比，iMAP 可以进行更完整的场景重建，并且内存占用明显更小。 我们在 TUM RGB-D 数据集上展示了与最先进的 SLAM 系统相比具有竞争力的跟踪性能。</p><p>总而言之，这篇论文的主要贡献是：</p><ul><li>第一个使用隐式神经场景表示并能够联合优化完整 3D 地图和相机姿势的稠密实时 SLAM 系统。</li><li>通过自动关键帧选择和损失引导稀疏主动采样实现实时增量训练隐式场景网络的能力。</li><li>我们提出的SLAM公式的并行实现（完全在PyTorch中多处理），它与手持RGB-D相机联机工作。</li></ul><h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h2><p><strong>视觉 SLAM 系统 Visual SLAM Systems</strong>    用于建模环境的实时视觉 SLAM 系统通常以分层方式构建，其中稀疏表示用于定位，更详细的几何或语义分层。 然而，在这里，我们在“稠密 SLAM”范式中工作，其中统一的稠密场景表示也是相机跟踪的基础。 稠密表示避免了任意抽象，例如关键点，能够以稳健的不变方式进行跟踪和重新定位，并且作为与传感器无关的、统一的、完整的空间表示具有长期吸引力。</p><p>稠密 SLAM 中的一些方法明确表示表面，但需要直接表示体积以实现全面的应用，例如规划。 如果使用固定分辨率，则使用占用或有符号距离函数的体积标准表示在内存方面代价很大。 分层方法更有效，但实现起来很复杂，并且通常只提供小范围的详细信息。 在任何一种情况下，表示都是相当严格的，并且由于它们使用了大量的参数，因此不适合与相机姿势进行联合优化。</p><p>机器学习可以发现密集结构的低维嵌入，从而实现高效、联合优化的表示。  CodeSLAM就是一个例子，但使用深度图视图表示而不是完整的体积 3D。 学习技术也被用于改进密集重建，但需要现有的扫描或先验的训练数据。</p><p><strong>使用 MLP 进行隐式场景表示 Implicit Scene Representation with MLPs</strong>    在利用隐式MLP神经模型进行目标重建、目标压缩、新的视图合成和场景完成方面，场景表示和图形显示取得了很大进展。最近的两篇论文 [35,39] 也探讨了相机姿态优化。但是到目前为止，这些方法被认为是一个离线工具，计算要求是几小时、几天或几周。结果表明，当深度图像可用时，利用引导稀疏采样进行渲染和训练时，这些方法适用于实时SLAM。</p><p><strong>持续学习 Continual Learning</strong>    通过使用单个 MLP 作为主场景模型，我们将实时 SLAM 视为在线持续学习。 一个有效的持续学习系统应该展示可塑性（获取新知识的能力）和稳定性（保留旧知识）。 灾难性遗忘是神经网络的一个众所周知的特性，并且是稳定性的失败，新的经历会覆盖记忆。</p><p>减轻灾难性遗忘的一项工作重点是使用相对权重来保护表示免受新数据的影响。 这让人想起 SLAM 中的经典过滤方法，例如 EKF，值得未来研究。 在对每个单独的任务进行训练后冻结或合并子网络的方法对于 SLAM 来说可能过于简单和离散。</p><p>相反，我们将注意力转向基于重放的持续学习方法，其中先前的知识要么直接存储在缓冲区中，要么压缩在生成模型中。 我们使用一种简单的方法，自动选择关键帧来存储和压缩过去的记忆。 我们在持续运行的地图更新过程中使用这些关键帧的损失引导随机抽样来定期重播和加强先前观察到的场景区域，同时继续通过新的关键帧添加信息。 在 SLAM 术语中，这种方法类似于 PTAM 开创的方法，其中历史关键帧集和重复的全局束调整作为长期场景表示。</p><h2 id="3-iMAP-A-Real-Time-Implicit-SLAM-System"><a href="#3-iMAP-A-Real-Time-Implicit-SLAM-System" class="headerlink" title="3. iMAP: A Real-Time Implicit SLAM System"></a>3. iMAP: A Real-Time Implicit SLAM System</h2><h3 id="3-1-System-Overview"><a href="#3-1-System-Overview" class="headerlink" title="3.1. System Overview"></a>3.1. System Overview</h3><p>图2概述了iMAP的工作原理。使用将3D坐标映射到颜色和体积密度的全连接神经网络$ F_\theta $来表示3D体积图 (第3.2节)。给定相机的姿态，我们可以通过累积来自反向投影射线中的样本的网络查询来渲染像素的颜色和深度 (第3.3节)。</p><p><img src="/images/paper-reading-iMAP/image-20220830225347891.png" alt="图2：iMAP system pipeline."></p><p>我们通过相对于一组稀疏的主动采样测量值（第 3.6 节）逐步优化网络权重和相机位姿，从深度和彩色视频中映射场景。 两个进程同时运行：跟踪（第 3.4 节），它优化当前帧相对于锁定网络的位姿； 和映射（第 3.4 节），它联合优化所选关键帧的网络和相机位姿，根据信息增益增量选择（第 3.5 节）。</p><h3 id="3-2-Implicit-Scene-Neural-Network"><a href="#3-2-Implicit-Scene-Neural-Network" class="headerlink" title="3.2. Implicit Scene Neural Network"></a>3.2. Implicit Scene Neural Network</h3><p>遵循 NeRF 中的网络架构，我们使用具有 4 个特征大小为 256 的隐藏层的 MLP，以及将 3D 坐标$ \mathrm p = (x, y, z) $映射到颜色和体积密度值的两个输出头：$ F_\theta{\mathrm p} = (\mathrm c , \rho)$。 与 NeRF 不同，我们不考虑观察方向，因为我们对镜面反射建模不感兴趣。</p><p>我们应用傅里叶特征网络中提出的高斯位置嵌入将输入 3D 坐标提升到 n 维空间：sin(<strong>Bp</strong>)，其中 <strong>B</strong> 是从具有标准偏差$ \sigma $的正态分布采样的 [n×3] 矩阵。 该嵌入用作 MLP 的输入，也连接到网络的第二个激活层。 从 SIREN [27] 中汲取灵感，我们允许优化嵌入矩阵 <strong>B</strong>，实现为具有正弦激活的单个全连接层。</p><h3 id="3-3-Depth-and-Colour-Rendering"><a href="#3-3-Depth-and-Colour-Rendering" class="headerlink" title="3.3. Depth and Colour Rendering"></a>3.3. Depth and Colour Rendering</h3><p>我们的新可微渲染引擎受 NeRF 和 NodeSLAM 的启发，查询场景网络以从给定视图获取深度和彩色图像。</p><p>给定一个相机位姿$ T_{WC} $和一个像素坐标$ [u, v] $，我们首先反向投影一个归一化的观察方向并将其转换为世界坐标：$ r = T_{WC}K^{−1}[u, v]$，相机内在矩阵$ K $。 我们沿着射线$ \mathrm p_i = d_i\mathrm r $取一组$ N $个样本，具有相应的深度值$ {d_1,····, d_N}$，并在网络中查询颜色和体积密度$ (\mathrm c_i, \rho_i) = F_\theta(\mathrm p_i)$。我们遵循 NeRF 的分层和分层体积采样策略。</p><p>体积密度通过乘以样本间距离$ \delta_i = d_{i+1} - d_i $并通过激活函数$ o_i = 1 - exp(-\rho_i \delta_i) $转换为占用概率。然后每个样本的射线终止概率可以 计算为$\omega_i = o_i \prod_{j = 1}^{i - 1}(1 - o_j)$。 最后，深度和颜色被渲染为期望值：</p><p><img src="/images/paper-reading-iMAP/image-20220830225234185.png"></p><p>我们可以将沿射线的深度方差计算为：</p><p><img src="/images/paper-reading-iMAP/image-20220830225300639.png"></p><h3 id="3-4-Joint-optimisation"><a href="#3-4-Joint-optimisation" class="headerlink" title="3.4. Joint optimisation"></a>3.4. Joint optimisation</h3><p>我们联合优化了隐式场景网络参数$ \theta $和不断增长的$ W $关键帧集的相机姿态，每个关键帧都有相关的颜色和深度测量以及初始姿态估计：${I_i,D_i,T_i}$。</p><p>我们的渲染函数对于这些变量是可微的，因此我们执行迭代优化以最小化每个关键帧中选定数量的渲染像素$ s_i $的几何和光度误差。</p><p>光度损失是渲染和测量颜色值$ e_i^p[u,v] = \left| I_i[u,v] - \hat I_i[u,v] \right| $之间的 L1 范数，用于$ M $个像素样本：</p><p><img src="/images/paper-reading-iMAP/image-20220830225657705.png"></p><p>几何损失测量深度差异$ e_i^g[u,v] = \left| D_i[u,v] - \hat D_i[u,v] \right| $并使用深度方差作为归一化因子，在对象边界等不确定区域降低损失：</p><p><img src="/images/paper-reading-iMAP/image-20220830225809862.png"></p><p>我们将 Adam优化器应用于两个损失的加权和，因子$ \lambda_p $调整赋予光度误差的权重：</p><p><img src="/images/paper-reading-iMAP/image-20220830225854970.png"></p><p><strong>相机追踪 Camera Tracking</strong>    在在线 SLAM 中，接近帧率的摄像机跟踪很重要，因为对较小位移的优化更加稳健。 我们运行一个并行跟踪过程，在使用相同的损失和优化器的同时，以比联合优化高得多的帧速率连续优化最新帧相对于固定场景网络的位姿。 跟踪的姿势初始化在选定关键帧的映射过程中被细化。</p><h3 id="3-5-Keyframe-Selection"><a href="#3-5-Keyframe-Selection" class="headerlink" title="3.5. Keyframe Selection"></a>3.5. Keyframe Selection</h3><p>使用来自视频流的所有图像联合优化网络参数和相机位姿在计算上是不可行的。 然而，由于视频图像中存在巨大的冗余，我们可以用一组稀疏的代表性关键帧来表示一个场景，这些关键帧是根据信息增益增量选择的。 始终选择第一帧来初始化网络并固定世界坐标系。 每次添加新的关键帧时，我们都会锁定我们网络的副本以表示我们在那个时间点的 3D 地图的快照。 随后的帧将根据该副本进行检查，如果它们看到一个显着的新区域，则选择它们。</p><p>为此，我们渲染一组统一的像素样本$ s $并计算归一化深度误差小于阈值$ t_D = 0.1 $的比例$ P $，以测量我们的地图快照已经解释的帧的比例：</p><p><img src="/images/paper-reading-iMAP/image-20220830230036340.png"></p><p>当该比例低于阈值$ P &lt; t_P $（我们将$ t_P $设置为0.65）时，该帧将添加到关键帧集。归一化深度误差会产生自适应关键帧选择，当相机更靠近物体时，需要更高的精度，因此需要更紧密的关键帧。</p><p>在映射过程中接收到的每一帧都用于联合优化几次迭代（10 到 20 次之间），因此我们的关键帧集总是由所选集以及不断变化的最新帧组成。</p><h3 id="3-6-Active-Sampling"><a href="#3-6-Active-Sampling" class="headerlink" title="3.6. Active Sampling"></a>3.6. Active Sampling</h3><p><strong>图像主动采样 Image Active Sampling</strong>    渲染和优化所有图像像素在计算和内存方面代价很大。 我们利用图像规律性在每次迭代中仅渲染和优化一组非常稀疏的随机像素（每张图像 200 个）。 此外，我们使用渲染损失来指导在具有更高细节的信息区域或重建尚不精确的信息区域中的主动采样。</p><p>每次联合优化迭代分为两个阶段。首先，我们采样一组$ s_i $像素，均匀分布在每个关键帧的深度和颜色图像上。这些像素用于更新网络和相机位姿，并计算损失统计。 为此，我们将每张图像划分为 [8×8] 网格，并计算每个正方形区域$ R_j $内的平均损失，其中$ j = {1, 2, · · · , 64} $：</p><p><img src="/images/paper-reading-iMAP/image-20220830230713156.png"></p><p>其中$ r_j = s_i \cap R_j $是从$ R_j $均匀采样的像素。 我们将这些统计数据归一化为概率分布：</p><p><img src="/images/paper-reading-iMAP/image-20220830230837596.png"></p><p>我们使用这个分布对每个区域重新采样一组新的$ n_i \cdot f_i[j] $个均匀样本（$ n_i $是每个关键帧中的总样本），将更多样本分配到具有高损失的区域。 场景网络使用来自活动样本的损失进行更新（在相机跟踪中仅使用统一采样）。 图像主动采样如图 3 所示。</p><p><img src="/images/paper-reading-iMAP/image-20220830230953670.png" alt="图 3：图像主动采样。 左：使用一组均匀样本的几何损失计算整个图像网格的损失分布。 右图：根据损失分布进一步分配活动样本。"></p><p><strong>关键帧主动采样 Keyframe Active Sampling</strong>    在 iMAP 中，我们使用一组选定的关键帧不断优化我们的场景地图，作为记忆库来避免网络遗忘。 我们希望将更多样本分配给具有更高损失的关键帧，因为它们与新探索的、高度详细的或网络开始忘记的区域相关。 我们遵循类似于图像主动采样的过程，并将 ni 个样本分配给每个关键帧，与关键帧之间的损失分布成比例，见图 4。</p><p><strong>有界关键帧选择 Bounded Keyframe Selection</strong>    随着相机移动到新的和未探索的区域，我们的关键帧集不断增长。 为了绑定联合优化计算，我们在每次迭代中选择一个固定数量的关键帧（实时系统中为 3 个），根据损失分布随机采样。 我们总是在联合优化中包含最后一个关键帧和当前实时帧，以组成一个$ W = 5 $不断变化的帧的有界窗口。 参见图 4。</p><p><img src="/images/paper-reading-iMAP/image-20220830231107081-16618741509601.png" alt="图4: 关键帧主动采样。我们在注册的关键帧上保持损耗分布。该分布用于对关键帧 (红色框) 的有界窗口进行采样，并用于在每个关键帧中分配像素样本。"></p><h2 id="4-Experimental-Results"><a href="#4-Experimental-Results" class="headerlink" title="4. Experimental Results"></a>4. Experimental Results</h2><p>通过综合实验，我们评估了 iMAP 的 3D 重建和跟踪，并对设计选择的准确性和速度进行了详细的烧蚀分析。</p><h3 id="4-1-Experimental-Setup"><a href="#4-1-Experimental-Setup" class="headerlink" title="4.1. Experimental Setup"></a>4.1. Experimental Setup</h3><p><strong>数据集</strong>    我们在模拟和真实序列上进行实验。 对于重建评估，我们使用 Replica 数据集，这是对真实房间规模环境的高质量 3D 重建，有 5 个办公室和 3 个公寓。 对于每个 Replica 场景，我们渲染 2000 个 RGB-D 帧的随机轨迹。 对于原始摄像机记录，我们使用手持式 Microsoft Azure Kinect 在各种环境中捕获 RGB-D 视频，并在 TUM RGB-D 数据集上进行测试以评估摄像机跟踪。</p><p><strong>实施细节</strong>    对于所有实验，我们设置以下默认参数：关键帧配准阈值$ t_P = 0.65 $，光度损失加权$ \lambda_p = 5 $，关键帧窗口大小$ W = 5 $，像素样本$ |s_i|  = 200 $，位置嵌入大小$ m = 93 $和$ \sigma = 25$，以及 32 个粗分类和 12 个细分类用于渲染。  3D 点坐标通过$\frac {1}{10}$归一化以接近 [0, 1] 范围。</p><p>在手持相机的在线操作中，到达处理帧之间的流式图像被丢弃。 对于此处介绍的实验，每个捕获的帧都被处理，以 10 Hz 运行。 如果需要，我们通过在统一体素网格中从网络查询占用值，然后运行行进立方体来恢复网格重建。 网格化用于可视化和评估目的，不构成我们的 SLAM 系统的一部分。</p><h3 id="4-2-Scene-Reconstruction-Evaluation"><a href="#4-2-Scene-Reconstruction-Evaluation" class="headerlink" title="4.2. Scene Reconstruction Evaluation"></a>4.2. Scene Reconstruction Evaluation</h3><p><strong>尺度</strong>    我们从地面实况和重建网格中采样了200000个点，并计算了三个定量指标：精度（cm）：重建网格中的采样点与最近地面实况点之间的平均距离；完成度（cm）：采样点与地面真实网格和最近重建点之间的平均距离；和完成率（&lt;5cm%）：重建网格中完成小于5cm的点的百分比。</p><p><img src="/images/paper-reading-iMAP/image-20220830233300102.png" alt="图 5：Replica room-0 的重建和跟踪结果以及注册的关键帧。"></p><p><img src="/images/paper-reading-iMAP/image-20220830233317768.png" alt="图 6：iMAP（左）设法填充未观察到的区域，这些区域可被视为 TSDF 融合中的漏洞（右）。"></p><p>联合优化 3D 地图和相机位姿的能力使我们的系统能够构建完整的全局连贯场景重建，如图 1 和 7 所示，以及准确的相机跟踪，如图 5 所示。iMAP 的鲁棒性和多功能性 通过图 9 和 8 中的重建，在各种真实世界的录音中得到了证明，这些重建显示了它在从整个房间到小物体和薄结构的规模上工作的能力。</p><p><img src="/images/paper-reading-iMAP/image-20220830233059436.png" alt="图 7：副本重建，突出显示 iMAP 如何填充未观察到的区域，这些区域是 TSDF 融合中的白洞。"></p><p><img src="/images/paper-reading-iMAP/image-20220830233041963.png" alt="图 8：使用 Azure Kinect 映射的各种真实场景的对比重建结果。  TDSF 融合结果中的白洞似乎由 iMAP 填充。"></p><p><img src="/images/paper-reading-iMAP/image-20220830233021258.png" alt="图 9：iMAP 在各种现实世界设置中的实时重建结果。"></p><p>我们将iMAP中的场景重建与TSDF fusion进行了比较，后者是基于融合的密集SLAM方法的代表。为了隔离重建，我们使用iMAP生成的摄像机跟踪进行TSDF fusion。我们的隐式表示最显著的优势是能够在未观察到的区域填充，如图7和图8所示。iMAP在所有8个复制场景中平均实现了4%的高完成率，如表1所示，office-3的完成率提高了11%。</p><p>具有不同配置设置的 iMAP 和 TSDF 融合的内存消耗如表 2 所示。在 TSDF 融合中默认值为 2563 体素分辨率和 iMAP 中的网络宽度为 256 时，我们的系统可以表示内存使用量减少 60 倍的场景，同时获得相似的 重建精度如表 1 所示。</p><p><img src="/images/paper-reading-iMAP/image-20220830233129794.png" alt="表1：8个室内复制场景的重建结果。我们报告了每个场景中最高的完成率，以及相应的准确性和完成率值。"></p><p><img src="/images/paper-reading-iMAP/image-20220830232944402.png" alt="表 2：内存消耗：对于 iMAP 作为网络大小的函数，对于体素分辨率的 TSDF 融合。"></p><p>当使用真实相机时，除了更好地完成外，我们的方法在深度相机无法提供准确读数的地方（如黑色物体（图8d）和反射或透明表面（图6））优于TSDF融合。这种性能可归因于重建的光度损失以及地图网络的插值能力。</p><h3 id="4-3-TUM-Evaluation"><a href="#4-3-TUM-Evaluation" class="headerlink" title="4.3. TUM Evaluation"></a>4.3. TUM Evaluation</h3><p>我们在来自 TUM RGB-D 的三个序列上运行 iMAP。 跟踪 ATE RMSE 如表 3 所示。我们与基于面元的 BAD-SLAM、TSDF 融合 Kintinuous和稀疏 ORB-SLAM2 等最先进的 SLAM 系统进行了比较。 在姿势准确性方面，iMAP 的表现并不优于它们，但在 2 到 6 厘米的误差方面具有竞争力。 网格重建如图 10 所示。在图 11 中，我们强调了 iMAP 如何填充未观察区域中的孔，这与 BAD-SLAM 不同。</p><p><img src="/images/paper-reading-iMAP/image-20220830232831812.png" alt="表 3：在 TUM RGB-D 数据集上以厘米为单位的 ATE RMSE。"></p><p><img src="/images/paper-reading-iMAP/image-20220830232809469.png" alt="图 10：TUM 数据集的 iMAP 重建结果。"></p><p><img src="/images/paper-reading-iMAP/image-20220830232904051.png" alt="图 11：iMAP（顶部）对 BAD-SLAM（底部）的孔填充能力。"></p><h3 id="4-4-Ablative-Analysis"><a href="#4-4-Ablative-Analysis" class="headerlink" title="4.4. Ablative Analysis"></a>4.4. Ablative Analysis</h3><p>我们使用最大的 Replica 场景分析影响我们系统的设计选择：office-2 和三个不同的随机种子。 完成率结果和时序如表 4 所示。我们发现网络$ width = 256 $，关键帧窗口大小限制为$ W = 5 $，每帧 200 像素样本提供了收敛速度和准确性的最佳折衷。我们在图 12 中进一步表明，主动采样比随机采样能够实现更快的精度收敛和更高的场景完成度。</p><p><img src="/images/paper-reading-iMAP/image-20220830232727343.png" alt="表 4：跟踪（6 次迭代）和映射（10 次迭代）的时序结果，在同一 GPU 上同时运行。 默认配置：网络宽度 256，窗口大小 5，每个关键帧 200 个样本。 最后一行：副本 office-2 的完成率。"></p><p>这些设计选择使我们的在线隐式SLAM系统能够以10Hz的频率运行以进行跟踪，以2Hz的频率进行映射。我们的实验证明了随机抽样在优化中的作用，并强调了关键发现，即使用随机变化的信息进行快速迭代比使用密集和缓慢迭代更好。</p><p>将几何和光度损失结合起来，使我们的系统能够从几个关键帧获得全房间尺度的重建；对于表1中的8个复制场景，平均为13。如表5所示，使用更多关键帧对进一步提高场景完成率几乎没有作用。</p><p><img src="/images/paper-reading-iMAP/image-20220830232657552.png" alt="表 5：Replica office-2 中不同选择阈值的关键帧数和完成率结果。"></p><p>隐式场景网络具有在添加高频场景细节之前快速收敛到低频形状的特性。 图 13 显示了来自静态摄像机的网络训练，平均超过 5 个不同的真实场景。 深度损失在一秒钟内降至 5 厘米以下； 在 4 秒内低于 2 厘米； 然后继续缓慢下降。当映射一个新场景时，我们的系统需要几秒钟来进行粗略的重建，并需要几分钟来添加精细的细节。 在图 14 中，我们展示了系统如何从粗略重建开始，并随着网络训练和相机靠近物体而添加细节。 这是 SLAM 中的一个有用属性，因为它使实时跟踪即使在移动到未探索区域时也能正常工作。</p><p><img src="/images/paper-reading-iMAP/image-20220830232622823.png" alt="图 13：达到 5cm、2cm、1cm 和 0.75cm 深度误差分别需要大约 1、4、20、43 秒。"></p><p><img src="/images/paper-reading-iMAP/image-20220830232552221.png" alt="图 14：重建细节的演变。"></p><h2 id="5-Conclusions"><a href="#5-Conclusions" class="headerlink" title="5. Conclusions"></a>5. Conclusions</h2><p>我们将密集 SLAM 视为实时持续学习，并表明 MLP 可以作为实时系统中唯一的场景表示从头开始训练，从而使 RGB-D 相机能够构建和跟踪完整且准确的体积模型 房间规模的场景。 我们方法的实时但长期 SLAM 性能的关键是：并行跟踪和映射、用于快速优化的损失引导像素采样以及智能关键帧选择作为重放以避免网络遗忘。  iMAP 的未来方向包括如何制作更结构化和组合性的表示，以明确地推理场景中的自相似性。</p>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式表示 </tag>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论文阅读《NICE-SLAM：Neural Implicit Scalable Encoding for SLAM》</title>
      <link href="2022/08/30/paper-reading-nice-slam/"/>
      <url>2022/08/30/paper-reading-nice-slam/</url>
      
        <content type="html"><![CDATA[<h1 id="论文阅读《NICE-SLAM-Neural-Implicit-Scalable-Encoding-for-SLAM》"><a href="#论文阅读《NICE-SLAM-Neural-Implicit-Scalable-Encoding-for-SLAM》" class="headerlink" title="论文阅读《NICE-SLAM: Neural Implicit Scalable Encoding for SLAM》"></a>论文阅读《NICE-SLAM: Neural Implicit Scalable Encoding for SLAM》</h1><p><img src="/images/paper-reading-nice-slam/poster_nice-slam_00.png"></p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>神经隐式表征最近在各个领域都显示出了令人鼓舞的结果，包括在同步定位和建图(SLAM)方面的良好进展。然而，现有的方法会产生过度平滑的场景重建，并难以扩展到大型场景。这些限制主要是由于它们简单的全连接网络架构，没有在观测中包含局部信息。在本文中，提出了<strong>NICE-SLAM</strong>，一种通过引入<strong>层次式场景表示（hierarchical scene representation）</strong>来整合多层局部信息的稠密SLAM系统。用预先训练好的几何先验来优化这种表示，可以在大型室内场景上进行稠密重建。与最近的神经隐式SLAM系统相比，我们的方法更具可扩展性、高效和鲁棒性。在5个具有挑战性的数据集上的实验表明，NICE-SLAM在建图和跟踪质量方面都具有竞争性的结果。</p><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><p>稠密视觉SLAM是3D计算机视觉的一个基础问题，在自动驾驶、室内机器人、混合现实等领域有着广泛的应用。为了使SLAM系统在实际应用程序中真正有用，以下属性是必不可少的。<strong>首先</strong>，我们希望SLAM系统能够是实时的。<strong>接下来</strong>，该系统应该有能力对没有观测的区域做出合理的预测。<strong>此外</strong>，该系统应该能够扩展到大型场景。<strong>最后</strong>，对有噪声或观测缺失的情况具有鲁棒性是至关重要的。</p><p>在实时稠密视觉SLAM系统的范围内，近几年RGB-D相机已经引入了许多方法。传统的稠密视觉SLAM系统满足实时需求，可以用于大规模场景，但他们<strong>无法对未观测到的区域做出合理的几何估计</strong>。另一方面，基于学习的SLAM方法获得一定水平的预测能力，因为它们通常在特定任务的数据集上进行训练。此外，<strong>基于学习的方法往往能更好地处理噪声和异常值</strong>。然而，这些方法通常只在具有多个对象的小场景中工作。最近，Sucar等人在实时稠密SLAM系统（称为<strong>iMAP</strong>）中应用了<strong>神经隐式表示（neural implicit representation）</strong>，他们对房间大小的数据集显示了良好的跟踪和建图结果。然而，当扩展到更大的场景时，例如，一个由多个房间组成的公寓，在稠密重建和相机跟踪精度方面都可以观察到显著的性能下降。</p><p>iMAP的关键限制因素源于它使用了一个单一的多层感知器(MLP)来表示整个场景，它只能随着每一个新的、潜在的部分场景而进行全局更新RGB-D观测。相比之下，最近的工作证明，建立基于多级网格特征可以帮助保存几何细节和重建复杂的场景，但这些都是没有实时功能的离线方法。</p><p>在这项工作中，我们试图结合<strong>分层场景表征（hierarchical scene representation）</strong>和<strong>神经隐式表征（neural implicit representation）</strong>的优势，以完成稠密RGB-D SLAM的任务。为此，我们引入了NICE-SLAM，这是一种稠密的RGB-D SLAM系统，可以应用于大规模场景，同时保持预测能力。我们的关键思想是<strong>用层次特征网格来表示场景的几何形状和外观</strong>，并结合在不同空间分辨率下预训练的神经隐式解码器的<strong>归纳偏差（inductive biases）</strong>。通过从占用率和彩色解码器输出中得到的渲染后的深度和彩色图像，我们可以通过最小化<strong>重渲染损失（re-rendering losses）</strong>，只在可视范围内优化特征网格。我们对各种室内RGB-D序列进行了广泛的评估，并证明了我们的方法的可扩展性和预测能力。总的来说，我们做出了以下贡献：</p><ul><li>我们提出了<strong>NICE-SLAM</strong>，一个稠密的RGB-D SLAM系统，对于各种具有挑战性的场景具有实时能力、可扩展性、可预测性以及鲁棒性。</li><li>NICE-SLAM的核心是一个<strong>层次化的、基于网格的神经隐式编码</strong>。与全局神经场景编码相比，这种表示<strong>允许局部更新</strong>，这是针对大规模方法的先决条件。</li><li>我们对各种数据集进行了广泛的评估，从而证明了在建图和跟踪方面的竞争性能。</li></ul><h2 id="2-相关工作"><a href="#2-相关工作" class="headerlink" title="2. 相关工作"></a>2. 相关工作</h2><p><strong>稠密视觉SLAM</strong>。大多数现代的视觉SLAM方法都遵循了Klein等人的开创性工作中引入的整体架构，将任务分解为建图和跟踪。地图表示通常可以分为两类：<strong>以视图为中心（view-centric）</strong>和<strong>以世界为中心（world-centric）</strong>。第一个是<strong>将三维几何图形锚定到特定的关键帧上</strong>，通常在密集的设置中表示为深度图。这类产品早期的例子之一是DTAM。由于其简单性，DTAM已被广泛应用于最近许多基于学习的SLAM系统。例如，DeepV2D在回归深度和姿态估计之间交替，但使用了测试时间优化。BA-Net和DeepFactor通过使用一组基础深度图简化了优化问题。还有一些方法，如CodeSLAM、Scene和NodeSLAM，它们可以优化一个可解码成关键帧或对象深度图的潜在表示。Droid-SLAM使用回归光流来定义几何残差进行细化。TANDEM结合了多视图立体几何和DSO的实时稠密SLAM系统。另一方面，以世界为中心的地图表示将三维几何图形固定在统一的世界坐标中，可以进一步划分为表面（surfels）和体素网格（voxel grids），通常存储占用概率或TSDF值。体素网格已广泛应用于RGB-D SLAM，例如Kinect-Fusion。在我们提出的管道中，我们也<strong>采用了体素网格表示</strong>。与以前的SLAM方法相比，我们存储几何的隐式潜在编码，并在建图过程中直接优化它们。这种更丰富的表示方式允许我们在较低的网格分辨率下实现更精确的几何图形。</p><p><strong>神经隐式表示</strong>。最近，神经隐式表示在对象几何表示、场景补全、新视图合成还有生成模型方面显示出了很好的结果。最近的几篇论文试图用RGB-(D)输入来预测场景级的几何形状，但它们都假设了给定的相机姿态。另一组工作解决了相机姿态优化的问题，但它们需要一个相当长的优化过程，这并<strong>不适合实时应用</strong>。与我们的方法最相关的工作是<strong>iMAP</strong>。给定一个RGB-D序列，他们引入了一个实时稠密SLAM系统，该系统使用一个单一的多层感知器(MLP)来紧凑地表示完整的场景。然而，由于<strong>单个MLP多层感知机模型容量有限，iMAP不能产生详细的场景几何形状和精确的摄像机跟踪，特别是对于较大的场景</strong>。相比之下，我们提供了一个类似于iMAP的可扩展的解决方案，它结合了可学习的潜在嵌入和一个预先训练的连续隐式解码器。通过这种方式，我们的方法可以重建复杂的几何形状和为更大的室内场景预测详细的纹理，同时保持更少的计算和更快的收敛。值得注意的是，有的工作还将传统的网格结构与学习到的特征表示结合起来，以实现可扩展性，但它们都不是实时的。此外，DI-Fusion也优化了给定RGB-D序列的特征网格，但它们的重建通常包含孔洞，它们的相机跟踪对纯表面渲染损失没有鲁棒性。</p><h2 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h2><p>我们在图2中概述了我们的方法。我们使用四个特征网格及其相应的解码器来表示场景几何结构和外观（第3.1节）。我们使用估计的cam-era校准来跟踪每个像素的观察光线。通过沿观察光线采样点并查询网络，我们可以渲染该光线的深度和颜色值（第3.2节）。通过最小化深度和颜色的重新渲染损失，我们能够以交替方式（第3.3节）优化选定关键帧（第3-4节）的相机姿态和场景几何体。</p><p><img src="/images/paper-reading-nice-slam/image-20220830095757113.png" alt="图2. 系统概述。方法以RGB-D图像流作为输入，并输出相机姿态和学习到的分层特征网格形式的场景表示。从右到左的pipeline可解释为一个生成模型，它从给定的场景表示和相机姿态中呈现深度和彩色图像。在测试时，我们通过通过可微分渲染器（从左到右）反向传播图像和深度重建损失，通过求解逆问题来估计场景表示和相机姿态。这两个实体都在交替优化中进行估计：映射：反向传播仅更新分层场景表示；跟踪：反向传播仅更新相机姿势。为了更好的可读性，我们将几何编码的精细比例网格与大小相同的颜色网格连接起来，并将其显示为具有两个属性（红色和橙色）的一个网格。"></p><h3 id="3-1-分层场景表示-Hierarchical-Scene-Representation"><a href="#3-1-分层场景表示-Hierarchical-Scene-Representation" class="headerlink" title="3.1 分层场景表示 Hierarchical Scene Representation"></a>3.1 分层场景表示 Hierarchical Scene Representation</h3><p>我们现在介绍了我们的分层场景表示，它结合了多层次网格特征和预先训练的解码器的占用预测。该几何图形被编码到三个特征网格$\phi_\theta^l$中，对应的MLP多层感知机解码 $f^l $，其中$ l \in  \{ 0 , 1 , 2  \}  $指的是<strong>粗糙层（coarse）、中间层（mid-level）以及精细层（fine-level）</strong>场景细节。此外，我们也有一个单独的特征网格$ \psi_\omega $以及解码器$ g_\omega $去建模场景外观。这里$ \theta $和$ \omega $分别指的是几何和颜色的优化参数，比如，网格中的特征以及颜色解码器中的权重。</p><p><strong>中间层（Mid-level）和精细层( Fine-level )几何表示</strong>。观测的场景几何是表示在中间层和精细层特征网格中的。在重建过程中，我们以一种从粗到细的方式使用这两个网格，首先通过优化中层特征网格来重建几何结构，然后使用精细级进行细化。在实现中，我们使用边长分别为32cm和16cm的体素网格，除了TUM RGBD（16cm和8cm）外。对于中间层几何表示，这些特征被使用相关的MLP多层感知机直接解码为占用概率值$ f^1 $。对于任何点$ \mathrm p \in \mathbb{R}^3 $，我们可以得到占用概率值为</p><p><img src="/images/paper-reading-nice-slam/image-20220830103457027.png"></p><p>其中$ \phi_\theta^1(\mathrm p) $表示特征网格在点$ \mathrm p $处进行<strong>三线性插值（tri-linearly interpolated）</strong>。相对低的分辨率允许我们高效的优化网格特征去拟合观测值。为了在场景几何图形中捕捉更小的高频细节，我们以<strong>残差（residual）</strong>的方式添加到<strong>精细层fine-level</strong>的特征中。特别地，精细层特征解码器将相应的中间层特征和精细层特征作为输入，并输出一个来自中间层占用的偏移量，比如：</p><p><img src="/images/paper-reading-nice-slam/image-20220830103443393.png"></p><p>其中，一个点的最终占用值表示如下：</p><p><img src="/images/paper-reading-nice-slam/image-20220830103422480.png"></p><p>注意，我们固定预训练的解码器$ f^1 $和$ f^2 $，并通过完整的优化过程仅优化特征网格$ \phi_\theta^1 $和。我们$ \phi_\theta^2 $证明，这有助于稳定优化和学习一致的几何图形。</p><p><strong>粗糙层（Coarse-level）几何表示。</strong>粗糙层特征网格的目的是捕捉场景的高级几何图形（例如，墙壁、地板等），并独立于中间层和精细层进行优化。粗糙网格的目标是能够预测观测到的几何图形（在中间层/精细层中进行编码）之外的近似占用值，即使每个粗糙体素只有被部分观测。因此，我们使用了一个非常低的分辨率，在实现中它的边长为2米。与中间层网格类似，我们通过插值特征并通过多层感知机直接解码为占用值，比如：</p><p><img src="/images/paper-reading-nice-slam/image-20220830103650838.png"></p><p>在跟踪过程中，粗糙层占用值仅用于预测以前未观测到的场景部分。这种预测的几何形状允许我们跟踪，即使是当当前大部分图像以前是没看到过的。</p><p><strong>预训练特征编码器（Pre-training Feature Decoders）</strong>。在我们的框架中，我们使用三种不同的固定的多层感知机来将网格特征解码为占用值。粗糙和中间层解码器作为ConvONet的一部分进行预训练，它由一个CNN编码器和一个MLP解码器组成。我们使用预测值和真值GT之间的<strong>二进制交叉熵损失（binary cross-entropy）</strong>来训练编码器/解码器。经过训练后，我们只使用多层感知机MLP解码器，因为我们将直接优化特征，以适应我们的重建管道中的观测值。通过这种方式，预先训练好的解码器可以在解码我们优化后的特征时，利用从训练集学习到的<strong>特定于分辨率（resolution-specific）</strong>的先验。</p><p>同样的策略也用于预训练精细层解码器，除了我们只是在输入到解码器之前将中间层特征$ \phi_\theta^1(\mathrm p) $与精细层特征$ \phi_\theta^2(\mathrm p) $连接在一起。</p><p><strong>颜色表示（Color representation）</strong>。虽然我们主要对场景几何形状感兴趣，但我们也对颜色信息进行编码，允许我们渲染RGB图像，从而为跟踪提供了额外的信号。为了在场景中编码颜色信息，我们应用了其它特征网格$ \psi_\omega $和解码器$ g_\omega $：</p><p><img src="/images/paper-reading-nice-slam/image-20220830104042286.png"></p><p>其中，$ \omega $表示在优化过程中的可学习参数，不同于具有较强先验信息的几何结构，我们发现，联合优化颜色特征$ \psi_\omega $和解码器$ g_\omega $可以提高跟踪性能，如表5所示。请注意，与iMAP类似，这可能会导致遗忘问题，而且颜色只在局部保持一致。如果我们想可视化整个场景的颜色，它可以进行全局优化作为后处理步骤。</p><p><strong>网络设计（Network Design）</strong>。对于所有的MLP多层感知机解码器，我们使用了32个和5个全连接块的隐藏特征维度。除了粗糙层的几何表示外，作为MLP解码器的输入之前，我们在点$ \mathrm{p} $处应用了一个可学习的高斯位置编码。我们观察到，这允许发现几何形状和外观的高频细节。</p><h3 id="3-2-深度和颜色渲染-Depth-and-Color-Rendering"><a href="#3-2-深度和颜色渲染-Depth-and-Color-Rendering" class="headerlink" title="3.2 深度和颜色渲染 Depth and Color Rendering"></a>3.2 深度和颜色渲染 Depth and Color Rendering</h3><p>最近受神经辐射场NeRF中体积渲染成功的启发，我们还建议使用一个可微渲染过程，该过程集成了来自3.1小节我们的场景表示中预测占用率和颜色。</p><p>给定相机内参和当前相机的位姿，我们可以计算一个像素坐标的视线朝向。我们首先沿着射线上的$ N_{strat} $个点进行分层采样，并且在深度值附近均匀采样$ N_{imp} $个点，每条射线共采样$  N=N_{strat}+N_{imp} $个点。更正式一点，令$  \mathrm{p}_i  =  \mathrm{o}  + d_i\mathrm{r}  ,  i   \in  \{ 1 , … , N \}  $表示给定相机原点$ \mathrm{o} $的射线$ \mathrm{r} $上的采样点，$ d_i $对应于沿该射线上点$ \mathrm p_i $的深度值。</p><p>对于每个点$ \mathrm p_i $，采用公式(4)、公式（3）、公式（5），我们能分别计算出粗糙层的占用概率值$ o_{\mathrm p_i}^0 $，精细层占用概率值$ o_{\mathrm p_i} $，以及颜色值$ c_{\mathrm p_i} $。我们在点$\mathrm p_i$上建模射线的<strong>终止概率（termination probability）</strong>，在粗糙层上：$\omega_i^c = o_{\mathrm p_i}^0  \prod_{ j = 1 }^{ i - 1 } (1 - o_{\mathrm p_j}^0 ) $，在精细层上：$\omega_i^f = o_{\mathrm p_i}  \prod_{j = 1}^{i - 1} (1 - o_{\mathrm p_j}) $ 。</p><p>最后，对于每条射线，粗糙层和精细层的深度和颜色都可以渲染为：</p><p><img src="/images/paper-reading-nice-slam/image-20220830105607305.png"></p><p>此外，沿着射线我们也计算<strong>深度方差（depth variances）</strong>：</p><p><img src="/images/paper-reading-nice-slam/image-20220830105621987.png"></p><h3 id="3-3-建图和跟踪Mapping-and-Tracking"><a href="#3-3-建图和跟踪Mapping-and-Tracking" class="headerlink" title="3.3 建图和跟踪Mapping and Tracking"></a>3.3 建图和跟踪Mapping and Tracking</h3><p>在本节中，我们将详细提供我们分层场景表示中的场景几何$ \theta $和外观$ \omega $参数，以及相机姿态的优化。</p><p><strong>建图（Mapping）</strong>。为了优化3.1小节中提到的场景表示，我们从当前帧和所选的关键帧中统一采样总M个像素。接下来，我们将以一种分阶段的方式来执行优化以最小化<strong>几何损失（geometric loss）和光度损失（photometric loss）</strong>。</p><p><strong>几何损失</strong>只是在粗糙层和精细层上观测深度和预测深度之间的$ L_1 $损失：</p><p><img src="/images/paper-reading-nice-slam/image-20220830110038114.png"></p><p><strong>光度损失</strong>是$M$个采样像素点上渲染颜色和观测颜色值之间的一个$L_1$损失：</p><p><img src="/images/paper-reading-nice-slam/image-20220830110106917.png"></p><p>在第一阶段，我们只使用公式（8）中的几何损失$ \mathcal L_g^f $来优化中间层的特征网格 $\phi_\theta^1$。接下来，我们共同优化了中间层和精细层的 $\phi_\theta^1$，$\phi_\theta^2$特征，具有相同的精细层的深度损失$ \mathcal L_g^f $。最后，我们进行<strong>局部BA优化，共同优化所有层次的特征网格、颜色解码器以及$K$个选定关键帧的相机外参</strong>$ {\mathrm R_i,\mathrm t_i} $。</p><p><img src="/images/paper-reading-nice-slam/image-20220830110419117.png"></p><p>其中，$ \lambda_p$是损失权重因子。</p><p>这种多阶段优化方案可以更好地收敛，因为更高分辨率的外观和精细层特征可以依赖于来自中间层特征网格的已经细化的几何形状。</p><p>请注意，我们在三个线程中并行化系统以加快优化过程：一个线程用于粗糙层建图，第二个线程用于中间层和精细层几何和颜色优化，第三个线程用于相机跟踪。</p><p><strong>相机跟踪（Camera Tracking）</strong>。除了优化场景表示之外，我们还并行运行相机跟踪来优化当前帧的相机姿态，比如，旋转矩阵和平移向量。最后，我们在当前帧中采样$ M_t $个像素并在公式（9）中应用相同的光度损失，但使用了修改后的几何损失：</p><p><img src="/images/paper-reading-nice-slam/image-20220830110515715.png"></p><p>修正后的损失减小了重建几何中的某些区域，如物体边缘。相机跟踪最终被表述为以下最小化问题：</p><p><img src="/images/paper-reading-nice-slam/image-20220830110533217.png"></p><p>粗糙层的特征网格能够对场景几何图形进行短程预测。当相机移动到以前未观察到的区域时，这种推算出的几何形状为跟踪提供了一个有意义的信号。使其对突然帧丢失或相机快速相机移动更加鲁棒。我们在补充材料中提供了实验内容。</p><p><strong>对动态物体的鲁棒性（Robustness to Dynamic Objects）</strong>。为了使优化在跟踪过程中对动态对象更加鲁棒，我们使用大的深度/颜色重渲染损失来过滤像素。我们从优化中删除那些，公式（12）中损失大于当前帧中所有像素的10倍损失中值的像素。图6显示了一个动态对象被忽略，因为它不在渲染的RGB和深度图像中。请注意，对于这个任务，我们只在建图过程中优化场景表示。在动态环境下联合优化相机参数和场景表示是不重要的，我们把它看作是一个未来有意思的发展方向。</p><h3 id="3-4-关键帧选取-Keyframe-Selection"><a href="#3-4-关键帧选取-Keyframe-Selection" class="headerlink" title="3.4 关键帧选取 Keyframe Selection"></a>3.4 关键帧选取 Keyframe Selection</h3><p>与其他SLAM系统类似，我们使用一组选定的关键帧不断优化我们的分层场景表示。我们按照与iMAP相同的策略，<strong>维护一个全局关键帧列表</strong>，其中我们<strong>根据信息增益逐步添加新的关键帧</strong>。然而，与iMAP相比，我们只包含在优化场景几何图形时，与当前帧有视觉重叠的关键帧。这是可能的，因为我们能够对基于网格的表示进行局部更新，而且我们不会遭受同样的遗忘问题。这种关键帧选择策略不仅确保了当前视图之外的几何图形保持静态，而且还导致了一个非常有效的优化问题，因为每次我们只优化必要的参数。在实际应用中，我们首先随机采样像素，并使用优化的相机姿态反向投影对应的深度。然后，我们将点云投影到全局关键帧列表中的每个关键帧上。从那些有投影点的关键帧中，我们随机选择了$ K−2 $帧。此外，我们还在场景表示优化中包括了最近的关键帧和当前帧，形成总共$ K $个活动帧。关于关键帧选择策略的消融研究（Ablation Study），请参阅第4.4节。</p><h2 id="4-实验"><a href="#4-实验" class="headerlink" title="4. 实验"></a>4. 实验</h2><p>我们在多种数据集上评估我们的SLAM框架，包括真实的和合成的，不同的大小和复杂性。我们还进行了一项全面的消融研究来支持我们的设计选择。</p><h3 id="4-1-实验设置"><a href="#4-1-实验设置" class="headerlink" title="4.1 实验设置"></a>4.1 实验设置</h3><p><strong>数据集Datasets</strong>。我们考虑了5个通用数据集：Replica、ScanNet、TUM RGB-D数据集、Co-Fusion数据集，以及一个有多个房间的自己获取的大公寓。我们遵循TUM RGB-D数据集相同的预处理步骤。</p><p><strong>基准Baselines</strong>。我们将TSDF-Fusion与我们的相机位姿进行了比较，体素网格分辨率为 2563 ，DI-Fusion使用其官方实现，以及我们针对iMAP的重新实现：iMAP∗。我们的重新实现在两个场景重建和相机跟踪中具有与原始iMAP相似的性能。</p><p><strong>度量指标Metrics</strong>。我们同时使用二维和三维的度量值来评估场景的几何图形。对于二维度量，我们评估了来自重建网格和GT真值网格的1000个随机采样的深度图上的L1损失。为了进行公平的比较，我们在计算平均L1损失之前，将双边求解器应用于DI-Fusion和TSDF-Fusion来填充深度孔洞。对于3D指标，我们遵循iMAP论文的做法，并考虑精度Accuracy[cm]、完成Completion[cm]和完成率[&lt;5cm%]，除了我们删除了不在任何相机的观察障碍内的不可见区域。对于相机跟踪的评估，我们使用了ATE RMSE。如果没有另外指定，在默认情况下，我们将报告5次运行的平均结果。</p><p><strong>实现细节Implementation Details</strong>。我们在一台拥有3.80GHz Intel i7-10700K CPU与NVIDIA RTX 3090 GPU的台式电脑上运行我们的SLAM系统。在我们所有的实验中，我们使用了射线 $N_{strat}=32$ 和 $N_{imp}=16$ 上的采样点数，光度损失加权$ \lambda_p=0.2 $和$ \lambda_{pt}=0.5 $。对于小规模的合成数据集（Replica和Co-Fusion），我们选择了$ K=5 $个关键帧和分别采样$ M=1000 $和$ M_t=200 $个像素。对于大规模的真实数据集(ScanNet和自捕获场景)，我们使用$ K=10 ， M=5000 ， M_t=1000 $。对于具有挑战性的TUM RGB-D数据集，我们使用了$K=10 ， M=5000 ， M_t=5000$。对于我们重新实现的iMAP∗，我们遵循文献中提到的所有超参数，除了我们将采样像素的数量设置为5000，因为它在重建和跟踪中都有更好的性能。</p><h3 id="4-2-建图和跟踪的评估-Evaluation-of-Mapping-and-Tracking"><a href="#4-2-建图和跟踪的评估-Evaluation-of-Mapping-and-Tracking" class="headerlink" title="4.2 建图和跟踪的评估 Evaluation of Mapping and Tracking"></a>4.2 建图和跟踪的评估 Evaluation of Mapping and Tracking</h3><p><strong>Replica数据集上的评估</strong>。为了评估Replica，我们使用了由iMAP的作者提供的相同的渲染RGB-D序列。通过分层的场景表示，我们的方法能够在有限的迭代中精确地重建几何图形。如<strong>表1</strong>所示，NICE-SLAM在几乎所有指标上都显著优于baseline基准方法，同时保持了合理的内存消耗。定性地说，我们可以从<strong>图3</strong>中看到，我们的方法产生了更清晰的几何形状和更少的伪影。</p><p><img src="/images/paper-reading-nice-slam/image-20220830100300984.png" alt="表1. Replica数据集上的重建结果。iMAP∗表示我们重新实现的iMAP。TSDF-Fusion使用来自NICE-SLAM的相机位姿。每个场景的详细度量标准可以在补充文件中找到。"></p><p><img src="/images/paper-reading-nice-slam/image-20220830100311009.png" alt="图3. Replica数据集上的重建结果。iMAP∗是指我们重新实现的iMAP。"></p><p><strong>TUM RGB-D数据集上的评估</strong>。我们还评估了在小型TUM RGB-D数据集上的相机跟踪性能。如<strong>表2</strong>所示，我们的方法优于iMAP和DI-Fusion，尽管我们的设计更适合大场景。可以注意到，跟踪最好的方法（BAD-SLAM，ORB-SLAM2）仍然优于基于隐式场景表示的方法（iMAP和我们的方法）。然而，我们的方法<strong>显著地减少了这两类方法之间的差距，同时保留了隐式表示的表征优势</strong>。</p><p><img src="/images/paper-reading-nice-slam/image-20220830100359426.png" alt="表2. TUM RGB-D数据集上的相机跟踪结果。 采用ATE RMSE[cm]（↓）作为评价指标。NICE-SLAM减少了使用神经隐式表示的SLAM方法与传统方法之间的差距。我们报告了这个表中所有方法的5次运行中最好的一次。取iMAP、badslam、Kintinuous和ORB-SLAM2的数据。"></p><p><strong>ScanNet数据集上的评估</strong>。我们从ScanNet中选择多个大型场景来基准测试不同方法的可扩展性。对于图4中所示的几何形状，我们可以清楚地注意到，比起TSDF-Fusion、DI-Fusion和iMAP∗，<strong>NICE-SLAM产生了更清晰、更详细的几何形状</strong>。在跟踪方面，我们可以观察到，iMAP∗和DI-Fusion要么完全失败，要么引入了较大的漂移，而我们的方法<strong>成功地重建了整个场景</strong>。在跟踪方面，我们可以观察到，iMAP∗和DI-Fusion要么完全失败，要么引入了较大的漂移，而我们的方法成功地重建了整个场景。从定量上来说，我们的跟踪结果也明显比DI-Fusion和iMAP∗更准确，如<strong>表3</strong>所示。</p><p><img src="/images/paper-reading-nice-slam/image-20220830100510404.png" alt="表3. ScanNet数据集上的相机跟踪结果。我们方法在这个数据集上始终产生更好的结果。采用ATE RMSE（↓）作为评价度量。"></p><p><img src="/images/paper-reading-nice-slam/image-20220830100518979.png" alt="图4. ScanNet数据集上的3D重建和跟踪。 黑色轨迹是来自ScanNet，红色轨迹是本文方法的跟踪结果。我们尝试了iMAP∗的各种超参数，结果最好，但大多较差"></p><p><strong>在更大场景数据集上的评估</strong>。为了评估我们的方法的可扩展性，我们在一个有多个房间的大公寓中捕获了一个序列。<strong>图1</strong>和<strong>图5</strong>显示了使用NICE-SLAM、DI-Fusion和iMAP*获得的重建结果。作为参考，我们还展示了在Open3D中使用离线工具Redwoud的三维重建。我们可以看到，NICE-SLAM与离线方法具有相似的结果，而iMAP∗和DI-FusioN无法重建整个序列。</p><img src="/images/paper-reading-nice-slam/image-20220830100553865.png" alt="图1. 采用NICE-SLAM进行多个房间公寓的三维重建。一个层次化的特征网格联合编码几何图形和颜色信息，并同时用于建图和跟踪。我们描述了最终的面片和相机跟踪轨迹。" style="zoom:50%;"><p><img src="/images/paper-reading-nice-slam/image-20220830100608619.png" alt="图5. 在多房间公寓数据集上的三维重建和跟踪。相机跟踪轨迹用红色显示。iMAP*和DI-Fusion未能重建出整个序列。我们还显示了离线方法的结果作为参考"></p><h3 id="4-3-性能分析-Performance-Analysis"><a href="#4-3-性能分析-Performance-Analysis" class="headerlink" title="4.3 性能分析 Performance Analysis"></a>4.3 性能分析 Performance Analysis</h3><p>除了对不同数据集上的场景重建和相机跟踪的评估外，下面我们还评估了所提出方案的其他特性。</p><p><strong>计算复杂度Computation Complexity</strong>。首先，我们比较了查询一个3D点的颜色和占用率/体积密度所需的浮点操作(FLOPs)的数量，见<strong>表4</strong>。我们的方法只需要iMAP 1/4 的FLOP。值得一提的是，即使在非常大的场景中，我们方法中的流程也保持不变。相比之下，由于iMAP中使用单一MLP，MLP的容量限制可能需要更多的参数，这就导致更多的FLOPS。</p><p><strong>运行时Runtime</strong>。我们还在<strong>表4</strong>中比较了使用相同数量的像素样本（$ M_t=200 $用于跟踪和$ M=1000 $用于建图）。我们可以注意到，我们的方法在跟踪和建图方面比iMAP分别快2倍和3倍。这表明使用浅的多层感知机MLP解码器的特征网格比单一深层MLP的优势。</p><p><img src="/images/paper-reading-nice-slam/image-20220830100739492.png" alt="表4. 计算复杂度与运算时间。我们的场景表示不仅提高了重建和跟踪的质量，而且速度更快。iMAP的运行时取自其论文[47]中的数据。"></p><p><strong>对于动态物体的鲁棒性Robustness to Dynamic Objects</strong>。这里我们考虑包含动态移动对象的Co-Fusion数据集。如<strong>图6</strong>所示，我们的方法在优化过程中正确地识别并忽略了属于动态对象的像素样本，这将导致更好的场景表示建模（参见渲染的RGB和深度）。此外，我们还与iMAP∗在相同序列上进行了相机跟踪比较。我们方法和iMAP∗的ATE RMSE评分分别为<strong>1.6cm</strong>和7.8cm，这清楚地证明了我们对动态对象的鲁棒性。</p><p><strong>几何预测和孔洞填充Geometry Forecast and Hole Filling</strong>。如<strong>图7</strong>所示，由于使用粗糙层场景，我们能够补全未观察到的场景区域。相比之下，由iMAP∗重建的看不见的区域噪声很大，因为在iMAP∗中没有编码场景先验知识。</p><p><img src="/images/paper-reading-nice-slam/image-20220830100816351.png" alt="图6. 对于动态物体的鲁棒性。我们展示了覆盖在图像上的采样像素的中间（左）、渲染的RGB（中间）和渲染的深度（右），以说明处理动态环境的能力。跟踪过程中的掩码像素样本用黑色表示，而使用的像素样本用红色表示。"></p><p><img src="/images/paper-reading-nice-slam/image-20220830100840244.png" alt="图7. 几何预测和空洞填充。白色区域是观测过的区域，青色表示未观测但被预测的区域。由于使用了粗糙层的场景先验，我们的方法比iMAP∗具有更好的预测能力。这反过来也提高了我们的跟踪性能。"></p><h3 id="4-4-消融实验Ablation-Study"><a href="#4-4-消融实验Ablation-Study" class="headerlink" title="4.4 消融实验Ablation Study"></a>4.4 消融实验Ablation Study</h3><p>在本节中，我们将研究我们的分层结构的选择和颜色表示的重要性。</p><p><strong>分层结构Hierarchical Architecture</strong>。<strong>图8</strong>将我们的分层架构与其他两种情况进行比较：a）一个特征网格与我们的精细层表示具有相同的分辨率（只有高分辨率）；b）一个具有中间层分辨率的特征网格（只有低分辨率）。当精细层的表示参与优化时，我们的层次结构可以快速地添加几何细节，这也导致了更好的收敛性。</p><p><strong>局部光束平差 Local BA</strong>。我们在ScanNet上验证了局部捆机调整的有效性。如果我们不联合优化K个关键帧的相机姿态和场景表示（在<strong>表5</strong>中没有局部BA），则相机跟踪不仅精度明显降低，而且可靠性也较差。</p><p><strong>颜色表示Color Representation</strong>。在<strong>表5</strong>中，我们比较了公式（9）中没有光度损失$ \mathcal{L}_p $的方法。这表明，虽然由于有限的优化预算和缺乏样本，我们估计的颜色并不完美点，学习这种颜色表示仍然对精确的相机跟踪起着重要的作用。</p><p><strong>关键帧选取KeyFrame Selection</strong>。我们使用iMAP的关键帧选择策略（表5中的w/iMAP关键帧）来测试我们的方法，其中他们从整个场景中选择关键帧。这对于iMAP是必要的，以防止其简单的多层感知机忘记了之前的几何形状。然而，它也会导致收敛缓慢和不准确的跟踪。</p><p><img src="/images/paper-reading-nice-slam/image-20220830101405391.png" alt="表5. 消融实验。我们研究了局部BA、颜色表示以及我们的关键帧选择策略的有效性。每个场景运行5次，并计算其ATE RMSE的平均值和标准差。我们在ScanNet中报告了6个场景的平均值"></p><p><img src="/images/paper-reading-nice-slam/image-20220830101414155.png" alt="图8. 分层结构消融实验。具有在不同结构的Replica数据集上对单个深度图像的几何优化。为了更平滑，曲线可以更好地可视化。"></p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>我们提出了<strong>NICE-SLAM</strong>，一种稠密视觉SLAM方法，它结合了神经隐式表示的优势和基于层次网格的场景表示的可扩展性。与单个大的多层感知机MLP的场景表示相比，我们的实验证明，我们的表示（浅层的MLPs+多分辨率特征网格）不仅保证了精细的建图和高的跟踪精度，但由于局部场景更新的好处，速度更快和计算更少。此外，我们的网络能够填补小洞，并将场景几何推断到未观察到的区域，从而稳定相机的跟踪。</p><p><strong>局限性Limitations</strong>。该方法的预测能力仅限于粗糙表示的尺度。此外，我们的方法不执行闭环检测，这是一个有趣的未来方向。最终，虽然传统方法缺乏一些特征，但与基于学习的方法相比，仍然存在着性能差距需要去缩小。</p>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式表示 </tag>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Harry Shum &quot;You are what you write&quot;</title>
      <link href="2022/08/29/harry-shum-you-are-what-you-write/"/>
      <url>2022/08/29/harry-shum-you-are-what-you-write/</url>
      
        <content type="html"><![CDATA[<h1 id="Harry-Shum-“You-are-what-you-write”"><a href="#Harry-Shum-“You-are-what-you-write”" class="headerlink" title="Harry Shum “You are what you write”"></a>Harry Shum “You are what you write”</h1><blockquote><p>原文链接：<a href="https://www.linkedin.com/pulse/you-what-write-harry-shum">https://www.linkedin.com/pulse/you-what-write-harry-shum</a></p></blockquote><p>Twitter、PowerPoint、Facebook、Instagram 和短信是否正在侵蚀我们的思考能力？</p><p>中国有句谚语“见文如见人”，字面意思是“读文献，见作者”。如果我们是我们所写的，那么作为一个社会的一员，我们将成为谁？</p><p>最近我坐在一个技术评审中，听着我们的一个评审员拷问正在演讲的工程师：你为什么选择这种设计？为什么该服务显示效果不好？有多少用户会改用这个解决方案？</p><p><strong>演讲者的回答缺乏深度。他似乎没有做足够的严格思考，就是那种你静静地坐下来，筛选研究，思考各种选择，确定你知道什么，不知道什么，以及哪里需要做更多的工作。</strong>我作为一个年轻的研究人员所做的那种思考，当我走捷径的时候，同行们会把我和我的工作拆开。那时，我采用了一种有规律的方法，花几个小时来思考，甚至花更多的时间来思考最困难的部分–把它写下来。</p><p>今天，长篇写作正在被取代。推特被当作对话。PowerPoint将思想浓缩为子弹。文字已经被换成了表情符号和GIF。而我们已经沉迷于这些噪音。<a href="http://www.visualcapitalist.com/happens-internet-minute-2017/">在互联网的一分钟内会发生什么？</a>1600万条文本信息。180万条快照。452,000条推特。1.56亿封电子邮件。谁有时间去思考，更不用说写作了？</p><p>也许我们，在技术行业，已经塑造了这个现实。我们创造了电话、应用程序和24/7连接的世界。我们让社会放下了笔。今天我所做的唯一写作是电子邮件或快速的微信回复。</p><p>因此，现在我担心我们正在失去一个宝贵的工具，它可以帮助我们深入思考，表达我们最真实的一面，并扩展我们周围人的智力。而对于我们技术界的人来说，这尤其令人不安。人工智能的风险比以往任何时候都高。我们面临着巨大的压力，要快速出货，要实现更多、更快，但我们不能以牺牲最高的工程质量为代价来实现这一点。我们必须仔细考虑后果和替代方案。当一辆自动驾驶汽车撞到人时，谁会受到责备？写代码的工程师是司机。谁要对有偏见的人工智能算法负责？创造人工智能的工程师。</p><p>我看到更少的工程师撰写和分享深度思考，但这种深度思考才能给整个行业带来更多<a href="https://www.cnbc.com/2018/01/24/google-engineer-steve-yege-calls-company-100-percent-competitor-focused.html">真正的创新</a>。<strong>我们将如何实现重大的变革性突破而不是增量的里程碑？</strong></p><p><strong>通过写作。因为思考的方式实际上就是写作。</strong></p><p>把笔放在纸上迫使你通过迭代、修改和探索替代方案来发展和完善你的思维。任何能够深入思考的人都可以写出漂亮的代码、鼓舞人心的论文或制定计划，将下一个大事情付诸实施。我鼓励你阅读<a href="https://www.reidhoffman.org/linkedin-pitch-to-greylock/">里德-霍夫曼（Reid Hoffman）对LinkedIn的B轮投资</a>，他在其中分享了帮助他成功的思维。当时，他分享说，一个风险公司的合伙人接触到了大约5000个投稿，更仔细地看了600到800个，做了0到2笔交易。</p><p>写作提供了创造持久人工制品的可能性。我想到了我发表的论文，虽然可能是作为参考材料，但也是经久不衰的。<a href="https://dl.acm.org/citation.cfm?id=344932">Plenoptic Sampling</a>. <a href="https://dl.acm.org/citation.cfm?id=1015719">Lazy Snapping</a>. <a href="https://www.semanticscholar.org/paper/Poisson-matting-Sun-Jia/263b48170776e98a3cf4fbdbdc391d596522c6dc">Poisson Matting</a>. 这些是我的工作对计算机视觉和图形领域的贡献。它们将在我身上生存，如果我幸运的话，甚至可以帮助塑造一两个人的思想。</p><p>我在卡内基梅隆大学最喜欢的一位教授<a href="https://www.ri.cmu.edu/ri-faculty/takeo-kanade/">Takeo Kanade</a>说，<strong>你必须像写侦探小说一样写研究论文。你需要故事、悬念、惊喜和 “啊哈 “来向同行解释你的想法，激励他人做出贡献，推动你的工作和整个领域的发展。</strong></p><p>写作是一个均衡器，可以从整个团队中获得最佳效果。在亚马逊，演讲是用<a href="https://www.linkedin.com/pulse/beauty-amazons-6-pager-brad-porter/">六页纸</a>完成的。会议开始时，每个人都在阅读，然后是对作者的评论和提问。每个人都在相同的环境下工作，内向的人、外向的人和非母语的人都有平等的机会来表达他们的想法。这不是关于演讲者的个性，而是文字。</p><p>归根结底，写作有助于使你成功。<strong>你可能是最聪明的人，有最好的想法，但如果你不能以令人信服的方式传达你的想法，你就不会走远。</strong>在我们的AI+R团队中，有两位工程师以其经常性的写作习惯激励着我，他们是<a href="https://www.linkedin.com/in/bill-ramsey-4571513/">Bill Ramsey</a>和<a href="https://www.linkedin.com/in/ronnyk/">Ronny Kohavi</a>。Bill在微软写了250多篇博文，使我们整个技术社区受益。对于Ronny，你甚至不需要见到他–他那篇被高度引用的A/B测试实验论文说明了一切，他在LinkedIn上发表的文章让整个行业受益。</p><p>当你在读这篇文章时，你可能正在记录你的反对意见：我需要推动结果，所以我需要直接去写代码。我以代码闻名，所以我不需要写论文。我不是native speaker，我用代码说话更好。我不知道该写些什么。我没有时间……但是，为了你自己的成功，为了你公司的成功，为了行业的进步，请把它们放在一边，开始写作。</p><p>我看到有很多机会可以将长篇写作重新纳入工程文化–规划文件、项目建议书、技术LRP、评论文章，以激励我们一起工作，集体创造和培养大的想法和大的思维。</p><p>我最近迈出了第一步，与我的同事Xiaodong He和Di Li一起写了一篇研究论文，<a href="https://arxiv.org/abs/1801.01957">From Eliza to XiaoIce: Challenges and Opportunities with Social Chatbots</a>，这是多年来的第一次，所以请不要评头论足，只有建设性的反馈！</p><p>让我们通过写更多的东西来改写我们的思想领导力和工程质量的标准吧!</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Richard Hamming &quot;You and Your Research&quot;</title>
      <link href="2022/08/29/richard-hamming-you-and-your-research/"/>
      <url>2022/08/29/richard-hamming-you-and-your-research/</url>
      
        <content type="html"><![CDATA[<h1 id="Richard-Hamming-“You-and-Your-Research”"><a href="#Richard-Hamming-“You-and-Your-Research”" class="headerlink" title="Richard Hamming “You and Your Research”"></a>Richard Hamming “You and Your Research”</h1><blockquote><p>原文链接：<a href="https://www.cs.virginia.edu/~robins/YouAndYourResearch.html">https://www.cs.virginia.edu/~robins/YouAndYourResearch.html</a></p><p>中文链接：<a href="https://tieba.baidu.com/p/248718051?red_tag=0886115742">https://tieba.baidu.com/p/248718051?red_tag=0886115742</a></p></blockquote><p>1986年3月7日，Richard Hamming在贝尔通信研究中心给200多名科学家们，做了一次演讲，题目叫做”You and Your Research”。他试图回答下面这样一个问题。</p><blockquote><p><strong>“为什么有的科学家做出了影响深远的重大成果，而大多数其他人的成果都被历史遗忘了？”</strong></p></blockquote><p>这篇演讲非常有名，属于经典文献。不仅对科学工作者有启发意义，每一个从事创造性工作的人，都应该读一下。</p><p>下面是<a href="https://www.ruanyifeng.com/blog/2016/04/you-and-your-research.html">阮一峰</a>的摘录，删除了一些涉及具体的人和事的段落，内容更集中易读，并且为每个部分加上了小标题。</p><h2 id="You-and-Your-Research"><a href="#You-and-Your-Research" class="headerlink" title="You and Your Research"></a>You and Your Research</h2><p>我演讲的题目是”你和你的研究”。我要谈的不是普通的研究，而是重大的研究，就是相当诺贝尔奖那一级别的研究。比如，相对论，香农的信息论，以及其他杰出的理论—-这就是我要讲的。</p><p>1945年，我进入洛斯阿拉莫斯国家实验室，负责计算机方面的事，因此见过费曼、费米、奥本海默等大科学家。我一直问自己这样的问题： “为什么他们做出了这样的成果？”和”我和他们的差别是什么” 。我读了传记、自传，去问他们本人：”你是怎么干起来这样的事的？” 我试着搞清原因，这就是今天要谈的内容。</p><p>为什么这个话题重要？因为你只有一次生命。即使你相信来世，那也没关系，为什么不在今生就做一些重大的事呢。</p><h3 id="一、要有做大事的想法"><a href="#一、要有做大事的想法" class="headerlink" title="一、要有做大事的想法"></a>一、要有做大事的想法</h3><p>首先，你要有干大事的想法。很多人毕生只是例行公事般地从事安全的工作，所以产出有限。就这么简单：如果你要干大事，你必须毫不迟疑地去解决重大难题。</p><p>我遇到费曼时，就知道他肯定能得诺贝尔奖。因为他会从事伟大的工作。不论未来走哪个方向，这个人都会干大事。</p><p>你要跟自己说，往前走，去做大事！</p><h3 id="二、年轻的时候就要有勇气追求答案"><a href="#二、年轻的时候就要有勇气追求答案" class="headerlink" title="二、年轻的时候就要有勇气追求答案"></a>二、年轻的时候就要有勇气追求答案</h3><p>成功科学家的重要品质之一就是勇气。</p><p>一旦你鼓起了勇气，相信自己能解决重要的问题，那么你就行。如果你觉得你不行，几乎肯定你不会去做。伟大的科学家都充满勇气，他们不管周围境况，勇往直前；他们思考、思考、再思考。</p><p>年龄是另一个因素。你要做就得趁年轻。爱因斯坦做事就早，所有的量子理论的大科学家开始做他们的”事”的时候，都早得吓人。大多数数学家、理论物理学家，以及天体物理学家都在他们的早年，作出了我们公认的他们最好的成就。这并不是说他们岁数大了以后，就不能做有益的工作。是我们认为他们最有价值的事是他们年轻的时候所为。另一方面，在音乐、政治和文学方面，通常的情况是，那些我们仰慕的大作品往往出炉较晚。</p><h3 id="三、忍受不确定的状态"><a href="#三、忍受不确定的状态" class="headerlink" title="三、忍受不确定的状态"></a>三、忍受不确定的状态</h3><p>伟大科学家还有另一个性格方面的特点，那就是”似是而非”。大多数人愿意相信世上万物非此即彼，是非分明。大科学家们却能很大程度地容忍”似是而非”。他们对自己的想法非常自信，但是又保持足够的警觉，随时挑出其中的错误和瑕疵。</p><p>如果你过于自信，你将忽视其中的破绽；如果你过分怀疑，你甚至将无从起步。这需要一个良好的平衡。多数大科学家非常清楚为什么他们的理论是真知灼见，同时也知道哪里还有些小毛病。</p><h3 id="四、比别人多努力10"><a href="#四、比别人多努力10" class="headerlink" title="四、比别人多努力10%"></a>四、比别人多努力10%</h3><p>大多数伟大的科学家都有惊人的动力。他们总是比别人投入更多。假设两个人拥有几乎一样的能力，其中一个人比另一个人多干10%，几年后他将多产一倍。</p><p>你知道得越多，就学得越多；你学得越多，就做得越多；你做得越多，机会就越多。</p><h3 id="五、全力投入重要的问题"><a href="#五、全力投入重要的问题" class="headerlink" title="五、全力投入重要的问题"></a>五、全力投入重要的问题</h3><p>如果你找到一件真正重要的事情，就不要让任何别的事情分散你的注意力。</p><p>多数大科学家口袋里约有一二十个大问题，想方设法去攻克。每当他们发现一个新想法出现的时候，你就会听到他们说：”唔，这个与该问题有关。” 他们于是抛开其他一切，全力投入此问题。</p><p>他们的思想是时刻准备着的，看见机会就紧跟其后。当然，很多时候也不能奏效，一个主要的诀窍就是活得长一点。</p><h3 id="六、敞开办公室大门"><a href="#六、敞开办公室大门" class="headerlink" title="六、敞开办公室大门"></a>六、敞开办公室大门</h3><p>另一个性格特点，我一开始没注意到：有人的办公室大门是关着的，另一些人是开着的。</p><p>我观察到，如果关上办公室的门，你今天或明天确实会比别人多干不少的活。但是，十年后就未必了。因为你可能干了不少不值得干的事。那些把门敞开的人，的确受了很多的打扰，但他也不时地获得线索，了解这世界什么更重要。</p><p>我可以说，那些敞开了门干活的人和最终成就了大事的人之间，存在千丝万缕的联系。</p><h3 id="七、做可以成为他人基石的工作"><a href="#七、做可以成为他人基石的工作" class="headerlink" title="七、做可以成为他人基石的工作"></a>七、做可以成为他人基石的工作</h3><p>早年，我在攻克一个又一个难题，成功的多，失败的少。可是，周五解决了一个问题回到家里后，我却并不快活，反而很沮丧。我看到生活就是一个问题接着一个问题又接着另一个问题。</p><p>想了相当长一阵子后，我决定以另一种方式干活：你的工作要成为别人工作的基石！于是别人就会说： “看哪，我站在他的肩膀之上，我看得更远了。”</p><p>科学的本质是积累！我再也不去做相互孤立的问题，除非它能代表某一类问题的共性。我决不再去解决单一的问题。</p><p>你要么让人们在你的成果上有所建树，要么别人不得不把你干的活从头再来复制一遍。</p><h3 id="八、重视推销和表达自己"><a href="#八、重视推销和表达自己" class="headerlink" title="八、重视推销和表达自己"></a>八、重视推销和表达自己</h3><p>做完一件事情还不够，你还得把它”贩卖”出去。</p><p>对于一个科学家而言，推销是一件棘手的事。这很讨厌，你本不该做这事，这世界就该等着，当你做成某件大事时，他们就该赶快出来主动迎接。但是，事与愿违，每个人都忙着他们自己的活。你必须很好地主动介绍，使得他们能把手头的活放在一边，过来瞧瞧你的东西，理解它，然后回过头来说：”是，那玩意不错。” 现实是即使你发表了研究成果，如果读者们把你的文章翻过去，不停下来读它，你就会竹篮打水一场空。</p><p>你得学会写好、写清楚以便人们愿意看；你必须学会发表相当正式的发言；你还必须学会作出非正式的谈话。我们有不少所谓的”后排科学家”。在一个会议上，他们更愿意闭口不谈。他们不愿站在一个炙手可热的会议的中央，在大庭广众之下说：”我们应该做这件事，为了这些原因……” 你必须掌握这种形式的交流，准备发表演说。</p><p>我刚开始做演讲的时候，非常非常紧张，几乎表现出生理上的病态。我意识到，我得学习作演讲，否则整个职业生涯就不会有很好的发展。我决定一定要做一个非常好的演讲，一个真正符合听众需要的演讲，不只针对专业人士，而是针对更广泛的听众。</p><p>现在，我认为，研究要只花50%的时间，另外50%的时间用来表达，这是一个非常大的数字。</p><h3 id="九、阅读方法比数量更重要"><a href="#九、阅读方法比数量更重要" class="headerlink" title="九、阅读方法比数量更重要"></a>九、阅读方法比数量更重要</h3><p>你也不要在图书馆花太多时间，一味追随别人的研究成果。</p><p>贝尔实验室有个同事，一个非常非常聪明的家伙。他老在图书馆里呆着，读所有的东西。如果你想要参考资料，你到他那里去，他就会告诉你所有的参考资料。但我觉得，长此以往，他不会有任何以他命名的成果。他现在已退休，成为了一个副教授。他是很有价值，我对此没有疑问。他写了一些不错的文章登在《物理评论》上，但他没有以他命名的成果，因为他读得太多。如果你成天研究别人怎么做，你就会按别人的老路子思考。</p><p>如果你想要有不同的新思维，你需要去搞清问题，而不是成天靠读书去找答案。这不是可取的方法。</p><p>我的建议是：阅读，但不是靠量，而是靠正确的阅读方法起作用。</p><h3 id="十、重视写书"><a href="#十、重视写书" class="headerlink" title="十、重视写书"></a>十、重视写书</h3><p>短期来看，论文非常重要。但如果你想要一个长期的认可，写书的作用更大，因为我们大多数人需要方向。现今的知识几乎是无穷的，我们需要寻找自己的方向。那些帮助我们融会贯通的、代表重要思想的书，会被后代珍视。</p><p>写论文也是必要的，但我倾向于认为，长期看，那些只写至关重要内容的书更重要。</p><h3 id="十一、远见超出你的能力时，才去做管理"><a href="#十一、远见超出你的能力时，才去做管理" class="headerlink" title="十一、远见超出你的能力时，才去做管理"></a>十一、远见超出你的能力时，才去做管理</h3><p>如果你想成为一名伟大的研究者，就不要成为一个公司的总裁。你得清楚你要什么。</p><p>一天，我到我的老板Bode那里，对他说：”为什么你要当这个部门的头呢？为什么你不去当一名大科学家呢？” 他说：”Hamming， 我有远见，知道贝尔实验室的数学部分要怎样，如果要让这个”远见”得到共识，我就得当上部门的头。”</p><p>当你觉得你想干什么的远见，正好在你的能力范围内，你就应努力获取它。如果有一天你的远见大大超过了你的能力时，你就应该去做管理工作。而且，远见越大，你就应做越大的管理。如果你拥有一个关于整个实验室应该向何处去，或者有关整个贝尔系统，你就得到该去的位子让它实现。你从底层是无法轻易让它实现的。</p><p>这取决于你的目标和对目标的渴望。我选择回避管理工作因为我更希望做我容易应付的事。但这是我的选择，只对我起作用。每个人有权做出自己的选择，保持一个开放的心态。但别试着两样都占。</p><p>（完）</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经验分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NeRF学习笔记（五）：神经隐式SLAM方法</title>
      <link href="2022/08/28/nerf-notes-5/"/>
      <url>2022/08/28/nerf-notes-5/</url>
      
        <content type="html"><![CDATA[<h1 id="NeRF学习笔记（五）：神经隐式SLAM方法"><a href="#NeRF学习笔记（五）：神经隐式SLAM方法" class="headerlink" title="NeRF学习笔记（五）：神经隐式SLAM方法"></a>NeRF学习笔记（五）：神经隐式SLAM方法</h1><h2 id="iMAP-Implicit-Mapping-and-Positioning-in-Real-Time"><a href="#iMAP-Implicit-Mapping-and-Positioning-in-Real-Time" class="headerlink" title="iMAP: Implicit Mapping and Positioning in Real-Time"></a>iMAP: Implicit Mapping and Positioning in Real-Time</h2><h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><p>A multilayer perceptron (MLP) can serve as the only scene representation in a real-time SLAM system for a handheld RGB-D camera.</p><h3 id="Novelty"><a href="#Novelty" class="headerlink" title="Novelty"></a>Novelty</h3><img src="/images/nerf-notes-5/image-20220828142210542.png" style="zoom: 80%;"><h3 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h3><h4 id="System-Overview"><a href="#System-Overview" class="headerlink" title="System Overview"></a>System Overview</h4><p><img src="/images/nerf-notes-5/image-20220828143520145.png"></p><h4 id="Implicit-Scene-Neural-Network"><a href="#Implicit-Scene-Neural-Network" class="headerlink" title="Implicit Scene Neural Network"></a>Implicit Scene Neural Network</h4><p><img src="/images/nerf-notes-5/image-20220828143947957.png"></p><h4 id="Depth-and-Colour-Rendering"><a href="#Depth-and-Colour-Rendering" class="headerlink" title="Depth and Colour Rendering"></a>Depth and Colour Rendering</h4><p><img src="/images/nerf-notes-5/image-20220828144007758.png"></p><h4 id="Joint-optimization-Camera-Tracking"><a href="#Joint-optimization-Camera-Tracking" class="headerlink" title="Joint optimization/Camera Tracking"></a>Joint optimization/Camera Tracking</h4><p><img src="/images/nerf-notes-5/image-20220828144052400.png"></p><h4 id="Keyframe-Selection"><a href="#Keyframe-Selection" class="headerlink" title="Keyframe Selection"></a>Keyframe Selection</h4><p><img src="/images/nerf-notes-5/image-20220828144322859.png"></p><p><img src="/images/nerf-notes-5/image-20220828144339666.png"></p><p>大致的流程如下：</p><ul><li>假设有一个keyframe已经加入了，此时复制网络的参数，作为当前地图的snapshot（就是新增keyframe就更新当前地图的snapshot）；</li><li>然后每次新得到一帧图像，就从当前的snapshot渲染一张depth图（这里不需要是渲染整张图，可以是渲染一部分，得到一个统计规律）；</li><li>根据渲染的pixel samples，和ground truth的pixel相减，观察新观察到的一帧，有百分之多少的区域是已经被之前lock的network表达了；</li><li>如果这个区域并不是很多，说明这一帧有很多新的地方，就应该加入到keyframe list中。</li></ul><h4 id="Active-Sampling"><a href="#Active-Sampling" class="headerlink" title="Active Sampling"></a>Active Sampling</h4><p><img src="/images/nerf-notes-5/image-20220828145010688.png"></p><p>这里的操作是：</p><ul><li>把一张图分成很多的bin（箱子），然后均匀的采样并且渲染出来，观察loss的分布是什么样的。</li><li>之后我们根据loss的分布来分配pixel的数量。如果有的地方loss相对较大，那这些区域就应该更多的优化，可以多sample一些pixel。（从上图就能看出来，loss大的地方，右边小红点也要多一些）</li></ul><p><img src="/images/nerf-notes-5/image-20220828145023433.png"></p><p>这里的操作是：</p><ul><li>每次mapping的时候只选常数个keyframe，比如只选5个keyframe加入到mapping中。</li><li>可以设计更好的机制进行keyframe的选择，比如对每个keyframe都进行一下渲染，然后看看loss的分布是什么样子的。如果有的keyframe的loss比较大，就应该加入到mapping中，loss比较大就说明网络已经忘掉之前学习的keyframe了，我们应当让这些keyframe参与mapping来加强网络的记忆。</li></ul><h3 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h3><h4 id="Scene-Reconstruction-Evaluation"><a href="#Scene-Reconstruction-Evaluation" class="headerlink" title="Scene Reconstruction Evaluation"></a>Scene Reconstruction Evaluation</h4><p><img src="/images/nerf-notes-5/image-20220828151136832.png"></p><p><img src="/images/nerf-notes-5/image-20220828152057866.png"></p><p><img src="/images/nerf-notes-5/image-20220828152155886.png"></p><img src="/images/nerf-notes-5/image-20220828152114392.png" style="zoom:80%;"><p>这里做实验的时候，需要注意TSDF Fusion只是一个mapping的方法，必须给他一个相机位置，而如果给ground truth肯定不公平，所以给了iMAP的相机位置。</p><p>上面的表格中，加粗的数据是最好的，可以发现TSDF Fusion的误差（Acc.）最低，而iMAP的Completion和Completion Rational都是最高的。</p><p>分析：</p><p>对于TSDF Fusion，它确信的地方才会建图，不确定的地方不会建图，所以Accuracy会高一些（Accuracy指的是重建的结果到ground truth的距离），也是因为这个，他的completion会低一些。</p><h4 id="TUM-Evaluation"><a href="#TUM-Evaluation" class="headerlink" title="TUM Evaluation"></a>TUM Evaluation</h4><img src="/images/nerf-notes-5/image-20220828152303765.png" style="zoom:80%;"><p>这里把iMAP和另外三种传统方法作了比较，表中的数据是误差。可以看到iMAP的误差比较大，但是还是说明iMAP能够在TUM这样比较复杂的数据集上面跑通。</p><p><img src="/images/nerf-notes-5/image-20220828152436760.png"></p><p>类似于之前的比较，iMAP能够填补一些没有看到的地方。</p><h4 id="Ablative-Analysis"><a href="#Ablative-Analysis" class="headerlink" title="Ablative Analysis"></a>Ablative Analysis</h4><p><img src="/images/nerf-notes-5/image-20220828152530019.png"></p><p>这里比较了有无Active Sampling的区别。Acc.是误差，越低越好，而Comp. Ratio是越高越好，可以看到Active Sample是能够起到比较好的效果。</p><p><img src="/images/nerf-notes-5/image-20220828153107325.png"></p><p>iMAP这个工作还发现，网络能够很快的把低频的信号收敛的比较好，而高频的细节需要慢慢的加入。</p><p>从上面可以看到，网络可以很快地把Depth Error降到比较小，但如果要继续的降低误差就比较难了。</p><p><img src="/images/nerf-notes-5/image-20220828153259485.png"></p><p>这里展示了网络重建的过程，和上面的图是对应的。可以看到网络能够很快把大致的样子重建出来，然后再慢慢的加细节，比如书柜上面、墙上面的一些细节。</p><h2 id="NICE-SLAM-Neural-Implicit-Scalable-Encoding-for-SLAM"><a href="#NICE-SLAM-Neural-Implicit-Scalable-Encoding-for-SLAM" class="headerlink" title="NICE-SLAM: Neural Implicit Scalable Encoding for SLAM"></a>NICE-SLAM: Neural Implicit Scalable Encoding for SLAM</h2><p>NICE-SLAM可以在<strong>大规模的室内场景</strong>中生成密集的几何与准确的相机跟踪。</p><h3 id="Neural-Implicit-Representations"><a href="#Neural-Implicit-Representations" class="headerlink" title="Neural Implicit Representations"></a>Neural Implicit Representations</h3><p><img src="/images/nerf-notes-5/image-20220828154646170.png"></p><p>神经隐式表达可以捕获高保真的几何</p><p><img src="/images/nerf-notes-5/image-20220828160226134.png"></p><p>也可以渲染很高清晰度的图片</p><p><img src="/images/nerf-notes-5/image-20220828160257679.png"></p><h3 id="iMAP-vs-NICE-SLAM"><a href="#iMAP-vs-NICE-SLAM" class="headerlink" title="iMAP vs NICE-SLAM"></a>iMAP vs NICE-SLAM</h3><p><img src="/images/nerf-notes-5/image-20220828160931068.png"></p><p><img src="/images/nerf-notes-5/image-20220828160941848.png"></p><p>iMAP是通过持续学习的方式同时估计相机位姿和密集的场景几何。但是由于iMAP使用单个MLP作为场景的唯一表达，所以存在以下问题：</p><ul><li>容量有限，当场景变大时，iMAP会失败；</li><li>每个新输入的RGBD帧都可以更新整个MLP，因此会遇到遗忘的问题；</li><li>优化整个MLP非常慢，尤其是当MLP变得非常大时。</li></ul><p><img src="/images/nerf-notes-5/image-20220828161143121.png"></p><p><img src="/images/nerf-notes-5/image-20220828161302418.png"></p><p>相比之下，NICE-SLAM对场景表达做了简单有效的改进，优化分层特征网格，并且结合不同空间层级下训练的微型MLP的归纳偏差，使用这种表达NICE-SLAM在大规模室内场景表示中表现良好，解决了网络遗忘问题，并且保证了更少的运行时间，可以快速收敛。</p><h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><p>如下图，左侧为RGBD序列，NICE-SLAM同时估计相机位姿和场景的三维几何，表示为分层特征网格，如右侧所示。</p><p>首先，根据相机参数随机采样射线，沿每条射线进行三维点的采样，并且使用三线性插值提取每个点的特征（对应图中右下角”Ray -&gt; Point Sampler“部分）；</p><p>接着，使用微型的MLP预测光线上三维点的占用值和颜色值（对应图右侧浅蓝色部分）；</p><p>最后，使用类似NeRF的体渲染方程，沿射线去和，生成深度和彩色图像（对应图中间深蓝色的部分）。</p><p><img src="/images/nerf-notes-5/image-20220828162554601.png"></p><p>我们关注输入和生成图像之间的重渲染损失，由于渲染过程是可微的，能够以交替方式反向求导，最小化重渲染损失。通过优化分层特征网格来实现mapping；通过优化相机参数来实现tracking。</p><p><img src="/images/nerf-notes-5/image-20220828162606024.png"></p><h3 id="MLP-pretraining"><a href="#MLP-pretraining" class="headerlink" title="MLP pretraining"></a>MLP pretraining</h3><p>微型MLP，也就是MLP的解码器，是作为Convolutional Occupancy Networks的一部分进行了预训练。而Convolutional Occupancy Networks由一个CNN的编码器和一个MLP的解码器组成，与其相同，我们在训练的时候也是使用了预测值和真实值之间的交叉熵损失来训练编码器和解码器。</p><p>训练之后，NICE-SLAM使用解码器的MLP，这样在优化特征网格时，预训练的解码器可以利用从训练集中学习到的特定先验来指导优化。</p><p><img src="/images/nerf-notes-5/image-20220828162636320.png"></p><h3 id="More-About-Feature-Grid"><a href="#More-About-Feature-Grid" class="headerlink" title="More About Feature Grid"></a>More About Feature Grid</h3><p><img src="/images/nerf-notes-5/image-20220828231515424.png"></p><p>图中的MLP都是在上面Convolutional Occupancy Networks的框架中训练出来的。</p><p>Coarse Level对应的网格分辨率比较大，单独的出一个Occupancy，单独的渲染一张depth图，只会用在没有被观测到的部分上；</p><p>Mid Level对应的是分辨率中等的特征网格，从中拿到feature和点坐标，过MLP可以得到一个occupancy值；</p><p>Fine Level是在Mid Level的基础上预测一个Δ，它是从更高的分辨率里得到feature，并且把中等分辨率的也考虑进来。最后这两个MLP得到的occupancy叠加起来，得到最后Fine Level的Occupancy；</p><p>Color Leve这里，颜色是需要比较高分辨率的Feature Grid，因为高频信息比较多，然后只从Hierarchical Feature Grid里面取到feature，然后跟点坐标一起过MLP，拿到color prediction；</p><p>最终通过类似NeRF的渲染器得到depth和color图。</p><p>需要注意的是，这里的几何MLP（Coarse Mid Fine Level）都是fixtures的，这样就可以进行局部的更新，因为这样voxel feature是和位置有关的，不会像iMAP一样改变MLP的一个参数就影响整个梯度。</p><h3 id="Depth-and-Color-Rendering"><a href="#Depth-and-Color-Rendering" class="headerlink" title="Depth and Color Rendering"></a>Depth and Color Rendering</h3><img src="/images/nerf-notes-5/image-20220828235737837.png" style="zoom:80%;"><p>需要注意的地方：</p><ul><li>NICE-SLAM没有第二轮采样（NeRF和iMAP都有第二轮采样，第二轮采样根据第一轮采样的结果进行分配），因为本身有depth图，可以在depth图对应的表面附近多采样一些，根据经验将采样间隔定义为5%的depth值（depth值指的是当前光线的深度值）。所以这里的Importance就直接在表面附近采样。</li><li>NICE-SLAM使用了Occupancy作为几何的表达而不是volume density，因为volume density过了marching cube之后结果都不是很好（主讲人这里说有一些工作中有对比图）</li></ul><h3 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h3><img src="/images/nerf-notes-5/image-20220828235802444.png" style="zoom:80%;"><p>需要注意的地方：</p><ul><li><p>Geometric loss指的是渲染出来的depth要和ground truth观测的depth尽可能接近的loss</p></li><li><p>Photometric loss就是渲染出来的颜色也要和ground truth接近的loss</p></li><li><p>Staged optimization</p><ul><li>第一阶段只优化mid-level，使用几何损失</li><li>第二阶段联合优化mid 和 fine level，仍然使用几何损失，因为目前还是没有color图</li><li>第三阶段进行BA操作（Bundle Adjustment），在之前的基础上加上了color图和相机位置</li></ul></li><li><p>总的目标函数是两个几何的loss（一个是coarse level的depth图，一个是mid和fine level加起来渲染出来的depth图），和一个根据颜色的loss</p><p>最小化的待优化变量是所有的网格的参数，由于color的MLP没有找到比较好的训练方式，所以这里把color的MLP参数（w）加到里面去，同时相机的外参（R和t）也要加到里面去</p></li><li><p>NICE-SLAM使用了三个线程。一个线程是coarse level，一个线程跑staged optimization，一个是前端相机的tracking</p></li></ul><h3 id="Tracking"><a href="#Tracking" class="headerlink" title="Tracking"></a>Tracking</h3><img src="/images/nerf-notes-5/image-20220828235819703.png" style="zoom:80%;"><h3 id="保证局部更新的两个系统设计"><a href="#保证局部更新的两个系统设计" class="headerlink" title="保证局部更新的两个系统设计"></a>保证局部更新的两个系统设计</h3><p><img src="/images/nerf-notes-5/image-20220829003247098.png"></p><p>NICE-SLAM基于网格的表示是只支持局部更新并且不会遭受与iMAP相同的遗忘问题，这两个设计不仅可以确保当前视图之外的几何保持静态，同时使得优化非常有效，每次只需要优化必要的参数，即优化当前视锥内的网格特征，不需要把整个网格所有特征放进来优化。</p><p>上图说明了只优化当前视锥内的网格特征的有效性。图中每一个节点都表示一个网格特征，节点是红色的表示可以被优化，蓝色表示不可以被优化。</p><p>左图中，所有的feature都可以被优化，选择一些keyframe，这些keyframe会射出一些射线。假设射线A和B就是目前要进行优化的，射线上面会进行采样，影响到x点的feature，而x点的feature会影响到左图中红色区域。如果有一个射线C，因为射线C没有参与到mapping，所以我们希望射线C渲染出来的结果跟以前一样，但假如x点变了，那么渲染的结果就变了，与我们的希望不符。</p><p>为了解决上面的问题，就只对当前视锥内的网格特征进行优化，如右图所示。这样不仅会保留之前重建的几何形状，并且在优化的过程中也会显著的减小参数的数量。</p><h3 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h3><h4 id="Reconstruction-Results-on-the-Replica-Dataset"><a href="#Reconstruction-Results-on-the-Replica-Dataset" class="headerlink" title="Reconstruction Results on the Replica Dataset"></a>Reconstruction Results on the Replica Dataset</h4><p><img src="/images/nerf-notes-5/image-20220829182217204.png"></p><p><img src="/images/nerf-notes-5/image-20220829182224544.png"></p><p>由于NICE-SLAM使用的更偏显示的表达，所以占用的空间比iMAP高。</p><h4 id="Tracking-results-on-ScanNet"><a href="#Tracking-results-on-ScanNet" class="headerlink" title="Tracking results on ScanNet"></a>Tracking results on ScanNet</h4><p><img src="/images/nerf-notes-5/image-20220829182514836.png"></p><p><img src="/images/nerf-notes-5/image-20220829182524655.png"></p><h4 id="Camera-Tracking-Results-on-TUM-RGB-D"><a href="#Camera-Tracking-Results-on-TUM-RGB-D" class="headerlink" title="Camera Tracking Results on TUM RGB-D"></a>Camera Tracking Results on TUM RGB-D</h4><p><img src="/images/nerf-notes-5/image-20220829182544556.png"></p><h4 id="3D-Reconstruction-and-Tracking-on-a-Multi-room-Apartment"><a href="#3D-Reconstruction-and-Tracking-on-a-Multi-room-Apartment" class="headerlink" title="3D Reconstruction and Tracking on a Multi-room Apartment"></a>3D Reconstruction and Tracking on a Multi-room Apartment</h4><p><img src="/images/nerf-notes-5/image-20220829182641061.png"></p><h4 id="Geometry-Forecast-and-Hole-Filling"><a href="#Geometry-Forecast-and-Hole-Filling" class="headerlink" title="Geometry Forecast and Hole Filling"></a>Geometry Forecast and Hole Filling</h4><p><img src="/images/nerf-notes-5/image-20220829182741121.png"></p><h4 id="Robustness-to-Frame-Loss"><a href="#Robustness-to-Frame-Loss" class="headerlink" title="Robustness to Frame Loss"></a>Robustness to Frame Loss</h4><p><img src="/images/nerf-notes-5/image-20220829182806574.png"></p><h4 id="Computation-Complexity"><a href="#Computation-Complexity" class="headerlink" title="Computation Complexity"></a>Computation Complexity</h4><p><img src="/images/nerf-notes-5/image-20220829182835156.png"></p><h4 id="Ablation-Study-on-Tracking"><a href="#Ablation-Study-on-Tracking" class="headerlink" title="Ablation Study on Tracking"></a>Ablation Study on Tracking</h4><p><img src="/images/nerf-notes-5/image-20220829182847575.png"></p><h4 id="Ablation-Study-on-Hierarchical-Architecture"><a href="#Ablation-Study-on-Hierarchical-Architecture" class="headerlink" title="Ablation Study on Hierarchical Architecture"></a>Ablation Study on Hierarchical Architecture</h4><p><img src="/images/nerf-notes-5/image-20220829182903336.png"></p><h3 id="Future-Work"><a href="#Future-Work" class="headerlink" title="Future Work"></a>Future Work</h3><ul><li>Loop closure </li><li>Global BA </li><li>Adaptively assign voxels</li><li>Extend to outdoor scenes</li><li>Make tracking as accurate as traditional methods </li><li>NICE novel view rendering w/o the need of camera pose</li></ul>]]></content>
      
      
      <categories>
          
          <category> NeRF&amp;3DGS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式表示 </tag>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NeRF学习笔记（四）：基于NeRF的三维场景重建和理解</title>
      <link href="2022/08/24/nerf-notes-4/"/>
      <url>2022/08/24/nerf-notes-4/</url>
      
        <content type="html"><![CDATA[<h1 id="NeRF学习笔记（四）：基于NeRF的三维场景重建和理解"><a href="#NeRF学习笔记（四）：基于NeRF的三维场景重建和理解" class="headerlink" title="NeRF学习笔记（四）：基于NeRF的三维场景重建和理解"></a>NeRF学习笔记（四）：基于NeRF的三维场景重建和理解</h1><h2 id="NeRF的背景和基础原理"><a href="#NeRF的背景和基础原理" class="headerlink" title="NeRF的背景和基础原理"></a>NeRF的背景和基础原理</h2><h3 id="场景表征-Scene-Representations"><a href="#场景表征-Scene-Representations" class="headerlink" title="场景表征 Scene Representations"></a>场景表征 Scene Representations</h3><p><img src="/images/nerf-notes-4/image-20220827135123022.png"></p><h4 id="Classical-Geometric-Scene-Representation"><a href="#Classical-Geometric-Scene-Representation" class="headerlink" title="Classical Geometric Scene Representation"></a>Classical Geometric Scene Representation</h4><p><img src="/images/nerf-notes-4/image-20220827135218953.png"></p><h4 id="Neural-Scene-Representation"><a href="#Neural-Scene-Representation" class="headerlink" title="Neural Scene Representation"></a>Neural Scene Representation</h4><p><img src="/images/nerf-notes-4/image-20220827135331359.png"></p><h3 id="Neural-Radiance-Fields-NeRF"><a href="#Neural-Radiance-Fields-NeRF" class="headerlink" title="Neural Radiance Fields (NeRF)"></a>Neural Radiance Fields (NeRF)</h3><p>NeRF核心是用全连接神经网络来代表一个三维场景，本质上来说NeRF是对于三维空间的连续化的体素（volumetric）表征，而传统的体素表征倾向于将空间离散为一个三维网格，对分辨率有一定的要求。</p><p><img src="/images/nerf-notes-4/image-20220827140644609.png"></p><h2 id="NeRF与场景理解"><a href="#NeRF与场景理解" class="headerlink" title="NeRF与场景理解"></a>NeRF与场景理解</h2><h3 id="2D-Semantic-NeRF"><a href="#2D-Semantic-NeRF" class="headerlink" title="2D: Semantic-NeRF"></a>2D: Semantic-NeRF</h3><p><img src="/images/nerf-notes-4/image-20220827150341608.png"></p><p><img src="/images/nerf-notes-4/image-20220827150606140.png"></p><h4 id="Semantic-NeRF设置"><a href="#Semantic-NeRF设置" class="headerlink" title="Semantic-NeRF设置"></a>Semantic-NeRF设置</h4><p><img src="/images/nerf-notes-4/image-20220827150632151.png"></p><h4 id="Semantic-NeRF网络结构"><a href="#Semantic-NeRF网络结构" class="headerlink" title="Semantic-NeRF网络结构"></a>Semantic-NeRF网络结构</h4><p><img src="/images/nerf-notes-4/image-20220827150654064.png"></p><h4 id="Semantic-NeRF渲染公式与损失函数"><a href="#Semantic-NeRF渲染公式与损失函数" class="headerlink" title="Semantic-NeRF渲染公式与损失函数"></a>Semantic-NeRF渲染公式与损失函数</h4><img src="/images/nerf-notes-4/image-20220827150718117.png" style="zoom:67%;"><img src="/images/nerf-notes-4/image-20220827151927733.png" style="zoom:67%;"><h4 id="Semantic-NeRF应用"><a href="#Semantic-NeRF应用" class="headerlink" title="Semantic-NeRF应用"></a>Semantic-NeRF应用</h4><p><img src="/images/nerf-notes-4/image-20220827151950345.png"></p><h3 id="3D-NeSF"><a href="#3D-NeSF" class="headerlink" title="3D: NeSF"></a>3D: NeSF</h3><p><img src="/images/nerf-notes-4/image-20220827152228233.png"></p><p><strong>NeSF的流程图：</strong></p><p><img src="/images/nerf-notes-4/image-20220827152319237.png"></p><h2 id="基于NeRF的语义SLAM"><a href="#基于NeRF的语义SLAM" class="headerlink" title="基于NeRF的语义SLAM"></a>基于NeRF的语义SLAM</h2><h3 id="iMAP-Implicit-Mapping-and-Positioning-in-Real-Time"><a href="#iMAP-Implicit-Mapping-and-Positioning-in-Real-Time" class="headerlink" title="iMAP: Implicit Mapping and Positioning in Real-Time"></a>iMAP: Implicit Mapping and Positioning in Real-Time</h3><img src="/images/nerf-notes-4/image-20220827153221157.png" style="zoom:80%;"><h4 id="iMAP系统流程"><a href="#iMAP系统流程" class="headerlink" title="iMAP系统流程"></a>iMAP系统流程</h4><p><img src="/images/nerf-notes-4/image-20220827153208785.png"></p><h2 id="NeRF-Semantics亟待解决的问题"><a href="#NeRF-Semantics亟待解决的问题" class="headerlink" title="NeRF+Semantics亟待解决的问题"></a>NeRF+Semantics亟待解决的问题</h2><h3 id="未来工作"><a href="#未来工作" class="headerlink" title="未来工作"></a>未来工作</h3><p><img src="/images/nerf-notes-4/image-20220827153555543.png"></p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p><img src="/images/nerf-notes-4/image-20220827153605058-16615887765601.png"></p>]]></content>
      
      
      <categories>
          
          <category> NeRF&amp;3DGS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NeRF </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NeRF学习笔记（三）：基于NeRF的三维内容生成</title>
      <link href="2022/08/22/nerf-notes-3/"/>
      <url>2022/08/22/nerf-notes-3/</url>
      
        <content type="html"><![CDATA[<h1 id="NeRF学习笔记（三）：基于NeRF的三维内容生成"><a href="#NeRF学习笔记（三）：基于NeRF的三维内容生成" class="headerlink" title="NeRF学习笔记（三）：基于NeRF的三维内容生成"></a>NeRF学习笔记（三）：基于NeRF的三维内容生成</h1><h2 id="Why-NeRF-Succeeded"><a href="#Why-NeRF-Succeeded" class="headerlink" title="Why NeRF Succeeded"></a>Why NeRF Succeeded</h2><h3 id="Why-3D-content-creation-from-images"><a href="#Why-3D-content-creation-from-images" class="headerlink" title="Why 3D content creation from images"></a>Why 3D content creation from images</h3><h4 id="What-are-3D-contents"><a href="#What-are-3D-contents" class="headerlink" title="What are 3D contents"></a>What are 3D contents</h4><p>3D内容是形状和外观模型的组合，可以从不同的视点渲染为2D图像。</p><p><img src="/images/nerf-notes-3/image-20220826145404694.png"></p><h4 id="Rendering-and-inverse-rendering"><a href="#Rendering-and-inverse-rendering" class="headerlink" title="Rendering and inverse rendering"></a>Rendering and inverse rendering</h4><p>计算机图形学主要是假设我们有了这些3D内容，即形状、材质和光照，我们如何设计更高效和高质量的渲染操作来生成图片。</p><p>从计算机视觉的角度来说的话，我们给定了一堆图片，可以是从真实世界中拍摄的图片，也可以是渲染出来的图片，通过反渲染的操作去生成这些3D内容。</p><p>下文主要讨论的是Inverse Rendering技术。</p><p><img src="/images/nerf-notes-3/image-20220826145519227.png"></p><h4 id="3-key-factors-in-inverse-rendering"><a href="#3-key-factors-in-inverse-rendering" class="headerlink" title="3 key factors in inverse rendering"></a>3 key factors in inverse rendering</h4><h5 id="What-shape-representations-to-use"><a href="#What-shape-representations-to-use" class="headerlink" title="What shape representations to use?"></a>What shape representations to use?</h5><p>这部分可以参考<a href="https://immortalqx.github.io/2022/08/17/geometry-notes-1/">几何的隐式表示与显示表示</a>。</p><p>在Inverse  Rendering中，非常关键的就是选择合适的形状表征方式，不同的方式有不同的优化特点，会影响我们反渲染的难度。</p><p><img src="/images/nerf-notes-3/image-20220826150712723.png"></p><h5 id="What-appearance-representations-to-use"><a href="#What-appearance-representations-to-use" class="headerlink" title="What appearance representations to use?"></a>What appearance representations to use?</h5><p>第一种方法，上面的材质纹理贴图是把3D的形状展开成2D的平面，在每个图片上存储对应3D点的性质，比如世界地图就是2D平面上表示了3D的地球；下面的环境光可以用下面这样的全景图来记录。根据材质纹理贴图和环境光就可以渲染</p><p>第二种方法叫做Radiance field（辐射场），早期的时候叫做surface light field（2000年的文章）。 他的定义比较简单，物体中的每个点，从不同的角度看会有不同的内容（颜色）。</p><p>两种方法的对比：</p><ul><li>左边这种方法将材料和光照分开了，而右边没有给材料和光照分开处理。</li><li>左边的方法是非常理想的，很容易编辑材质或者更换光照，但同时又是非常难解决的。</li><li>右边这种方法非常简单，但是很难去编辑，很难把物体放到新的环境去观察它的外观，因为新的环境光照会变化很多，导致物体的外观也变化了。</li></ul><p><img src="/images/nerf-notes-3/image-20220826151123260.png"></p><h5 id="What-rendering-operator-to-use"><a href="#What-rendering-operator-to-use" class="headerlink" title="What rendering operator to use?"></a>What rendering operator to use?</h5><p><img src="/images/nerf-notes-3/image-20220826195207170.png"></p><h3 id="Why-NeRF-is-a-big-thing"><a href="#Why-NeRF-is-a-big-thing" class="headerlink" title="Why NeRF is a big thing"></a>Why NeRF is a big thing</h3><h4 id="Break-NeRF-into-3-components"><a href="#Break-NeRF-into-3-components" class="headerlink" title="Break NeRF into 3 components"></a>Break NeRF into 3 components</h4><p>Shape：NeRF使用Soft opacity field表示形状，这种方式非常soft，类似于把物体表示成一种雾。</p><p>Appearance：NeRF使用Radiance field表示。</p><p>Randering：NeRF渲染的过程中，会在同一条ray上sample很多点，再把这些点结合起来，得到最后这条ray的颜色。（讲座的录屏里面有视频介绍）</p><p><img src="/images/nerf-notes-3/image-20220826201154910.png"></p><p><img src="/images/nerf-notes-3/image-20220826202739889.png"></p><h4 id="Take-home-messages-from-NeRF"><a href="#Take-home-messages-from-NeRF" class="headerlink" title="Take-home messages from NeRF"></a>Take-home messages from NeRF</h4><h5 id="soft-shape"><a href="#soft-shape" class="headerlink" title="soft shape"></a>soft shape</h5><p>NeRF初始化的时候，类似于虚空的状态，什么也没有，然后在优化的过程中，image loss会在需要的位置生成需要的三维模型。</p><p><img src="/images/nerf-notes-3/image-20220826224752952.png"></p><p>与hard geometry相比较：</p><ul><li>不需要object segmentation mask，不会面临genus的问题。对于hard geometry，如果initial shape是一个球，没有object segmentation mask的话，需要把它变成圆环是一个非常困难的操作。</li><li>没有boundary discontinuity，容易做differentiable rendering。</li><li>渲染的代价很大，比如之前一条ray的颜色是一条ray上很多点的颜色结合起来的，而hard geometry里面只需要找到相机的ray与表面的交点即可渲染。</li><li>对于soft shape，目前还没有非常好的工具去编辑它。</li></ul><p><img src="/images/nerf-notes-3/image-20220826224820202.png"></p><p>soft shape相关的新工作：</p><p><img src="/images/nerf-notes-3/image-20220826230027190.png"></p><h5 id="Fourier-features-fixes-the-spectral-bias-of-MLPs"><a href="#Fourier-features-fixes-the-spectral-bias-of-MLPs" class="headerlink" title="Fourier features fixes the spectral bias of MLPs"></a>Fourier features fixes the spectral bias of MLPs</h5><blockquote><p>这里讲座讲的东西没太听懂，有几个英文单词没听过，，，</p><p>不过这个部分NeRF论文里面讲了，就是通过高维变换让MLP可以学习高频函数</p></blockquote><p><img src="/images/nerf-notes-3/image-20220826230343475.png"></p><h5 id="neural-fields-for-inverse-rendering"><a href="#neural-fields-for-inverse-rendering" class="headerlink" title="neural fields for inverse rendering"></a>neural fields for inverse rendering</h5><ul><li><p>Compact：neural fields指的是用神经网络表示信号，这种表征方式特别袖珍。比如每隔NeRF的内容只有10MB</p></li><li><p>Continuous：这种表示方式他的场景没有被discretized，因为它是连续的，可以表示更加高质量的信号</p></li><li><p>Flexible and easy for optimization：这个神经网络本身有一些非常平滑的表示方式，所以很好优化。</p></li></ul><p><img src="/images/nerf-notes-3/image-20220826230843872.png"></p><h2 id="NeRF"><a href="#NeRF" class="headerlink" title="NeRF++"></a>NeRF++</h2><blockquote><p>从这里开始介绍自己的工作了，NeRF++扩展了NeRF到360 capture of unbounded scenes，解决的是NeRF只能够对没有背景的物体进行建模的问题，实现了既能够重建前景，也能够重建背景。</p></blockquote><h3 id="5-Capture-scenarios"><a href="#5-Capture-scenarios" class="headerlink" title="5 Capture scenarios"></a>5 Capture scenarios</h3><ul><li>360 Inward-facing：物体在中间，相机绕着物体拍。对于NeRF，这种情况没有背景，背景是白色的，但这种情况相对于真实情况是很困难的。</li><li>Forward-facing：相机在一个很小的范围内运动，相机基本朝着一个方向，NeRF很擅长这种场景。</li><li>360 Outward-facing：类似于拍摄全景图。</li><li>Unconstrained 360 Outward-facing：类似于360 Outward-facing，但分布更加不规则</li><li>360 capture of unbounded scenes：360 Inward-facing与360 Outward-facing的结合，更贴合实际的情况，去拍摄一个实际的物体，既能够拍摄到处于中央的物体，也会拍摄到背景图。</li></ul><p><img src="/images/nerf-notes-3/image-20220826235634923.png"></p><h3 id="Core-idea"><a href="#Core-idea" class="headerlink" title="Core idea"></a>Core idea</h3><h4 id="Separate-foreground-background"><a href="#Separate-foreground-background" class="headerlink" title="Separate foreground/background"></a>Separate foreground/background</h4><p>NeRF有一种很好的compositional性质，它的一条ray上面sample了很多的点最后再把这些点结合起来得到ray的颜色，这些点在结合的过程中就可以被分成前景和背景。</p><p><img src="/images/nerf-notes-3/image-20220827102747393.png"></p><h4 id="Symmetry-between-360-inward-facing-and-360-outward-facing-captures"><a href="#Symmetry-between-360-inward-facing-and-360-outward-facing-captures" class="headerlink" title="Symmetry between 360 inward-facing and 360 outward-facing captures"></a>Symmetry between 360 inward-facing and 360 outward-facing captures</h4><p>上面还没有解决resolution问题，因为背景很大，ray可能会延申到很远。</p><p>可以画一个球，把场景包围起来，也可以画一个球把相机包围起来，如下图所示。从这里可以看出360 inward-facing 和 360 outward-facing是有对称关系的。</p><p><img src="/images/nerf-notes-3/image-20220827103700850.png"></p><p>可以通过映射的方式，把outward-facing capture这个非常大的场景map成一个Bounded unit cube。</p><p>下面这个球里面，离中心越远的地方，在cube中就更密，而距离中心更近的地方，在cube中更稀疏。</p><p><img src="/images/nerf-notes-3/image-20220827104111339.png"></p><p>如下图所示，对于前景，它的空间没有受到任何的挤压，而对于外面的背景，通过上面的Inverted sphere parametrization方式，映射到了Bounded unit cube里面，空间会受到挤压。</p><p>这样，Foreground和Background都定义在一个unit cube中，就可以用普通的NeRF去model它了。（NeRF就是compositional的，很容易得到结果）</p><p><img src="/images/nerf-notes-3/image-20220827104848368.png"></p><h3 id="NeRF-vs-NeRF"><a href="#NeRF-vs-NeRF" class="headerlink" title="NeRF++ vs NeRF"></a>NeRF++ vs NeRF</h3><ul><li>NeRF faces resolution issue for 360 captures of unbounded scenes</li><li>NeRF++ separates foreground/background modelling, as NeRF is compositional</li><li>NeRF++ uses inverted sphere parametrization to establish symmetry between 360 inward-facing and 360 outward-facing captures </li></ul><h2 id="Future-works"><a href="#Future-works" class="headerlink" title="Future works"></a>Future works</h2><p><img src="/images/nerf-notes-3/image-20220827113930120.png"></p><h2 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h2><p><strong>Q：三维重建与反渲染的关系？</strong></p><p><strong>A：</strong>三维重建广义上也可以说是反渲染，他可以说是反渲染的特例。三维重建更注重shape，没有特别关注Appearance的部分。</p><p><strong>Q：如何理解辐射场？</strong></p><p><strong>A：</strong>TODO</p><p><strong>Q：为什么NeRF只用没有空间信息的MLP？</strong></p><p><strong>A：</strong>TODO</p>]]></content>
      
      
      <categories>
          
          <category> NeRF&amp;3DGS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NeRF </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NeRF学习笔记（二）：论文阅读与思考</title>
      <link href="2022/08/21/nerf-notes-2/"/>
      <url>2022/08/21/nerf-notes-2/</url>
      
        <content type="html"><![CDATA[<h1 id="NeRF学习笔记（二）：论文阅读与思考"><a href="#NeRF学习笔记（二）：论文阅读与思考" class="headerlink" title="NeRF学习笔记（二）：论文阅读与思考"></a>NeRF学习笔记（二）：论文阅读与思考</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p><strong>Q：如何理解稀疏的输入视图集</strong></p><p><strong>A：</strong> a sparse set of input views 稀疏的输入视图集。也就是输入视图并不是连续的，可能就是在若干个方向或者角度拍几张照片，就能合成一个连续的360度环绕的场景</p><p><strong>Q：如何理解volume density</strong></p><p>volume density字面意思是体积密度，实际上理解为<strong>不透明度</strong>会更好，不透明度对应对光的吸收能力，volume density越大，不透明度越高，对光的吸收能力越强。</p><p>这个在后面的公式有所涉及。</p><p><strong>Q：为什么要输入这么五个坐标？</strong></p><p><strong>A：</strong>因为考虑到不同视角上某一点的颜色是不一样的。正因如此，原文用了view-dependent，即某点的颜色是跟视角相关的</p><p><strong>Q：如何理解5D坐标（空间位置$(x，y，z)$和观察方向$(θ，φ)$)？</strong></p><p><strong>A：</strong>作者应该是确定了某个坐标系，空间位置$(x,y,z)$就是被观察物体某个点在这个坐标系中的坐标，而观察方向$(θ，φ)$就是相机指向被观察物体这个点的射线，通过两个角度可以表示三维下的一条射线。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p><strong>Q：什么是MLP网络？</strong></p><p><strong>A：</strong>多层感知器（Multilayer Perceptron，缩写MLP）是一种前向结构的人工神经网络，映射一组输入向量到一组输出向量。MLP可以被看作是一个有向图，由多个的节点层所组成，每一层都全连接到下一层。除了输入节点，每个节点都是一个带有非线性激活函数的神经元（或称处理单元）。一种被称为反向传播算法的监督学习方法常被用来训练MLP。</p><p><strong>Q：还有什么想说的？</strong></p><blockquote><p>这里是搬运的，目前并不了解PINN</p></blockquote><p><strong>A：</strong>这篇论文的思想非常像流体力学的PINN，也是使用一个神经网络拟合某一个对象。PINN是用网络输出尽可能拟合离散点的函数值，而NERF就是用神经网络的输出拟合稀疏的相机拍摄图像。而且，与一般的问题不同，PINN和NERF都是尽可能过拟合标签值，因为它们都是应用于某一个特定的对象，如前者应用于某一个偏微分方程（组），后者应用于某一个场景。但是这引出了另一个问题：网络的泛化性很差，即不能通过微调将网络迁移适应于另一个不同的场景。</p><p>另外有很多优点也是PINN和NERF所共通的。比如，流体力学求解方程的数值方法，需要采样大量的点才能逼近真实解，而且天然的时序特征导致了求解效率的低下；NERF以前的存储离散化体网络也需要耗费大量存储成本。</p><p>更一般地说，PINN全称是physical-informed neural network，NERF本质上也是一种物理理论与神经网络的融合。流体力学的PINN和NERF有天然的近似性自然也就不奇怪了。</p><h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2 Related Work"></a>2 Related Work</h2><p>暂时没有问题</p><h2 id="3-Neural-Radiance-Field-Scene-Representation"><a href="#3-Neural-Radiance-Field-Scene-Representation" class="headerlink" title="3 Neural Radiance Field Scene Representation"></a>3 Neural Radiance Field Scene Representation</h2><p><strong>Q：如何理解”We encourage the representation to be multiview consistent by restricting the network to predict the volume density σ as a function of only the location x, while allowing the RGB color c to be predicted as a function of both location and viewing direction. “即，这里为什么要限制体积密度σ作为位置x的函数，而让颜色c作为位置x和观看方向(θ，φ)的函数？观看方向(θ，φ)为什么会影响多视图的一致性？</strong></p><p><strong>思考：</strong>从论文里面看，它这里的操作是先用8个完全连接层处理输入的3D坐标$(x，y，z)$，得到一个体积密度$σ$和256维的特征向量。然后特征向量和观看方向$(θ，φ)$连接起来，得到一个256+2维的向量，再给到最后的全连接层里面，从而输出与试图相关的颜色$c$。</p><p>这样处理虽然是为了限制体积密度σ作为位置x的函数，但会不会也导致颜色$c$和观察方向$(θ，φ)$的关系不是很大了（毕竟只占了两个维度）？这样的话，如何设计并优化针对特定物理问题的网络？</p><p>在知乎上看到一个很有趣的探讨：我们直觉理解空间点和颜色是没有任何关系的，在一个空间点放什么东西完全是人为确定。但是这篇文章可以通过MLP硬拟合这种关系，其中一个前提是MLP只用于某一特定场景的渲染，只是学习这种拟合关系而不是学会推理。所以，如果要使得网络具备迁移泛化能力，必须解除坐标与RGB这种不合逻辑的映射关系。</p><p><strong>A：</strong>TODO</p><h2 id="4-Volume-Rendering-with-Radiance-Fields"><a href="#4-Volume-Rendering-with-Radiance-Fields" class="headerlink" title="4 Volume Rendering with Radiance Fields"></a>4 Volume Rendering with Radiance Fields</h2><p><strong>Q：如何理解“The volume density σ(x) can be interpreted as the diﬀerential probability of a ray terminating at an inﬁnitesimal particle at location x. ”</strong></p><p><strong>A：</strong>我认为这里应该和<strong>Abstract</strong>部分的问题<strong>“如何理解volume density”</strong>是一样的。这句话翻译过来就是“体积密度$σ(x)$可以解释为一条射线在$x$位置的无穷小粒子处终止的微分概率”，比较拗口，不过很明显关键部分是“射线在某个位置终止的微分概率”。这看起来应该和之前解释的不透明度差不多，光在这里终止（被吸收）的概率越大就说明这里越不透明。而之所以是微分概率，应该是体积密度$σ(x)$表示的只是某个点的不透明率。</p><p><strong>Q：前面定义的网络已经计算出了从某个视角看到的某点颜色$c=(r，g，b)$和体积密度$σ$，为什么这里仍然需要通过公式1把预期颜色$C$计算出来？它们有什么区别？为什么不直接拟合？</strong></p><p><strong>A：</strong>$C$是最终渲染时需要计算的值，$c$是RGB颜色值。拟合的只是空间单点的颜色$c$，只有通过离散积分一条光线上所有采样单点的颜色$c$，才能得到从某个视角看过去的2D图像上某个点的最终渲染颜色。如果硬要拟合整条光线所有点的$C$且使它们一样，那就只是angle-dependent而非view-dependent了，RGB和xyz坐标参数还是有关系的。</p><p><strong>PS：这部分公式1到公式3是连续积分离散化的推导，这是最基本的数值方法，需要好好回顾一下！！！另外一个就是，目前没有学习图形学相关的一些知识，这方面知识欠缺比较多。</strong></p><h2 id="5-Optimizing-a-Neural-Radiance-Field"><a href="#5-Optimizing-a-Neural-Radiance-Field" class="headerlink" title="5 Optimizing a Neural Radiance Field"></a>5 Optimizing a Neural Radiance Field</h2><h3 id="5-1-Positional-encoding"><a href="#5-1-Positional-encoding" class="headerlink" title="5.1 Positional encoding"></a>5.1 Positional encoding</h3><p><strong>Q：为什么第一段说使用高频函数将输入映射到更高维空间，能够更好地拟合包含高频变化的数据？</strong></p><p><strong>思考：</strong>这种数据高频变化的思想不仅仅局限在三维重建中。我觉得可以泛化到具有剧烈域变化的数据集，此时可以对输入数据进行高维映射，以获得对数据更好的表征，更好地实现数据域适应。</p><p><strong>A：</strong>TODO</p><p><strong>Q：如何理解此处的编码函数？</strong></p><p><strong>A：</strong>TODO</p><h3 id="5-2-Hierarchical-volume-sampling"><a href="#5-2-Hierarchical-volume-sampling" class="headerlink" title="5.2 Hierarchical volume sampling"></a>5.2 Hierarchical volume sampling</h3><p><strong>Q：为什么通过同时优化两个网络（粗网络和细网络）可以解决自由空间和遮挡区域被重复采样的问题？</strong></p><p><strong>A：</strong>TODO</p><h3 id="5-3-Implementation-details"><a href="#5-3-Implementation-details" class="headerlink" title="5.3 Implementation details"></a>5.3 Implementation details</h3><p>暂时没有问题</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/542200751">NeRF论文阅读</a></li><li><a href="http://www.liuxiao.org/2021/11/%e8%ae%ba%e6%96%87%e7%ac%94%e8%ae%b0%ef%bc%9anerf-representing-scenes-as-neural-radiance-fields-for-view-synthesis/">论文笔记：NeRF: Representing Scenes as Neural Radiance Fields for View Synthesis</a></li><li><a href="https://zhuanlan.zhihu.com/p/360365941">【NeRF论文笔记】用于视图合成的神经辐射场技术</a></li><li><a href="https://blog.csdn.net/YuhsiHu/article/details/124318473">【论文精读】NeRF中的数学公式推导</a></li><li><a href="https://raymondkevin.top/2021/07/22/neural-radiance-fields-volume-rendering-%E5%85%AC%E5%BC%8F%E5%88%86%E6%9E%90/">Neural Radiance Field’s Volume Rendering 公式分析</a></li><li><a href="https://zh.m.wikipedia.org/zh-hans/%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E5%99%A8">多层感知器</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> NeRF&amp;3DGS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NeRF </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NeRF学习笔记（一）：论文翻译</title>
      <link href="2022/08/19/nerf-notes-1/"/>
      <url>2022/08/19/nerf-notes-1/</url>
      
        <content type="html"><![CDATA[<h1 id="NeRF学习笔记（一）：论文翻译"><a href="#NeRF学习笔记（一）：论文翻译" class="headerlink" title="NeRF学习笔记（一）：论文翻译"></a>NeRF学习笔记（一）：论文翻译</h1><blockquote><p>NeRF: Representing Scenes as Neural Radiance Fields for View Synthesis</p></blockquote><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>我们提出了一种方法，通过使用稀疏的输入视图集来优化底层的连续体积场景函数，来实现合成复杂场景的新视图的最新结果。我们的算法使用一个全连接（非卷积）深度网络表示一个场景，该网络的输入是一个连续的5D坐标（空间位置$(x, y, z)$和观看方向$(\theta, \varphi)$），其输出是该空间位置的体积密度和视图相关的发射辐射。我们通过查询沿着相机光线的5D坐标来合成视图，并使用经典的体积渲染技术将输出的颜色和密度投影到图像中。因为体积渲染是自然可微的，优化我们的表示所需的唯一输入是一组具有已知相机姿态的图像。我们描述了如何有效地优化神经辐射场，以呈现具有复杂的几何形状和外观的场景的逼真的新观点，并展示了优于之前的神经渲染和观点合成工作的结果。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>在这项工作中，我们通过直接优化连续5D场景表示的参数来最小化网络输出值与捕获图像之间的误差，解决了长期存在的视图合成问题。</p><p><img src="/images/nerf-notes-1/image-20220818203438571.png" alt="图1：我们提出了一种方法，从一组输入图像中优化场景的连续5D神经辐射场表示（在任何连续位置的体积密度和取决于视图的颜色）。我们使用来自体积渲染的技术，沿着射线积累这个场景表示的样本，从任何视角渲染场景。在这里，我们可视化了在周围半球上随机捕获的合成Drums场景的100个输入视图，并展示了从我们优化的NeRF表示中渲染的两个新视图。"></p><p>我们将静态场景表示为连续的5D函数，该函数的输出值是空间中每个点$(x，y，z)$在每个方向$(\theta，\varphi)$上发射的辐射度，以及每个点处的密度。该密度类似于可微分的不透明度，代表光线通过$(x，y，z)$时累积的辐射量。我们的方法通过从单一的5D坐标$(x，y，z，\theta，\varphi)$回归到体积密度和与视角有关的RGB颜色，来优化没有任何卷积层的深度完全连接的神经网络，用这个网络来表示该函数。为了渲染NERF，我们：（1）使相机光线穿过场景以生成一组采样的3D点；（2）使用这些点及其对应的2D观察方向作为神经网络的输入以产生一组输出的颜色和密度，以及（3）使用经典立体渲染技术将这些颜色和密度累积到2D图像中。因为这个过程自然是可微的，所以我们可以使用梯度下降来优化这个模型，方法是最小化每个观察图像和从我们的表示呈现的对应视图之间的误差。在多个视图上最小化该误差，鼓励网络通过向包含真实基础场景内容的位置分配高体积密度和准确的颜色来预测场景的连贯模型。图2直观地显示了这个整体管道。</p><p><img src="/images/nerf-notes-1/image-20220818203247431.png" alt="图2：我们的神经辐射场场景表示和可区分的渲染程序的概述。我们通过沿相机射线的5D坐标（位置和观察方向）采样来合成图像（a），将这些位置输入MLP以产生颜色和体积密度（b），并使用体积渲染技术将这些值合成为图像（c）。这个渲染函数是可微分的，所以我们可以通过最小化合成图像和地面真实观察图像之间的残差来优化我们的场景表现（d）。"></p><p>我们发现，NERF的基础实现不能收敛到足够高的分辨率表示，并且在每条相机光线所需的样本数很庞杂。我们通过使用位置编码来变换输入的5D坐标来解决这些问题，该位置编码使得MLP能够表示更高频率的函数，并且我们提出了分层采样过程来减少实现高频率采样过程所需要的数据点。</p><p>我们的方法继承了体积表示的优点：两者都可以表示复杂的真实世界几何和外观，并且非常适合使用基于梯度的优化方法。重要的是，我们的方法克服了在高分辨率下建模复杂场景时，存储离散化体素网格所需要的高昂成本。总的来说，我们的工作可以概括为以下几点：</p><p>（1）一种将具有复杂几何形状和材料的连续场景表示为5D神经辐射场的方法，参数化为基本MLP网络。</p><p>（2）一个基于经典体积渲染技术的可区分的渲染程序，我们用它来优化这些来自标准RGB图像的表示。这包括一个分层采样策略，将MLP的能力分配给具有可见场景内容的空间。</p><p>（3）将每个输入的5D坐标映射到更高的维度空间的位置编码，这使我们能够成功地优化神经辐射场以表示高频的场景内容。</p><p>我们证明了我们所得到的神经辐射场方法在数量和质量上都优于最先进的视图合成方法，包括将神经三维表征适合于场景的作品，以及训练深度卷积网络以预测采样体积表征的作品。据我们所知，本文提出了第一个连续的神经场景表征，能够从自然环境中拍摄的RGB图像中呈现出真实物体和场景的高分辨率逼真的新视图。</p><h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2 Related Work"></a>2 Related Work</h2><p>计算机视觉的一个很有前途的方向是在MLP的权重中编码对象和场景，它直接从三维空间位置映射到形状的隐式表示。然而，到目前为止，这些方法还无法以与使用三角形网格或体素网格等离散表示场景相同的保真度再现具有复杂几何形状的真实场景。在本节中，我们将回顾这两项工作，并将它们与我们的方法进行对比，这增强了神经场景表示的能力，以产生渲染复杂的现实场景的最先进的结果。</p><h3 id="2-1-Neural-3D-shape-representations"><a href="#2-1-Neural-3D-shape-representations" class="headerlink" title="2.1 Neural 3D shape representations"></a>2.1 Neural 3D shape representations</h3><p>最近的工作通过优化将$xyz$坐标映射到有符号的距离函数或占用场的深度网络，研究了连续三维形状作为水平集的隐式表示。然而，这些模型受到其访问地面真实三维几何的需求的限制，通常来自合成的三维形状数据集，如ShapeNet。随后的工作通过制定可微渲染函数，放宽了对地面真实三维形状的要求，允许神经隐式形状表示仅使用二维图像进行优化。Niemeyer等人将曲面表示为三维占用场，并使用数值方法找到每条光线的曲面交点，然后使用隐式微分计算精确的导数。每个射线交叉位置作为神经三维纹理域的输入，该域预测该点的漫反射颜色。Sitzmann等人使用一种不那么直接的神经三维表示，只需在每个连续的三维坐标上输出一个特征向量和RGB颜色，并提出一个由沿着每条射线行进来决定表面的位置的递归神经网络组成的可微呈现函数。</p><p>虽然这些技术可能代表复杂和高分辨率的几何，但到目前为止，它们仅限于低几何复杂度的简单形状，导致过度平滑渲染。我们展示了一种优化网络编码5维辐射场（具有二维视觉相关外观的三维体积）的替代策略，可以代表更高分辨率的几何形状和外观，以呈现复杂场景的逼真的新视图。</p><h3 id="2-2-View-synthesis-and-image-based-rendering"><a href="#2-2-View-synthesis-and-image-based-rendering" class="headerlink" title="2.2 View synthesis and image-based rendering"></a>2.2 View synthesis and image-based rendering</h3><p>计算机视觉和图像社区通过从观察到的图像中预测传统的几何图形和外观表示，在新视图合成的任务上取得了重大进展。一种流行的方法是使用基于网格的场景表示。可微分栅格器或示踪器可以直接优化网格表示，使用梯度下降复制一组输入图像。然而，基于图像重投影的基于梯度的网格优化往往是困难的，可能是由于局部最小值或损失景观的条件较差。此外，该策略要求在优化之前提供一个具有固定拓扑的模板网格作为初始化，这对于无约束的真实场景通常是不可用的。</p><p>另一类方法使用体积表示来解决从一组输入的RGB图像中进行高质量逼真的视点合成的任务。体积方法能够实际地表示复杂的形状和材料，非常适合基于梯度的优化，并且往往比基于网格的方法产生更少的视觉上分散注意力的伪影。早期的体积测量方法使用观察到的图像来直接彩色体素网格。最近，一些方法使用多个场景的大型数据集来训练深度网络，从一组输入图像中预测采样的体积表示，然后使用alpha合成或学习合成在测试时呈现新的视图。其他工作针对每个特定场景优化了 CNN 和采样体素网格的组合，使得 CNN 可以补偿来自低分辨率体素网格的离散化伪影，或者允许预测的体素网格根据输入时间或动画控制而变化。尽管这些体积技术在新视图合成方面取得了令人印象深刻的结果，但由于其离散采样，其扩展到更高分辨率图像的能力受到时间和空间复杂性的根本限制——渲染更高分辨率的图像需要更精细的三维空间采样。我们通过在深度全连接神经网络的参数中编码一个连续的体积来规避这个问题，这不仅产生比之前的体积方法明显更高质量的渲染，而且只需要这些采样体积表示的存储成本的一小部分。</p><h2 id="3-Neural-Radiance-Field-Scene-Representation"><a href="#3-Neural-Radiance-Field-Scene-Representation" class="headerlink" title="3 Neural Radiance Field Scene Representation"></a>3 Neural Radiance Field Scene Representation</h2><p>我们将连续场景表示为5D矢量函数，其输入是3D位置$x=(x，y，z)$和2D观察方向$(\theta，\varphi)$的组合，其输出是从某个视角看到的某点颜色$c=(r，g，b)$和体积密度$\sigma$。实际处理中，我们用MLP网络逼近这种连续的5D场景表示，并优化其权重$\Theta$，从每个输入的5D坐标映射到其相应的体积密度和定向发射颜色。</p><p>为了让表示的多视图一致，我们通过限制网络预测体积密度$\sigma$仅作为位置$x$的函数，同时允许RGB颜色$c$作为位置和观看方向的函数来预测。为了实现这一点，MLP$F_\Theta$首先处理具有8个完全连接层的输入3D坐标$x$（使用ReLU激活和每层256个通道），并输出$\sigma$和一个256维的特征向量。然后，这个特征向量与相机射线的查看方向连接起来，并传递到一个额外的完全连接层（使用ReLU激活和128个通道），输出与视图相关的RGB颜色。</p><p>关于我们的方法如何使用输入查看方向（the input viewing direction）来表示非兰伯式（non-Lambertian）的效果，请参见图3。</p><p><img src="/images/nerf-notes-1/image-20220819170634947-16609183673502.png" alt="图3：一种与视图相关的发射辐射的可视化方法。我们的神经辐射场表示输出RGB颜色作为空间位置x和观察方向d的5D函数。在这里，我们在船舶场景的神经表示中可视化两个空间位置的方向颜色分布。在（a）和（b）中，我们展示了来自两个不同的相机位置的两个固定的3D点的外观：一个在船的一侧（橙色插图），另一个在水面上（蓝色插图）。我们的方法预测了这两个三维点的不断变化的镜面外观，并且在（c）中，我们展示了这种行为如何在观看方向的整个半球连续地推广。"></p><p>如图4所示，在没有视图依赖性的情况下训练的模型（仅$x$作为输入）难以表示镜面反射。</p><p><img src="/images/nerf-notes-1/image-20220819170644501.png" alt="图4：在这里，我们展示了我们的完整模型如何从表示与视图相关的辐射亮度和通过高频位置编码传递输入坐标中获益。移除视图相关性可防止模型在推土机踏板上重新创建镜面反射。删除位置编码会大大降低模型表示高频几何体和纹理的能力，从而导致过度平滑的外观。"></p><h2 id="4-Volume-Rendering-with-Radiance-Fields"><a href="#4-Volume-Rendering-with-Radiance-Fields" class="headerlink" title="4 Volume Rendering with Radiance Fields"></a>4 Volume Rendering with Radiance Fields</h2><p>我们的5D神经辐射场将场景表示为空间中任意点的体积密度和点的颜色。我们使用经典立体渲染的原理来渲染通过场景的任何光线的颜色。体积密度$\sigma(x)$可以解释为一条射线在$x$位置的无穷小粒子处终止的微分概率。</p><p>具有近边界和远边界$t_n$和$t_f$的相机射线$r(t)=o+td$的预期颜色$C(r)$为：</p><p><img src="/images/nerf-notes-1/image-20220819180135061.png"></p><p>函数$T(t)$表示沿射线从$t_n$到$t$的累积透过率，即射线从$t_n$传播到$t$而没有击中任何其他粒子的概率。从我们的连续神经辐射场渲染一个视图，需要估计通过所需的虚拟相机的每个像素跟踪的相机射线的这个积分$C(r)$。</p><p>我们用求积法对这个连续积分进行了数值估计。确定性求交通常用于渲染离散体素网格，它将有效地限制我们的表示的分辨率，因为MLP只能在一个固定的离散位置集上被查询。相反，我们使用分层抽样方法，我们将$[t_n，t_f]$划分为$N$个均匀间隔的间隔，然后从每个间隔中均匀随机抽取一个样本：</p><p><img src="/images/nerf-notes-1/image-20220819180214509.png"></p><p>虽然我们使用一组离散的样本来估计积分，但分层抽样使我们能够表示一个连续的场景表示，因为它导致MLP在优化过程中在连续的位置进行评估。我们使用这些样本来估计$C(r)$与Max讨论的体积渲染审查中的求积规则：</p><p><img src="/images/nerf-notes-1/image-20220819180728845.png"></p><p>其中$\delta_i = t_{i+1}-t_i$是相邻样本之间的距离。从$(c_i，\sigma_i)$区间计算$\hat C(r)$的函数是可微的，并且可以简化为传统的$\alpha$合成，其中$\alpha=1-exp(-\sigma_i\delta_i)$。</p><h2 id="5-Optimizing-a-Neural-Radiance-Field"><a href="#5-Optimizing-a-Neural-Radiance-Field" class="headerlink" title="5 Optimizing a Neural Radiance Field"></a>5 Optimizing a Neural Radiance Field</h2><p>在上一节中，我们描述了将场景建模为神经辐射场并从该表示中渲染新视图所需的核心组件。然而，我们观察到，这些组件不足以实现最好的质量。我们引入了两种改进方法来表示高分辨率复杂场景。第一种是<strong>对输入坐标进行位置编码</strong>，有助于MLP表示高频函数，第二种是<strong>分层采样</strong>，使我们能够有效地对这种高频表示进行采样。</p><h3 id="5-1-Positional-encoding"><a href="#5-1-Positional-encoding" class="headerlink" title="5.1 Positional encoding"></a>5.1 Positional encoding</h3><p>尽管神经网络是通用函数逼近器，但我们发现，让网络$F_\Theta$直接操作$xyz\theta\varphi$输入坐标会导致渲染在表示颜色和几何结构的高频变化方面表现不佳。这与Rahaman等人最近的工作一致，这表明深层网络偏向于学习低频函数。他们还表明，在将输入传递到网络之前，使用高频函数将输入映射到更高维空间，能够更好地拟合包含高频变化的数据。</p><p>我们在神经场景表示的背景下利用了这些发现，将$F_\Theta$重新定义为两个函数$F_\Theta=F’_\Theta◦\gamma$（一个是学习的，一个不是学习的）的组合，这样显著的提高了性能。这里，$\gamma$是从$\mathbb R$到高维空间$\mathbb R^{2L}$的映射，而$F’_\Theta$仍然只是一个正则MLP。形式上，我们使用的编码函数是：</p><p><img src="/images/nerf-notes-1/image-20220819202905807.png"></p><p>该函数$\gamma(·)$分别应用于$x$中的三个坐标值中的每一个（它们被归一化为$[−1,1]$）和笛卡尔观察方向单位向量$d$的三个分量（其通过构造位于$[−1, 1]$）。在我们的实验中，我们将$\gamma(x)$设为$L=10$，$\gamma(d)$设为$L=4$。</p><p>在流行的 Transformer 架构中使用了类似的映射，它被称为位置编码。 然而，Transformers 将它用于不同的目标，即提供序列中令牌的离散位置作为不包含任何顺序概念的架构的输入。 相反，我们使用这些函数将连续输入坐标映射到更高维空间，以使我们的 MLP 更容易逼近更高频率的函数。 </p><h3 id="5-2-Hierarchical-volume-sampling"><a href="#5-2-Hierarchical-volume-sampling" class="headerlink" title="5.2 Hierarchical volume sampling"></a>5.2 Hierarchical volume sampling</h3><p>我们在沿每条相机光线的 $N$ 个查询点处密集评估神经辐射场网络的渲染策略是低效的：对渲染图像没有贡献的自由空间和遮挡区域仍然被重复采样。 我们从体积渲染的早期工作中汲取灵感，并提出了一种分层表示，通过按比例分配样本对最终渲染的预期影响来提高渲染效率。</p><p>我们不只是使用单个网络来表示场景，而是同时优化两个网络：一个“粗”和一个“精细”。我们首先使用分层抽样对一组$N_c$位置进行抽样，并评估这些位置的“粗略”网络，如方程式（2）和（3）中所述。给定这个“粗略”网络的输出，然后我们沿着每条射线产生更有信息量的点采样，其中样本偏向体积的相关部分。为此，我们首先从方程式（3）中重写来自粗网络 $\hat C_c(r)$ 的 alpha 合成颜色作为沿射线的所有采样颜色$c_i$的加权和：</p><p><img src="/images/nerf-notes-1/image-20220819211125521.png"></p><p>将这些权重归一化为$\hat w_i=w_i/\sum^{N_c}_{j=1}w_j$沿射线生成分段常数 PDF。我们使用逆变换采样从该分布中采样第二组$N_f$个位置，在第一组和第二组样本的并集处评估我们的“精细”网络，并使用公式（3），不过是使用所有$N_c+N_f$样本计算光线$\hat C_f(r)$的最终渲染颜色。此过程将更多样本分配给我们希望包含可见内容的区域。这与重要性采样的目标类似，但我们使用采样值作为整个积分域的非均匀离散化，而不是将每个样本视为整个积分的独立概率估计。</p><h3 id="5-3-Implementation-details"><a href="#5-3-Implementation-details" class="headerlink" title="5.3 Implementation details"></a>5.3 Implementation details</h3><p>我们为每个场景优化单独的神经连续体积表示网络。这只需要场景的捕获RGB图像数据集、相应的摄像机姿态和内在参数以及场景边界（我们使用地面真实摄像机姿态、内在参数和合成数据的边界，并使用COLMAP来估计真实数据的这些参数）。在每次优化迭代中，我们从数据集中所有像素的集合中随机采样一批摄像机光线，然后按照第5.2节所述的分层采样，从粗网络中查询$N_c$样本，从细网络中查询$N_c+N_f$样本。然后，我们使用第4节中描述的体渲染过程来渲染两组样本中每个光线的颜色。我们的损失函数是粗略和精细渲染的渲染像素颜色和真实像素颜色之间的总平方误差：</p><p><img src="/images/nerf-notes-1/image-20220819213135323.png"></p><p>其中，$R$是每个批次中的光线集，$C(R)$、$\hat C(R)$和$\hat C_f(r)$分别是光线$R$的基本真值、粗体积预测和细体积预测RGB颜色。请注意，即使最终渲染来自$\hat C_f(r)$，我们也将$\hat C_c(r)$的损失最小化，以便粗网络的权重分布可用于在细网络中分配样本。</p><p>在我们的实验中，我们使用了4096条射线的批量大小，每个射线在粗体积中的$N_c=64$个坐标处采样，在细体积中的$N_f=128$个附加坐标处采样。我们使用Adam优化器，学习速率从$5×10^{-4}$开始，在优化过程中指数衰减到$5×10^{−5}$（其他Adam超参数保留为默认值$β_1=0.9$，$β_2=0.999$，以及 $\epsilon= 10^{−7}$)。在单个NVIDIA V100 GPU上，单个场景的优化通常需要大约100-300k次迭代才能收敛（大约1-2天）。</p><h2 id="6-Results"><a href="#6-Results" class="headerlink" title="6 Results"></a>6 Results</h2><p>我们定量（表 1）和定性（图 5 和 6）表明我们的方法优于以前的工作，并提供广泛的消融研究来验证我们的设计选择（表 2）。 我们敦促读者观看我们的补充视频，以更好地了解我们的方法在渲染新颖视图的平滑路径时对基线方法的显着改进。</p><h3 id="6-1-Datasets"><a href="#6-1-Datasets" class="headerlink" title="6.1 Datasets"></a>6.1 Datasets</h3><h4 id="Synthetic-renderings-of-objects"><a href="#Synthetic-renderings-of-objects" class="headerlink" title="Synthetic renderings of objects"></a>Synthetic renderings of objects</h4><p>我们首先展示了两个物体合成渲染数据集的实验结果（表1，“Diffuse synthetic 360◦” 和“现实合成360”◦”). 深度体素[40]数据集包含四个具有简单几何结构的朗伯对象。从上半球采样的视点以512×512像素渲染每个对象（479作为输入，1000用于测试）。此外，我们还生成了自己的数据集，其中包含八个对象的路径跟踪图像，这些对象具有复杂的几何结构和真实的非朗伯材质。六个是从上半球采样的视点渲染的，两个是从整个球体采样的视点绘制的。我们渲染每个场景的100个视图作为输入，200个视图用于测试，所有视图均为800×800像素。</p><p><img src="/images/nerf-notes-1/image-20220819214247424.png" alt="表1：我们的方法在合成图像和真实图像数据集上的定量性能优于先前的工作。我们报告了PSNR/SSIM（越高越好）和LPIPS（越低越好）。深度体素数据集由4个具有简单几何结构的不同对象组成。我们的真实合成数据集由8个具有复杂非朗伯材质的几何复杂对象的路径跟踪渲染组成。真实数据集由8个真实场景的手持前向捕捉组成（NV无法在此数据上进行评估，因为它仅重建有界体积内的对象）。虽然LLFF实现了略好的LPIP，但我们敦促读者观看我们的补充视频，其中我们的方法实现了更好的多视图一致性，并产生了比所有基线更少的伪影。"></p><h4 id="Real-images-of-complex-scenes"><a href="#Real-images-of-complex-scenes" class="headerlink" title="Real images of complex scenes"></a>Real images of complex scenes</h4><p>我们展示了使用大致前向图像捕获的复杂现实世界场景的结果（表 1，“Real ForwardFacing”）。 该数据集包含用手持手机拍摄的 8 个场景（5 个取自 LLFF 论文，3 个我们拍摄），用 20 到 62 张图像拍摄，其中$ 1/8 $用于测试集。 所有图像均为$ 1008×756 $像素。</p><h3 id="6-2-Comparisons"><a href="#6-2-Comparisons" class="headerlink" title="6.2 Comparisons"></a>6.2 Comparisons</h3><p>为了评估我们的模型，我们将其与当前性能最佳的视图合成技术进行比较，详情如下。除局部光场融合外，所有方法都使用相同的输入视图集为每个场景训练单独的网络，该方法在大型数据集上训练单个3D卷积网络，然后使用相同的训练网络在测试时处理新场景的输入图像。</p><h4 id="Neural-Volumes（NV）"><a href="#Neural-Volumes（NV）" class="headerlink" title="Neural Volumes（NV）"></a>Neural Volumes（NV）</h4><p>合成完全位于不同背景前面的有界体积内的对象的新颖视图（必须在没有感兴趣对象的情况下单独捕获）。它优化了深度三维卷积网络，以预测具有1283个样本的离散化RGB$\alpha$体素网格以及具有323个样本的三维扭曲网格。该算法通过使摄像机光线行进通过扭曲的体素网格来渲染新视图。</p><h4 id="Scene-Representation-Networks（SRN）"><a href="#Scene-Representation-Networks（SRN）" class="headerlink" title="Scene Representation Networks（SRN）"></a>Scene Representation Networks（SRN）</h4><p>将连续场景表示为不透明表面，由将每个$(x，y，z)$坐标映射到特征向量的MLP隐式定义。他们训练一个递归神经网络，通过使用任何3D坐标处的特征向量来预测沿着光线的下一步大小，沿着光线在场景表示中行进。最后一步的特征向量被解码为曲面上该点的单一颜色。</p><h4 id="Local-Light-Field-Fusion（LLFF）"><a href="#Local-Light-Field-Fusion（LLFF）" class="headerlink" title="Local Light Field Fusion（LLFF）"></a>Local Light Field Fusion（LLFF）</h4><p>LLFF设计用于为采样良好的前向场景生成真实感新颖的视图。它使用经过训练的三维卷积网络直接预测每个输入视图的离散化截头体采样RGB$\alpha$网格（多平面图像或MPI），然后通过$\alpha$合成和将附近的MPI混合到新视点中来渲染新视图。</p><p><img src="/images/nerf-notes-1/image-20220819214609455.png" alt="图5：使用基于物理的渲染器生成的新合成数据集的场景的测试集视图比较。我们的方法能够恢复几何结构和外观的细节，如船的索具、乐高的齿轮和踏板、麦克风的闪亮支架和网格格栅以及材料的非朗伯反射。LLFF展示了麦克风支架上的带状伪影和材料的物体边缘，以及船桅杆和乐高物体内部的重影伪影。SRN在任何情况下都会产生模糊和扭曲的渲染。神经体积无法捕捉麦克风格栅或乐高齿轮上的细节，也完全无法恢复船上索具的几何结构。"></p><p><img src="/images/nerf-notes-1/image-20220819214638645.png" alt="图6：真实世界场景的测试集视图的比较。LLFF专为该用例设计（真实场景的前向捕捉）。我们的方法能够在渲染视图中比LLFF更一致地表示精细几何体，如T-rex中的蕨类植物叶子和骨架肋骨和栏杆所示。我们的方法还正确重建LLFF难以清晰渲染的部分遮挡区域，例如底部蕨类作物叶子后面的黄色架子和底部兰花作物背景中的绿色叶子。多重渲染之间的混合也可能导致LLFF中的重复边缘，如顶部兰花作物中所示。SRN捕捉每个场景中的低频几何和颜色变化，但无法再现任何细节。"></p><h3 id="6-3-Discussion"><a href="#6-3-Discussion" class="headerlink" title="6.3 Discussion"></a>6.3 Discussion</h3><p>我们彻底超越了在所有场景中优化每个场景（NV 和 SRN）的单独网络的两个基线。 此外，与 LLFF（除一个指标外的所有指标）相比，我们产生了质量和数量上更优越的渲染，同时仅使用它们的输入图像作为我们的整个训练集。</p><p>SRN方法产生高度平滑的几何体和纹理，其视图合成的表示能力受到限制，因为每个相机光线仅选择一个深度和颜色。NV基线能够捕获合理详细的体积几何结构和外观，但其使用的底层显式1283体素网格阻止其缩放以高分辨率表示精细细节。LLFF特别提供了一个“采样准则”，输入视图之间的视差不超过64像素，因此它经常无法估计合成数据集中的正确几何体，其中包含多达400-500像素的视图之间视差。此外，LLFF在不同场景表示之间进行混合，以呈现不同的视图，导致视觉上分散注意力的不一致性，这在我们的补充视频中很明显。</p><p>这些方法之间最大的实际权衡是时间与空间。所有比较的单场景方法每个场景至少需要12小时的训练。相比之下，LLFF可以在10分钟内处理一个小的输入数据集。然而，LLFF为每个输入图像生成一个大的三维体素网格，导致巨大的存储需求（一个“真实合成”场景超过15GB）。我们的方法只需要5 MB的网络权重（与LLFF相比，相对压缩为3000×），这甚至比我们任何数据集中单个场景的输入图像的内存更少。</p><h3 id="6-4-Ablation-studies"><a href="#6-4-Ablation-studies" class="headerlink" title="6.4 Ablation studies"></a>6.4 Ablation studies</h3><p>我们通过表2中的广泛消融研究验证了算法的设计选择和参数。我们在“真实合成360°” 场景。第9行显示了作为参考点的完整模型。第1行显示了我们模型的最小版本，没有位置编码（$PE$）、视图相关性（$VD$）或分层采样（$H$）。在第2-4行中，我们从完整模型中一次一个地删除这三个组件，观察到位置编码（第2行）和视图相关性（第3行）提供了最大的定量效益，随后是分层采样（第4行）。第5-6行显示了随着输入图像数量的减少，我们的性能如何下降。请注意，当提供100幅图像时，我们的方法仅使用25幅输入图像的性能在所有度量中仍超过NV、SRN和LLFF（见补充材料）。在第7-8行中，我们验证了在$x$的位置编码中使用的最大频率$L$的选择（用于$d$的最大频率按比例缩放）。仅使用5个频率会降低性能，但将频率数从10个增加到15个不会提高性能。我们认为，一旦$2^L$超过采样输入图像中存在的最大频率（我们的数据中约为1024），增加$L$的益处就会受到限制。</p><p><img src="/images/nerf-notes-1/image-20220819215424287.png" alt="表2：我们模型的消融研究。这些度量是我们真实合成数据集中8个场景的平均值。详细说明见第6.4节。"></p><h2 id="7-Conclusion"><a href="#7-Conclusion" class="headerlink" title="7 Conclusion"></a>7 Conclusion</h2><p>我们的工作直接解决了以前使用MLP将对象和场景表示为连续函数的工作的不足。我们证明，将场景表示为5D神经辐射场（输出体积密度和视为3D位置和2D观看方向的函数的视相关发射辐射的MLP）比之前主要的训练深度卷积网络以输出离散体素表示的方法产生更好的渲染。</p><p>尽管我们提出了一种分层采样策略，以提高渲染的采样效率（用于训练和测试），但在研究有效优化和渲染神经辐射场的技术方面仍有更多的进展。未来工作的另一个方向是可解释性：体素网格和网格等采样表示允许对渲染视图的预期质量和故障模式进行推理，但不清楚当我们在深度神经网络的权重中编码场景时如何分析这些问题。我们相信，这项工作在基于真实世界图像的图形管道方面取得了进展，其中复杂场景可以由从实际对象和场景的图像优化的神经辐射场组成。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://blog.csdn.net/qq_43620967/article/details/124467551">NeRF论文翻译笔记</a></li><li><a href="https://zhuanlan.zhihu.com/p/542200751">NeRF论文阅读</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> NeRF&amp;3DGS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NeRF </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几何的隐式表示与显示表示</title>
      <link href="2022/08/17/geometry-notes-1/"/>
      <url>2022/08/17/geometry-notes-1/</url>
      
        <content type="html"><![CDATA[<h1 id="几何的隐式表示与显示表示"><a href="#几何的隐式表示与显示表示" class="headerlink" title="几何的隐式表示与显示表示"></a>几何的隐式表示与显示表示</h1><h2 id="Many-Ways-to-Represent-Geometry"><a href="#Many-Ways-to-Represent-Geometry" class="headerlink" title="Many Ways to Represent Geometry"></a>Many Ways to Represent Geometry</h2><p><strong>Implicit</strong> 隐式表示</p><ul><li>algebraic surface</li><li>level sets</li><li>distance functions</li><li>…</li></ul><p><strong>Explicit</strong> 显示表示</p><ul><li>point cloud</li><li>polygon mesh</li><li>subdivision, NURBS</li><li>…</li></ul><p>Each choice best suited to a different task/type of geometry</p><h2 id="Implicit-隐式表示"><a href="#Implicit-隐式表示" class="headerlink" title="Implicit 隐式表示"></a>Implicit 隐式表示</h2><p>隐式表示就是告诉我们点满足某种<strong>特定的关系</strong>，而不是告诉我们点具体在哪。</p><h3 id="More-Implicit-Representations-in-Computer-Graphics"><a href="#More-Implicit-Representations-in-Computer-Graphics" class="headerlink" title="More Implicit Representations in Computer Graphics"></a>More Implicit Representations in Computer Graphics</h3><h4 id="Algebraic-Surfaces"><a href="#Algebraic-Surfaces" class="headerlink" title="Algebraic Surfaces"></a>Algebraic Surfaces</h4><p>直接用数学公式表示，最大的问题是不直观，比如右边的心形很难直观的想出来，而更复杂的情况就很难表示，比如下面的奶牛就很难用公式表示出来。</p><img src="/images/geometry-notes-1/image-20220817174204989.png" style="zoom:67%;"><h4 id="Constructive-Solid-Geometry"><a href="#Constructive-Solid-Geometry" class="headerlink" title="Constructive Solid Geometry"></a>Constructive Solid Geometry</h4><p>通过一系列基本几何的基本运算来定义新的几何。</p><p>比如下面圆柱A、球B就是基本几何，通过类似于集合的交、并、差运算，就可以形成新的几何。</p><img src="/images/geometry-notes-1/image-20220817174235470.png" style="zoom:67%;"><h4 id="Distance-Functions"><a href="#Distance-Functions" class="headerlink" title="Distance Functions"></a>Distance Functions</h4><p>不直接描述几何的表面，而是描述空间中任意一个点到物体表面的最小距离。</p><p>物体内距离为负，物体表面距离为零，物体外距离为正。</p><img src="/images/geometry-notes-1/image-20220817174252399.png" style="zoom:67%;"><p>可以将两个距离函数做blending，得到一个新的几何物体。</p><img src="/images/geometry-notes-1/image-20220817174346265.png" style="zoom:67%;"><p>距离函数的表示能力非常强，比如下图的例子，它将物体之间的联系圆滑的过度过去。</p><img src="/images/geometry-notes-1/image-20220817180535506.png" style="zoom:67%;"><h4 id="Level-Set-Methods"><a href="#Level-Set-Methods" class="headerlink" title="Level Set Methods"></a>Level Set Methods</h4><p>如果距离函数不方便写成解析的形式，还可以通过水平集的方法表示出来。水平集和上面距离函数的区别仅仅是表示形式的区别。</p><p>可以通过双线性插值等方法，得到$f(x)=0$的位置。</p><p>地理上的等高线和水平集比较类似，一条等高线就是$f(x)$等于某个高度的地方。</p><img src="/images/geometry-notes-1/image-20220817174408560.png" style="zoom:67%;"><p>水平集不一定要定义在二维的格子上，也可以定义在三维的格子上，下面就是一个例子。</p><p>水平集根据组织密度，构成了三维体积模型。</p><img src="/images/geometry-notes-1/image-20220817180551459.png" style="zoom:67%;"><h4 id="Fractals"><a href="#Fractals" class="headerlink" title="Fractals"></a>Fractals</h4><p>几何还有一种特殊的方法，叫做fractal（分形）。</p><p>分形是一个自相似的过程，包括在不同的尺寸上，指的是自己的一个部分和它的整体长得非常像，类似于递归。</p><img src="/images/geometry-notes-1/image-20220817174431695.png" style="zoom:67%;"><h3 id="Pros-amp-Cons"><a href="#Pros-amp-Cons" class="headerlink" title="Pros &amp; Cons"></a>Pros &amp; Cons</h3><p><strong>Pros:</strong> </p><ul><li><p>compact description (e.g., a function)  </p></li><li><p>certain queries easy (inside object, distance to surface)  </p><p>将点代入$f(x,y,z)$，如果小于零在里面，大于零在外面，等于零在面上。例如下面这个例子：</p><img src="/images/geometry-notes-1/image-20220816182952182.png" style="zoom:67%;"></li><li><p>good for ray-to-surface intersection (more later)  </p></li><li><p>for simple shapes, exact description / no sampling error  </p></li><li><p>easy to handle changes in topology (e.g., fluid)</p></li></ul><p><strong>Cons:</strong> </p><ul><li><p>difficult to model complex shapes</p></li><li><p>sampling can be hard</p><img src="/images/geometry-notes-1/image-20220816182336846.png" alt="" style="zoom: 50%;"></li></ul><h2 id="Explicit-显示表示"><a href="#Explicit-显示表示" class="headerlink" title="Explicit 显示表示"></a>Explicit 显示表示</h2><p>显示表示指的是<strong>直接给出所有的点，或者通过参数映射给出所有的点</strong>。下图是通过参数映射表示点的例子。</p><img src="/images/geometry-notes-1/image-20220817170953766.png" style="zoom: 50%;"><h3 id="Many-Explicit-Representations-in-Graphics"><a href="#Many-Explicit-Representations-in-Graphics" class="headerlink" title="Many Explicit Representations in Graphics"></a>Many Explicit Representations in Graphics</h3><h4 id="Point-Cloud"><a href="#Point-Cloud" class="headerlink" title="Point Cloud"></a>Point Cloud</h4><img src="/images/geometry-notes-1/image-20220817175002386.png" style="zoom:67%;"><h4 id="Polygon-Mesh"><a href="#Polygon-Mesh" class="headerlink" title="Polygon Mesh"></a>Polygon Mesh</h4><img src="/images/geometry-notes-1/image-20220817175139019.png" style="zoom:67%;"><h4 id="The-Wavefront-Object-File-obj-Forma"><a href="#The-Wavefront-Object-File-obj-Forma" class="headerlink" title="The Wavefront Object File (.obj) Forma"></a>The Wavefront Object File (.obj) Forma</h4><img src="/images/geometry-notes-1/image-20220817175231519.png" style="zoom:67%;"><h3 id="Pros-amp-Cons-1"><a href="#Pros-amp-Cons-1" class="headerlink" title="Pros &amp; Cons"></a>Pros &amp; Cons</h3><p><strong>Pros</strong>：</p><p>采样很简单，将所有的UV代入就能得到所有的点了</p><img src="/images/geometry-notes-1/image-20220817171013319.png" alt="" style="zoom:50%;"><p><strong>Cons</strong>：</p><p>判断点在表面的里面还是外面很困难</p><img src="/images/geometry-notes-1/image-20220817171033168.png" alt="" style="zoom:50%;"><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>在隐式表示Constructive Solid Geometry部分，这些运算如何使用解析的形式表示出来？如果基本几何之间只使用一部分做运算（两个基本几何的中心不对齐），又怎么表示？</li><li>在显示表示中，可以通过映射表示几何物体，比如$f(u, v) = ((2 + cos u) cos v,(2 + cos u) sin v,sin u)$就表示了一个圆环，这样从二维向三维映射的方式能够表示所有的几何物体吗？如果是一头奶牛，可以使用$f(u,v)$的映射表示吗？如果圆环的位置移动了，或者姿态改变了，还可以通过二维向三维的映射表示吗？（也许可以先计算几何当前位置到某个“标准位置”的映射关系，即三维到三维的映射，然后把这个映射再反馈到二维到三维的映射中？这应该只是一个线性的变换？？？）</li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://blog.csdn.net/weixin_45314475/article/details/121732013">计算机图形学入门（九）-几何（基本表示方法：隐式和显式）</a></li><li><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">GAMES101: 现代计算机图形学入门</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 三维视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式表示 </tag>
            
            <tag> 显示表示 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三维视觉的神经隐式表示</title>
      <link href="2022/08/13/inr-notes-1/"/>
      <url>2022/08/13/inr-notes-1/</url>
      
        <content type="html"><![CDATA[<h1 id="三维视觉的神经隐式表示"><a href="#三维视觉的神经隐式表示" class="headerlink" title="三维视觉的神经隐式表示"></a>三维视觉的神经隐式表示</h1><h2 id="Traditional-3D-Reconstruction-Pipeline"><a href="#Traditional-3D-Reconstruction-Pipeline" class="headerlink" title="Traditional 3D Reconstruction Pipeline"></a>Traditional 3D Reconstruction Pipeline</h2><p><img src="/images/inr-notes-1/image-20220813134955574.png"></p><p>classical multi-view reconstruction:</p><ul><li>input a set of images</li><li>estimate camera poses using bundle adjustment</li><li>find dense correspondences</li><li>create depth maps</li><li>fuse these depth maps into a coherent reconstruction of the object or a bigger scene</li></ul><h2 id="3D-Representations"><a href="#3D-Representations" class="headerlink" title="3D Representations"></a>3D Representations</h2><p>对3D物体表示方法有以下几种方式，分别是基于voxel（体素），基于Points（点云），基于mesh和基于volume的方法，其中前三种方法的问题是都是离散的，这就造成了它们都是不可微的；而最后的一种方法则是连续可微的方程。</p><p><img src="/images/inr-notes-1/image-20220813164105835.png"></p><h3 id="基于voxel（体素）"><a href="#基于voxel（体素）" class="headerlink" title="基于voxel（体素）"></a>基于voxel（体素）</h3><p><img src="/images/inr-notes-1/image-20220813163921749.png"></p><h3 id="基于Points（点云）"><a href="#基于Points（点云）" class="headerlink" title="基于Points（点云）"></a>基于Points（点云）</h3><p><img src="/images/inr-notes-1/image-20220813163927732.png"></p><h3 id="基于mesh"><a href="#基于mesh" class="headerlink" title="基于mesh"></a>基于mesh</h3><p><img src="/images/inr-notes-1/image-20220813163936647.png"></p><h3 id="基于volume"><a href="#基于volume" class="headerlink" title="基于volume"></a>基于volume</h3><p><img src="/images/inr-notes-1/image-20220813163943333.png"></p><p><img src="/images/inr-notes-1/image-20220813163951122.png"></p><h2 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h2><p><img src="/images/inr-notes-1/image-20220813164115576.png"></p><p><img src="/images/inr-notes-1/image-20220813164123406.png"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.youtube.com/watch?v=F9mRv4v80w0&amp;list=WL&amp;index=4">TUM AI Lecture Series - Neural Implicit Representations for 3D Vision (Andreas Geiger)</a></li><li><a href="http://www.cvlibs.net/publications/Mescheder2019CVPR_slides.pdf">Mescheder2019CVPR_slides</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 三维视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式表示 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>隐式神经表示</title>
      <link href="2022/08/12/inr-notes-0/"/>
      <url>2022/08/12/inr-notes-0/</url>
      
        <content type="html"><![CDATA[<h1 id="隐式神经表示"><a href="#隐式神经表示" class="headerlink" title="隐式神经表示"></a>隐式神经表示</h1><h2 id="什么是隐式神经表示？"><a href="#什么是隐式神经表示？" class="headerlink" title="什么是隐式神经表示？"></a>什么是隐式神经表示？</h2><p>隐式神经表示（Implicit Neural Representations）是一种对各种信号进行参数化的新方法。</p><p>传统的信号表示通常是离散的——例如，图像是离散的像素网格，音频信号是离散的幅度样本，3D 形状通常被参数化为体素、点云或网格的网格。</p><p>而在真实世界中，我们看到的世界可以认为是连续的，或者近似连续的，因此可以考虑使用连续函数来表示信号的真实状态。隐式神经表示就将信号参数化为连续函数，该函数将信号的域（即，坐标。例如图像的像素坐标）映射到该坐标处的任何内容（对于图像就是[R,G,B]）。 但是这些函数很难处理，我们无从得知连续函数的准确形式， 因此有人提出<strong>用神经网络来逼近连续函数，这种表示方法被称为隐式神经表示“（Implicit Neural Representation，INR）</strong>。</p><h2 id="隐式神经表示的优点？"><a href="#隐式神经表示的优点？" class="headerlink" title="隐式神经表示的优点？"></a>隐式神经表示的优点？</h2><p>首先，它们不再与空间分辨率耦合，例如，图像与像素数耦合。 这是因为它们是连续函数！ 因此，对信号进行参数化所需的内存与空间分辨率无关，并且仅与底层信号的复杂性成比例。 另一个推论是隐式表示具有“无限分辨率”——它们可以以任意空间分辨率进行采样。这对于许多应用程序非常有用，例如超分辨率，或在 3D 和更高维度的参数化信号中，其中内存需求随着空间分辨率快速增长。 </p><p>此外，跨神经隐式表示的泛化相当于在函数空间上学习先验，通过学习神经网络权重的先验来实现——这通常被称为元学习（meta-learning），是两个非常活跃的研究的一个非常令人兴奋的交叉领域！ 另一个令人兴奋的交叉领域是在神经隐式表示和神经网络架构中的对称性研究——例如，创建一个 3D 旋转等变的神经网络架构会立即通过神经隐式表示生成旋转等变生成模型的可行路径。</p><p>隐式神经表示的另一个关键前景在于直接在这些表示空间中操作的算法。换言之，“卷积神经网络”与对隐式表示的图像进行操作的神经网络等效于什么？</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/vsitzmann/awesome-implicit-representations">Awesome Implicit Neural Representations</a></li><li><a href="https://zhuanlan.zhihu.com/p/372338398">Implicit Neural Representation 隐式神经表示</a></li><li><a href="https://zhuanlan.zhihu.com/p/423612080">Implicit Neural Representations: From Objects to 3D Scenes隐式神经表征：从物体到三维场景</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 三维视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 隐式表示 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo中同时使用多个主题</title>
      <link href="2022/04/17/hexo-multi-theme/"/>
      <url>2022/04/17/hexo-multi-theme/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo中同时使用多个主题"><a href="#Hexo中同时使用多个主题" class="headerlink" title="Hexo中同时使用多个主题"></a>Hexo中同时使用多个主题</h1><p>最近想在github上搭建一个Homepage，但是我的博客已经把immortalqx.github.io这个坑给占着了。</p><p>一个很自然的想法就是让Hexo同时使用多个主题，一个主题给我的博客，一个主题给我的Homepage，这样就可以在保持博客现状的情况下搭建一个风格严谨的Homepage。</p><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>类似于<code>hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</code>这样的命令，对hexo来说是默认按照<code>_config.yml</code>设定的参数来执行渲染的。而<code>_config.yml</code>文件中指定了网站的url、root、source_dir和public_dir等非常关键的数据。</p><p>所以我们可以写两个config文件，比如<code>_config.yml</code>继续用于博客，然后新建一个<code>_config_homepage.yml</code>用于搭建Homepage。之后，我们可以通过<code>hexo g</code>可以默认使用<code>_config.yml</code>来搭建博客，再通过<code>hexo --config _config_homepage.yml g</code>来指定Homepage的config文件来搭建Homepage。</p><p>在使用<code>hexo --config _config_homepage.yml</code>之前，我们还需要修改<code>_config_homepage.yml</code>文件中的参数，让Homepage依附于博客，即把Homepage的public_dir放到博客的public_dir下，这样就可以通过类似于immortalqx.github.io/homepage的形式来访问Homepage。</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ol><li><p>更改博客采用的主题的config文件，将新增Homepage的标签（不同主题设置有区别，这里以<a href="https://github.com/blinkfox/hexo-theme-matery">matery</a>为例）。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">menu</span><span class="token punctuation">:</span>  <span class="token key atrule">Index</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>home<span class="token punctuation">...</span><span class="token punctuation">...</span>  <span class="token key atrule">Homepage</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> /homepage    <span class="token key atrule">icon</span><span class="token punctuation">:</span> fas fa<span class="token punctuation">-</span>award<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>复制root目录下的<code>_config.yml</code>文件，重命名为<code>_config_homepage.yml</code>。</p></li><li><p>安装需要使用的新主题（以<a href="https://github.com/PhosphorW/hexo-theme-academia">academia</a>为例）。注意要记得安装新主题需要的一些依赖，防止无法进行渲染。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">cd</span> your-hexo-directory<span class="token function">git</span> clone https://github.com/PhosphorW/hexo-theme-academia.git themes/academia<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>修改<code>_config_homepage.yml</code>文件，（下面仅列出需要修改的数据，根据使用的主题要修改的数据可能不一样）。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># Site</span><span class="token comment"># 部分选项置空，防止和采用的theme冲突</span><span class="token key atrule">title</span><span class="token punctuation">:</span> Homepage<span class="token key atrule">subtitle</span><span class="token punctuation">:</span> <span class="token string">'Homepage'</span><span class="token key atrule">description</span><span class="token punctuation">:</span><span class="token key atrule">keywords</span><span class="token punctuation">:</span><span class="token key atrule">author</span><span class="token punctuation">:</span><span class="token key atrule">language</span><span class="token punctuation">:</span> EN<span class="token key atrule">timezone</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">...</span><span class="token punctuation">...</span><span class="token comment"># URL</span><span class="token comment"># 在原来的基础上增加一个“/homepage”</span><span class="token key atrule">url</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//Immortalqx.github.io/homepage<span class="token key atrule">root</span><span class="token punctuation">:</span> /homepage<span class="token punctuation">...</span><span class="token punctuation">...</span><span class="token comment"># Directory</span><span class="token comment"># 新设置一个source文件夹，但是public文件夹要放到博客的public文件夹下(这样才能够在博客中打开Homepage)</span><span class="token key atrule">source_dir</span><span class="token punctuation">:</span> source_homepage<span class="token key atrule">public_dir</span><span class="token punctuation">:</span> public/homepage<span class="token punctuation">...</span><span class="token punctuation">...</span><span class="token comment"># Extensions</span><span class="token comment">## Plugins: https://hexo.io/plugins/</span><span class="token comment">## Themes: https://hexo.io/themes/</span><span class="token comment"># 设置成需要使用的新主题</span><span class="token key atrule">theme</span><span class="token punctuation">:</span> academia<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>修改academia主题的config，更改资源文件目录，icon、favicon等。这里就看个人喜好了，可以在这里新增一个跳转到博客的链接，也可以不写。</p></li><li><p>创建采用新主题的页面：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo <span class="token parameter variable">--config</span> _config_homepage.yml new <span class="token string">"xxxxx"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>在新页面中增加内容。</p></li></ol><h4 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo clhexo <span class="token parameter variable">--config</span> _config.yml ghexo <span class="token parameter variable">--config</span> _config_homepage.yml ghexo d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意事项：</p><ul><li>由于本博客介绍的方法中，新主题渲染的页面在博客的public文件夹下，所以可以通过<code>hexo cl</code>来清除原来渲染的页面。</li><li>通过<code>hexo --config</code>来指定config文件渲染博客和Homepage。</li><li>由于所有渲染内容都在原博客的public文件夹下，所以这里对应的是同一个github仓库，只需要<code>hexo d</code>就能同时把两个主题渲染的页面推送过去。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的前置声明</title>
      <link href="2022/04/10/cpp-notes-9/"/>
      <url>2022/04/10/cpp-notes-9/</url>
      
        <content type="html"><![CDATA[<h1 id="C-中的前置声明"><a href="#C-中的前置声明" class="headerlink" title="C++中的前置声明"></a>C++中的前置声明</h1><blockquote><p>最近在阅读orb-slam2的源码，一眼就看到了代码中的前置声明，这里做个笔记复习一下。</p></blockquote><p>最新的Google C++ Style Guide对前置声明的建议是：</p><p>Avoid using forward declarations where possible. Instead, <a href="https://google.github.io/styleguide/cppguide.html#Include_What_You_Use">include the headers you need</a>.</p><h2 id="Note-1"><a href="#Note-1" class="headerlink" title="Note 1"></a>Note 1</h2><blockquote><p>参考：<a href="https://www.zhihu.com/question/63201378/answer/208096403">如何看待C++前置声明？ - 夏洋的回答 - 知乎</a></p></blockquote><p>简单来说，前置声明最大的好处就是『<strong>节省编译时间</strong>』。毕竟C++的编译时间长已经是一个臭名昭著人人喊打的问题。<strong>但对于Google来说，这方面的效率节省就不见得那么可观了</strong>——毕竟Google内部有超大规模的分布式编译集群『Forge』。哪怕是十万以上的target，全部build一遍也就是几分钟的事情。</p><p>与此同时，前置声明带来的问题则显得更加关键：</p><p>例如，如果一个类的实现者需要把这个类<strong>改个名字/换个命名空间</strong>，出于兼容性他原本可以在原命名空间里/用原名<strong>通过using来起一个别名指向新类</strong>。然而<strong>别名不能被前向声明</strong>。内网有一份代码改动一下子试图修改总计265个头文件，就是实现者为了要改这个类的名字而不得不去改所有的调用处。想一想，如果这265个文件分属于50个不同的团队，你得拿到50个人的同意才能提交这份改动，想不想打人？</p><p>再举一个code style中提到的，更为严重的例子——它可能导致<strong>运行时出现错误的结果</strong>：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// b.h:</span><span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">D</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">B</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// good_user.cc:</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"b.h"</span></span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>B<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>D<span class="token operator">*</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment">// calls f(B*)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>若把#include换成前置声明，由于声明时不知道D是B的子类，test()中f(x)就会导致f(void*)被调用，而不是f(B*)。</p><p>再比如，C++标准5.3.5/5中规定，<strong>delete一个不完整类型的指针</strong>时，如果这个类型有non-trivial的<a href="https://www.zhihu.com/search?q=%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:208096403%7D">析构函数</a>，那么这种行为是<strong>未定义</strong>的。把前置声明换成#include则能保证消除这种风险。</p><p>诚然，从理论上说，一个牛逼的程序员当然是可以通过分析一个头文件的源码来决定会不会碰到以上诸多坑，并由此决定用哪个好。但一来不是所有人都是牛逼程序员，二来，把精力花费在这件事情上真的值得吗？</p><h2 id="Note-2"><a href="#Note-2" class="headerlink" title="Note 2"></a>Note 2</h2><blockquote><p>参考：<a href="https://www.zhihu.com/question/379789314/answer/1082007099">c++ 两个头文件互相引用，如何解决？ - 程序员柠檬的回答 - 知乎</a></p></blockquote><p>这里触发了C++的一个知识点，叫 <strong>C++前置声明</strong> 这是发生这种情况的根本原因，我在这里大概给你讲一下。</p><p>A.h:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">A_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">A_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"B.h"</span></span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token keyword">typedef</span> vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>sizetype size_type<span class="token punctuation">;</span>B b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>B.h:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">B_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">B_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"A.h"</span></span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span>A<span class="token double-colon punctuation">::</span>size_type num<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这种循环依赖场景中，由于C++是按单个编译单元编译的，编译报错。</p><h3 id="解决方法是-引入前置声明。"><a href="#解决方法是-引入前置声明。" class="headerlink" title="解决方法是: 引入前置声明。"></a>解决方法是: 引入前置声明。</h3><ol><li>把A中的B转成<code>B*</code>；</li><li>class A中先声明B，也就是前置声明；</li><li>A.h 移除对类B.h文件的包含（若用了#ifdef则不必须）</li></ol><p>A.h:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">A_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">A_H</span></span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token keyword">typedef</span> vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>sizetype size_type<span class="token punctuation">;</span>B<span class="token operator">*</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>B.h:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">B_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">B_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"A.h"</span></span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span>A<span class="token double-colon punctuation">::</span>size_type num<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="为什么要用指针B-呢？"><a href="#为什么要用指针B-呢？" class="headerlink" title="为什么要用指针B* 呢？"></a>为什么要用指针B* 呢？</h3><p>因为用了前置声明，编译器无法确定对象的实际大小，而指针的大小在特定机器类型上是固定的（x86机器是4byte，x64机器是8byte）</p><h2 id="Note-3"><a href="#Note-3" class="headerlink" title="Note 3"></a>Note 3</h2><blockquote><p>参考：<a href="https://www.zhihu.com/question/379789314/answer/1561485926">c++ 两个头文件互相引用，如何解决？ - 60荷兰盾的回答 - 知乎</a></p></blockquote><p>自己也碰到了这个问题，我发现前置声明可能会有隐患，而且代码结构还是不够清晰。个人感觉一旦出现相互引用，大概率是两个模块设计的不合理，应该是可以拆解的。看到其他答主有说抽出一个共有的基类，但是在某些情况下不适用。个人的解决办法是把其中一个类拆分。比如A和B相互引用，那么我把A拆成C和D两个类。那么现在有B,C,D三个类了，有可能就解决了这个问题。</p><p>简而言之，要么纵向拆解，要么横向拆解。</p><h2 id="Note-4"><a href="#Note-4" class="headerlink" title="Note 4"></a>Note 4</h2><blockquote><p>参考：<a href="https://codeantenna.com/a/ZeGUBeamqi">C++中，两个头文件互相引用怎么办</a></p></blockquote><p>两个头文件相互包含会导致超前引用的问题，所谓超前引用是指一个类型在定义之前就被用来定义变量和声明函数。发生这种情况是无法编译通过的，不过可以采取一些手段解决该问题。</p><p>超前引用导致的错误有以下几种处理办法：</p><h3 id="1-使用类声明"><a href="#1-使用类声明" class="headerlink" title="1. 使用类声明"></a>1. 使用类声明</h3><p>在超前引用一个类之前，首先用一个特殊的语句说明该标识符是一个类名，即将被超前引用。其使用方法是：<br>  a)  用class ClassB；声明即将超前引用的类名<br>  b)  定义class ClassA<br>  c)  定义class ClassB;<br>  d)  编制两个类的实现代码。</p><p>上述方法适用于所有代码在同一个文件中，一般情况下，ClassA和ClassB分别有自己的头文件和cpp文件，这种</p><p>方法需要演变成：</p><p>   a) 分别定义ClassA和ClassB，并在cpp文件中实现之<br>   b) 在两个头文件的开头分别用class ClassB;和class ClassA;声明对方<br>   c) 在两个cpp文件中分别包含另外一个类的头文件</p><p>NOTE:这种方法切记不可使用类名来定义变量和函数的变量参数，只可用来定义引用或者指针。    </p><h3 id="2-使用全局变量"><a href="#2-使用全局变量" class="headerlink" title="2. 使用全局变量"></a>2. 使用全局变量</h3><p>由于全局变量可以避免超前引用，不用赘述。我的习惯是，把类对象的extern语句加在该类头文件的最后，大家喜欢怎样写那都没有什么大问题，关键是保证不要在头文件中胡乱包含。</p><h3 id="3-使用基类指针"><a href="#3-使用基类指针" class="headerlink" title="3. 使用基类指针"></a>3. 使用基类指针</h3><p>这种方法是在引用超前引用类的地方一律用基类指针。而一般情况下，两个互相引用的类并不涉及其基类，因此不会造成超前引用。</p>]]></content>
      
      
      <categories>
          
          <category> 编程基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 编程规范（二）</title>
      <link href="2022/04/07/cpp-notes-8/"/>
      <url>2022/04/07/cpp-notes-8/</url>
      
        <content type="html"><![CDATA[<h1 id="C-编程规范（二）"><a href="#C-编程规范（二）" class="headerlink" title="C++ 编程规范（二）"></a>C++ 编程规范（二）</h1><blockquote><p>这部分就直接从那边往这边搬运了</p></blockquote><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释虽然写起来很痛苦, 但对保证代码可读性至关重要. 下面的规则描述了如何注释以及在哪儿注释. 当然也要记住: 注释固然很重要, 但最好的代码应当本身就是文档. 有意义的类型名和变量名, 要远胜过要用注释解释的含糊不清的名字.</p><p>你写的注释是给代码读者看的, 也就是下一个需要理解你的代码的人. 所以慷慨些吧, 下一个读者可能就是你!</p><h3 id="注释风格"><a href="#注释风格" class="headerlink" title="注释风格"></a>注释风格</h3><p><strong>总述</strong></p><p>使用 <code>//</code> 或 <code>/* */</code>, 统一就好.</p><p><strong>说明</strong></p><p><code>//</code> 或 <code>/* */</code> 都可以; 但 <code>//</code> <em>更</em> 常用. 要在如何注释及注释风格上确保统一.</p><h3 id="文件注释"><a href="#文件注释" class="headerlink" title="文件注释"></a>文件注释</h3><p><strong>总述</strong></p><p>在每一个文件开头加入版权公告.</p><p>文件注释描述了该文件的内容. 如果一个文件只声明, 或实现, 或测试了一个对象, 并且这个对象已经在它的声明处进行了详细的注释, 那么就没必要再加上文件注释. 除此之外的其他文件都需要文件注释.</p><p><strong>说明</strong></p><h4 id="法律公告和作者信息"><a href="#法律公告和作者信息" class="headerlink" title="法律公告和作者信息"></a>法律公告和作者信息</h4><p>每个文件都应该包含许可证引用. 为项目选择合适的许可证版本.(比如, Apache 2.0, BSD, LGPL, GPL)</p><p>如果你对原始作者的文件做了重大修改, 请考虑删除原作者信息.</p><h4 id="文件内容"><a href="#文件内容" class="headerlink" title="文件内容"></a>文件内容</h4><p>如果一个 <code>.h</code> 文件声明了多个概念, 则文件注释应当对文件的内容做一个大致的说明, 同时说明各概念之间的联系. 一个一到两行的文件注释就足够了, 对于每个概念的详细文档应当放在各个概念中, 而不是文件注释中.</p><p>不要在 <code>.h</code> 和 <code>.cc</code> 之间复制注释, 这样的注释偏离了注释的实际意义.</p><h3 id="类注释"><a href="#类注释" class="headerlink" title="类注释"></a>类注释</h3><p><strong>总述</strong></p><p>每个类的定义都要附带一份注释, 描述类的功能和用法, 除非它的功能相当明显.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Iterates over the contents of a GargantuanTable.</span><span class="token comment">// Example:</span><span class="token comment">//    GargantuanTableIterator* iter = table-&gt;NewIterator();</span><span class="token comment">//    for (iter-&gt;Seek("foo"); !iter-&gt;done(); iter-&gt;Next()) {</span><span class="token comment">//      process(iter-&gt;key(), iter-&gt;value());</span><span class="token comment">//    }</span><span class="token comment">//    delete iter;</span><span class="token keyword">class</span> <span class="token class-name">GargantuanTableIterator</span> <span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>说明</strong></p><p>类注释应当为读者理解如何使用与何时使用类提供足够的信息, 同时应当提醒读者在正确使用此类时应当考虑的因素. 如果类有任何同步前提, 请用文档说明. 如果该类的实例可被多线程访问, 要特别注意文档说明多线程环境下相关的规则和常量使用.</p><p>如果你想用一小段代码演示这个类的基本用法或通常用法, 放在类注释里也非常合适.</p><p>如果类的声明和定义分开了(例如分别放在了 <code>.h</code> 和 <code>.cc</code> 文件中), 此时, 描述类用法的注释应当和接口定义放在一起, 描述类的操作和实现的注释应当和实现放在一起.</p><h3 id="函数注释"><a href="#函数注释" class="headerlink" title="函数注释"></a>函数注释</h3><p><strong>总述</strong></p><p>函数声明处的注释描述函数功能; 定义处的注释描述函数实现.</p><p><strong>说明</strong></p><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>基本上每个函数声明处前都应当加上注释, 描述函数的功能和用途. 只有在函数的功能简单而明显时才能省略这些注释(例如, 简单的取值和设值函数). 注释使用叙述式 (“Opens the file”) 而非指令式 (“Open the file”); 注释只是为了描述函数, 而不是命令函数做什么. 通常, 注释不会描述函数如何工作. 那是函数定义部分的事情.</p><p>函数声明处注释的内容:</p><ul><li>函数的输入输出.</li><li>对类成员函数而言: 函数调用期间对象是否需要保持引用参数, 是否会释放这些参数.</li><li>函数是否分配了必须由调用者释放的空间.</li><li>参数是否可以为空指针.</li><li>是否存在函数使用上的性能隐患.</li><li>如果函数是可重入的, 其同步前提是什么?</li></ul><p>举例如下:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Returns an iterator for this table.  It is the client's</span><span class="token comment">// responsibility to delete the iterator when it is done with it,</span><span class="token comment">// and it must not use the iterator once the GargantuanTable object</span><span class="token comment">// on which the iterator was created has been deleted.</span><span class="token comment">//</span><span class="token comment">// The iterator is initially positioned at the beginning of the table.</span><span class="token comment">//</span><span class="token comment">// This method is equivalent to:</span><span class="token comment">//    Iterator* iter = table-&gt;NewIterator();</span><span class="token comment">//    iter-&gt;Seek("");</span><span class="token comment">//    return iter;</span><span class="token comment">// If you are going to immediately seek to another place in the</span><span class="token comment">// returned iterator, it will be faster to use NewIterator()</span><span class="token comment">// and avoid the extra seek.</span>Iterator<span class="token operator">*</span> <span class="token function">GetIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但也要避免罗罗嗦嗦, 或者对显而易见的内容进行说明. 下面的注释就没有必要加上 “否则返回 false”, 因为已经暗含其中了:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Returns true if the table cannot hold any more entries.</span><span class="token keyword">bool</span> <span class="token function">IsTableFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注释函数重载时, 注释的重点应该是函数中被重载的部分, 而不是简单的重复被重载的函数的注释. 多数情况下, 函数重载不需要额外的文档, 因此也没有必要加上注释.</p><p>注释构造/析构函数时, 切记读代码的人知道构造/析构函数的功能, 所以 “销毁这一对象” 这样的注释是没有意义的. 你应当注明的是注明构造函数对参数做了什么 (例如, 是否取得指针所有权) 以及析构函数清理了什么. 如果都是些无关紧要的内容, 直接省掉注释. 析构函数前没有注释是很正常的.</p><h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><p>如果函数的实现过程中用到了很巧妙的方式, 那么在函数定义处应当加上解释性的注释. 例如, 你所使用的编程技巧, 实现的大致步骤, 或解释如此实现的理由. 举个例子, 你可以说明为什么函数的前半部分要加锁而后半部分不需要.</p><p><em>不要</em> 从 <code>.h</code> 文件或其他地方的函数声明处直接复制注释. 简要重述函数功能是可以的, 但注释重点要放在如何实现上.</p><h3 id="变量注释"><a href="#变量注释" class="headerlink" title="变量注释"></a>变量注释</h3><p><strong>总述</strong></p><p>通常变量名本身足以很好说明变量用途. 某些情况下, 也需要额外的注释说明.</p><p><strong>说明</strong></p><h4 id="类数据成员"><a href="#类数据成员" class="headerlink" title="类数据成员"></a>类数据成员</h4><p>每个类数据成员 (也叫实例变量或成员变量) 都应该用注释说明用途. 如果有非变量的参数(例如特殊值, 数据成员之间的关系, 生命周期等)不能够用类型与变量名明确表达, 则应当加上注释. 然而, 如果变量类型与变量名已经足以描述一个变量, 那么就不再需要加上注释.</p><p>特别地, 如果变量可以接受 <code>NULL</code> 或 <code>-1</code> 等警戒值, 须加以说明. 比如:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">private</span><span class="token operator">:</span> <span class="token comment">// Used to bounds-check table accesses. -1 means</span> <span class="token comment">// that we don't yet know how many entries the table has.</span> <span class="token keyword">int</span> num_total_entries_<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>和数据成员一样, 所有全局变量也要注释说明含义及用途, 以及作为全局变量的原因. 比如:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// The total number of tests cases that we run through in this regression test.</span><span class="token keyword">const</span> <span class="token keyword">int</span> kNumTestCases <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="实现注释"><a href="#实现注释" class="headerlink" title="实现注释"></a>实现注释</h3><p><strong>总述</strong></p><p>对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释.</p><p><strong>说明</strong></p><h4 id="代码前注释"><a href="#代码前注释" class="headerlink" title="代码前注释"></a>代码前注释</h4><p>巧妙或复杂的代码段前要加注释. 比如:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Divide result by two, taking into account that x</span><span class="token comment">// contains the carry from the add.</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> result<span class="token operator">-&gt;</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  x <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">*</span>result<span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">(</span><span class="token operator">*</span>result<span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> x <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>  x <span class="token operator">&amp;=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="行注释"><a href="#行注释" class="headerlink" title="行注释"></a>行注释</h4><p>比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释. 比如:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// If we have enough memory, mmap the data portion too.</span>mmap_budget <span class="token operator">=</span> <span class="token generic-function"><span class="token function">max</span><span class="token generic class-name"><span class="token operator">&lt;</span>int64<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> mmap_budget <span class="token operator">-</span> index_<span class="token operator">-&gt;</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>mmap_budget <span class="token operator">&gt;=</span> data_size_ <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">MmapData</span><span class="token punctuation">(</span>mmap_chunk_bytes<span class="token punctuation">,</span> mlock<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token comment">// Error already logged.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意, 这里用了两段注释分别描述这段代码的作用, 和提示函数返回时错误已经被记入日志.</p><p>如果你需要连续进行多行注释, 可以使之对齐获得更好的可读性:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">DoSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// Comment here so the comments line up.</span><span class="token function">DoSomethingElseThatIsLonger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Two spaces between the code and the comment.</span><span class="token punctuation">{</span> <span class="token comment">// One space before comment when opening a new scope is allowed,</span>  <span class="token comment">// thus the comment lines up with the following comments and code.</span>  <span class="token function">DoSomethingElse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Two spaces before line comments normally.</span><span class="token punctuation">}</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> list<span class="token punctuation">{</span>                    <span class="token comment">// Comments in braced lists describe the next element...</span>                    <span class="token string">"First item"</span><span class="token punctuation">,</span>                    <span class="token comment">// .. and should be aligned appropriately.</span><span class="token string">"Second item"</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">DoSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* For trailing block comments, one space is fine. */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="函数参数注释"><a href="#函数参数注释" class="headerlink" title="函数参数注释"></a>函数参数注释</h4><p>如果函数参数的意义不明显, 考虑用下面的方式进行弥补:</p><ul><li>如果参数是一个字面常量, 并且这一常量在多处函数调用中被使用, 用以推断它们一致, 你应当用一个常量名让这一约定变得更明显, 并且保证这一约定不会被打破.</li><li>考虑更改函数的签名, 让某个 <code>bool</code> 类型的参数变为 <code>enum</code> 类型, 这样可以让这个参数的值表达其意义.</li><li>如果某个函数有多个配置选项, 你可以考虑定义一个类或结构体以保存所有的选项, 并传入类或结构体的实例. 这样的方法有许多优点, 例如这样的选项可以在调用处用变量名引用, 这样就能清晰地表明其意义. 同时也减少了函数参数的数量, 使得函数调用更易读也易写. 除此之外, 以这样的方式, 如果你使用其他的选项, 就无需对调用点进行更改.</li><li>用具名变量代替大段而复杂的嵌套表达式.</li><li>万不得已时, 才考虑在调用点用注释阐明参数的意义.</li></ul><p>比如下面的示例的对比:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// What are these arguments?</span><span class="token keyword">const</span> DecimalNumber product <span class="token operator">=</span> <span class="token function">CalculateProduct</span><span class="token punctuation">(</span>values<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>和</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ProductOptions options<span class="token punctuation">;</span>options<span class="token punctuation">.</span><span class="token function">set_precision_decimals</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>options<span class="token punctuation">.</span><span class="token function">set_use_cache</span><span class="token punctuation">(</span>ProductOptions<span class="token double-colon punctuation">::</span>kDontUseCache<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> DecimalNumber product <span class="token operator">=</span>    <span class="token function">CalculateProduct</span><span class="token punctuation">(</span>values<span class="token punctuation">,</span> options<span class="token punctuation">,</span> <span class="token comment">/*completion_callback=*/</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>哪个更清晰一目了然.</p><h4 id="不允许的行为"><a href="#不允许的行为" class="headerlink" title="不允许的行为"></a>不允许的行为</h4><p>不要描述显而易见的现象, <em>永远不要</em> 用自然语言翻译代码作为注释, 除非即使对深入理解 C++ 的读者来说代码的行为都是不明显的. 要假设读代码的人 C++ 水平比你高, 即便他/她可能不知道你的用意:</p><p>你所提供的注释应当解释代码 <em>为什么</em> 要这么做和代码的目的, 或者最好是让代码自文档化.</p><p>比较这样的注释:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Find the element in the vector.  &lt;-- 差: 这太明显了!</span><span class="token keyword">auto</span> iter <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>iter <span class="token operator">!=</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">Process</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>和这样的注释:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Process "element" unless it was already processed.</span><span class="token keyword">auto</span> iter <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>iter <span class="token operator">!=</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">Process</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自文档化的代码根本就不需要注释. 上面例子中的注释对下面的代码来说就是毫无必要的:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IsAlreadyProcessed</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">Process</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="标点-拼写和语法"><a href="#标点-拼写和语法" class="headerlink" title="标点, 拼写和语法"></a>标点, 拼写和语法</h3><p><strong>总述</strong></p><p>注意标点, 拼写和语法; 写的好的注释比差的要易读的多.</p><p><strong>说明</strong></p><p>注释的通常写法是包含正确大小写和结尾句号的完整叙述性语句. 大多数情况下, 完整的句子比句子片段可读性更高. 短一点的注释, 比如代码行尾注释, 可以随意点, 但依然要注意风格的一致性.</p><p>虽然被别人指出该用分号时却用了逗号多少有些尴尬, 但清晰易读的代码还是很重要的. 正确的标点, 拼写和语法对此会有很大帮助.</p><h3 id="TODO-注释"><a href="#TODO-注释" class="headerlink" title="TODO 注释"></a>TODO 注释</h3><p><strong>总述</strong></p><p>对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 <code>TODO</code> 注释.</p><p><code>TODO</code> 注释要使用全大写的字符串 <code>TODO</code>, 在随后的圆括号里写上你的名字, 邮件地址, bug ID, 或其它身份标识和与这一 <code>TODO</code> 相关的 issue. 主要目的是让添加注释的人 (也是可以请求提供更多细节的人) 可根据规范的 <code>TODO</code> 格式进行查找. 添加 <code>TODO</code> 注释并不意味着你要自己来修正, 因此当你加上带有姓名的 <code>TODO</code> 时, 一般都是写上自己的名字.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// TODO(kl@gmail.com): Use a "*" here for concatenation operator.</span><span class="token comment">// TODO(Zeke) change this to use relations.</span><span class="token comment">// TODO(bug 12345): remove the "Last visitors" feature</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果加 <code>TODO</code> 是为了在 “将来某一天做某事”, 可以附上一个非常明确的时间 “Fix by November 2005”), 或者一个明确的事项 (“Remove this code when all clients can handle XML responses.”).</p><h3 id="弃用注释"><a href="#弃用注释" class="headerlink" title="弃用注释"></a>弃用注释</h3><p><strong>总述</strong></p><p>通过弃用注释（<code>DEPRECATED</code> comments）以标记某接口点已弃用.</p><p>您可以写上包含全大写的 <code>DEPRECATED</code> 的注释, 以标记某接口为弃用状态. 注释可以放在接口声明前, 或者同一行.</p><p>在 <code>DEPRECATED</code> 一词后, 在括号中留下您的名字, 邮箱地址以及其他身份标识.</p><p>弃用注释应当包涵简短而清晰的指引, 以帮助其他人修复其调用点. 在 C++ 中, 你可以将一个弃用函数改造成一个内联函数, 这一函数将调用新的接口.</p><p>仅仅标记接口为 <code>DEPRECATED</code> 并不会让大家不约而同地弃用, 您还得亲自主动修正调用点（callsites）, 或是找个帮手.</p><p>修正好的代码应该不会再涉及弃用接口点了, 着实改用新接口点. 如果您不知从何下手, 可以找标记弃用注释的当事人一起商量.</p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>每个人都可能有自己的代码风格和格式, 但如果一个项目中的所有人都遵循同一风格的话, 这个项目就能更顺利地进行. 每个人未必能同意下述的每一处格式规则, 而且其中的不少规则需要一定时间的适应, 但整个项目服从统一的编程风格是很重要的, 只有这样才能让所有人轻松地阅读和理解代码.</p><p>为了帮助你正确的格式化代码, 我们写了一个 <a href="https://raw.githubusercontent.com/google/styleguide/gh-pages/google-c-style.el">emacs 配置文件</a>.</p><h3 id="行长度"><a href="#行长度" class="headerlink" title="行长度"></a>行长度</h3><p><strong>总述</strong></p><p>每一行代码字符数不超过 80.</p><p>我们也认识到这条规则是有争议的, 但很多已有代码都遵照这一规则, 因此我们感觉一致性更重要.</p><p><strong>优点</strong></p><p>提倡该原则的人认为强迫他们调整编辑器窗口大小是很野蛮的行为. 很多人同时并排开几个代码窗口, 根本没有多余的空间拉伸窗口. 大家都把窗口最大尺寸加以限定, 并且 80 列宽是传统标准. 那么为什么要改变呢?</p><p><strong>缺点</strong></p><p>反对该原则的人则认为更宽的代码行更易阅读. 80 列的限制是上个世纪 60 年代的大型机的古板缺陷; 现代设备具有更宽的显示屏, 可以很轻松地显示更多代码.</p><p><strong>结论</strong></p><p>80 个字符是最大值.</p><p>如果无法在不伤害易读性的条件下进行断行, 那么注释行可以超过 80 个字符, 这样可以方便复制粘贴. 例如, 带有命令示例或 URL 的行可以超过 80 个字符.</p><p>包含长路径的 <code>#include</code> 语句可以超出80列.</p><p><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/#define-guard">头文件保护</a> 可以无视该原则.</p><h3 id="非-ASCII-字符"><a href="#非-ASCII-字符" class="headerlink" title="非 ASCII 字符"></a>非 ASCII 字符</h3><p><strong>总述</strong></p><p>尽量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码.</p><p><strong>说明</strong></p><p>即使是英文, 也不应将用户界面的文本硬编码到源代码中, 因此非 ASCII 字符应当很少被用到. 特殊情况下可以适当包含此类字符. 例如, 代码分析外部数据文件时, 可以适当硬编码数据文件中作为分隔符的非 ASCII 字符串; 更常见的是 (不需要本地化的) 单元测试代码可能包含非 ASCII 字符串. 此类情况下, 应使用 UTF-8 编码, 因为很多工具都可以理解和处理 UTF-8 编码.</p><p>十六进制编码也可以, 能增强可读性的情况下尤其鼓励 —— 比如 <code>"\xEF\xBB\xBF"</code>, 或者更简洁地写作 <code>u8"\uFEFF"</code>, 在 Unicode 中是 <em>零宽度 无间断</em> 的间隔符号, 如果不用十六进制直接放在 UTF-8 格式的源文件中, 是看不到的.</p><p>(Yang.Y 注: <code>"\xEF\xBB\xBF"</code> 通常用作 UTF-8 with BOM 编码标记)</p><p>使用 <code>u8</code> 前缀把带 <code>uXXXX</code> 转义序列的字符串字面值编码成 UTF-8. 不要用在本身就带 UTF-8 字符的字符串字面值上, 因为如果编译器不把源代码识别成 UTF-8, 输出就会出错.</p><p>别用 C++11 的 <code>char16_t</code> 和 <code>char32_t</code>, 它们和 UTF-8 文本没有关系, <code>wchar_t</code> 同理, 除非你写的代码要调用 Windows API, 后者广泛使用了 <code>wchar_t</code>.</p><h3 id="空格还是制表位"><a href="#空格还是制表位" class="headerlink" title="空格还是制表位"></a>空格还是制表位</h3><p><strong>总述</strong></p><p>只使用空格, 每次缩进 2 个空格.</p><p><strong>说明</strong></p><p>我们使用空格缩进. 不要在代码中使用制表符. 你应该设置编辑器将制表符转为空格.</p><h3 id="函数声明与定义"><a href="#函数声明与定义" class="headerlink" title="函数声明与定义"></a>函数声明与定义</h3><p><strong>总述</strong></p><p>返回类型和函数名在同一行, 参数也尽量放在同一行, 如果放不下就对形参分行, 分行方式与 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/formatting/#function-calls">函数调用</a> 一致.</p><p><strong>说明</strong></p><p>函数看上去像这样:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ReturnType <span class="token class-name">ClassName</span><span class="token double-colon punctuation">::</span><span class="token function">FunctionName</span><span class="token punctuation">(</span>Type par_name1<span class="token punctuation">,</span> Type par_name2<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">DoSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果同一行文本太多, 放不下所有参数:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ReturnType <span class="token class-name">ClassName</span><span class="token double-colon punctuation">::</span><span class="token function">ReallyLongFunctionName</span><span class="token punctuation">(</span>Type par_name1<span class="token punctuation">,</span> Type par_name2<span class="token punctuation">,</span>                                             Type par_name3<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">DoSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>甚至连第一个参数都放不下:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ReturnType <span class="token class-name">LongClassName</span><span class="token double-colon punctuation">::</span><span class="token function">ReallyReallyReallyLongFunctionName</span><span class="token punctuation">(</span>    Type par_name1<span class="token punctuation">,</span>  <span class="token comment">// 4 space indent</span>    Type par_name2<span class="token punctuation">,</span>    Type par_name3<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">DoSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 2 space indent</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意以下几点:</p><ul><li>使用好的参数名.</li><li>只有在参数未被使用或者其用途非常明显时, 才能省略参数名.</li><li>如果返回类型和函数名在一行放不下, 分行.</li><li>如果返回类型与函数声明或定义分行了, 不要缩进.</li><li>左圆括号总是和函数名在同一行.</li><li>函数名和左圆括号间永远没有空格.</li><li>圆括号与参数间没有空格.</li><li>左大括号总在最后一个参数同一行的末尾处, 不另起新行.</li><li>右大括号总是单独位于函数最后一行, 或者与左大括号同一行.</li><li>右圆括号和左大括号间总是有一个空格.</li><li>所有形参应尽可能对齐.</li><li>缺省缩进为 2 个空格.</li><li>换行后的参数保持 4 个空格的缩进.</li></ul><p>未被使用的参数, 或者根据上下文很容易看出其用途的参数, 可以省略参数名:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">Foo</span><span class="token punctuation">(</span>Foo<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token keyword">const</span> Foo<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Foo<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Foo<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Foo<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Foo<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>未被使用的参数如果其用途不明显的话, 在函数定义处将参数名注释起来:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Shape</span> <span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Rotate</span><span class="token punctuation">(</span><span class="token keyword">double</span> radians<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Circle</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Shape</span></span> <span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">void</span> <span class="token function">Rotate</span><span class="token punctuation">(</span><span class="token keyword">double</span> radians<span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token class-name">Circle</span><span class="token double-colon punctuation">::</span><span class="token function">Rotate</span><span class="token punctuation">(</span><span class="token keyword">double</span> <span class="token comment">/*radians*/</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">// 差 - 如果将来有人要实现, 很难猜出变量的作用.</span><span class="token keyword">void</span> <span class="token class-name">Circle</span><span class="token double-colon punctuation">::</span><span class="token function">Rotate</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>属性, 和展开为属性的宏, 写在函数声明或定义的最前面, 即返回类型之前:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">MUST_USE_RESULT <span class="token keyword">bool</span> <span class="token function">IsOK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h3><p><strong>总述</strong></p><p>Lambda 表达式对形参和函数体的格式化和其他函数一致; 捕获列表同理, 表项用逗号隔开.</p><p><strong>说明</strong></p><p>若用引用捕获, 在变量名和 <code>&amp;</code> 之间不留空格.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">auto</span> add_to_x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>x<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span> x <span class="token operator">+=</span> n<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>短 lambda 就写得和内联函数一样.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> blacklist <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> digits <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>digits<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">remove_if</span><span class="token punctuation">(</span>digits<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> digits<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>blacklist<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token keyword">return</span> blacklist<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> blacklist<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>             digits<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p><strong>总述</strong></p><p>要么一行写完函数调用, 要么在圆括号里对参数分行, 要么参数另起一行且缩进四格. 如果没有其它顾虑的话, 尽可能精简行数, 比如把多个参数适当地放在同一行里.</p><p><strong>说明</strong></p><p>函数调用遵循如下形式：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> retval <span class="token operator">=</span> <span class="token function">DoSomething</span><span class="token punctuation">(</span>argument1<span class="token punctuation">,</span> argument2<span class="token punctuation">,</span> argument3<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果同一行放不下, 可断为多行, 后面每一行都和第一个实参对齐, 左圆括号后和右圆括号前不要留空格：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> retval <span class="token operator">=</span> <span class="token function">DoSomething</span><span class="token punctuation">(</span>averyveryveryverylongargument1<span class="token punctuation">,</span>                          argument2<span class="token punctuation">,</span> argument3<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>参数也可以放在次行, 缩进四格：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">DoSomething</span><span class="token punctuation">(</span>        argument1<span class="token punctuation">,</span> argument2<span class="token punctuation">,</span>  <span class="token comment">// 4 空格缩进</span>        argument3<span class="token punctuation">,</span> argument4<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把多个参数放在同一行以减少函数调用所需的行数, 除非影响到可读性. 有人认为把每个参数都独立成行, 不仅更好读, 而且方便编辑参数. 不过, 比起所谓的参数编辑, 我们更看重可读性, 且后者比较好办：</p><p>如果一些参数本身就是略复杂的表达式, 且降低了可读性, 那么可以直接创建临时变量描述该表达式, 并传递给函数：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> my_heuristic <span class="token operator">=</span> scores<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">*</span> y <span class="token operator">+</span> bases<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">bool</span> retval <span class="token operator">=</span> <span class="token function">DoSomething</span><span class="token punctuation">(</span>my_heuristic<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者放着不管, 补充上注释：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> retval <span class="token operator">=</span> <span class="token function">DoSomething</span><span class="token punctuation">(</span>scores<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">*</span> y <span class="token operator">+</span> bases<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment">// Score heuristic.</span>                          x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果某参数独立成行, 对可读性更有帮助的话, 那也可以如此做. 参数的格式处理应当以可读性而非其他作为最重要的原则.</p><p>此外, 如果一系列参数本身就有一定的结构, 可以酌情地按其结构来决定参数格式：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 通过 3x3 矩阵转换 widget.</span>my_widget<span class="token punctuation">.</span><span class="token function">Transform</span><span class="token punctuation">(</span>x1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> x3<span class="token punctuation">,</span>                    y1<span class="token punctuation">,</span> y2<span class="token punctuation">,</span> y3<span class="token punctuation">,</span>                    z1<span class="token punctuation">,</span> z2<span class="token punctuation">,</span> z3<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="列表初始化格式"><a href="#列表初始化格式" class="headerlink" title="列表初始化格式"></a>列表初始化格式</h3><p><strong>总述</strong></p><p>您平时怎么格式化函数调用, 就怎么格式化 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/#braced-initializer-list">列表初始化</a>.</p><p><strong>说明</strong></p><p>如果列表初始化伴随着名字, 比如类型或变量名, 格式化时将将名字视作函数调用名, {} 视作函数调用的括号. 如果没有名字, 就视作名字长度为零.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 一行列表初始化示范.</span><span class="token keyword">return</span> <span class="token punctuation">{</span>foo<span class="token punctuation">,</span> bar<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">functioncall</span><span class="token punctuation">(</span><span class="token punctuation">{</span>foo<span class="token punctuation">,</span> bar<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> p<span class="token punctuation">{</span>foo<span class="token punctuation">,</span> bar<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 当不得不断行时.</span><span class="token function">SomeFunction</span><span class="token punctuation">(</span>    <span class="token punctuation">{</span><span class="token string">"assume a zero-length name before {"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">// 假设在 { 前有长度为零的名字.</span>    some_other_function_parameter<span class="token punctuation">)</span><span class="token punctuation">;</span>SomeType variable<span class="token punctuation">{</span>    some<span class="token punctuation">,</span> other<span class="token punctuation">,</span> values<span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token string">"assume a zero-length name before {"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">// 假设在 { 前有长度为零的名字.</span>    SomeOtherType<span class="token punctuation">{</span>        <span class="token string">"Very long string requiring the surrounding breaks."</span><span class="token punctuation">,</span>  <span class="token comment">// 非常长的字符串, 前后都需要断行.</span>        some<span class="token punctuation">,</span> other values<span class="token punctuation">}</span><span class="token punctuation">,</span>    SomeOtherType<span class="token punctuation">{</span><span class="token string">"Slightly shorter string"</span><span class="token punctuation">,</span>  <span class="token comment">// 稍短的字符串.</span>                  some<span class="token punctuation">,</span> other<span class="token punctuation">,</span> values<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>SomeType variable<span class="token punctuation">{</span>    <span class="token string">"This is too long to fit all in one line"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 字符串过长, 因此无法放在同一行.</span>MyType m <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment">// 注意了, 您可以在 { 前断行.</span>    superlongvariablename1<span class="token punctuation">,</span>    superlongvariablename2<span class="token punctuation">,</span>    <span class="token punctuation">{</span><span class="token keyword">short</span><span class="token punctuation">,</span> interior<span class="token punctuation">,</span> list<span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span>interiorwrappinglist<span class="token punctuation">,</span>     interiorwrappinglist2<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p><strong>总述</strong></p><p>倾向于不在圆括号内使用空格. 关键字 <code>if</code> 和 <code>else</code> 另起一行.</p><p><strong>说明</strong></p><p>对基本条件语句有两种可以接受的格式. 一种在圆括号和条件之间有空格, 另一种没有.</p><p>最常见的是没有空格的格式. 哪一种都可以, 最重要的是 <em>保持一致</em>. 如果你是在修改一个文件, 参考当前已有格式. 如果是写新的代码, 参考目录下或项目中其它文件. 还在犹豫的话, 就不要加空格了.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 圆括号里没有空格.</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment">// 2 空格缩进.</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// else 与 if 的右括号同一行.</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你更喜欢在圆括号内部加空格:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span> condition <span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 圆括号与空格紧邻 - 不常见</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment">// 2 空格缩进.</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  <span class="token comment">// else 与 if 的右括号同一行.</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意所有情况下 <code>if</code> 和左圆括号间都有个空格. 右圆括号和左大括号之间也要有个空格:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span>     <span class="token comment">// 差 - IF 后面没空格.</span><span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment">// 差 - { 前面没空格.</span><span class="token keyword">if</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 变本加厉地差.</span><span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 好 - IF 和 { 都与空格紧邻.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果能增强可读性, 简短的条件语句允许写在同一行. 只有当语句简单并且没有使用 <code>else</code> 子句时使用:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> kFoo<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> kBar<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果语句有 <code>else</code> 分支则不允许:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 不允许 - 当有 ELSE 分支时 IF 块却写在同一行</span><span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token function">DoThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token function">DoThat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通常, 单行语句不需要使用大括号, 如果你喜欢用也没问题; 复杂的条件或循环语句用大括号可读性会更好. 也有一些项目要求 <code>if</code> 必须总是使用大括号:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span>  <span class="token function">DoSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 2 空格缩进.</span><span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">DoSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 2 空格缩进.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但如果语句中某个 <code>if-else</code> 分支使用了大括号的话, 其它分支也必须使用:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 不可以这样子 - IF 有大括号 ELSE 却没有.</span><span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>  foo<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span>  bar<span class="token punctuation">;</span><span class="token comment">// 不可以这样子 - ELSE 有大括号 IF 却没有.</span><span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span>  foo<span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token punctuation">{</span>  bar<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 只要其中一个分支用了大括号, 两个分支都要用上大括号.</span><span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>  foo<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  bar<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="循环和开关选择语句"><a href="#循环和开关选择语句" class="headerlink" title="循环和开关选择语句"></a>循环和开关选择语句</h3><p><strong>总述</strong></p><p><code>switch</code> 语句可以使用大括号分段, 以表明 cases 之间不是连在一起的. 在单语句循环里, 括号可用可不用. 空循环体应使用 <code>{}</code> 或 <code>continue</code>.</p><p><strong>说明</strong></p><p><code>switch</code> 语句中的 <code>case</code> 块可以使用大括号也可以不用, 取决于你的个人喜好. 如果用的话, 要按照下文所述的方法.</p><p>如果有不满足 <code>case</code> 条件的枚举值, <code>switch</code> 应该总是包含一个 <code>default</code> 匹配 (如果有输入值没有 case 去处理, 编译器将给出 warning). 如果 <code>default</code> 应该永远执行不到, 简单的加条 <code>assert</code>:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">switch</span> <span class="token punctuation">(</span>var<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span> <span class="token punctuation">{</span>  <span class="token comment">// 2 空格缩进</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      <span class="token comment">// 4 空格缩进</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">default</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在单语句循环里, 括号可用可不用：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> kSomeNumber<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I love you\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> kSomeNumber<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"I take it back\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>空循环体应使用 <code>{}</code> 或 <code>continue</code>, 而不是一个简单的分号.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">while</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 反复循环直到条件失效.</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> kSomeNumber<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment">// 可 - 空循环体.</span><span class="token keyword">while</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>  <span class="token comment">// 可 - contunue 表明没有逻辑.</span><span class="token keyword">while</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 差 - 看起来仅仅只是 while/loop 的部分之一.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="指针和引用表达式"><a href="#指针和引用表达式" class="headerlink" title="指针和引用表达式"></a>指针和引用表达式</h3><p><strong>总述</strong></p><p>句点或箭头前后不要有空格. 指针/地址操作符 (<code>*, &amp;</code>) 之后不能有空格.</p><p><strong>说明</strong></p><p>下面是指针和引用表达式的正确使用范例:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">x <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>x <span class="token operator">=</span> r<span class="token punctuation">.</span>y<span class="token punctuation">;</span>x <span class="token operator">=</span> r<span class="token operator">-&gt;</span>y<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意:</p><ul><li>在访问成员时, 句点或箭头前后没有空格.</li><li>指针操作符 <code>*</code> 或 <code>&amp;</code> 后没有空格.</li></ul><p>在声明指针变量或参数时, 星号与类型或变量名紧挨都可以:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 好, 空格前置.</span><span class="token keyword">char</span> <span class="token operator">*</span>c<span class="token punctuation">;</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>str<span class="token punctuation">;</span><span class="token comment">// 好, 空格后置.</span><span class="token keyword">char</span><span class="token operator">*</span> c<span class="token punctuation">;</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> str<span class="token punctuation">;</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token operator">*</span>y<span class="token punctuation">;</span>  <span class="token comment">// 不允许 - 在多重声明中不能使用 &amp; 或 *</span><span class="token keyword">char</span> <span class="token operator">*</span> c<span class="token punctuation">;</span>  <span class="token comment">// 差 - * 两边都有空格</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span> str<span class="token punctuation">;</span>  <span class="token comment">// 差 - &amp; 两边都有空格.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在单个文件内要保持风格一致, 所以, 如果是修改现有文件, 要遵照该文件的风格.</p><h3 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h3><p><strong>总述</strong></p><p>如果一个布尔表达式超过 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/formatting/#line-length">标准行宽</a>, 断行方式要统一一下.</p><p><strong>说明</strong></p><p>下例中, 逻辑与 (<code>&amp;&amp;</code>) 操作符总位于行尾:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>this_one_thing <span class="token operator">&gt;</span> this_other_thing <span class="token operator">&amp;&amp;</span>    a_third_thing <span class="token operator">==</span> a_fourth_thing <span class="token operator">&amp;&amp;</span>    yet_another <span class="token operator">&amp;&amp;</span> last_one<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意, 上例的逻辑与 (<code>&amp;&amp;</code>) 操作符均位于行尾. 这个格式在 Google 里很常见, 虽然把所有操作符放在开头也可以. 可以考虑额外插入圆括号, 合理使用的话对增强可读性是很有帮助的. 此外, 直接用符号形式的操作符, 比如 <code>&amp;&amp;</code> 和 <code>~</code>, 不要用词语形式的 <code>and</code> 和 <code>compl</code>.</p><h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><p><strong>总述</strong></p><p>不要在 <code>return</code> 表达式里加上非必须的圆括号.</p><p><strong>说明</strong></p><p>只有在写 <code>x = expr</code> 要加上括号的时候才在 <code>return expr;</code> 里使用括号.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">return</span> result<span class="token punctuation">;</span>                  <span class="token comment">// 返回值很简单, 没有圆括号.</span><span class="token comment">// 可以用圆括号把复杂表达式圈起来, 改善可读性.</span><span class="token keyword">return</span> <span class="token punctuation">(</span>some_long_condition <span class="token operator">&amp;&amp;</span>        another_condition<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 毕竟您从来不会写 var = (value);</span><span class="token keyword">return</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// return 可不是函数！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="变量及数组初始化"><a href="#变量及数组初始化" class="headerlink" title="变量及数组初始化"></a>变量及数组初始化</h3><p><strong>总述</strong></p><p>用 <code>=</code>, <code>()</code> 和 <code>{}</code> 均可.</p><p><strong>说明</strong></p><p>您可以用 <code>=</code>, <code>()</code> 和 <code>{}</code>, 以下的例子都是正确的：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> x<span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>string <span class="token function">name</span><span class="token punctuation">(</span><span class="token string">"Some Name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>string name <span class="token operator">=</span> <span class="token string">"Some Name"</span><span class="token punctuation">;</span>string name<span class="token punctuation">{</span><span class="token string">"Some Name"</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请务必小心列表初始化 <code>{...}</code> 用 <code>std::initializer_list</code> 构造函数初始化出的类型. 非空列表初始化就会优先调用 <code>std::initializer_list</code>, 不过空列表初始化除外, 后者原则上会调用默认构造函数. 为了强制禁用 <code>std::initializer_list</code> 构造函数, 请改用括号.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">v</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 内容为 100 个 1 的向量.</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">{</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 内容为 100 和 1 的向量.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此外, 列表初始化不允许整型类型的四舍五入, 这可以用来避免一些类型上的编程失误.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">pi</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 好 - pi == 3.</span><span class="token keyword">int</span> pi<span class="token punctuation">{</span><span class="token number">3.14</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// 编译错误: 缩窄转换.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h3><p><strong>总述</strong></p><p>预处理指令不要缩进, 从行首开始.</p><p><strong>说明</strong></p><p>即使预处理指令位于缩进代码块中, 指令也应从行首开始.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 好 - 指令从行首开始</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>lopsided_score<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">DISASTER_PENDING      </span><span class="token comment">// 正确 - 从行首开始</span></span>    <span class="token function">DropEverything</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">if</span> <span class="token expression">NOTIFY               </span><span class="token comment">// 非必要 - # 后跟空格</span></span>    <span class="token function">NotifyClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">endif</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>    <span class="token function">BackToNormal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token comment">// 差 - 指令缩进</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>lopsided_score<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">DISASTER_PENDING  </span><span class="token comment">// 差 - "#if" 应该放在行开头</span></span>    <span class="token function">DropEverything</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span>                <span class="token comment">// 差 - "#endif" 不要缩进</span></span>    <span class="token function">BackToNormal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="类格式"><a href="#类格式" class="headerlink" title="类格式"></a>类格式</h3><p><strong>总述</strong></p><p>访问控制块的声明依次序是 <code>public:</code>, <code>protected:</code>, <code>private:</code>, 每个都缩进 1 个空格.</p><p><strong>说明</strong></p><p>类声明 (下面的代码中缺少注释, 参考 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/comments/#class-comments">类注释</a>) 的基本格式如下:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">OtherClass</span></span> <span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span>      <span class="token comment">// 注意有一个空格的缩进</span>  <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 标准的两空格缩进</span>  <span class="token keyword">explicit</span> <span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token keyword">int</span> var<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">~</span><span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">SomeFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">SomeFunctionThatDoesNothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">}</span>  <span class="token keyword">void</span> <span class="token function">set_some_var</span><span class="token punctuation">(</span><span class="token keyword">int</span> var<span class="token punctuation">)</span> <span class="token punctuation">{</span> some_var_ <span class="token operator">=</span> var<span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token keyword">int</span> <span class="token function">some_var</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> some_var_<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">private</span><span class="token operator">:</span>  <span class="token keyword">bool</span> <span class="token function">SomeInternalFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> some_var_<span class="token punctuation">;</span>  <span class="token keyword">int</span> some_other_var_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意事项:</p><ul><li>所有基类名应在 80 列限制下尽量与子类名放在同一行.</li><li>关键词 <code>public:</code>, <code>protected:</code>, <code>private:</code> 要缩进 1 个空格.</li><li>除第一个关键词 (一般是 <code>public</code>) 外, 其他关键词前要空一行. 如果类比较小的话也可以不空.</li><li>这些关键词后不要保留空行.</li><li><code>public</code> 放在最前面, 然后是 <code>protected</code>, 最后是 <code>private</code>.</li><li>关于声明顺序的规则请参考 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/#declaration-order">声明顺序</a> 一节.</li></ul><h3 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h3><p><strong>总述</strong></p><p>构造函数初始化列表放在同一行或按四格缩进并排多行.</p><p><strong>说明</strong></p><p>下面两种初始值列表方式都可以接受:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 如果所有变量能放在同一行:</span><span class="token class-name">MyClass</span><span class="token double-colon punctuation">::</span><span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token keyword">int</span> var<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">some_var_</span><span class="token punctuation">(</span>var<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">DoSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 如果不能放在同一行,</span><span class="token comment">// 必须置于冒号后, 并缩进 4 个空格</span><span class="token class-name">MyClass</span><span class="token double-colon punctuation">::</span><span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token keyword">int</span> var<span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">some_var_</span><span class="token punctuation">(</span>var<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">some_other_var_</span><span class="token punctuation">(</span>var <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">DoSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 如果初始化列表需要置于多行, 将每一个成员放在单独的一行</span><span class="token comment">// 并逐行对齐</span><span class="token class-name">MyClass</span><span class="token double-colon punctuation">::</span><span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token keyword">int</span> var<span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">some_var_</span><span class="token punctuation">(</span>var<span class="token punctuation">)</span><span class="token punctuation">,</span>             <span class="token comment">// 4 space indent</span>      <span class="token function">some_other_var_</span><span class="token punctuation">(</span>var <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// lined up</span>  <span class="token function">DoSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 右大括号 } 可以和左大括号 { 放在同一行</span><span class="token comment">// 如果这样做合适的话</span><span class="token class-name">MyClass</span><span class="token double-colon punctuation">::</span><span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token keyword">int</span> var<span class="token punctuation">)</span>    <span class="token operator">:</span> <span class="token function">some_var_</span><span class="token punctuation">(</span>var<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="命名空间格式化"><a href="#命名空间格式化" class="headerlink" title="命名空间格式化"></a>命名空间格式化</h3><p><strong>总述</strong></p><p>命名空间内容不缩进.</p><p><strong>说明</strong></p><p><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/scoping/#namespaces">命名空间</a> 不要增加额外的缩进层次, 例如:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">namespace</span> <span class="token punctuation">{</span><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 正确. 命名空间内没有额外的缩进.</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token comment">// namespace</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不要在命名空间内缩进:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">namespace</span> <span class="token punctuation">{</span>  <span class="token comment">// 错, 缩进多余了.</span>  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>  <span class="token comment">// namespace</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>声明嵌套命名空间时, 每个命名空间都独立成行.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">namespace</span> foo <span class="token punctuation">{</span><span class="token keyword">namespace</span> bar <span class="token punctuation">{</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="水平留白"><a href="#水平留白" class="headerlink" title="水平留白"></a>水平留白</h3><p><strong>总述</strong></p><p>水平留白的使用根据在代码中的位置决定. 永远不要在行尾添加没意义的留白.</p><p><strong>说明</strong></p><h4 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">bool</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 左大括号前总是有空格.</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 分号前不加空格.</span><span class="token comment">// 列表初始化中大括号内的空格是可选的.</span><span class="token comment">// 如果加了空格, 那么两边都要加上.</span><span class="token keyword">int</span> x<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> x<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// 继承与初始化列表中的冒号前后恒有空格.</span><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Bar</span></span> <span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token comment">// 对于单行函数的实现, 在大括号内加上空格</span>  <span class="token comment">// 然后是函数实现</span>  <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">baz_</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment">// 大括号里面是空的话, 不加空格.</span>  <span class="token keyword">void</span> <span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> baz_ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment">// 用空格把大括号与实现分开.</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加冗余的留白会给其他人编辑时造成额外负担. 因此, 行尾不要留空格. 如果确定一行代码已经修改完毕, 将多余的空格去掉; 或者在专门清理空格时去掉（尤其是在没有其他人在处理这件事的时候). (Yang.Y 注: 现在大部分代码编辑器稍加设置后, 都支持自动删除行首/行尾空格, 如果不支持, 考虑换一款编辑器或 IDE)</p><h4 id="循环和条件语句"><a href="#循环和条件语句" class="headerlink" title="循环和条件语句"></a>循环和条件语句</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment">// if 条件语句和循环语句关键字后均有空格.</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          <span class="token comment">// else 前后有空格.</span><span class="token punctuation">}</span><span class="token keyword">while</span> <span class="token punctuation">(</span>test<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>   <span class="token comment">// 圆括号内部不紧邻空格.</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">switch</span> <span class="token punctuation">(</span> i <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 循环和条件语句的圆括号里可以与空格紧邻.</span><span class="token keyword">if</span> <span class="token punctuation">(</span> test <span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">// 圆括号, 但这很少见. 总之要一致.</span><span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span> <span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 循环里内 ; 后恒有空格, ;  前可以加个空格.</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>         <span class="token comment">// switch case 的冒号前无空格.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span> <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token comment">// 如果冒号有代码, 加个空格.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 赋值运算符前后总是有空格.</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">// 其它二元操作符也前后恒有空格, 不过对于表达式的子式可以不加空格.</span><span class="token comment">// 圆括号内部没有紧邻空格.</span>v <span class="token operator">=</span> w <span class="token operator">*</span> x <span class="token operator">+</span> y <span class="token operator">/</span> z<span class="token punctuation">;</span>v <span class="token operator">=</span> w<span class="token operator">*</span>x <span class="token operator">+</span> y<span class="token operator">/</span>z<span class="token punctuation">;</span>v <span class="token operator">=</span> w <span class="token operator">*</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 在参数和一元操作符之间不加空格.</span>x <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">;</span><span class="token operator">++</span>x<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>y<span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="模板和转换"><a href="#模板和转换" class="headerlink" title="模板和转换"></a>模板和转换</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 尖括号(&lt; and &gt;) 不与空格紧邻, &lt; 前没有空格, &gt; 和 ( 之间也没有.</span>vector<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> x<span class="token punctuation">;</span>y <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 在类型与指针操作符之间留空格也可以, 但要保持一致.</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">&gt;</span> x<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="垂直留白"><a href="#垂直留白" class="headerlink" title="垂直留白"></a>垂直留白</h3><p><strong>总述</strong></p><p>垂直留白越少越好.</p><p><strong>说明</strong></p><p>这不仅仅是规则而是原则问题了: 不在万不得已, 不要使用空行. 尤其是: 两个函数定义之间的空行不要超过 2 行, 函数体首尾不要留空行, 函数体中也不要随意添加空行.</p><p>基本原则是: 同一屏可以显示的代码越多, 越容易理解程序的控制流. 当然, 过于密集的代码块和过于疏松的代码块同样难看, 这取决于你的判断. 但通常是垂直留白越少越好.</p><p>下面的规则可以让加入的空行更有效:</p><ul><li>函数体内开头或结尾的空行可读性微乎其微.</li><li>在多重 if-else 块里加空行或许有点可读性.</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一图以蔽之</p><p><img src="/images/cpp-notes/google-cpp-style.png" alt="google-cpp-style"></p>]]></content>
      
      
      <categories>
          
          <category> 编程基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 编程规范（一）</title>
      <link href="2022/04/05/cpp-notes-7/"/>
      <url>2022/04/05/cpp-notes-7/</url>
      
        <content type="html"><![CDATA[<h1 id="C-编程规范（一）"><a href="#C-编程规范（一）" class="headerlink" title="C++ 编程规范（一）"></a>C++ 编程规范（一）</h1><p>本文是我对于<a href="https://zh-google-styleguide.readthedocs.io/en/latest/">Google 开源项目风格指南——中文版</a>的学习笔记，在学习的过程中搬运和整理出了这篇文章。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>编程规范是一个特别重要的问题。</p><p>关于编程规范、代码风格相关的教程，网上已经特别丰富，本文仅做一个简单的介绍，期望读者阅读本文后能够对如何规范的用C++语言进行编程有一个基本的认知。</p><p>如果想要更详细的介绍，可以参考：<a href="https://zh-google-styleguide.readthedocs.io/en/latest/">Google 开源项目风格指南——中文版</a>。</p><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p>通常每一个 <code>.cc</code> 文件都有一个对应的 <code>.h</code> 文件。也有一些常见例外，如单元测试代码和只包含 <code>main()</code> 函数的 <code>.cc</code> 文件。正确使用头文件可令代码在可读性、文件大小和性能上大为改观。</p><h3 id="define-保护"><a href="#define-保护" class="headerlink" title="#define 保护"></a>#define 保护</h3><blockquote><p>这其实是非常容易被忽视的一点，因为很多时候我们都习惯于用编译器创建头文件，而创建的头文件里面通常直接就包含了”#define保护”。</p><p>我们可能不知道为什么会有它，也可能很少去考虑它的作用，一旦我们哪天遇到了“特殊情况”——比如在终端用vim创建头文件，大概率就忘记有<code>#ifndef......#define......#endif......</code>这么一回事了。</p></blockquote><p>所有头文件都应该有 <code>#define</code> 保护来防止头文件被多重包含，命名格式当是：<code>&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_</code>。</p><p>为保证唯一性，头文件的命名应该基于所在项目源代码树的全路径。例如，项目 <code>foo</code> 中的头文件 <code>foo/src/bar/baz.h</code> 可按如下方式保护：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">FOO_BAR_BAZ_H_</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FOO_BAR_BAZ_H_</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// FOO_BAR_BAZ_H_</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="include-的路径及顺序"><a href="#include-的路径及顺序" class="headerlink" title="#include 的路径及顺序"></a>#include 的路径及顺序</h3><p>使用标准的头文件包含顺序可增强可读性，避免隐藏依赖。</p><p>推荐的 #include 顺序为：相关头文件，C 库，C++ 库，其他库的 .h，本项目内的 .h。</p><p>项目内头文件应按照项目源代码目录树结构排列，避免使用 UNIX 特殊的快捷目录 <code>.</code>（当前目录）或 <code>..</code>（上级目录）。例如，<code>google-awesome-project/src/base/logging.h</code> 应该按如下方式包含：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"base/logging.h"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>又如，<code>dir/foo.cc</code> 或 <code>dir/foo_test.cc</code> 的主要作用是实现或测试 <code>dir2/foo2.h</code> 的功能，<code>foo.cc</code> 中包含头文件的次序如下：</p><ol><li><code>dir2/foo2.h</code>（优先位置，详情如下）</li><li>C 系统文件</li><li>C++ 系统文件</li><li>其他库的 <code>.h</code> 文件</li><li>本项目内 <code>.h</code> 文件</li></ol><p>这种优先的顺序排序保证当 <code>dir2/foo2.h</code> 遗漏某些必要的库时， <code>dir/foo.cc</code> 或 <code>dir/foo_test.cc</code> 的构建会立刻中止。因此这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是维护其他包的人们。</p><p><code>dir/foo.cc</code> 和 <code>dir2/foo2.h</code> 通常位于同一目录下（如 <code>base/basictypes_unittest.cc</code> 和 <code>base/basictypes.h</code>），但也可以放在不同目录下。</p><p>按字母顺序分别对每种类型的头文件进行二次排序是不错的主意。注意较老的代码可不符合这条规则，要在方便的时候改正它们。</p><p>您所依赖的符号（symbols）被哪些头文件所定义，您就应该包含（include）哪些头文件，<a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/#forward-declarations">前置声明</a>（forward declarations）情况除外。比如您要用到 <code>bar.h</code> 中的某个符号，哪怕您所包含的 <code>foo.h</code> 已经包含了 <code>bar.h</code>，也照样得包含 <code>bar.h</code>，除非 <code>foo.h</code> 有明确说明它会自动向您提供 <code>bar.h</code> 中的 symbol。不过，凡是 cc 文件所对应的「相关头文件」已经包含的，就不用再重复包含进其 cc 文件里面了，就像 <code>foo.cc</code> 只包含 <code>foo.h</code> 就够了，不用再管后者所包含的其它内容。</p><p>举例来说，<code>google-awesome-project/src/foo/internal/fooserver.cc</code> 的包含次序如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"foo/public/fooserver.h"</span> <span class="token comment">// 优先位置</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;hash_map&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"base/basictypes.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"base/commandlineflags.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"foo/public/bar.h"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>例外：</strong></p><p>有时，平台特定（system-specific）代码需要条件编译（conditional includes），这些代码可以放到其它 includes 之后。当然，您的平台特定代码也要够简练且独立，比如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"foo/public/fooserver.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"base/port.h"</span>  <span class="token comment">// For LANG_CXX11.</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">LANG_CXX11</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;initializer_list&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span>  <span class="token comment">// LANG_CXX11</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="头文件中应该写什么内容？"><a href="#头文件中应该写什么内容？" class="headerlink" title="头文件中应该写什么内容？"></a>头文件中应该写什么内容？</h3><p>参考另外一篇文章：<a href="https://immortalqx.github.io/2021/11/21/cpp-notes-0/">C++中的头文件</a></p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>使用具名的命名空间时，其名称可基于项目名或相对路径。比如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// .h 文件</span><span class="token keyword">namespace</span> mynamespace <span class="token punctuation">{</span><span class="token comment">// 所有声明都置于命名空间中</span><span class="token comment">// 注意不要使用缩进</span><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">void</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment">// namespace mynamespace</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// .cc 文件</span><span class="token keyword">namespace</span> mynamespace <span class="token punctuation">{</span><span class="token comment">// 函数定义都置于命名空间中</span><span class="token keyword">void</span> <span class="token class-name">MyClass</span><span class="token double-colon punctuation">::</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token comment">// namespace mynamespace</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>禁止使用 using 指示（using-directive）。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 禁止 —— 污染命名空间</span><span class="token keyword">using</span> <span class="token keyword">namespace</span> foo<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>禁止使用内联命名空间（inline namespace）。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 内联命名空间很容易令人迷惑，毕竟其内部的成员不再受其声明所在命名空间的限制。</span><span class="token comment">// 内联命名空间只在大型版本控制里有用。</span><span class="token keyword">namespace</span> X <span class="token punctuation">{</span><span class="token keyword">inline</span> <span class="token keyword">namespace</span> Y <span class="token punctuation">{</span><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment">// namespace Y</span><span class="token punctuation">}</span>  <span class="token comment">// namespace X</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="非成员函数、静态成员函数和全局函数"><a href="#非成员函数、静态成员函数和全局函数" class="headerlink" title="非成员函数、静态成员函数和全局函数"></a>非成员函数、静态成员函数和全局函数</h3><p>使用静态成员函数或命名空间内的非成员函数，尽量不要用裸的全局函数。</p><p>将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关。</p><p>推荐：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">namespace</span> myproject <span class="token punctuation">{</span><span class="token keyword">namespace</span> foo_bar <span class="token punctuation">{</span><span class="token keyword">void</span> <span class="token function">Function1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">Function2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment">// namespace foo_bar</span><span class="token punctuation">}</span>  <span class="token comment">// namespace myproject</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不推荐：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">namespace</span> myproject <span class="token punctuation">{</span><span class="token keyword">class</span> <span class="token class-name">FooBar</span> <span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Function1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Function2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment">// namespace myproject</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义在同一编译单元的函数，被其他编译单元直接调用可能会引入不必要的耦合和链接时依赖；静态成员函数对此尤其敏感。可以考虑提取到新类中，或者将函数置于独立库的命名空间内。</p><p>如果你必须定义非成员函数，又只是在 <code>.cc</code> 文件中使用它，可使用匿名 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/scoping/#namespaces">2.1. 命名空间</a> 或 <code>static</code> 链接关键字（如 <code>static int Foo() {...}</code>）限定其作用域。</p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><blockquote><p>将函数变量尽可能置于最小作用域内，并在变量声明时进行初始化。</p></blockquote><p>C++ 允许在函数的任何位置声明变量。我们提倡在尽可能小的作用域中声明变量，离第一次使用越近越好。这使得代码浏览者更容易定位变量声明的位置，了解变量的类型和初始值。特别是，应使用初始化的方式替代声明再赋值，比如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> i<span class="token punctuation">;</span>i <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 坏——初始化和声明分离</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 好——初始化时声明</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 用花括号初始化更好</span>v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 好——v 一开始就初始化</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>属于 <code>if</code>，<code>while</code> 和 <code>for</code> 语句的变量应当在这些语句中正常地声明，这样子这些变量的作用域就被限制在这些语句中了，举例而言：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token function">strchr</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token char">'/'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> str <span class="token operator">=</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>例外：</strong></p><p>有一个例外，如果变量是一个对象，每次进入作用域都要调用其构造函数，每次退出作用域都要调用其析构函数，这会导致效率降低。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 低效的实现</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Foo f<span class="token punctuation">;</span>                  <span class="token comment">// 构造函数和析构函数分别调用 1000000 次!</span>    f<span class="token punctuation">.</span><span class="token function">DoSomething</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在循环作用域外面声明这类变量要高效的多:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Foo f<span class="token punctuation">;</span>                      <span class="token comment">// 构造函数和析构函数只调用 1 次</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    f<span class="token punctuation">.</span><span class="token function">DoSomething</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="静态和全局变量"><a href="#静态和全局变量" class="headerlink" title="静态和全局变量"></a>静态和全局变量</h3><blockquote><p>禁止定义静态储存周期非POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中的静态变量执行时的构造和析构顺序是未明确的，这将导致代码的不可移植。</p></blockquote><p>禁止使用类的 <a href="http://zh.cppreference.com/w/cpp/language/storage_duration#.E5.AD.98.E5.82.A8.E6.9C.9F">静态储存周期</a> 变量：由于构造和析构函数调用顺序的不确定性，它们会导致难以发现的 bug 。不过 <code>constexpr</code> 变量除外，毕竟它们又不涉及动态初始化或析构。</p><p>静态生存周期的对象，即包括了全局变量，静态变量，静态类成员变量和函数静态变量，都必须是原生数据类型 （POD : Plain Old Data）：即 int，char 和 float，以及 POD 类型的指针、数组和结构体。</p><p>静态变量的构造函数、析构函数和初始化的顺序在 C++ 中是只有部分明确的，甚至随着构建变化而变化，导致难以发现的 bug。所以除了禁用类类型的全局变量，我们也不允许用函数返回值来初始化 POD 变量，除非该函数（比如 <code>getenv()</code> 或 <code>getpid()</code> ）不涉及任何全局变量。函数作用域里的静态变量除外，毕竟它的初始化顺序是有明确定义的，而且只会在指令执行到它的声明那里才会发生。</p><blockquote><p>同一个编译单元内是明确的，静态初始化优先于动态初始化，初始化顺序按照声明顺序进行，销毁则逆序。不同的编译单元之间初始化和销毁顺序属于未明确行为（unspecified behaviour）。</p></blockquote><p>同理，全局和静态变量在程序中断时会被析构，无论所谓中断是从 <code>main()</code> 返回还是对 <code>exit()</code> 的调用。析构顺序正好与构造函数调用的顺序相反。但既然构造顺序未定义，那么析构顺序当然也就不定了。比如，在程序结束时某静态变量已经被析构了，但代码还在跑——比如其它线程——并试图访问它且失败；再比如，一个静态 string 变量也许会在一个引用了前者的其它变量析构之前被析构掉。</p><p>改善以上析构问题的办法之一是用 <code>quick_exit()</code> 来代替 <code>exit()</code> 并中断程序。它们的不同之处是前者不会执行任何析构，也不会执行 <code>atexit()</code> 所绑定的任何 handlers。如果您想在执行 <code>quick_exit()</code> 来中断时执行某 handler（比如刷新 log），您可以把它绑定到 <code>_at_quick_exit()</code>。如果您想在 <code>exit()</code> 和 <code>quick_exit()</code> 都用上该 handler，都绑定上去。</p><p>综上所述，我们只允许 POD 类型的静态变量，即完全禁用 <code>vector</code> (使用 C 数组替代) 和 <code>string</code> (使用 <code>const char []</code>)。</p><p>如果您确实需要一个 <code>class</code> 类型的静态或全局变量，可以考虑在 <code>main()</code> 函数或 <code>pthread_once()</code> 内初始化一个指针且永不回收。注意只能用 raw 指针，别用智能指针，毕竟后者的析构函数涉及到上文指出的不定顺序问题。</p><blockquote><p>上文提及的静态变量泛指静态生存周期的对象，包括: 全局变量，静态变量，静态类成员变量，以及函数静态变量.</p></blockquote><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类是 C++ 中代码的基本单元。显然，它们被广泛使用。本节列举了在写一个类时的主要注意事项。</p><h3 id="构造函数的职责"><a href="#构造函数的职责" class="headerlink" title="构造函数的职责"></a>构造函数的职责</h3><p>构造函数不允许调用虚函数。如果代码允许，直接终止程序是一个合适的处理错误的方式。否则，考虑用 <code>Init()</code> 方法或工厂函数。</p><p>构造函数不得调用虚函数，或尝试报告一个非致命错误。如果对象需要进行有意义的 (non-trivial) 初始化，考虑使用明确的 Init() 方法或使用工厂模式。</p><p>Avoid <code>Init()</code> methods on objects with no other states that affect which public methods may be called (此类形式的半构造对象有时无法正确工作)。</p><h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>在类型定义中，类型转换运算符和单参数构造函数都应当用 <code>explicit</code> 进行标记。一个例外是，拷贝和移动构造函数不应当被标记为 <code>explicit</code>，因为它们并不执行类型转换。</p><p>对于设计目的就是用于对其他类型进行透明包装的类来说，隐式类型转换有时是必要且合适的。这时应当联系项目组长并说明特殊情况。</p><p>不能以一个参数进行调用的构造函数不应当加上 <code>explicit</code>。接受一个 <code>std::initializer_list</code> 作为参数的构造函数也应当省略 <code>explicit</code>，以便支持拷贝初始化（）例如 <code>MyType m = {1, 2};</code>）。</p><h3 id="可拷贝类型和可移动类型"><a href="#可拷贝类型和可移动类型" class="headerlink" title="可拷贝类型和可移动类型"></a>可拷贝类型和可移动类型</h3><p>如果需要就让你的类型可拷贝 / 可移动。作为一个经验法则，如果对于你的用户来说这个拷贝操作不是一眼就能看出来的，那就不要把类型设置为可拷贝。如果让类型可拷贝，一定要同时给出拷贝构造函数和赋值操作的定义，反之亦然。如果让类型可移动，同时移动操作的效率高于拷贝操作，那么就把移动的两个操作（移动构造函数和赋值操作）也给出定义。如果类型不可拷贝，但是移动操作的正确性对用户显然可见，那么把这个类型设置为只可移动并定义移动的两个操作。</p><p>如果定义了拷贝/移动操作，则要保证这些操作的默认实现是正确的。记得时刻检查默认操作的正确性，并且在文档中说明类是可拷贝的且/或可移动的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span> <span class="token keyword">public</span><span class="token operator">:</span>  <span class="token function">Foo</span><span class="token punctuation">(</span>Foo<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">field_</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>field<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment">// 差，只定义了移动构造函数，而没有定义对应的赋值运算符.</span> <span class="token keyword">private</span><span class="token operator">:</span>  Field field_<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于存在对象切割的风险，不要为任何有可能有派生类的对象提供赋值操作或者拷贝 / 移动构造函数（当然也不要继承有这样的成员函数的类）。如果你的基类需要可复制属性，请提供一个 <code>public virtual Clone()</code> 和一个 <code>protected</code> 的拷贝构造函数以供派生类实现。</p><p>如果你的类不需要拷贝 / 移动操作，请显式地通过在 <code>public</code> 域中使用 <code>= delete</code> 或其他手段禁用之。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// MyClass is neither copyable nor movable.</span><span class="token function">MyClass</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyClass<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>MyClass<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyClass<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="结构体-VS-类"><a href="#结构体-VS-类" class="headerlink" title="结构体 VS. 类"></a>结构体 VS. 类</h3><p>仅当只有数据成员时使用 <code>struct</code>， 其它一概使用 <code>class</code>。</p><p>在 C++ 中 <code>struct</code> 和 <code>class</code> 关键字几乎含义一样。我们为这两个关键字添加我们自己的语义理解，以便为定义的数据类型选择合适的关键字。</p><p><code>struct</code> 用来定义包含数据的被动式对象，也可以包含相关的常量，但除了存取数据成员之外，没有别的函数功能。并且存取功能是通过直接访问位域，而非函数调用。除了构造函数，析构函数，<code>Initialize()</code>，<code>Reset()</code>，<code>Validate()</code> 等类似的用于设定数据成员的函数外，不能提供其它功能的函数。</p><p>如果需要更多的函数功能，<code>class</code> 更适合。如果拿不准，就用 <code>class</code>。</p><p>为了和 STL 保持一致，对于仿函数等特性可以不用 <code>class</code> 而是使用 <code>struct</code>。</p><p>注意：类和结构体的成员变量使用不同的 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/#variable-names">命名规则</a>。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><p>我们倾向于按值返回， 否则按引用返回。 避免返回指针， 除非它可以为空。</p><h3 id="编写简短函数"><a href="#编写简短函数" class="headerlink" title="编写简短函数"></a>编写简短函数</h3><p>我们倾向于编写简短，凝练的函数。</p><p>我们承认长函数有时是合理的，因此并不硬性限制函数的长度。如果函数超过 40 行，可以思索一下能不能在不影响程序结构的前提下对其进行分割。</p><p>即使一个长函数现在工作的非常好，一旦有人对其修改，有可能出现新的问题，甚至导致难以发现的 bug。使函数尽量简短，以便于他人阅读和修改代码。</p><p>在处理代码时，你可能会发现复杂的长函数。不要害怕修改现有代码：如果证实这些代码使用 / 调试起来很困难，或者你只需要使用其中的一小段代码，考虑将其分割为更加简短并易于管理的若干函数。</p><h3 id="引用参数"><a href="#引用参数" class="headerlink" title="引用参数"></a>引用参数</h3><p>所有按引用传递的参数必须加上 <code>const</code>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>in<span class="token punctuation">,</span> string <span class="token operator">*</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>事实上这在 Google Code 是一个硬性约定：输入参数是值参或 <code>const</code> 引用，输出参数为指针。输入参数可以是 <code>const</code> 指针，但决不能是非 <code>const</code> 的引用参数，除非特殊要求，比如 <code>swap()</code>。</p><p>有时候，在输入形参中用 <code>const T*</code> 指针比 <code>const T&amp;</code> 更明智。比如：</p><ul><li>可能会传递空指针。</li><li>函数要把指针或对地址的引用赋值给输入形参。</li></ul><p>总而言之，大多时候输入形参往往是 <code>const T&amp;</code>。若用 <code>const T*</code> 则说明输入另有处理。所以若要使用 <code>const T*</code>，则应给出相应的理由，否则会使得读者感到迷惑。</p><h2 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h2><p>最重要的一致性规则是命名管理。命名的风格能让我们在不需要去查找类型声明的条件下快速地了解某个名字代表的含义：类型，变量，函数，常量，宏，等等，甚至。我们大脑中的模式匹配引擎非常依赖这些命名规则。</p><p>命名规则具有一定随意性，但相比按个人喜好命名，一致性更重要，所以无论你认为它们是否重要，规则总归是规则。</p><h3 id="通用命名规则"><a href="#通用命名规则" class="headerlink" title="通用命名规则"></a>通用命名规则</h3><p>函数命名，变量命名，文件命名要有描述性；少用缩写。</p><p>尽可能使用描述性的命名，别心疼空间，毕竟相比之下让代码易于新读者理解更重要。不要用只有项目开发者能理解的缩写，也不要通过砍掉几个字母来缩写单词。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> price_count_reader<span class="token punctuation">;</span>    <span class="token comment">// 无缩写</span><span class="token keyword">int</span> num_errors<span class="token punctuation">;</span>            <span class="token comment">// "num" 是一个常见的写法</span><span class="token keyword">int</span> num_dns_connections<span class="token punctuation">;</span>   <span class="token comment">// 人人都知道 "DNS" 是什么</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> n<span class="token punctuation">;</span>                     <span class="token comment">// 毫无意义.</span><span class="token keyword">int</span> nerr<span class="token punctuation">;</span>                  <span class="token comment">// 含糊不清的缩写.</span><span class="token keyword">int</span> n_comp_conns<span class="token punctuation">;</span>          <span class="token comment">// 含糊不清的缩写.</span><span class="token keyword">int</span> wgc_connections<span class="token punctuation">;</span>       <span class="token comment">// 只有贵团队知道是什么意思.</span><span class="token keyword">int</span> pc_reader<span class="token punctuation">;</span>             <span class="token comment">// "pc" 有太多可能的解释了.</span><span class="token keyword">int</span> cstmr_id<span class="token punctuation">;</span>              <span class="token comment">// 删减了若干字母.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，一些特定的广为人知的缩写是允许的，例如用 <code>i</code> 表示迭代变量和用 <code>T</code> 表示模板参数。</p><p>模板参数的命名应当遵循对应的分类：类型模板参数应当遵循 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/#type-names">类型命名</a> 的规则，而非类型模板应当遵循 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/#variable-names">变量命名</a> 的规则。</p><h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><p>文件名要全部小写，可以包含下划线 (<code>_</code>) 或连字符 (<code>-</code>)，依照项目的约定。如果没有约定，那么 “<code>_</code>” 更好。</p><p>可接受的文件命名示例：</p><ul><li><p><code>my_useful_class.cc</code></p></li><li><p><code>my-useful-class.cc</code></p></li><li><p><code>myusefulclass.cc</code></p></li><li><p><code>myusefulclass_test.cc</code> // <code>_unittest</code> 和 <code>_regtest</code> 已弃用。</p><p>C++ 文件要以 <code>.cc</code> 结尾，头文件以 <code>.h</code> 结尾。专门插入文本的文件则以 <code>.inc</code> 结尾，参见 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/headers/#self-contained-headers">头文件自足</a>。</p></li></ul><p>不要使用已经存在于 <code>/usr/include</code> 下的文件名（即编译器搜索系统头文件的路径），如 <code>db.h</code>。</p><p>通常应尽量让文件名更加明确。<code>http_server_logs.h</code> 就比 <code>logs.h</code> 要好。定义类时文件名一般成对出现，如 <code>foo_bar.h</code> 和 <code>foo_bar.cc</code>，对应于类 <code>FooBar</code>。</p><p>内联函数必须放在 <code>.h</code> 文件中。如果内联函数比较短，就直接放在 <code>.h</code> 中。</p><h3 id="类型命名"><a href="#类型命名" class="headerlink" title="类型命名"></a>类型命名</h3><p>类型名称的每个单词首字母均大写，不包含下划线：<code>MyExcitingClass</code>，<code>MyExcitingEnum</code>。</p><p>所有类型命名 —— 类，结构体，类型定义 (<code>typedef</code>)，枚举，类型模板参数 —— 均使用相同约定，即以大写字母开始，每个单词首字母均大写，不包含下划线。例如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 类和结构体</span><span class="token keyword">class</span> <span class="token class-name">UrlTable</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token class-name">UrlTableTester</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">struct</span> <span class="token class-name">UrlTableProperties</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// 类型定义</span><span class="token keyword">typedef</span> hash_map<span class="token operator">&lt;</span>UrlTableProperties <span class="token operator">*</span><span class="token punctuation">,</span> string<span class="token operator">&gt;</span> PropertiesMap<span class="token punctuation">;</span><span class="token comment">// using 别名</span><span class="token keyword">using</span> PropertiesMap <span class="token operator">=</span> hash_map<span class="token operator">&lt;</span>UrlTableProperties <span class="token operator">*</span><span class="token punctuation">,</span> string<span class="token operator">&gt;</span><span class="token punctuation">;</span><span class="token comment">// 枚举</span><span class="token keyword">enum</span> <span class="token class-name">UrlTableErrors</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><p>变量（包括函数参数）和数据成员名一律小写，单词之间用下划线连接。类的成员变量以下划线结尾，但结构体的就不用，如：<code>a_local_variable</code>，<code>a_struct_data_member</code>，<code>a_class_data_member_</code>。</p><h4 id="普通变量命名"><a href="#普通变量命名" class="headerlink" title="普通变量命名"></a>普通变量命名</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string table_name<span class="token punctuation">;</span>  <span class="token comment">// 好 - 用下划线.</span>string tablename<span class="token punctuation">;</span>   <span class="token comment">// 好 - 全小写.</span>string tableName<span class="token punctuation">;</span>  <span class="token comment">// 差 - 混合大小写</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="类数据成员"><a href="#类数据成员" class="headerlink" title="类数据成员"></a>类数据成员</h4><p>不管是静态的还是非静态的，类数据成员都可以和普通变量一样，但要接下划线。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">TableInfo</span> <span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">private</span><span class="token operator">:</span>  string table_name_<span class="token punctuation">;</span>  <span class="token comment">// 好 - 后加下划线.</span>  string tablename_<span class="token punctuation">;</span>   <span class="token comment">// 好.</span>  <span class="token keyword">static</span> Pool<span class="token operator">&lt;</span>TableInfo<span class="token operator">&gt;</span><span class="token operator">*</span> pool_<span class="token punctuation">;</span>  <span class="token comment">// 好.</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="结构体变量"><a href="#结构体变量" class="headerlink" title="结构体变量"></a>结构体变量</h4><p>不管是静态的还是非静态的，结构体数据成员都可以和普通变量一样，不用像类那样接下划线：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">UrlTableProperties</span> <span class="token punctuation">{</span>  string name<span class="token punctuation">;</span>  <span class="token keyword">int</span> num_entries<span class="token punctuation">;</span>  <span class="token keyword">static</span> Pool<span class="token operator">&lt;</span>UrlTableProperties<span class="token operator">&gt;</span><span class="token operator">*</span> pool<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结构体与类的使用讨论，参考 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/classes/#structs-vs-classes">结构体 vs. 类</a>。</p><h3 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h3><p>声明为 <code>constexpr</code> 或 <code>const</code> 的变量，或在程序运行期间其值始终保持不变的，命名时以 “k” 开头，大小写混合。例如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> kDaysInAWeek <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>所有具有静态存储类型的变量（例如静态变量或全局变量， 参见 <a href="http://en.cppreference.com/w/cpp/language/storage_duration#Storage_duration">存储类型</a>）都应当以此方式命名。对于其他存储类型的变量，如自动变量等，这条规则是可选的。如果不采用这条规则，就按照一般的变量命名规则。</p><h3 id="函数命名"><a href="#函数命名" class="headerlink" title="函数命名"></a>函数命名</h3><p>常规函数使用大小写混合，取值和设值函数则要求与变量名匹配：<code>MyExcitingFunction()</code>，<code>MyExcitingMethod()</code>，<code>my_exciting_member_variable()</code>，<code>set_my_exciting_member_variable()</code>。</p><p>一般来说，函数名的每个单词首字母大写（即 “驼峰变量名” 或 “帕斯卡变量名”），没有下划线。对于首字母缩写的单词，更倾向于将它们视作一个单词进行首字母大写（例如，写作 <code>StartRpc()</code> 而非 <code>StartRPC()</code>）。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">AddTableEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">DeleteUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">OpenFileOrDie</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（同样的命名规则同时适用于类作用域与命名空间作用域的常量， 因为它们是作为 API 的一部分暴露对外的， 因此应当让它们看起来像是一个函数， 因为在这时， 它们实际上是一个对象而非函数的这一事实对外不过是一个无关紧要的实现细节。）</p><p>取值和设值函数的命名与变量一致。一般来说它们的名称与实际的成员变量对应， 但并不强制要求。例如 <code>int count()</code> 与 <code>void set_count(int count)</code>。</p><h3 id="命名空间命名"><a href="#命名空间命名" class="headerlink" title="命名空间命名"></a>命名空间命名</h3><p>命名空间以小写字母命名。最高级命名空间的名字取决于项目名称。要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突。</p><p>顶级命名空间的名称应当是项目名或者是该命名空间中的代码所属的团队的名字。命名空间中的代码， 应当存放于和命名空间的名字匹配的文件夹或其子文件夹中。</p><p>注意 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/#general-naming-rules">不使用缩写作为名称</a> 的规则同样适用于命名空间。命名空间中的代码极少需要涉及命名空间的名称， 因此没有必要在命名空间中使用缩写。</p><p>要避免嵌套的命名空间与常见的顶级命名空间发生名称冲突。由于名称查找规则的存在， 命名空间之间的冲突完全有可能导致编译失败。尤其是， 不要创建嵌套的 <code>std</code> 命名空间。建议使用更独特的项目标识符 （<code>websearch::index</code>， <code>websearch::index_util</code>） 而非常见的极易发生冲突的名称 （比如 <code>websearch::util</code>）。</p><p>对于 <code>internal</code> 命名空间， 要当心加入到同一 <code>internal</code> 命名空间的代码之间发生冲突 （由于内部维护人员通常来自同一团队， 因此常有可能导致冲突）。在这种情况下， 请使用文件名以使得内部名称独一无二 （例如对于 <code>frobber.h</code>， 使用 <code>websearch::index::frobber_internal</code>）。</p><h3 id="枚举命名"><a href="#枚举命名" class="headerlink" title="枚举命名"></a>枚举命名</h3><p>枚举的命名应当和 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/#constant-names">常量</a> 或 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/#macro-names">宏</a> 一致: <code>kEnumName</code> 或是 <code>ENUM_NAME</code>。</p><p>单独的枚举值应该优先采用 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/#constant-names">常量</a> 的命名方式。但 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/#macro-names">宏</a> 方式的命名也可以接受。枚举名 <code>UrlTableErrors</code> （以及 <code>AlternateUrlTableErrors</code>） 是类型， 所以要用大小写混合的方式。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token class-name">UrlTableErrors</span> <span class="token punctuation">{</span>    kOK <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>    kErrorOutOfMemory<span class="token punctuation">,</span>    kErrorMalformedInput<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">enum</span> <span class="token class-name">AlternateUrlTableErrors</span> <span class="token punctuation">{</span>    OK <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>    OUT_OF_MEMORY <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>    MALFORMED_INPUT <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2009 年 1 月之前， 我们一直建议采用 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/#macro-names">宏</a> 的方式命名枚举值。由于枚举值和宏之间的命名冲突， 直接导致了很多问题。由此， 这里改为优先选择常量风格的命名方式。新代码应该尽可能优先使用常量风格。但是老代码没必要切换到常量风格， 除非宏风格确实会产生编译期问题。</p><h3 id="宏命名"><a href="#宏命名" class="headerlink" title="宏命名"></a>宏命名</h3><p>你并不打算 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/#preprocessor-macros">使用宏</a>， 对吧? 如果你一定要用， 像这样命名: <code>MY_MACRO_THAT_SCARES_SMALL_CHILDREN</code>。</p><p>参考 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/others/#preprocessor-macros">预处理宏</a>； 通常 <em>不应该</em> 使用宏。如果不得不用， 其命名像枚举命名一样全部大写， 使用下划线:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">ROUND</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>#define PI_ROUNDED <span class="token number">3.0</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="命名规则的特例"><a href="#命名规则的特例" class="headerlink" title="命名规则的特例"></a>命名规则的特例</h3><p>如果你命名的实体与已有 C/C++ 实体相似， 可参考现有命名策略.</p><p><code>bigopen()</code>: 函数名， 参照 <code>open()</code> 的形式</p><p><code>uint</code>: <code>typedef</code></p><p><code>bigpos</code>: <code>struct</code> 或 <code>class</code>， 参照 <code>pos</code> 的形式</p><p><code>sparse_hash_map</code>: STL 型实体； 参照 STL 命名约定</p><p><code>LONGLONG_MAX</code>: 常量， 如同 <code>INT_MAX</code></p>]]></content>
      
      
      <categories>
          
          <category> 编程基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 多线程编程（四）：生产者消费者模型</title>
      <link href="2022/02/08/cpp-notes-6/"/>
      <url>2022/02/08/cpp-notes-6/</url>
      
        <content type="html"><![CDATA[<h1 id="C-多线程编程（四）：生产者消费者模型"><a href="#C-多线程编程（四）：生产者消费者模型" class="headerlink" title="C++ 多线程编程（四）：生产者消费者模型"></a>C++ 多线程编程（四）：生产者消费者模型</h1><h2 id="1-生产者消费者模型简介"><a href="#1-生产者消费者模型简介" class="headerlink" title="1. 生产者消费者模型简介"></a>1. 生产者消费者模型简介</h2><p><strong>生产者和消费者问题是线程模型中的经典问题：</strong>生产者和消费者在同一时间段内共用同一个存储空间，生产者往存储空间中添加产品，消费者从存储空间中取走产品；当存储空间为空时，消费者阻塞，当存储空间满时，生产者阻塞。</p><p><strong>简单来说，这个模型是由两类线程构成：</strong></p><ul><li>生产者线程：“生产”产品，并把产品放到一个队列里；</li><li>消费者线程：“消费”产品，具体是从队列中取出产品。</li></ul><p><strong>为什么使用生产者消费者模型？</strong></p><p>在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据，否则新生产的数据也没有地方存放；同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者，不然没有数据消费者也没办法消费。</p><p>为了达到生产者生产数据和消费者消费数据之间的<strong>平衡</strong>，就需要一个缓冲区用来存储生产者生产的数据，所以就引入了生产者-消费者模式。</p><h2 id="2-实现生产者消费者模型"><a href="#2-实现生产者消费者模型" class="headerlink" title="2. 实现生产者消费者模型"></a>2. 实现生产者消费者模型</h2><p>生产者消费者模型可以分为：单生产者-单消费者模型，单生产者-多消费者模型，多生产者-单消费者模型，多生产者-多消费者模型。我这里主要介绍单生产者-单消费者模型，其他模型可以参考下面几个网址：</p><ul><li><a href="https://blog.csdn.net/chenxun_2010/article/details/49848865">c++ 11 多线线程系列———–生产者消费者</a></li><li><a href="https://blog.51cto.com/u_15357586/3790039">C++多线程——生产者/消费者模式/条件变量(Condition Variable)</a></li></ul><p>顾名思义，单生产者-单消费者模型就是只有一个生产者、一个消费者的情况，这是最简单的生产者消费者模型。实现代码如下所示：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;deque&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;condition_variable&gt;</span></span>std<span class="token double-colon punctuation">::</span>deque<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> q<span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>mutex mu<span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>condition_variable cond<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">function_1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">locker</span><span class="token punctuation">(</span>mu<span class="token punctuation">)</span><span class="token punctuation">;</span>        q<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>        locker<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cond<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Notify one waiting thread, if there is one.</span>        count<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">function_2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>data <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">locker</span><span class="token punctuation">(</span>mu<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            cond<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>locker<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Unlock mu and wait to be notified</span>        data <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        q<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        locker<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"t2 got a value from t1: "</span> <span class="token operator">&lt;&lt;</span> data <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>function_1<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>function_2<span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码有三个注意事项：</p><ol><li><p>在function_2中，在判断队列是否为空的时候，使用的是<code>while(q.empty())</code>，而不是<code>if(q.empty())</code>.</p><p>这是因为wait()从阻塞到返回，不一定就是由于notify_one()函数造成的，还有可能由于系统的不确定原因唤醒（可能和条件变量的实现机制有关），这个的时机和频率都是不确定的，被称作伪唤醒，如果在错误的时候被唤醒了，执行后面的语句就会错误，所以需要再次判断队列是否为空，如果还是为空，就继续wait()阻塞。</p></li><li><p>在管理互斥锁的时候，使用的是<code>std::unique_lock</code>而不是<code>std::lock_guard</code>，而且事实上也不能使用<code>std::lock_guard</code>。</p><p>这需要先解释下wait()函数所做的事情。可以看到，在wait()函数之前，使用互斥锁保护了，如果wait的时候什么都没做，岂不是一直持有互斥锁？那生产者也会一直卡住，不能够将数据放入队列中了。所以，wait()函数会先调用互斥锁的unlock()函数，然后再将自己睡眠，在被唤醒后，又会继续持有锁，保护后面的队列操作。而lock_guard没有lock和unlock接口，而unique_lock提供了。这就是必须使用unique_lock的原因。</p></li><li><p>使用细粒度锁，尽量减小锁的范围。</p><p>在notify_one()的时候，不需要处于互斥锁的保护范围内，所以在唤醒条件变量之前可以将锁unlock()。还可以将<code>cond.wait(locker);</code>换一种写法，wait()的第二个参数可以传入一个函数表示检查条件，这里使用lambda函数最为简单，如果这个函数返回的是true，wait()函数不会阻塞会直接返回，如果这个函数返回的是false，wait()函数就会阻塞着等待唤醒，如果被伪唤醒，会继续判断函数返回值。</p></li></ol><h2 id="3-实际应用生产者消费者模型"><a href="#3-实际应用生产者消费者模型" class="headerlink" title="3. 实际应用生产者消费者模型"></a>3. 实际应用生产者消费者模型</h2><blockquote><p>这里介绍一个个人认为比较好用的编程方法。</p></blockquote><p>在我们的实际开发中，比如在SLAM中，可能是定位一个线程，建图一个线程，定位线程会计算出目前的位置，而建图线程需要根据这个位置来建立地图。</p><p>如果采用上面这样的方式，代码就不是很简洁，并且你需要保证一些变量是全局的，两个线程都能够接触到，这样零零碎碎的变量比较多，管理起来很麻烦。</p><p>这里我推荐构建一个生产者消费者模型的类，并且最好是使用单例模式的模板类。这样的话就可以非常简单的在两个线程中通信，并且后续如果要对通信方式进行修改，也不需要修改到定位和建图的代码，封装性更好！</p><p>下面是一个简单的例子：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">THREAD_TEST_DATATRANS_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">THREAD_TEST_DATATRANS_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;list&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;condition_variable&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">Trans</span> <span class="token expression"><span class="token class-name">DataTrans</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">Instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">DataTrans</span><span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> m_queue<span class="token punctuation">;</span><span class="token comment">//队列</span>    std<span class="token double-colon punctuation">::</span>mutex m_mutex<span class="token punctuation">;</span><span class="token comment">//全局互斥锁</span>    std<span class="token double-colon punctuation">::</span>condition_variable_any m_notEmpty<span class="token punctuation">;</span><span class="token comment">//全局条件变量（不为空）</span>    std<span class="token double-colon punctuation">::</span>condition_variable_any m_notFull<span class="token punctuation">;</span><span class="token comment">//全局条件变量（不为满）</span>    <span class="token keyword">int</span> m_maxSize<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//队列最大容量</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token comment">//队列为空</span>    <span class="token keyword">bool</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> m_queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//队列已满</span>    <span class="token keyword">bool</span> <span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> m_queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> m_maxSize<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//构造函数</span>    <span class="token function">DataTrans</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token operator">-&gt;</span>m_maxSize <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 获取单实例对象</span>    <span class="token keyword">static</span> DataTrans <span class="token operator">&amp;</span><span class="token function">Instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment">/**         * 局部静态特性的方式实现单实例。         * 静态局部变量只在当前函数内有效，其他函数无法访问。         * 静态局部变量只在第一次被调用的时候初始化，也存储在静态存储区，生命周期从第一次被初始化起至程序结束止。         */</span>        <span class="token keyword">static</span> DataTrans instance<span class="token punctuation">;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">product</span><span class="token punctuation">(</span><span class="token keyword">const</span> T <span class="token operator">&amp;</span>v<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">locker</span><span class="token punctuation">(</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment">//生产者等待"产品队列缓冲区不为满"这一条件发生.</span>            m_notFull<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        m_queue<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        locker<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m_notEmpty<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">consumption</span><span class="token punctuation">(</span>T <span class="token operator">&amp;</span>v<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">locker</span><span class="token punctuation">(</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token comment">// 消费者等待"产品队列缓冲区不为空"这一条件发生.</span>            m_notEmpty<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//在队列里面消费一个元素,同时通知队列不满这个信号量</span>        v <span class="token operator">=</span> m_queue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m_queue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        locker<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m_notFull<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">//THREAD_TEST_DATATRANS_H</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用上面这个类的简单示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"DataTrans.h"</span></span><span class="token keyword">void</span> <span class="token function">function_1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Trans<span class="token punctuation">.</span><span class="token function">product</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"product:\t"</span> <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>        count<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">function_2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> data <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>data <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Trans<span class="token punctuation">.</span><span class="token function">consumption</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> data <span class="token operator">&lt;&lt;</span> <span class="token string">"\tis consumed!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>function_1<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>function_2<span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 多线程编程（三）：单例模式</title>
      <link href="2022/02/04/cpp-notes-5/"/>
      <url>2022/02/04/cpp-notes-5/</url>
      
        <content type="html"><![CDATA[<h1 id="C-多线程编程（三）：单例模式"><a href="#C-多线程编程（三）：单例模式" class="headerlink" title="C++ 多线程编程（三）：单例模式"></a>C++ 多线程编程（三）：单例模式</h1><h2 id="1-单例模式介绍"><a href="#1-单例模式介绍" class="headerlink" title="1. 单例模式介绍"></a>1. 单例模式介绍</h2><p>单例模式(Singleton Pattern)是设计模式的一种，其特点是只提供<strong>唯一</strong>一个类的实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。</p><p>定义一个单例类：</p><ol><li>私有化它的构造函数，以防止外界创建单例类的对象；</li><li>使用类的私有静态指针变量指向类的唯一实例；</li><li>使用一个公有的静态方法获取该实例。</li></ol><p>具体运用场景：</p><ol><li>设备管理器，系统中可能有多个设备，但是只有一个设备管理器，用于管理设备驱动;</li><li>数据池，用来缓存数据的数据结构，需要在一处写，多处读取或者多处写，多处读取;</li></ol><h2 id="2-单例模式的实现"><a href="#2-单例模式的实现" class="headerlink" title="2. 单例模式的实现"></a>2. 单例模式的实现</h2><h3 id="2-1-懒汉式"><a href="#2-1-懒汉式" class="headerlink" title="2.1 懒汉式"></a>2.1 懒汉式</h3><p>懒汉式(Lazy-Initialization)的方法是直到使用时才实例化对象，也就说直到调用get_instance() 方法的时候才 new 一个单例的对象， 如果不被调用就不会占用内存。</p><h4 id="2-1-1-最基础的懒汉式"><a href="#2-1-1-最基础的懒汉式" class="headerlink" title="2.1.1 最基础的懒汉式"></a>2.1.1 最基础的懒汉式</h4><p>这是最基础最简单的懒汉式，大多数人写懒汉式的话可能就是这种形式的，毕竟如果不在多线程中使用的话这里是没有任何问题的。</p><p>不过在多线程并发的情况下，这样无法保证实例唯一，甚至这样的做法是失效的。</p><p>下面是懒汉式实现和多线程中的测试代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;armadillo&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">Single</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 获取单实例对象</span>    <span class="token keyword">static</span> Single <span class="token operator">*</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>m_instance_ptr <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            m_instance_ptr <span class="token operator">=</span> <span class="token keyword">new</span> Single<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> m_instance_ptr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 打印实例地址</span>    <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"我的内存地址是:"</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Single</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"析构函数"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 禁止外部拷贝构造</span>    <span class="token function">Single</span><span class="token punctuation">(</span><span class="token keyword">const</span> Single <span class="token operator">&amp;</span>signal<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    <span class="token comment">// 禁止外部赋值操作</span>    <span class="token keyword">const</span> Single <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Single <span class="token operator">&amp;</span>signal<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> Single <span class="token operator">*</span>m_instance_ptr<span class="token punctuation">;</span>    <span class="token comment">// 禁止外部构造</span>    <span class="token function">Single</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"构造函数"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Single <span class="token operator">*</span>Single<span class="token double-colon punctuation">::</span>m_instance_ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//假设创建线程之前有一些其他工作要做</span>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Single <span class="token operator">*</span>single <span class="token operator">=</span> <span class="token class-name">Single</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    single<span class="token operator">-&gt;</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>thread T<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>i<span class="token operator">:</span> T<span class="token punctuation">)</span>        i <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//下面两个循环二选一即可！</span>    <span class="token comment">//for (auto &amp;i: T)</span>    <span class="token comment">//    i.detach();</span>    <span class="token comment">//getchar();</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>i<span class="token operator">:</span> T<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            i<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个运行结果是：</p><pre class="line-numbers language-none"><code class="language-none">构造函数构造函数我的内存地址是:构造函数0x7f6c14000b20构造函数构造函数我的内存地址是:0x7f6c04000b20构造函数我的内存地址是:0x7f6bfc000b20构造函数构造函数我的内存地址是:我的内存地址是:0x7f6c1c000b200x7f6c0c000b20构造函数我的内存地址是:0x7f6bf8000b20构造函数我的内存地址是:我的内存地址是:0x7f6bec000b20我的内存地址是:我的内存地址是:0x7f6bf4000b200x7f6be4000b200x7f6be8000b20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到这里的实例并不是唯一的！这种方式会导致两个问题：</p><ol><li><p><strong>线程安全的问题</strong></p><p>当多线程获取单例时有可能引发竞态条件：第一个线程在if中判断 <code>m_instance_ptr</code>是空的，于是开始实例化单例；同时第2个线程也尝试获取单例，这个时候判断<code>m_instance_ptr</code>还是空的，于是也开始实例化单例；这样就会实例化出两个对象，这就是线程安全问题的由来；</p><p><strong>解决办法</strong>：加锁</p></li><li><p><strong>内存泄漏</strong></p><p>注意到类中只负责new出对象，却没有负责delete对象，因此只有构造函数被调用，析构函数却没有被调用，因此会导致内存泄漏。</p><p><strong>解决办法</strong>：使用共享指针</p></li></ol><h4 id="2-1-2-线程安全、内存安全的懒汉式"><a href="#2-1-2-线程安全、内存安全的懒汉式" class="headerlink" title="2.1.2 线程安全、内存安全的懒汉式"></a>2.1.2 线程安全、内存安全的懒汉式</h4><p>这里我们可以使用智能指针、锁来保证这个懒汉式是线程安全且内存安全的。示例代码如下所示：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;armadillo&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span> <span class="token comment">// shared_ptr</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span>  <span class="token comment">// mutex</span></span><span class="token keyword">class</span> <span class="token class-name">Single</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">typedef</span> std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Single<span class="token operator">&gt;</span> Ptr<span class="token punctuation">;</span>    <span class="token comment">// 获取单实例对象</span>    <span class="token keyword">static</span> Ptr <span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment">// "double checked lock"</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>m_instance_ptr <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            std<span class="token double-colon punctuation">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lk</span><span class="token punctuation">(</span>m_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>m_instance_ptr <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                m_instance_ptr <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>Single<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> Single<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> m_instance_ptr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 打印实例地址</span>    <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"我的内存地址是:"</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//使用智能指针的时候不能够禁止外部析构！</span>    <span class="token operator">~</span><span class="token function">Single</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"析构函数"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 禁止外部拷贝构造</span>    <span class="token function">Single</span><span class="token punctuation">(</span><span class="token keyword">const</span> Single <span class="token operator">&amp;</span>signal<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    <span class="token comment">// 禁止外部赋值操作</span>    <span class="token keyword">const</span> Single <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Single <span class="token operator">&amp;</span>signal<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> Ptr m_instance_ptr<span class="token punctuation">;</span>    <span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>mutex m_mutex<span class="token punctuation">;</span>    <span class="token comment">// 禁止外部构造</span>    <span class="token function">Single</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"构造函数"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// initialization static variables out of class</span>Single<span class="token operator">:</span><span class="token base-clause"><span class="token operator">:</span><span class="token class-name">Ptr</span> Single<span class="token double-colon punctuation">::</span><span class="token class-name">m_instance_ptr</span> <span class="token operator">=</span> <span class="token keyword">nullptr</span></span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span>mutex Single<span class="token double-colon punctuation">::</span>m_mutex<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//假设开始前有准备工作要进行</span>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Single<span class="token double-colon punctuation">::</span>Ptr single <span class="token operator">=</span> <span class="token class-name">Single</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    single<span class="token operator">-&gt;</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>thread T<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>i<span class="token operator">:</span> T<span class="token punctuation">)</span>        i <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//下面两个循环二选一即可！</span>    <span class="token comment">//for (auto &amp;i: T)</span>    <span class="token comment">//    i.detach();</span>    <span class="token comment">//getchar();</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>i<span class="token operator">:</span> T<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            i<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个运行结果是：</p><pre class="line-numbers language-none"><code class="language-none">构造函数我的内存地址是:0x7f08b4000b20我的内存地址是:0x7f08b4000b20我的内存地址是:0x7f08b4000b20我的内存地址是:0x7f08b4000b20我的内存地址是:0x7f08b4000b20我的内存地址是:0x7f08b4000b20我的内存地址是:0x7f08b4000b20我的内存地址是:0x7f08b4000b20我的内存地址是:0x7f08b4000b20我的内存地址是:0x7f08b4000b20析构函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>shared_ptr和mutex都是C++11的标准，以上这种方法的优点是：</p><ul><li><p>基于shared_ptr，用了C++比较倡导的 RAII思想，用对象管理资源。</p><p>当shared_ptr析构的时候，new出来的对象也会被delete掉，以此避免内存泄漏。</p></li><li><p>加了锁，使用互斥量来达到线程安全。</p><p>这里使用了两个if判断语句的技术称为<strong>双检锁</strong>。好处是，只有判断指针为空的时候才加锁，避免每次调用get_instance的方法都加锁，锁的开销毕竟还是有点大的。</p></li></ul><p>不足之处在于：</p><ul><li>使用智能指针会要求用户也得使用智能指针，非必要不应该提出这种约束; </li><li>使用锁也有开销; </li><li>代码量也增多了，实现上我们希望越简单越好。</li></ul><p>还有更加严重的问题，在某些平台（与编译器和指令集架构有关），双检锁会失效！具体可以看<a href="http://www.drdobbs.com/cpp/c-and-the-perils-of-double-checked-locki/184405726">这篇文章</a>，解释了为什么会发生这样的事情。</p><p>因此这里还有第三种的基于 Magic Staic的方法达到线程安全</p><h4 id="2-1-3-magic-static（局部静态变量）"><a href="#2-1-3-magic-static（局部静态变量）" class="headerlink" title="2.1.3 magic static（局部静态变量）"></a>2.1.3 magic static（局部静态变量）</h4><p>这种方法又叫做<a href="https://stackoverflow.com/questions/449436/singleton-instance-declared-as-static-variable-of-getinstance-method-is-it-thre/449823#449823">Meyers’ Singleton</a>， 是《Effective C++》系列书籍的作者Meyers提出的。所用到的特性是在C++11标准中的<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2660.htm">Magic Static</a>特性：</p><blockquote><p>If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.<br>如果当变量在初始化的时候，并发同时进入声明语句，并发线程将会阻塞等待初始化结束。</p></blockquote><p>这样保证了并发线程在获取静态局部变量的时候一定是初始化过的，所以具有线程安全性。</p><p><a href="https://stackoverflow.com/questions/246564/what-is-the-lifetime-of-a-static-variable-in-a-c-function">C++静态变量的生存期</a> 是从声明到程序结束，这也是一种懒汉式。</p><p>示例代码如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;armadillo&gt;</span></span><span class="token comment">//静态局部变量的懒汉单例（C++11线程安全）</span><span class="token comment">///  内部静态变量的懒汉实现</span><span class="token keyword">class</span> <span class="token class-name">Single</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 获取单实例对象</span>    <span class="token keyword">static</span> Single <span class="token operator">&amp;</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment">/**         * 局部静态特性的方式实现单实例。         * 静态局部变量只在当前函数内有效，其他函数无法访问。         * 静态局部变量只在第一次被调用的时候初始化，也存储在静态存储区，生命周期从第一次被初始化起至程序结束止。         */</span>        <span class="token keyword">static</span> Single signal<span class="token punctuation">;</span>        <span class="token keyword">return</span> signal<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 打印实例地址</span>    <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"我的实例内存地址是:"</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Single</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"析构函数"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 禁止外部拷贝构造</span>    <span class="token function">Single</span><span class="token punctuation">(</span><span class="token keyword">const</span> Single <span class="token operator">&amp;</span>signal<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    <span class="token comment">// 禁止外部赋值操作</span>    <span class="token keyword">const</span> Single <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Single <span class="token operator">&amp;</span>signal<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token comment">// 禁止外部构造</span>    <span class="token function">Single</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"构造函数"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//假设开始前有准备工作要进行</span>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Single <span class="token operator">&amp;</span>single <span class="token operator">=</span> <span class="token class-name">Single</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    single<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>thread T<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>i<span class="token operator">:</span> T<span class="token punctuation">)</span>        i <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//下面两个循环二选一即可！</span>    <span class="token comment">//for (auto &amp;i: T)</span>    <span class="token comment">//    i.detach();</span>    <span class="token comment">//getchar();</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>i<span class="token operator">:</span> T<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            i<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个运行结果是：</p><pre class="line-numbers language-none"><code class="language-none">构造函数我的实例内存地址是:我的实例内存地址是:0x55c6ee5541d00x55c6ee5541d0我的实例内存地址是:0x55c6ee5541d0我的实例内存地址是:我的实例内存地址是:0x55c6ee5541d094312890450384我的实例内存地址是:我的实例内存地址是:0x55c6ee5541d0我的实例内存地址是:0x55c6ee5541d00x55c6ee5541d0我的实例内存地址是:0x55c6ee5541d0我的实例内存地址是:0x55c6ee5541d0析构函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>这是最推荐的一种单例实现方式：</strong></p><ol><li>通过局部静态变量的特性保证了线程安全 (C++11, GCC &gt; 4.3, VS2015支持该特性)；</li><li>不需要使用共享指针，代码简洁；</li><li>注意在使用的时候需要声明单例的引用 <code>Single&amp;</code> 才能获取对象。</li></ol><p>另外网上有人的实现返回指针而不是返回引用：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> Singleton<span class="token operator">*</span> <span class="token function">get_instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">&amp;</span>instance<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样做并不好，理由主要是无法避免用户使用<code>delete instance</code>导致对象被提前销毁。还是建议大家使用返回引用的方式。</p><h3 id="2-2-饿汉式"><a href="#2-2-饿汉式" class="headerlink" title="2.2 饿汉式"></a>2.2 饿汉式</h3><p>饿汉式（Eager Singleton）：指单例实例在程序运行时被立即执行初始化。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;armadillo&gt;</span></span><span class="token keyword">class</span> <span class="token class-name">Single</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment">// 获取单实例对象</span>    <span class="token keyword">static</span> Single <span class="token operator">&amp;</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 打印实例地址</span>    <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"我的实例内存地址是:"</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">this</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token operator">~</span><span class="token function">Single</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"析构函数"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// 禁止外部拷贝构造</span>    <span class="token function">Single</span><span class="token punctuation">(</span><span class="token keyword">const</span> Single <span class="token operator">&amp;</span>signal<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>    <span class="token comment">// 禁止外部赋值操作</span>    <span class="token keyword">const</span> Single <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Single <span class="token operator">&amp;</span>signal<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">static</span> Single instance<span class="token punctuation">;</span>    <span class="token comment">// 禁止外部构造</span>    <span class="token function">Single</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"构造函数"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">// initialize defaultly</span>Single Single<span class="token double-colon punctuation">::</span>instance<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//假设开始前有准备工作要进行</span>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Single <span class="token operator">&amp;</span>single <span class="token operator">=</span> <span class="token class-name">Single</span><span class="token double-colon punctuation">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    single<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>thread T<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>i<span class="token operator">:</span> T<span class="token punctuation">)</span>        i <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//下面两个循环二选一即可！</span>    <span class="token comment">//for (auto &amp;i: T)</span>    <span class="token comment">//    i.detach();</span>    <span class="token comment">//getchar();</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>i<span class="token operator">:</span> T<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            i<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一个运行结果是：</p><pre class="line-numbers language-none"><code class="language-none">构造函数我的实例内存地址是:我的实例内存地址是:0x55ee2cf391380x55ee2cf39138我的实例内存地址是:0x55ee2cf39138我的实例内存地址是:0x55ee2cf39138我的实例内存地址是:我的实例内存地址是:我的实例内存地址是:0x55ee2cf39138我的实例内存地址是:我的实例内存地址是:0x55ee2cf391380x55ee2cf39138我的实例内存地址是:0x55ee2cf391380x55ee2cf391380x55ee2cf39138析构函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于在main函数之前初始化，所以没有线程安全的问题。但是潜在问题在于no-local static对象（函数外的static对象）在不同编译单元中的初始化顺序是未定义的。</p><p>也就是说，<code>static Singleton instance</code>和<code>static Singleton&amp; getInstance()</code>二者的初始化顺序不确定，如果在初始化完成之前调用<code>getInstance() </code>方法会返回一个未定义的实例。</p><h2 id="3-何时使用单例模式"><a href="#3-何时使用单例模式" class="headerlink" title="3. 何时使用单例模式"></a>3. 何时使用单例模式</h2><blockquote><p>选自stackoverflow上的高分回答：<a href="https://stackoverflow.com/questions/86582/singleton-how-should-it-be-used">singleton-how-should-it-be-used</a></p></blockquote><p><strong>Use a Singleton if:</strong></p><ul><li>You need to have one and only one object of a type in system</li></ul><p><strong>Do not use a Singleton if:</strong></p><ul><li>You want to save memory</li><li>You want to try something new</li><li>You want to show off how much you know</li><li>Because everyone else is doing it (See <a href="http://en.wikipedia.org/wiki/Cargo_cult_programming">cargo cult programmer</a> in wikipedia)</li><li>In user interface widgets</li><li>It is supposed to be a cache</li><li>In strings</li><li>In Sessions</li><li>I can go all day long</li></ul><p><strong>How to create the best singleton:</strong></p><ul><li>The smaller, the better. I am a minimalist</li><li>Make sure it is thread safe</li><li>Make sure it is never null</li><li>Make sure it is created only once</li><li>Lazy or system initialization? Up to your requirements</li><li>Sometimes the OS or the JVM creates singletons for you (e.g. in Java every class definition is a singleton)</li><li>Provide a destructor or somehow figure out how to dispose resources</li><li>Use little memory</li></ul><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><ul><li>Eager Singleton 虽然是线程安全的，但存在潜在问题；</li><li>Lazy Singleton通常需要加锁来保证线程安全，但局部静态变量版本在C++11后是线程安全的；</li><li>局部静态变量版本（Meyers Singleton）最优雅。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记（八）：应用CNN和RNN解决数独问题</title>
      <link href="2022/01/25/machine-learning-8/"/>
      <url>2022/01/25/machine-learning-8/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习笔记（八）：应用CNN和RNN解决数独问题"><a href="#机器学习笔记（八）：应用CNN和RNN解决数独问题" class="headerlink" title="机器学习笔记（八）：应用CNN和RNN解决数独问题"></a>机器学习笔记（八）：应用CNN和RNN解决数独问题</h1><blockquote><p>这篇博客整理于我选修的《机器学习》课程的大作业。</p></blockquote><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>数独（shù dú, Sudoku）是源自18世纪<a href="https://baike.baidu.com/item/%E7%91%9E%E5%A3%AB/131482">瑞士</a>的一种数学游戏。是一种运用纸、笔进行演算的<a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E6%B8%B8%E6%88%8F/12814189">逻辑游戏</a>。玩家需要根据9×9盘面上的已知数字，推理出所有剩余空格的数字，并满足每一行、每一列、每一个粗线宫（3*3）内的数字均含1-9，不重复。</p><p>数独盘面是个九宫，每一宫又分为九个小格。在这八十一格中给出一定的已知数字和解题条件，利用逻辑和推理，在其他的空格上填入1-9的数字。使1-9每个数字在每一行、每一列和每一宫中都只出现一次，所以又称“九宫格”。</p><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>这个数据集包含了1百万数独的数据，你可以在<a href="https://www.kaggle.com/bryanpark/sudoku">这里</a>找到它。</p><p>数据集包含2列。<code>quizzes</code>栏目是未解的游戏，<code>solutions</code>栏目各自的已解游戏。每场比赛都由81个数字组成的字符串表示。以下是从字符串转换而来的9x9数独。数字0代表未解游戏中的空白位置。</p><p>示例的数据如下所示：</p><p><img src="/images/machine-learning-8/sudoku_data.png"></p><p>数据集包含2列。<code>quizzes</code>栏目是未解的游戏，<code>solutions</code>栏目各自的已解游戏。每场比赛都由81个数字组成的字符串表示。以下是从字符串转换而来的9x9数独。数字0代表未解游戏中的空白位置。</p><pre class="line-numbers language-none"><code class="language-none">[[0 0 4 3 0 0 2 0 9] [0 0 5 0 0 9 0 0 1] [0 7 0 0 6 0 0 4 3] [0 0 6 0 0 2 0 8 7] [1 9 0 0 0 7 4 0 0] [0 5 0 0 8 3 0 0 0] [6 0 0 0 0 0 1 0 5] [0 0 3 5 0 8 6 9 0] [0 4 2 9 1 0 3 0 0]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><h3 id="分析数独问题并确定解决方案"><a href="#分析数独问题并确定解决方案" class="headerlink" title="分析数独问题并确定解决方案"></a>分析数独问题并确定解决方案</h3><p>数独（shù dú, Sudoku）需要我们根据9×9盘面上的已知数字，推理出所有剩余空格的数字，并满足每一行、每一列、每一个粗线宫（3*3）内的数字均含1-9，不重复。</p><p>因此，数独是具有空间特征的，它有特殊的数字排列，这样的话，我们就可以尝试使用CNN来提取空间特征，进而通过CNN求解数独问题。</p><h3 id="思考解决数独问题的其他方案"><a href="#思考解决数独问题的其他方案" class="headerlink" title="思考解决数独问题的其他方案"></a>思考解决数独问题的其他方案</h3><p>但是，在网上查找资料的时候，我了解到CNN解决数独问题的时候，是将整个数独盘作为输入，一次正向传播就直接得到完整的解决方案，这样的话就忽视了目标之间存在的归纳偏置，以及它们是以一致的方式互相作用的，所以在一些情况下CNN模型就会出现问题。</p><p>同时，有一部分文章和评论认为使用CNN或者NN解决数独是单纯的用非常多的参数去记住数独的每一个答案，虽然不知道这个观点是否正确，但我觉得就算网络的参数不多，用CNN还是可以解决数独问题的。</p><p>CNN做数独的时候是一次性得到完整的解决方案，但我们做数独的时候，实际上是一步一步进行的：我们每次填入一个数字，然后观察这个数字带来的影响。所以数独的解决可以认为是一系列互相依赖的关系推理任务。</p><p>因此对于数独问题，循环网络的效果可能比卷积网络要好。按照上面的分析，循环关系网络（RRN）会比较适合数独问题。</p><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>根据上面的分析，我打算自己实现CNN网络解决数独问题，同时参考网上的资料尝试一下其他的方法，再把这些方法进行对比。</p><p>由于没有找到RRN处理数独问题的相关资料，所以我打算尝试一下用RNN解决数独问题，这个部分主要是参照<a href="https://www.toutiao.com/i6640028992575373828/?tt_from=mobile_qq&amp;utm_campaign=client_share&amp;timestamp=1552006941&amp;app=news_article&amp;utm_source=mobile_qq&amp;iid=65267103732&amp;utm_medium=toutiao_ios&amp;group_id=6640028992575373828&amp;wid=1638801556273">PyTorch中的数独RNN</a>。</p><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>下面是数据处理的相关代码。</p><p>这里我利用pandas来读取和处理数据，利用torch.utils.data来打包数据，这样处理后面就可以用DataLoader来加载数据，比较方便。</p><p>由于这里我需要同时满足CNN与RNN网络输入输出的要求（其实可以改成同样的，但是RNN部分只是看的差不多懂了，还不太会改，改了就出问题），所以我设置了一个one_hot参数，如果是RNN就使用one hot编码，如果是CNN就直接编码成一个9*9的矩阵。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data <span class="token keyword">as</span> data<span class="token keyword">import</span> torch<span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">def</span> <span class="token function">create_sudoku_tensors</span><span class="token punctuation">(</span>input_data<span class="token punctuation">,</span> one_hot<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> train_split<span class="token operator">=</span><span class="token number">0.7</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    分割训练集和测试集    :param input_data: 待分割的数据    :param one_hot: 是否使用one hot编码    :param train_split: 分割的比例    :return: 训练集，测试集    """</span>    <span class="token comment"># 数据的长度</span>    data_size <span class="token operator">=</span> input_data<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token comment"># 给每一个数独题信息进行编码</span>    <span class="token keyword">def</span> <span class="token function">one_hot_encode</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>        zeros <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">81</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> a <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">81</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            zeros<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">if</span> <span class="token builtin">int</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token keyword">else</span> <span class="token number">0</span>        <span class="token keyword">return</span> zeros    <span class="token comment"># 给每一个数独题信息进行编码</span>    <span class="token keyword">def</span> <span class="token function">encode</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>        zeros <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> a <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> b <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                zeros<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>a <span class="token operator">*</span> <span class="token number">9</span> <span class="token operator">+</span> b<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">return</span> zeros    <span class="token comment"># 得到编码内容</span>    <span class="token keyword">if</span> one_hot<span class="token punctuation">:</span>        quizzes_t <span class="token operator">=</span> input_data<span class="token punctuation">.</span>quizzes<span class="token punctuation">.</span><span class="token builtin">apply</span><span class="token punctuation">(</span>one_hot_encode<span class="token punctuation">)</span>        solutions_t <span class="token operator">=</span> input_data<span class="token punctuation">.</span>solutions<span class="token punctuation">.</span><span class="token builtin">apply</span><span class="token punctuation">(</span>one_hot_encode<span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        quizzes_t <span class="token operator">=</span> input_data<span class="token punctuation">.</span>quizzes<span class="token punctuation">.</span><span class="token builtin">apply</span><span class="token punctuation">(</span>encode<span class="token punctuation">)</span>        solutions_t <span class="token operator">=</span> input_data<span class="token punctuation">.</span>solutions<span class="token punctuation">.</span><span class="token builtin">apply</span><span class="token punctuation">(</span>encode<span class="token punctuation">)</span>    <span class="token comment"># 将编码好的内容拼接起来</span>    quizzes_t <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span>quizzes_t<span class="token punctuation">.</span>values<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    solutions_t <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span>solutions_t<span class="token punctuation">.</span>values<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 按比例进行随机分割</span>    randperm <span class="token operator">=</span> torch<span class="token punctuation">.</span>randperm<span class="token punctuation">(</span>data_size<span class="token punctuation">)</span>    train <span class="token operator">=</span> randperm<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token builtin">int</span><span class="token punctuation">(</span>train_split <span class="token operator">*</span> data_size<span class="token punctuation">)</span><span class="token punctuation">]</span>    test <span class="token operator">=</span> randperm<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">(</span>train_split <span class="token operator">*</span> data_size<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">]</span>    <span class="token comment"># 打包训练集和标签</span>    <span class="token keyword">return</span> data<span class="token punctuation">.</span>TensorDataset<span class="token punctuation">(</span>quizzes_t<span class="token punctuation">[</span>train<span class="token punctuation">]</span><span class="token punctuation">,</span> solutions_t<span class="token punctuation">[</span>train<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> \           data<span class="token punctuation">.</span>TensorDataset<span class="token punctuation">(</span>quizzes_t<span class="token punctuation">[</span>test<span class="token punctuation">]</span><span class="token punctuation">,</span> solutions_t<span class="token punctuation">[</span>test<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">create_constraint_mask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    创建一个mask    :return: mask    """</span>    constraint_mask <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">81</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">81</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">)</span>    <span class="token comment"># row constraints</span>    <span class="token keyword">for</span> a <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">81</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        r <span class="token operator">=</span> <span class="token number">9</span> <span class="token operator">*</span> <span class="token punctuation">(</span>a <span class="token operator">//</span> <span class="token number">9</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> b <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            constraint_mask<span class="token punctuation">[</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">+</span> b<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>    <span class="token comment"># column constraints</span>    <span class="token keyword">for</span> a <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">81</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        c <span class="token operator">=</span> a <span class="token operator">%</span> <span class="token number">9</span>        <span class="token keyword">for</span> b <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            constraint_mask<span class="token punctuation">[</span>a<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> c <span class="token operator">+</span> <span class="token number">9</span> <span class="token operator">*</span> b<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>    <span class="token comment"># box constraints</span>    <span class="token keyword">for</span> a <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">81</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        r <span class="token operator">=</span> a <span class="token operator">//</span> <span class="token number">9</span>        c <span class="token operator">=</span> a <span class="token operator">%</span> <span class="token number">9</span>        br <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">9</span> <span class="token operator">*</span> <span class="token punctuation">(</span>r <span class="token operator">//</span> <span class="token number">3</span><span class="token punctuation">)</span>        bc <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token punctuation">(</span>c <span class="token operator">//</span> <span class="token number">3</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> b <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            r <span class="token operator">=</span> b <span class="token operator">%</span> <span class="token number">3</span>            c <span class="token operator">=</span> <span class="token number">9</span> <span class="token operator">*</span> <span class="token punctuation">(</span>b <span class="token operator">//</span> <span class="token number">3</span><span class="token punctuation">)</span>            constraint_mask<span class="token punctuation">[</span>a<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> br <span class="token operator">+</span> bc <span class="token operator">+</span> r <span class="token operator">+</span> c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>    <span class="token keyword">return</span> constraint_mask<span class="token keyword">def</span> <span class="token function">load_dataset</span><span class="token punctuation">(</span>filepath<span class="token punctuation">,</span> one_hot<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> subsample<span class="token operator">=</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    加载数据集    :param filepath: 数据集文件    :param one_hot: 是否使用one hot编码    :param subsample: 数据集总共的行数    :return: 训练集、测试集    """</span>    dataset <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span>filepath<span class="token punctuation">,</span> sep<span class="token operator">=</span><span class="token string">','</span><span class="token punctuation">)</span>    <span class="token comment"># 返回随机 subsample 行数据</span>    my_sample <span class="token operator">=</span> dataset<span class="token punctuation">.</span>sample<span class="token punctuation">(</span>subsample<span class="token punctuation">)</span>    <span class="token comment"># 分割出训练集和测试集</span>    train_set<span class="token punctuation">,</span> test_set <span class="token operator">=</span> create_sudoku_tensors<span class="token punctuation">(</span>my_sample<span class="token punctuation">,</span> one_hot<span class="token punctuation">)</span>    <span class="token keyword">return</span> train_set<span class="token punctuation">,</span> test_set<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过下面的代码我们可以测试读取的数据格式。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># TEST</span>train_set<span class="token punctuation">,</span> test_set <span class="token operator">=</span> load_dataset<span class="token punctuation">(</span><span class="token string">"./src/data/sudoku_test.csv"</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token keyword">for</span> train_quiz<span class="token punctuation">,</span> train_label <span class="token keyword">in</span> train_set<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>train_quiz<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>train_label<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>    <span class="token keyword">break</span>train_set<span class="token punctuation">,</span> test_set <span class="token operator">=</span> load_dataset<span class="token punctuation">(</span><span class="token string">"./src/data/sudoku_test.csv"</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token keyword">for</span> train_quiz<span class="token punctuation">,</span> train_label <span class="token keyword">in</span> train_set<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>train_quiz<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>train_label<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>    <span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="搭建CNN模型"><a href="#搭建CNN模型" class="headerlink" title="搭建CNN模型"></a>搭建CNN模型</h2><p>这里主要是根据report3使用的FashionCNN来搭建的，大体框架基本一样，不过增加了padding，去除了池化层，同时也放弃了dropout层。</p><p>这个网络接收N*1*9*9的输入，最后会输出N*81*9的预测结果。</p><p>N是数据批数，81是9*9的数独盘面数字列表，9是对于某一个盘面数字，它是每一种数字的概率。（这里数字的取值范围是0-8，但是代表的是数字1-9，这是因为如果取值为1-9，而数独不需要填0，标签中也没有0，所以标签的取值范围还是0-8，这样就等于是标签对应不上，交叉熵损失函数还是会运行失败）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn<span class="token keyword">class</span> <span class="token class-name">SudokuCNN</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>SudokuCNN<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 第一层卷积</span>        <span class="token comment"># 输入[1,9,9]</span>        self<span class="token punctuation">.</span>layer1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>            nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>in_channels<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> out_channels<span class="token operator">=</span><span class="token number">64</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>BatchNorm2d<span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">)</span>        <span class="token comment"># 9-3+2*1+1</span>        <span class="token comment"># 第二层卷积</span>        <span class="token comment"># 输入[64,9,9]</span>        self<span class="token punctuation">.</span>layer2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>            nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>in_channels<span class="token operator">=</span><span class="token number">64</span><span class="token punctuation">,</span> out_channels<span class="token operator">=</span><span class="token number">128</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>BatchNorm2d<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">)</span>        <span class="token comment"># 第三层卷积</span>        <span class="token comment"># 输入[64，9，9]</span>        self<span class="token punctuation">.</span>layer3 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>            nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>in_channels<span class="token operator">=</span><span class="token number">128</span><span class="token punctuation">,</span> out_channels<span class="token operator">=</span><span class="token number">128</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>BatchNorm2d<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">)</span>        <span class="token comment"># 全连接层</span>        <span class="token comment"># 输入[128, 9, 9]</span>        self<span class="token punctuation">.</span>fc1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>in_features<span class="token operator">=</span><span class="token number">128</span> <span class="token operator">*</span> <span class="token number">9</span> <span class="token operator">*</span> <span class="token number">9</span><span class="token punctuation">,</span> out_features<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>in_features<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">,</span> out_features<span class="token operator">=</span><span class="token number">81</span> <span class="token operator">*</span> <span class="token number">9</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc3 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Softmax<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        out <span class="token operator">=</span> self<span class="token punctuation">.</span>layer1<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        out <span class="token operator">=</span> self<span class="token punctuation">.</span>layer2<span class="token punctuation">(</span>out<span class="token punctuation">)</span>        out <span class="token operator">=</span> self<span class="token punctuation">.</span>layer3<span class="token punctuation">(</span>out<span class="token punctuation">)</span>        <span class="token comment"># 矩阵展开为向量</span>        out <span class="token operator">=</span> out<span class="token punctuation">.</span>view<span class="token punctuation">(</span>out<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        out <span class="token operator">=</span> self<span class="token punctuation">.</span>fc1<span class="token punctuation">(</span>out<span class="token punctuation">)</span>        out <span class="token operator">=</span> self<span class="token punctuation">.</span>fc2<span class="token punctuation">(</span>out<span class="token punctuation">)</span>        <span class="token comment"># 向量变化为矩阵（81*9）</span>        out <span class="token operator">=</span> out<span class="token punctuation">.</span>view<span class="token punctuation">(</span>out<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">81</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span>        out <span class="token operator">=</span> self<span class="token punctuation">.</span>fc3<span class="token punctuation">(</span>out<span class="token punctuation">)</span>        <span class="token keyword">return</span> out<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="训练CNN模型"><a href="#训练CNN模型" class="headerlink" title="训练CNN模型"></a>训练CNN模型</h2><p>下面是训练CNN的代码，采用的是Adam优化器和CrossEntropyLoss损失函数。</p><p>测试的时候发现这里的学习率要取比较小，取大了loss可能就不下降，或者仅仅是下降了一点点，然后发生震荡。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> copy<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> torch<span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn<span class="token keyword">from</span> torch<span class="token punctuation">.</span>autograd <span class="token keyword">import</span> Variable<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data <span class="token keyword">import</span> Dataset<span class="token comment"># 尝试使用GPU</span>device <span class="token operator">=</span> torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string">"cuda:0"</span> <span class="token keyword">if</span> torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>is_available<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token string">"cpu"</span><span class="token punctuation">)</span><span class="token comment"># 加载数据集</span>batch_size <span class="token operator">=</span> <span class="token number">100</span>train_set<span class="token punctuation">,</span> test_set <span class="token operator">=</span> load_dataset<span class="token punctuation">(</span><span class="token string">"./src/data/sudoku.csv"</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token number">50000</span><span class="token punctuation">)</span>train_loader <span class="token operator">=</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>train_set<span class="token punctuation">,</span> batch_size<span class="token operator">=</span>batch_size<span class="token punctuation">)</span>test_loader <span class="token operator">=</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>test_set<span class="token punctuation">,</span> batch_size<span class="token operator">=</span>batch_size<span class="token punctuation">)</span><span class="token comment"># 加载模型</span>model <span class="token operator">=</span> SudokuCNN<span class="token punctuation">(</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token comment"># 损失函数</span>error <span class="token operator">=</span> nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 定义学习率</span>learning_rate <span class="token operator">=</span> <span class="token number">0.0005</span><span class="token comment"># 定义优化器</span>optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>model<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span>learning_rate<span class="token punctuation">)</span><span class="token comment"># 循环次数</span>num_epochs <span class="token operator">=</span> <span class="token number">50</span><span class="token comment"># 迭代次数</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token comment"># 是否画图</span>display <span class="token operator">=</span> <span class="token boolean">True</span><span class="token comment"># 最小迭代次数</span>min_epochs <span class="token operator">=</span> <span class="token number">5</span><span class="token comment"># 最小的损失</span>min_loss <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span><span class="token comment"># 最优模型</span>best_model <span class="token operator">=</span> <span class="token boolean">None</span><span class="token comment"># Lists for visualization of loss_function and accuracy</span>loss_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>iteration_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>accuracy_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_epochs<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 　分批次加载数据集</span>    <span class="token keyword">for</span> train_quiz<span class="token punctuation">,</span> train_label <span class="token keyword">in</span> train_loader<span class="token punctuation">:</span>        train_quiz<span class="token punctuation">,</span> train_label <span class="token operator">=</span> train_quiz<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token punctuation">,</span> train_label<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>        train_quiz <span class="token operator">=</span> Variable<span class="token punctuation">(</span>train_quiz<span class="token punctuation">.</span>view<span class="token punctuation">(</span>train_quiz<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        train_label <span class="token operator">=</span> Variable<span class="token punctuation">(</span>train_label<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># Forward pass</span>        outputs <span class="token operator">=</span> model<span class="token punctuation">(</span>train_quiz<span class="token punctuation">)</span>        outputs <span class="token operator">=</span> outputs<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span>        loss <span class="token operator">=</span> error<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> train_label<span class="token punctuation">.</span><span class="token builtin">long</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># Initializing a gradient as 0 so there is no mixing of gradient among the batches</span>        optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># Propagating the error backward</span>        loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># Optimizing the parameters</span>        optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>        count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token comment"># print('Epoch: {}, Batch: {}, Avg. Loss: {}'.format(epoch, count, loss_function.item()))</span>        <span class="token comment"># Testing the model</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token punctuation">(</span>count <span class="token operator">%</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># It's same as "if count % 50 == 0"</span>            total <span class="token operator">=</span> <span class="token number">0</span>            correct <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">for</span> test_quiz<span class="token punctuation">,</span> test_label <span class="token keyword">in</span> test_loader<span class="token punctuation">:</span>                test_quiz<span class="token punctuation">,</span> test_label <span class="token operator">=</span> test_quiz<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token punctuation">,</span> test_label<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>                test_quiz <span class="token operator">=</span> Variable<span class="token punctuation">(</span>test_quiz<span class="token punctuation">.</span>view<span class="token punctuation">(</span>test_quiz<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                test_label <span class="token operator">=</span> Variable<span class="token punctuation">(</span>test_label<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                outputs <span class="token operator">=</span> model<span class="token punctuation">(</span>test_quiz<span class="token punctuation">)</span>                outputs <span class="token operator">=</span> outputs<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span>                predictions <span class="token operator">=</span> torch<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>                correct <span class="token operator">+=</span> <span class="token punctuation">(</span>predictions <span class="token operator">==</span> test_label<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                total <span class="token operator">+=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>test_label<span class="token punctuation">)</span>            accuracy <span class="token operator">=</span> correct <span class="token operator">*</span> <span class="token number">100</span> <span class="token operator">/</span> total            loss_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>loss<span class="token punctuation">.</span>data<span class="token punctuation">)</span>            iteration_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>count<span class="token punctuation">)</span>            accuracy_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>accuracy<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token punctuation">(</span>count <span class="token operator">%</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Iteration: {}, Loss: {}, Accuracy: {}%"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span> loss<span class="token punctuation">.</span>data<span class="token punctuation">,</span> accuracy<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行输出：</p><pre class="line-numbers language-none"><code class="language-none">Iteration: 100, Loss: 2.154716968536377, Accuracy: 17.909875869750977%Iteration: 200, Loss: 2.1245620250701904, Accuracy: 22.032262802124023%Iteration: 300, Loss: 2.091231107711792, Accuracy: 26.08452606201172%Iteration: 400, Loss: 2.0490970611572266, Accuracy: 30.193002700805664%Iteration: 500, Loss: 2.010570764541626, Accuracy: 34.447654724121094%Iteration: 600, Loss: 1.973477840423584, Accuracy: 38.08658218383789%Iteration: 700, Loss: 1.9365869760513306, Accuracy: 41.5409049987793%Iteration: 800, Loss: 1.8946945667266846, Accuracy: 45.34855651855469%Iteration: 900, Loss: 1.8635038137435913, Accuracy: 48.742549896240234%.........................................Iteration: 17100, Loss: 1.4262917041778564, Accuracy: 71.87982940673828%Iteration: 17200, Loss: 1.4250632524490356, Accuracy: 71.79407501220703%Iteration: 17300, Loss: 1.423291802406311, Accuracy: 71.8446044921875%Iteration: 17400, Loss: 1.419376254081726, Accuracy: 71.94452667236328%Iteration: 17500, Loss: 1.4205855131149292, Accuracy: 71.94963073730469%<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实现过程中出现的问题"><a href="#实现过程中出现的问题" class="headerlink" title="实现过程中出现的问题"></a>实现过程中出现的问题</h3><p>前面处理数据和定义模型都挺顺利的，但是训练CNN模型这里出现的问题特别特别多，整个实现过程好像也就这部分出了问题，耽误了比较长的时间。</p><p><strong>这里主要是因为自己对交叉熵损失函数的具体实现过程不太了解，同时对pytorch处理tensor的一些常用手法不太熟练。</strong></p><p>一开始我是用one hot编码在这里训练和测试，但是交叉熵损失函数并不支持one hot编码，并且它还会报错，报错内容大概是“multi target”相关的，这导致我一开始没有精准的定位问题所在，然后我尝试了其他的损失函数，有的可以用但可能因为我<strong>当时的数据格式处理本身有问题</strong>，最后的结果不收敛。所以后面我专门去学习了pytorch中的损失函数，并且也知道了<strong>交叉熵损失函数是不支持one hot编码的。</strong></p><p>之后我就修改了处理数据的代码，让CNN得到9*9的数据，而RNN继续使用one hot编码。但是因为我的网络计算出来的是batch*81*9的，并且标签也是batch*81的，这样在CrossEntropyLoss函数里面还是会报错，报错内容大概是“期望 batch*9 但是得到了 batch*81”。（batch是数据批数）</p><p>这里的报错其实也很奇怪，上网查了比较久也没解决这个问题。后面我好好想了一下，*<em><font color="red">这个数独问题可以理解为一个特殊的分类问题，我们对每一个格子进行分类，判断它是什么数字类型。</font>**这样的话，就很自然的想到要把预测结果和标签都展开，预测结果展开为[(batch\</em>81), 9]的二维矩阵，而标签就展开为[batch*81]的向量。</p><p>通过这样的处理方式，我终于能够开始训练这个CNN网络了。（上面找问题找了四五天，不过解决其实就花了一个下午，感觉定位问题的位置很关键！）</p><h4 id="一个样例"><a href="#一个样例" class="headerlink" title="一个样例"></a>一个样例</h4><p>这里是一个样例代码，我在这个过程中犯的错误用比较简单的形式给再现了出来。</p><p>首先定义好各种变量。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> torch<span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>functional <span class="token keyword">as</span> F<span class="token comment"># 假设这是一个3分类问题，一共有4组样本</span><span class="token comment"># 下面是这个模型的输出</span>pred_y <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0.30722019</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.8358033</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.24752918</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                   <span class="token punctuation">[</span><span class="token number">0.72186664</span><span class="token punctuation">,</span> <span class="token number">0.58657704</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.25026393</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                   <span class="token punctuation">[</span><span class="token number">0.16449865</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0.44255082</span><span class="token punctuation">,</span> <span class="token number">0.68046693</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                   <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">0.52082402</span><span class="token punctuation">,</span> <span class="token number">1.71407838</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.36618063</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>pred_y <span class="token operator">=</span> torch<span class="token punctuation">.</span>from_numpy<span class="token punctuation">(</span>pred_y<span class="token punctuation">)</span><span class="token comment"># 真实的标签如下所示，很明显这里就是one hot编码</span>true_y_one_hot <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                   <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                   <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                   <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>true_y_one_hot <span class="token operator">=</span> torch<span class="token punctuation">.</span>from_numpy<span class="token punctuation">(</span>true_y_one_hot<span class="token punctuation">)</span><span class="token comment"># 这是采用普通编码的标签</span><span class="token comment"># true_y_1是正确编码的，对于数独问题，我们认为这里的标签实际上代表1，2，2，3</span>true_y_1 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>true_y_1 <span class="token operator">=</span> torch<span class="token punctuation">.</span>from_numpy<span class="token punctuation">(</span>true_y_1<span class="token punctuation">)</span><span class="token comment"># true_y_2是错误编码的，这最后会导致输出类型和标签对应不上</span>true_y_2 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>true_y_2 <span class="token operator">=</span> torch<span class="token punctuation">.</span>from_numpy<span class="token punctuation">(</span>true_y_2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果使用one hot编码，这样的运行结果如下所示：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">loss <span class="token operator">=</span> F<span class="token punctuation">.</span>cross_entropy<span class="token punctuation">(</span>pred_y<span class="token punctuation">,</span> true_y_one_hot<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>loss<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>运行输出：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">---------------------------------------------------------------------------RuntimeError                              Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token operator">&lt;</span>ipython-input-32-64c355d4eafe<span class="token operator">&gt;</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">&gt;</span>----<span class="token operator">&gt;</span> <span class="token number">1</span> loss <span class="token operator">=</span> F.cross_entropy<span class="token punctuation">(</span>pred_y, true_y_one_hot<span class="token punctuation">)</span>      <span class="token number">2</span> print<span class="token punctuation">(</span>loss<span class="token punctuation">)</span>~/.local/lib/python3.6/site-packages/torch/nn/functional.py <span class="token keyword">in</span> cross_entropy<span class="token punctuation">(</span>input, target, weight, size_average, ignore_index, reduce, reduction<span class="token punctuation">)</span>   <span class="token number">2822</span>     <span class="token keyword">if</span> size_average is not None or reduce is not None:   <span class="token number">2823</span>         reduction <span class="token operator">=</span> _Reduction.legacy_get_string<span class="token punctuation">(</span>size_average, reduce<span class="token punctuation">)</span>-<span class="token operator">&gt;</span> <span class="token number">2824</span>     <span class="token builtin class-name">return</span> torch._C._nn.cross_entropy_loss<span class="token punctuation">(</span>input, target, weight, _Reduction.get_enum<span class="token punctuation">(</span>reduction<span class="token punctuation">)</span>, ignore_index<span class="token punctuation">)</span>   <span class="token number">2825</span>    <span class="token number">2826</span>    RuntimeError: 1D target tensor expected, multi-target not supported<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果编码不正确，输出类型和标签不对应，就会发生下面这样的情况（在数独问题里面其实还要复杂一点）：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">loss <span class="token operator">=</span> F<span class="token punctuation">.</span>cross_entropy<span class="token punctuation">(</span>pred_y<span class="token punctuation">,</span> true_y_2<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>loss<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>运行输出：    </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">---------------------------------------------------------------------------IndexError                                Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token operator">&lt;</span>ipython-input-33-a6c07789433b<span class="token operator">&gt;</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">&gt;</span>----<span class="token operator">&gt;</span> <span class="token number">1</span> loss <span class="token operator">=</span> F.cross_entropy<span class="token punctuation">(</span>pred_y, true_y_2<span class="token punctuation">)</span>      <span class="token number">2</span> print<span class="token punctuation">(</span>loss<span class="token punctuation">)</span>~/.local/lib/python3.6/site-packages/torch/nn/functional.py <span class="token keyword">in</span> cross_entropy<span class="token punctuation">(</span>input, target, weight, size_average, ignore_index, reduce, reduction<span class="token punctuation">)</span>   <span class="token number">2822</span>     <span class="token keyword">if</span> size_average is not None or reduce is not None:   <span class="token number">2823</span>         reduction <span class="token operator">=</span> _Reduction.legacy_get_string<span class="token punctuation">(</span>size_average, reduce<span class="token punctuation">)</span>-<span class="token operator">&gt;</span> <span class="token number">2824</span>     <span class="token builtin class-name">return</span> torch._C._nn.cross_entropy_loss<span class="token punctuation">(</span>input, target, weight, _Reduction.get_enum<span class="token punctuation">(</span>reduction<span class="token punctuation">)</span>, ignore_index<span class="token punctuation">)</span>   <span class="token number">2825</span>    <span class="token number">2826</span> IndexError: Target <span class="token number">3</span> is out of bounds.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正常运行的话，是下面这样的情况：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">loss <span class="token operator">=</span> F<span class="token punctuation">.</span>cross_entropy<span class="token punctuation">(</span>pred_y<span class="token punctuation">,</span> true_y_1<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>loss<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>运行输出：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">tensor<span class="token punctuation">(</span><span class="token number">1.5929</span>, <span class="token assign-left variable">dtype</span><span class="token operator">=</span>torch.float64<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="测试CNN模型"><a href="#测试CNN模型" class="headerlink" title="测试CNN模型"></a>测试CNN模型</h2><p>通过下面的代码可以简单测试训练好的CNN模型。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> test_quiz<span class="token punctuation">,</span> test_label <span class="token keyword">in</span> test_loader<span class="token punctuation">:</span>    test_quiz<span class="token punctuation">,</span> test_label <span class="token operator">=</span> test_quiz<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token punctuation">,</span> test_label<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>    test_quiz <span class="token operator">=</span> Variable<span class="token punctuation">(</span>test_quiz<span class="token punctuation">.</span>view<span class="token punctuation">(</span>test_quiz<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    test_label <span class="token operator">=</span> Variable<span class="token punctuation">(</span>test_label<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    outputs <span class="token operator">=</span> model<span class="token punctuation">(</span>test_quiz<span class="token punctuation">)</span>    outputs <span class="token operator">=</span> outputs<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span>    predictions <span class="token operator">=</span> torch<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>    correct <span class="token operator">+=</span> <span class="token punctuation">(</span>predictions <span class="token operator">==</span> test_label<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    total <span class="token operator">+=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>test_label<span class="token punctuation">)</span>accuracy <span class="token operator">=</span> correct <span class="token operator">*</span> <span class="token number">100</span> <span class="token operator">/</span> total<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Test Accuracy: {}%"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>accuracy<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行输出：</p><pre class="line-numbers language-none"><code class="language-none">Test Accuracy: 71.94963073730469%<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="结果可视化"><a href="#结果可视化" class="headerlink" title="结果可视化"></a>结果可视化</h2><p>我们可以把训练和测试过程中的损失与准确率画出来。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 画出迭代中的损失</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>iteration_list<span class="token punctuation">,</span> loss_list<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">"No. of Iteration"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">"Loss"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">"Iterations vs Loss"</span><span class="token punctuation">)</span><span class="token comment"># 画出迭代中的准确度</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>iteration_list<span class="token punctuation">,</span> accuracy_list<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">"No. of Iteration"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">"Accuracy"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">"Iterations vs Accuracy"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行输出：</p><p><img src="/images/machine-learning-8/output_28_0.png"></p><p><img src="/images/machine-learning-8/output_28_1.png"></p><h2 id="尝试使用RNN模型"><a href="#尝试使用RNN模型" class="headerlink" title="尝试使用RNN模型"></a>尝试使用RNN模型</h2><p>在一开始做这个项目的时候，我查了很多关于CNN解决数独问题的资料，期间偶然了解到数独用循环网络做的效果会比较好，同时又找到一篇<a href="https://www.toutiao.com/i6640028992575373828/?tt_from=mobile_qq&amp;utm_campaign=client_share&amp;timestamp=1552006941&amp;app=news_article&amp;utm_source=mobile_qq&amp;iid=65267103732&amp;utm_medium=toutiao_ios&amp;group_id=6640028992575373828&amp;wid=1638801556273">PyTorch中的数独RNN</a>的文章，所以我打算尝试一下RNN模型做数独问题。</p><p>在这个环节中，RNN模型是从这篇文章里面搬运过来的，而训练过程有参考这篇文章，但为了和CNN进行对比也做了不少修改。</p><h3 id="搭建RNN模型"><a href="#搭建RNN模型" class="headerlink" title="搭建RNN模型"></a>搭建RNN模型</h3><p>下面是搭建的RNN模型。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn<span class="token keyword">class</span> <span class="token class-name">SudokuRNN</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> constraint_mask<span class="token punctuation">,</span> n<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">,</span> hidden1<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>SudokuRNN<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>constraint_mask <span class="token operator">=</span> constraint_mask<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">*</span> n<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> n <span class="token operator">*</span> n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>n <span class="token operator">=</span> n        self<span class="token punctuation">.</span>hidden1 <span class="token operator">=</span> hidden1        <span class="token comment"># Feature vector is the 3 constraints</span>        self<span class="token punctuation">.</span>input_size <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> n        self<span class="token punctuation">.</span>l1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>self<span class="token punctuation">.</span>input_size<span class="token punctuation">,</span>                            self<span class="token punctuation">.</span>hidden1<span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>a1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>l2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>self<span class="token punctuation">.</span>hidden1<span class="token punctuation">,</span>                            n<span class="token punctuation">,</span> bias<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>softmax <span class="token operator">=</span> nn<span class="token punctuation">.</span>Softmax<span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment"># x is a (batch, n^2, n) tensor</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        n <span class="token operator">=</span> self<span class="token punctuation">.</span>n        bts <span class="token operator">=</span> x<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        c <span class="token operator">=</span> self<span class="token punctuation">.</span>constraint_mask        min_empty <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        x_pred <span class="token operator">=</span> x<span class="token punctuation">.</span>clone<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> a <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>min_empty<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># score empty numbers</span>            constraints <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>view<span class="token punctuation">(</span>bts<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">*</span> n<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token operator">*</span> c<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span>            <span class="token comment"># empty cells</span>            empty_mask <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            f <span class="token operator">=</span> constraints<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>bts<span class="token punctuation">,</span> n <span class="token operator">*</span> n<span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> n<span class="token punctuation">)</span>            y_ <span class="token operator">=</span> self<span class="token punctuation">.</span>l2<span class="token punctuation">(</span>self<span class="token punctuation">.</span>a1<span class="token punctuation">(</span>self<span class="token punctuation">.</span>l1<span class="token punctuation">(</span>f<span class="token punctuation">[</span>empty_mask<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            s_ <span class="token operator">=</span> self<span class="token punctuation">.</span>softmax<span class="token punctuation">(</span>y_<span class="token punctuation">)</span>            <span class="token comment"># Score the rows</span>            x_pred<span class="token punctuation">[</span>empty_mask<span class="token punctuation">]</span> <span class="token operator">=</span> s_            s <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros_like<span class="token punctuation">(</span>x_pred<span class="token punctuation">)</span>            s<span class="token punctuation">[</span>empty_mask<span class="token punctuation">]</span> <span class="token operator">=</span> s_            <span class="token comment"># find most probable guess</span>            score<span class="token punctuation">,</span> score_pos <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>            mmax <span class="token operator">=</span> score<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>            <span class="token comment"># fill it in</span>            nz <span class="token operator">=</span> empty_mask<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>nonzero<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>            mmax_ <span class="token operator">=</span> mmax<span class="token punctuation">[</span>nz<span class="token punctuation">]</span>            ones <span class="token operator">=</span> torch<span class="token punctuation">.</span>ones<span class="token punctuation">(</span>nz<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            x<span class="token punctuation">.</span>index_put_<span class="token punctuation">(</span><span class="token punctuation">(</span>nz<span class="token punctuation">,</span> mmax_<span class="token punctuation">,</span> score_pos<span class="token punctuation">[</span>nz<span class="token punctuation">,</span> mmax_<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ones<span class="token punctuation">)</span>        <span class="token keyword">return</span> x_pred<span class="token punctuation">,</span> x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="训练并测试"><a href="#训练并测试" class="headerlink" title="训练并测试"></a>训练并测试</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> copy<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> torch<span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn<span class="token keyword">from</span> torch<span class="token punctuation">.</span>autograd <span class="token keyword">import</span> Variable<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data <span class="token keyword">import</span> Dataset<span class="token comment"># FIXME 这里RNN不能使用GPU，尝试着用就会报错。感觉是定义模型的时候出的问题。。。</span><span class="token comment"># device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")</span>device <span class="token operator">=</span> torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string">"cpu"</span><span class="token punctuation">)</span><span class="token comment"># 加载数据集</span>batch_size <span class="token operator">=</span> <span class="token number">100</span>train_set<span class="token punctuation">,</span> test_set <span class="token operator">=</span>load_dataset<span class="token punctuation">(</span><span class="token string">"./src/data/sudoku.csv"</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token comment"># train_set, test_set = load_dataset("./data/sudoku_test.csv", True, 1000)</span>train_loader <span class="token operator">=</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>train_set<span class="token punctuation">,</span> batch_size<span class="token operator">=</span>batch_size<span class="token punctuation">)</span>test_loader <span class="token operator">=</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>test_set<span class="token punctuation">,</span> batch_size<span class="token operator">=</span>batch_size<span class="token punctuation">)</span><span class="token comment"># 加载模型</span>model <span class="token operator">=</span> SudokuRNN<span class="token punctuation">(</span>create_constraint_mask<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token comment"># 损失函数</span>loss_fun <span class="token operator">=</span> nn<span class="token punctuation">.</span>MSELoss<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 定义学习率</span>learning_rate <span class="token operator">=</span> <span class="token number">0.01</span><span class="token comment"># 定义优化器</span>optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>model<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span>learning_rate<span class="token punctuation">,</span> weight_decay<span class="token operator">=</span><span class="token number">0.000</span><span class="token punctuation">)</span><span class="token comment"># 循环次数（用cpu训练，不敢弄太大了，训练时间太长）</span>num_epochs <span class="token operator">=</span> <span class="token number">1</span><span class="token comment"># 迭代次数</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token comment"># 是否画图</span>display <span class="token operator">=</span> <span class="token boolean">True</span><span class="token comment"># 最小迭代次数</span>min_epochs <span class="token operator">=</span> <span class="token number">0</span><span class="token comment"># 最小的损失</span>min_loss <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span><span class="token comment"># 最优模型</span>best_model <span class="token operator">=</span> <span class="token boolean">None</span><span class="token comment"># Lists for visualization of loss_function and accuracy</span>loss_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>iteration_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>accuracy_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>accuracy <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_epochs<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 　分批次加载数据集</span>    <span class="token keyword">for</span> train_quiz<span class="token punctuation">,</span> train_label <span class="token keyword">in</span> train_loader<span class="token punctuation">:</span>        train_quiz<span class="token punctuation">,</span> train_label <span class="token operator">=</span> train_quiz<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token punctuation">,</span> train_label<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>        train_quiz <span class="token operator">=</span> Variable<span class="token punctuation">(</span>train_quiz<span class="token punctuation">)</span>        train_label <span class="token operator">=</span> Variable<span class="token punctuation">(</span>train_label<span class="token punctuation">)</span>        model<span class="token punctuation">.</span>train<span class="token punctuation">(</span><span class="token punctuation">)</span>        optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>        pred<span class="token punctuation">,</span> mat <span class="token operator">=</span> model<span class="token punctuation">(</span>train_quiz<span class="token punctuation">)</span>        loss <span class="token operator">=</span> loss_fun<span class="token punctuation">(</span>pred<span class="token punctuation">,</span> train_label<span class="token punctuation">)</span>        loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># Optimizing the parameters</span>        optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>        count <span class="token operator">+=</span> <span class="token number">1</span>        model<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># Testing the model</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token punctuation">(</span>count <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># It's same as "if count % 50 == 0"</span>            total <span class="token operator">=</span> <span class="token number">0</span>            correct <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">for</span> test_quiz<span class="token punctuation">,</span> test_label <span class="token keyword">in</span> test_loader<span class="token punctuation">:</span>                test_quiz<span class="token punctuation">,</span> test_label <span class="token operator">=</span> test_quiz<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token punctuation">,</span> test_label<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>                test_quiz <span class="token operator">=</span> Variable<span class="token punctuation">(</span>test_quiz<span class="token punctuation">)</span>                test_label <span class="token operator">=</span> Variable<span class="token punctuation">(</span>test_label<span class="token punctuation">)</span>                test_pred<span class="token punctuation">,</span> test_fill <span class="token operator">=</span> model<span class="token punctuation">(</span>test_quiz<span class="token punctuation">)</span>                correct <span class="token operator">+=</span> <span class="token punctuation">(</span>test_fill<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> test_label<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span>                total <span class="token operator">+=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>test_label<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">81</span>            accuracy <span class="token operator">=</span> correct <span class="token operator">/</span> total            loss_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>loss<span class="token punctuation">.</span>data<span class="token punctuation">)</span>            iteration_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>count<span class="token punctuation">)</span>            accuracy_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>accuracy<span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"ACC: "</span><span class="token punctuation">,</span> accuracy<span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"error in cells: "</span><span class="token punctuation">,</span> total <span class="token operator">-</span> correct<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token punctuation">(</span>count <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Iteration: {}, Loss: {}, Accuracy: {}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span> loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> accuracy<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行输出：</p><pre class="line-numbers language-none"><code class="language-none">ACC:  0.6399711934156379error in cells:  87487ACC:  0.7732098765432098error in cells:  55110Iteration: 5, Loss: 0.05192449316382408, Accuracy: 0.7732098765432098ACC:  0.820440329218107error in cells:  43633ACC:  0.837559670781893error in cells:  39473....................................................................ACC:  0.9995720164609053error in cells:  104Iteration: 65, Loss: 0.0002745767415035516, Accuracy: 0.9995720164609053ACC:  0.9996378600823045error in cells:  88ACC:  0.9998024691358025error in cells:  48ACC:  0.9998106995884773error in cells:  46Iteration: 70, Loss: 0.00030164315830916166, Accuracy: 0.9998106995884773<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="结果可视化-1"><a href="#结果可视化-1" class="headerlink" title="结果可视化"></a>结果可视化</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 画出迭代中的损失</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>iteration_list<span class="token punctuation">,</span> loss_list<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">"No. of Iteration"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">"Loss"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">"Iterations vs Loss"</span><span class="token punctuation">)</span><span class="token comment"># 画出迭代中的准确度</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>iteration_list<span class="token punctuation">,</span> accuracy_list<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">"No. of Iteration"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">"Accuracy"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">"Iterations vs Accuracy"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/machine-learning-8/output_37_0.png"></p><p><img src="/images/machine-learning-8/output_37_1.png"></p><h2 id="对比CNN与RNN"><a href="#对比CNN与RNN" class="headerlink" title="对比CNN与RNN"></a>对比CNN与RNN</h2><h3 id="对CNN模型进行测试"><a href="#对CNN模型进行测试" class="headerlink" title="对CNN模型进行测试"></a>对CNN模型进行测试</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">import</span> time<span class="token keyword">from</span> torch<span class="token punctuation">.</span>autograd <span class="token keyword">import</span> Variable<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data <span class="token keyword">import</span> Dataset<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"===================对CNN模型进行测试==================="</span><span class="token punctuation">)</span>model_path<span class="token operator">=</span><span class="token string">"./src/SudokuCNN_model_1.40394.pth"</span>test_size<span class="token operator">=</span><span class="token number">10000</span><span class="token comment"># 为公平起见，CNN也是用cpu</span>device <span class="token operator">=</span> torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string">"cpu"</span><span class="token punctuation">)</span><span class="token comment"># 加载数据集</span>batch_size <span class="token operator">=</span> <span class="token number">100</span><span class="token comment"># 这里因为是测试，所以就取分割数据中的训练集部分做测试了(不是训练模型的训练集！)</span>test_set<span class="token punctuation">,</span> _ <span class="token operator">=</span> load_dataset<span class="token punctuation">(</span><span class="token string">"./src/data/sudoku.csv"</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">,</span> test_size<span class="token punctuation">)</span>test_loader <span class="token operator">=</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>test_set<span class="token punctuation">,</span> batch_size<span class="token operator">=</span>batch_size<span class="token punctuation">)</span><span class="token comment"># 加载模型</span>model <span class="token operator">=</span> SudokuCNN<span class="token punctuation">(</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>model<span class="token punctuation">.</span>load_state_dict<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>load<span class="token punctuation">(</span>model_path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># Testing the model</span>total <span class="token operator">=</span> <span class="token number">0</span>correct <span class="token operator">=</span> <span class="token number">0</span><span class="token comment"># 开始计时</span>start <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> test_quiz<span class="token punctuation">,</span> test_label <span class="token keyword">in</span> test_loader<span class="token punctuation">:</span>    test_quiz<span class="token punctuation">,</span> test_label <span class="token operator">=</span> test_quiz<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token punctuation">,</span> test_label<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>    test_quiz <span class="token operator">=</span> Variable<span class="token punctuation">(</span>test_quiz<span class="token punctuation">.</span>view<span class="token punctuation">(</span>test_quiz<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    test_label <span class="token operator">=</span> Variable<span class="token punctuation">(</span>test_label<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    outputs <span class="token operator">=</span> model<span class="token punctuation">(</span>test_quiz<span class="token punctuation">)</span>    outputs <span class="token operator">=</span> outputs<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span>    predictions <span class="token operator">=</span> torch<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>    correct <span class="token operator">+=</span> <span class="token punctuation">(</span>predictions <span class="token operator">==</span> test_label<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    total <span class="token operator">+=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>test_label<span class="token punctuation">)</span><span class="token comment"># 结束计时</span>end <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>    accuracy <span class="token operator">=</span> correct <span class="token operator">*</span> <span class="token number">100</span> <span class="token operator">/</span> total<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"SudokuCNN accuracy: {}%"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>accuracy<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"SudokuCNN cells in error: {}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>total <span class="token operator">-</span> correct<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"SudokuCNN time = %s"</span> <span class="token operator">%</span> <span class="token builtin">str</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"===================================================="</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行输出：</p><pre class="line-numbers language-none"><code class="language-none">===================对CNN模型进行测试===================SudokuCNN accuracy: 75.1141128540039%SudokuCNN cells in error: 141103SudokuCNN time = 8.729239000000003====================================================<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="对RNN模型进行测试"><a href="#对RNN模型进行测试" class="headerlink" title="对RNN模型进行测试"></a>对RNN模型进行测试</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"===================对RNN模型进行测试==================="</span><span class="token punctuation">)</span>model_path<span class="token operator">=</span><span class="token string">"./src/SudokuRNN_model_0.00001.pth"</span>test_size<span class="token operator">=</span><span class="token number">10000</span><span class="token comment"># 尝试使用GPU</span><span class="token comment"># device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")</span>device <span class="token operator">=</span> torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string">"cpu"</span><span class="token punctuation">)</span><span class="token comment"># 加载数据集</span>batch_size <span class="token operator">=</span> <span class="token number">100</span><span class="token comment"># 这里因为是测试，所以就取分割数据中的训练集部分做测试了(不是训练模型的训练集！)</span>test_set<span class="token punctuation">,</span> _ <span class="token operator">=</span> load_dataset<span class="token punctuation">(</span><span class="token string">"./src/data/sudoku.csv"</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">,</span> test_size<span class="token punctuation">)</span>test_loader <span class="token operator">=</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>test_set<span class="token punctuation">,</span> batch_size<span class="token operator">=</span>batch_size<span class="token punctuation">)</span><span class="token comment"># 加载模型</span>model <span class="token operator">=</span> SudokuRNN<span class="token punctuation">(</span>create_constraint_mask<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>model<span class="token punctuation">.</span>load_state_dict<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>load<span class="token punctuation">(</span>model_path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># Testing the model</span>total <span class="token operator">=</span> <span class="token number">0</span>correct <span class="token operator">=</span> <span class="token number">0</span><span class="token comment"># 开始计时</span>start <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> test_quiz<span class="token punctuation">,</span> test_label <span class="token keyword">in</span> test_loader<span class="token punctuation">:</span>    test_quiz<span class="token punctuation">,</span> test_label <span class="token operator">=</span> test_quiz<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token punctuation">,</span> test_label<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>    test_quiz <span class="token operator">=</span> Variable<span class="token punctuation">(</span>test_quiz<span class="token punctuation">)</span>    test_label <span class="token operator">=</span> Variable<span class="token punctuation">(</span>test_label<span class="token punctuation">)</span>    test_pred<span class="token punctuation">,</span> test_fill <span class="token operator">=</span> model<span class="token punctuation">(</span>test_quiz<span class="token punctuation">)</span>    correct <span class="token operator">+=</span> <span class="token punctuation">(</span>test_fill<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> test_label<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>dim<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span>    total <span class="token operator">+=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>test_label<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">81</span><span class="token comment"># 结束计时</span>end <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>accuracy <span class="token operator">=</span> correct <span class="token operator">*</span> <span class="token number">100</span> <span class="token operator">/</span> total<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"SudokuRNN accuracy: {}%"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>accuracy<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"SudokuRNN cells in error: {}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>total <span class="token operator">-</span> correct<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"SudokuRNN time = %s"</span> <span class="token operator">%</span> <span class="token builtin">str</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"===================================================="</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行输出：</p><pre class="line-numbers language-none"><code class="language-none">===================对RNN模型进行测试===================SudokuRNN accuracy: 99.96490299823633%SudokuRNN cells in error: 199SudokuRNN time = 337.7354459999997====================================================<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="比较分析"><a href="#比较分析" class="headerlink" title="比较分析"></a>比较分析</h3><p>从上面的结果我们发现:</p><ul><li><p>RNN的准确率远远超过CNN，RNN达到了99.6%的准确率，而CNN只有75%的准确率。</p></li><li><p>RNN的错误单元格数目也远比CNN少，后者的错误数是前者的100倍。</p></li><li><p>但是RNN解决数独问题花费的时间比CNN多得多。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我觉得数独问题和之前的服装分类问题是相通的：</p><ul><li><p>服装分类问题是一个非常经典的多分类问题，我们需要对10种服装进行分类；</p></li><li><p>而数独问题可以认为是一个特殊的多分类问题，我们可以说是对每一个单元格进行分类，最后通过这些单元格的分类结果，得到数独的解决方案。</p></li></ul><p><strong>关于卷积神经网络解决数独问题是不是通过大量的参数记忆答案：</strong></p><p>我在网上查阅资料的时候，有一部分文章和评论认为使用CNN或者NN解决数独是单纯的用非常多的参数去记住数独的每一个答案，这个观点我不知道是否正确，但是我对这个看法产生了比较大的兴趣，所以我后面有尝试修改我设计的卷积网络的参数，比如把卷积层节点调整为256或者512，再把全连接层的节点增加1000到2000个，再对网络进行训练和测试。</p><p>不过在我的测试中，我发现无论我怎么改参数（改太大会提示我GPU显存不够），这个网络的准确率最后都是75%左右，并且后面梯度下降的特别慢。所以我觉得可能卷积神经网络是通过空间特征提取，学习到了解决数独问题的函数，而不是仅仅通过大量的参数来记忆数独的答案。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> CNN </tag>
            
            <tag> RNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记（七）：使用CNN解决服装分类问题</title>
      <link href="2022/01/21/machine-learning-7/"/>
      <url>2022/01/21/machine-learning-7/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习笔记（七）：使用CNN解决服装分类问题"><a href="#机器学习笔记（七）：使用CNN解决服装分类问题" class="headerlink" title="机器学习笔记（七）：使用CNN解决服装分类问题"></a>机器学习笔记（七）：使用CNN解决服装分类问题</h1><blockquote><p>这篇博客整理于我选修的《机器学习》课程的大作业。</p></blockquote><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ul><li><p>任务类型：多分类</p></li><li><p>背景介绍：FashionMNIST 是一个替代 <a href="http://yann.lecun.com/exdb/mnist/">MNIST 手写数字集</a>的图像数据集。 它是由 Zalando（一家德国的时尚科技公司）旗下的研究部门提供。其涵盖了来自 10 种类别的共 7 万个不同商品的正面图片。</p><p>FashionMNIST 的大小、格式和训练集/测试集划分与原始的 MNIST 完全一致。60000/10000 的训练测试数据划分，28x28 的灰度图片。你可以直接用它来测试你的机器学习和深度学习算法性能，且不需要改动任何的代码。</p></li><li><p>这个数据集的样子大致如下（每个类别占三行）：</p><img src="/images/machine-learning-7/fashion-mnist.jpg" style="zoom: 67%;"></li></ul><h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><h3 id="选择网络模型"><a href="#选择网络模型" class="headerlink" title="选择网络模型"></a>选择网络模型</h3><p>这个任务的本质就是一个<strong>图像多分类问题</strong>，我们需要对给出的图像进行多分类，并且对不支持类别进行判断。</p><p>考虑到在图像领域，用传统的神经网络并不合适，因为图像是由一个个像素点构成，对于灰度图，每个像素点有一个通道，而对于彩色图，每个像素点有三个通道，分别代表RGB颜色，这样的话一张图片中包含的信息会非常多。</p><p>举一个例子，假设一个图像的尺寸是（1，28，28），即代表这个图像的是一个通道为1，长宽均为28的图像（此处1代表灰色图像）。如果使用全连接的网络结构，即网络中的神经与与相邻层上的每个神经元均连接，那就意味着我们的网络输入层有28 * 28 =784个神经元，再假设hidden层采用了15个神经元，而最后的输出层使用10个神经元。那么简单计算一下，我们需要的参数个数(w和b)就有：784<em>15</em>10+15+10=117625个（15和10是一层中的偏置项），这个参数太多了，随便进行一次反向传播计算量都是巨大的，从计算资源和调参的角度都不建议用传统的神经网络。</p><p>而对于卷积神经网络（CNN），卷积层可以很好的利用图像本身具有的二维空间特征，比全连接网络仅仅考虑单个像素点的效果会更好，同时使用卷积核后图片的尺寸变小，方便后续计算；而池化层通过降采样的方式，在不影响图像质量的情况下，压缩图片，减少参数，这样计算量也会比全连接网络小很多。</p><p>因此，这个任务中我打算使用卷积神经网络（CNN）。</p><h3 id="图片抓取与预处理"><a href="#图片抓取与预处理" class="headerlink" title="图片抓取与预处理"></a>图片抓取与预处理</h3><p>根据任务要求，我们需要编写爬虫程序，到淘宝等网站抓取一些衣服、鞋子的图片，并利用训练好的模型进行分类。但考虑到淘宝等购物网站的图片并不是那么的理想，图片上往往会有一些折扣或者其他信息，干扰较大，所以我打算主要从百度图片等网站来抓取图片。考虑到我对爬虫不是很了解，所以这里我打算从网上搜集相关的模板进行修改。</p><p>数据集里的图片背景很简单，看起来都是黑底的，而且每一类都是只有衣服，没有别的干扰因素。而我们抓取到的图片往往会复杂很多，比如是白底的，有模特穿着这件衣服，或者说一张图片里面有好几件衣服，甚至是抓取的图片和衣服并没有关系等，所以预处理是非常有必要的，不进行预处理直接给网络进行分类的话，效果肯定不好。我对OpenCV比较熟悉，所以后面我打算利用python-opencv对图片做一个简单的预处理。</p><h3 id="对不支持类别进行判断"><a href="#对不支持类别进行判断" class="headerlink" title="对不支持类别进行判断"></a>对不支持类别进行判断</h3><p>这个一开始我想的是直接多弄一个类别，叫做“不支持类别”，但是这样的话并潜在的图像几乎是无限的，并不好确定数据集，并且从网上了解到这样的做法后面可能会遇到很多未知的问题。</p><p>后面又了解到，在人脸识别领域，往往会先训练一个二分类器来区分是否是人脸，之后再进行人脸的分类，这样的做法能够使人脸的分类稳定。因此，我也打算训练一个二分类器，判断图片是不是服装，是服装就再进行服装的分类，否则就判定为“不支持类别”。</p><h2 id="搭建CNN"><a href="#搭建CNN" class="headerlink" title="搭建CNN"></a>搭建CNN</h2><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>torch.nn是专门为神经网络设计的模块化接口。nn构建于autograd之上，可以用来定义和运行神经网络。<br>nn.Module是nn中十分重要的类,包含网络各层的定义及forward方法。<br>定义自已的网络：</p><ul><li>需要继承nn.Module类，并实现forward方法。</li><li>一般把网络中具有可学习参数的层放在构造函数<strong>init</strong>()中，</li><li>不具有可学习参数的层(如ReLU)可放在构造函数中，也可不放在构造函数中(而在forward中使用nn.functional来代替)</li></ul><p>只要在nn.Module的子类中定义了forward函数，backward函数就会被自动实现(利用Autograd)。<br>在forward函数中可以使用任何Variable支持的函数，毕竟在整个pytorch构建的图中，是Variable在流动。还可以使用if,for,print,log等python语法.</p><p>注：Pytorch基于nn.Module构建的模型中，只支持mini-batch的Variable输入方式。</p><p>比如，只有一张输入图片，也需要变成 N x C x H x W 的形式：(batch channel H W) </p><p>例如：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">input_image <span class="token operator">=</span> torch<span class="token punctuation">.</span>FloatTensor<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">)</span>input_image <span class="token operator">=</span> Variable<span class="token punctuation">(</span>input_image<span class="token punctuation">)</span>input_image <span class="token operator">=</span> input_image<span class="token punctuation">.</span>unsqueeze<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>   <span class="token comment"># 1 x 1 x 28 x 28</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="设计FashionCNN类"><a href="#设计FashionCNN类" class="headerlink" title="设计FashionCNN类"></a>设计FashionCNN类</h3><p>如何使用Sequential、如何设计卷积层、各个部分的作用等上课都讲过，这里根据课上讲的来搭建即可。</p><p>但是搭建的时候需要特别注意CNN中的输入输出公式，课上只讲了进过卷积或者池化之后矩阵发生的变化，这个变化具体怎么发生的、哪些因素在影响好像没讲太多，我在实现这个CNN时，因为没有搞清楚CNN的输入输出公式，在搭建网络的时候出了很多的问题。</p><p>在弄清楚这些函数的计算公式，知道输入输出的变化规律之后，搭建模型或者修改模型会方便很多。</p><h4 id="部分函数的计算公式"><a href="#部分函数的计算公式" class="headerlink" title="部分函数的计算公式"></a>部分函数的计算公式</h4><p><strong>nn.Conv2d</strong></p><p>class torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True)</p><p>二维卷积层, 输入的尺度是(N, C_in, H, W)，输出尺度（N, C_out, H_out, W_out）。</p><p>计算公式：<code>out=（input+2∗padding−kernel_size)/stride+1</code></p><p><strong>nn.MaxPool2d</strong></p><p>class torch.nn.MaxPool2d(kernel_size, stride=None, padding=0, dilation=1, return_indices=False, ceil_mode=False)</p><p>计算公式：<code>out=(input+2∗padding−kernel_size)/stride+1</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn<span class="token keyword">class</span> <span class="token class-name">FashionCNN</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 在设计的时候，注意CNN里面的输入输出公式！！！</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span>FashionCNN<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 第一层卷积</span>        <span class="token comment"># 输入[1,28,28]</span>        self<span class="token punctuation">.</span>layer1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>            <span class="token comment"># 卷积层</span>            <span class="token comment">#   padding是边缘填充，可以分为四类：零填充，常数填充，镜像填充，重复填充。</span>            nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>in_channels<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> out_channels<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token comment"># 归一化处理https://zhuanlan.zhihu.com/p/205453986</span>            <span class="token comment">#   在卷积神经网络的卷积层之后总会添加BatchNorm2d进行数据的归一化处理</span>            <span class="token comment">#   这使得数据在进行Relu之前不会因为数据过大而导致网络性能的不稳定</span>            nn<span class="token punctuation">.</span>BatchNorm2d<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token comment"># 池化层</span>            <span class="token comment"># 　池化层是夹在连续的卷积层的中间层，池化层可以非常有效地缩小矩阵的尺寸。从而减少最后全连接层中的参数。</span>            nn<span class="token punctuation">.</span>MaxPool2d<span class="token punctuation">(</span>kernel_size<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span>        <span class="token comment"># 第二层卷积</span>        <span class="token comment"># 输入[32,14,14]https://img-blog.csdnimg.cn/20200604155746947.bmp</span>        self<span class="token punctuation">.</span>layer2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>            nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>in_channels<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">,</span> out_channels<span class="token operator">=</span><span class="token number">128</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>BatchNorm2d<span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>MaxPool2d<span class="token punctuation">(</span>kernel_size<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span>        <span class="token comment"># 第三层卷积</span>        <span class="token comment"># 输入[128，6，6]</span>        self<span class="token punctuation">.</span>layer3 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>            nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>in_channels<span class="token operator">=</span><span class="token number">128</span><span class="token punctuation">,</span> out_channels<span class="token operator">=</span><span class="token number">64</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>BatchNorm2d<span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>MaxPool2d<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span>        <span class="token comment"># 防止过拟合</span>        self<span class="token punctuation">.</span>drop <span class="token operator">=</span> nn<span class="token punctuation">.</span>Dropout2d<span class="token punctuation">(</span><span class="token number">0.25</span><span class="token punctuation">)</span>        <span class="token comment"># 全连接层</span>        <span class="token comment"># 输入[64,2，2]</span>        self<span class="token punctuation">.</span>fc1 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>in_features<span class="token operator">=</span><span class="token number">64</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> out_features<span class="token operator">=</span><span class="token number">600</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc2 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>in_features<span class="token operator">=</span><span class="token number">600</span><span class="token punctuation">,</span> out_features<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc3 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span>in_features<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span> out_features<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>fc4 <span class="token operator">=</span> nn<span class="token punctuation">.</span>Softmax<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>        out <span class="token operator">=</span> self<span class="token punctuation">.</span>layer1<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        out <span class="token operator">=</span> self<span class="token punctuation">.</span>layer2<span class="token punctuation">(</span>out<span class="token punctuation">)</span>        out <span class="token operator">=</span> self<span class="token punctuation">.</span>layer3<span class="token punctuation">(</span>out<span class="token punctuation">)</span>        out <span class="token operator">=</span> out<span class="token punctuation">.</span>view<span class="token punctuation">(</span>out<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        out <span class="token operator">=</span> self<span class="token punctuation">.</span>fc1<span class="token punctuation">(</span>out<span class="token punctuation">)</span>        out <span class="token operator">=</span> self<span class="token punctuation">.</span>drop<span class="token punctuation">(</span>out<span class="token punctuation">)</span>        out <span class="token operator">=</span> self<span class="token punctuation">.</span>fc2<span class="token punctuation">(</span>out<span class="token punctuation">)</span>        out <span class="token operator">=</span> self<span class="token punctuation">.</span>fc3<span class="token punctuation">(</span>out<span class="token punctuation">)</span>        out <span class="token operator">=</span> self<span class="token punctuation">.</span>fc4<span class="token punctuation">(</span>out<span class="token punctuation">)</span>        <span class="token keyword">return</span> out<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="训练CNN"><a href="#训练CNN" class="headerlink" title="训练CNN"></a>训练CNN</h2><h3 id="引入库"><a href="#引入库" class="headerlink" title="引入库"></a>引入库</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> copy<span class="token keyword">from</span> itertools <span class="token keyword">import</span> chain<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token comment"># import numpy as np</span><span class="token keyword">import</span> torch<span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn<span class="token keyword">import</span> torchvision<span class="token keyword">import</span> torchvision<span class="token punctuation">.</span>transforms <span class="token keyword">as</span> transforms<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>metrics <span class="token keyword">import</span> confusion_matrix<span class="token keyword">from</span> torch<span class="token punctuation">.</span>autograd <span class="token keyword">import</span> Variable<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data <span class="token keyword">import</span> Dataset<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果GPU可用，则使用</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 尝试使用GPU</span>device <span class="token operator">=</span> torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string">"cuda:0"</span> <span class="token keyword">if</span> torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>is_available<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token string">"cpu"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="加载数据集"><a href="#加载数据集" class="headerlink" title="加载数据集"></a>加载数据集</h3><p>虽然提供了.npy格式的数据集，但是里面的图片是整型的，不是浮点数型的，用来训练的话还需要归一化。</p><p>这里我觉得使用torch.utils.data里面的Dataset会方便一些，因此采用了这种方法加载数据集。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 加载数据集</span>train_set <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>FashionMNIST<span class="token punctuation">(</span><span class="token string">"./src/data"</span><span class="token punctuation">,</span> download<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>                                              transform<span class="token operator">=</span>transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span><span class="token punctuation">[</span>transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>test_set <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>FashionMNIST<span class="token punctuation">(</span><span class="token string">"./src/data"</span><span class="token punctuation">,</span> download<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> train<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>                                             transform<span class="token operator">=</span>transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span><span class="token punctuation">[</span>transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>train_loader <span class="token operator">=</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>train_set<span class="token punctuation">,</span> batch_size<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span>test_loader <span class="token operator">=</span> torch<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>test_set<span class="token punctuation">,</span> batch_size<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="加载模型、定义训练变量"><a href="#加载模型、定义训练变量" class="headerlink" title="加载模型、定义训练变量"></a>加载模型、定义训练变量</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 加载模型</span>model <span class="token operator">=</span> FashionCNN<span class="token punctuation">(</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token comment"># 使用交叉熵损失函数</span>error <span class="token operator">=</span> nn<span class="token punctuation">.</span>CrossEntropyLoss<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 定义学习率</span>learning_rate <span class="token operator">=</span> <span class="token number">0.0005</span><span class="token comment"># 定义优化器</span>optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span>model<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lr<span class="token operator">=</span>learning_rate<span class="token punctuation">)</span><span class="token comment"># 循环次数</span>num_epochs <span class="token operator">=</span> <span class="token number">5</span><span class="token comment"># 迭代次数</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token comment"># 是否画图</span>display <span class="token operator">=</span> <span class="token boolean">True</span><span class="token comment"># 最小迭代次数</span>min_epochs <span class="token operator">=</span> <span class="token number">1</span><span class="token comment"># 最小的损失</span>min_loss <span class="token operator">=</span> <span class="token number">0.2</span><span class="token comment"># 最优模型</span>best_model <span class="token operator">=</span> <span class="token boolean">None</span><span class="token comment"># Lists for visualization of loss and accuracy</span>loss_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>iteration_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>accuracy_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment"># Lists for knowing classwise accuracy</span>predictions_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>labels_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="进行训练"><a href="#进行训练" class="headerlink" title="进行训练"></a>进行训练</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_epochs<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 　分批次加载数据集</span>    <span class="token keyword">for</span> train_images<span class="token punctuation">,</span> train_labels <span class="token keyword">in</span> train_loader<span class="token punctuation">:</span>        <span class="token comment"># for i in range(len(train_images_list) // 100):</span>        <span class="token comment"># Transferring images and labels to GPU if available</span>        <span class="token comment"># train_images = torch.tensor(train_images_list[i * 100:(i + 1) * 100])</span>        <span class="token comment"># train_labels = torch.tensor(train_labels_list[i * 100:(i + 1) * 100])</span>        train_images<span class="token punctuation">,</span> train_labels <span class="token operator">=</span> train_images<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token punctuation">,</span> train_labels<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>        train <span class="token operator">=</span> Variable<span class="token punctuation">(</span>train_images<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        train_labels <span class="token operator">=</span> Variable<span class="token punctuation">(</span>train_labels<span class="token punctuation">)</span>        <span class="token comment"># Forward pass</span>        outputs <span class="token operator">=</span> model<span class="token punctuation">(</span>train<span class="token punctuation">)</span>        loss <span class="token operator">=</span> error<span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> train_labels<span class="token punctuation">)</span>        <span class="token comment"># Initializing a gradient as 0 so there is no mixing of gradient among the batches</span>        optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># Propagating the error backward</span>        loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># Optimizing the parameters</span>        optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>        count <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token comment"># Testing the model</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token punctuation">(</span>count <span class="token operator">%</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># It's same as "if count % 50 == 0"</span>            total <span class="token operator">=</span> <span class="token number">0</span>            correct <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">for</span> test_images<span class="token punctuation">,</span> test_labels <span class="token keyword">in</span> test_loader<span class="token punctuation">:</span>                <span class="token comment"># for j in range(len(test_images_list) // 100):</span>                <span class="token comment">#     test_images = torch.tensor(test_images_list[i * 100:(i + 1) * 100])</span>                <span class="token comment">#     test_labels = torch.tensor(test_labels_list[i * 100:(i + 1) * 100])</span>                test_images<span class="token punctuation">,</span> test_labels <span class="token operator">=</span> test_images<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token punctuation">,</span> test_labels<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>                labels_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>test_labels<span class="token punctuation">)</span>                test_real <span class="token operator">=</span> Variable<span class="token punctuation">(</span>test_images<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                outputs <span class="token operator">=</span> model<span class="token punctuation">(</span>test_real<span class="token punctuation">)</span>                predictions <span class="token operator">=</span> torch<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>                predictions_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>predictions<span class="token punctuation">)</span>                correct <span class="token operator">+=</span> <span class="token punctuation">(</span>predictions <span class="token operator">==</span> test_labels<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                total <span class="token operator">+=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>test_labels<span class="token punctuation">)</span>            accuracy <span class="token operator">=</span> correct <span class="token operator">*</span> <span class="token number">100</span> <span class="token operator">/</span> total            loss_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>loss<span class="token punctuation">.</span>data<span class="token punctuation">)</span>            iteration_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>count<span class="token punctuation">)</span>            accuracy_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>accuracy<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token punctuation">(</span>count <span class="token operator">%</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Iteration: {}, Loss: {}, Accuracy: {}%"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span> loss<span class="token punctuation">.</span>data<span class="token punctuation">,</span> accuracy<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 一般可以默认验证集的损失函数值由下降转向上升（即最小值）处，模型的泛化能力最好。</span>        <span class="token keyword">if</span> epoch <span class="token operator">&gt;=</span> min_epochs <span class="token keyword">and</span> loss<span class="token punctuation">.</span>data <span class="token operator">&lt;=</span> min_loss<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"update best model"</span><span class="token punctuation">)</span>            min_loss <span class="token operator">=</span> loss<span class="token punctuation">.</span>data            best_model <span class="token operator">=</span> copy<span class="token punctuation">.</span>deepcopy<span class="token punctuation">(</span>model<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>训练过程中的输出：</p><pre class="line-numbers language-none"><code class="language-none">Iteration: 500, Loss: 0.4136478304862976, Accuracy: 88.0999984741211%update best modelupdate best modelupdate best modelupdate best modelupdate best modelupdate best modelupdate best modelIteration: 1000, Loss: 0.3463529646396637, Accuracy: 89.75%update best modelIteration: 1500, Loss: 0.18912623822689056, Accuracy: 88.80999755859375%update best modelupdate best modelupdate best modelIteration: 2000, Loss: 0.15128815174102783, Accuracy: 90.06999969482422%update best modelupdate best modelIteration: 2500, Loss: 0.15940940380096436, Accuracy: 89.0%update best modelupdate best modelIteration: 3000, Loss: 0.1301259845495224, Accuracy: 90.20999908447266%<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="保存最优模型"><a href="#保存最优模型" class="headerlink" title="保存最优模型"></a>保存最优模型</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>save<span class="token punctuation">(</span>best_model<span class="token punctuation">.</span>state_dict<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"best_model.pth"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="画出迭代中的损失变化"><a href="#画出迭代中的损失变化" class="headerlink" title="画出迭代中的损失变化"></a>画出迭代中的损失变化</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 画出迭代中的损失</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>iteration_list<span class="token punctuation">,</span> loss_list<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">"No. of Iteration"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">"Loss"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">"Iterations vs Loss"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/machine-learning-7/output_20_0.png"></p><h3 id="画出迭代中的准确度变化"><a href="#画出迭代中的准确度变化" class="headerlink" title="画出迭代中的准确度变化"></a>画出迭代中的准确度变化</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>iteration_list<span class="token punctuation">,</span> accuracy_list<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">"No. of Iteration"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">"Accuracy"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">"Iterations vs Accuracy"</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/machine-learning-7/output_22_0.png"></p><h3 id="画出混淆矩阵"><a href="#画出混淆矩阵" class="headerlink" title="画出混淆矩阵"></a>画出混淆矩阵</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">predictions_l <span class="token operator">=</span> <span class="token punctuation">[</span>predictions_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>predictions_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>labels_l <span class="token operator">=</span> <span class="token punctuation">[</span>labels_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>labels_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>predictions_l <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>chain<span class="token punctuation">.</span>from_iterable<span class="token punctuation">(</span>predictions_l<span class="token punctuation">)</span><span class="token punctuation">)</span>labels_l <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>chain<span class="token punctuation">.</span>from_iterable<span class="token punctuation">(</span>labels_l<span class="token punctuation">)</span><span class="token punctuation">)</span>cm <span class="token operator">=</span> confusion_matrix<span class="token punctuation">(</span>labels_l<span class="token punctuation">,</span> predictions_l<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>matshow<span class="token punctuation">(</span>cm<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>colorbar<span class="token punctuation">(</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'Confusion Matrix'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Groundtruth'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'Predict'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/machine-learning-7/output_24_0.png"></p><h2 id="从百度图片爬取图片"><a href="#从百度图片爬取图片" class="headerlink" title="从百度图片爬取图片"></a>从百度图片爬取图片</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">import</span> re<span class="token keyword">import</span> requests<span class="token triple-quoted-string string">"""通过爬虫获取图片从网上找的一个爬虫例子，然后改了改就直接用了考虑到淘宝等购物网站搜到的图片比较复杂，干扰信息过多，所以爬取了百度图片"""</span><span class="token keyword">def</span> <span class="token function">get_label</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">:</span>    output_mapping <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token number">0</span><span class="token punctuation">:</span> <span class="token string">"T-shirt"</span><span class="token punctuation">,</span>        <span class="token number">1</span><span class="token punctuation">:</span> <span class="token string">"Trouser"</span><span class="token punctuation">,</span>        <span class="token number">2</span><span class="token punctuation">:</span> <span class="token string">"Pullover"</span><span class="token punctuation">,</span>        <span class="token number">3</span><span class="token punctuation">:</span> <span class="token string">"Dress"</span><span class="token punctuation">,</span>        <span class="token number">4</span><span class="token punctuation">:</span> <span class="token string">"Coat"</span><span class="token punctuation">,</span>        <span class="token number">5</span><span class="token punctuation">:</span> <span class="token string">"Sandal"</span><span class="token punctuation">,</span>        <span class="token number">6</span><span class="token punctuation">:</span> <span class="token string">"Shirt"</span><span class="token punctuation">,</span>        <span class="token number">7</span><span class="token punctuation">:</span> <span class="token string">"Sneaker"</span><span class="token punctuation">,</span>        <span class="token number">8</span><span class="token punctuation">:</span> <span class="token string">"Bag"</span><span class="token punctuation">,</span>        <span class="token number">9</span><span class="token punctuation">:</span> <span class="token string">"Ankle Boot"</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> output_mapping<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">get_images_from_baidu</span><span class="token punctuation">(</span>keyword<span class="token punctuation">,</span> page_num<span class="token punctuation">,</span> save_dir<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># UA 伪装：当前爬取信息伪装成浏览器</span>    <span class="token comment"># 将 User-Agent 封装到一个字典中</span>    <span class="token comment"># 【（网页右键 → 审查元素）或者 F12】 → 【Network】 → 【Ctrl+R】 → 左边选一项，右边在 【Response Hearders】 里查找</span>    header <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token string">'User-Agent'</span><span class="token punctuation">:</span> <span class="token string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) '</span>                      <span class="token string">'Chrome/78.0.3904.108 Safari/537.36'</span><span class="token punctuation">}</span>    <span class="token comment"># 请求的 url</span>    url <span class="token operator">=</span> <span class="token string">'https://image.baidu.com/search/acjson?'</span>    n <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> pn <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">30</span> <span class="token operator">*</span> page_num<span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 请求参数</span>        param <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'tn'</span><span class="token punctuation">:</span> <span class="token string">'resultjson_com'</span><span class="token punctuation">,</span>                 <span class="token comment"># 'logid': '7603311155072595725',</span>                 <span class="token string">'ipn'</span><span class="token punctuation">:</span> <span class="token string">'rj'</span><span class="token punctuation">,</span>                 <span class="token string">'ct'</span><span class="token punctuation">:</span> <span class="token number">201326592</span><span class="token punctuation">,</span>                 <span class="token string">'is'</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>                 <span class="token string">'fp'</span><span class="token punctuation">:</span> <span class="token string">'result'</span><span class="token punctuation">,</span>                 <span class="token string">'queryWord'</span><span class="token punctuation">:</span> keyword<span class="token punctuation">,</span>                 <span class="token string">'cl'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>                 <span class="token string">'lm'</span><span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>                 <span class="token string">'ie'</span><span class="token punctuation">:</span> <span class="token string">'utf-8'</span><span class="token punctuation">,</span>                 <span class="token string">'oe'</span><span class="token punctuation">:</span> <span class="token string">'utf-8'</span><span class="token punctuation">,</span>                 <span class="token string">'adpicid'</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>                 <span class="token string">'st'</span><span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>                 <span class="token string">'z'</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>                 <span class="token string">'ic'</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>                 <span class="token string">'hd'</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>                 <span class="token string">'latest'</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>                 <span class="token string">'copyright'</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>                 <span class="token string">'word'</span><span class="token punctuation">:</span> keyword<span class="token punctuation">,</span>                 <span class="token string">'s'</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>                 <span class="token string">'se'</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>                 <span class="token string">'tab'</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>                 <span class="token string">'width'</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>                 <span class="token string">'height'</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>                 <span class="token string">'face'</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>                 <span class="token string">'istype'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>                 <span class="token string">'qc'</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>                 <span class="token string">'nc'</span><span class="token punctuation">:</span> <span class="token string">'1'</span><span class="token punctuation">,</span>                 <span class="token string">'fr'</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>                 <span class="token string">'expermode'</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>                 <span class="token string">'force'</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>                 <span class="token string">'cg'</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>  <span class="token comment"># 这个参数没公开，但是不可少</span>                 <span class="token string">'pn'</span><span class="token punctuation">:</span> pn<span class="token punctuation">,</span>  <span class="token comment"># 显示：30-60-90</span>                 <span class="token string">'rn'</span><span class="token punctuation">:</span> <span class="token string">'30'</span><span class="token punctuation">,</span>  <span class="token comment"># 每页显示 30 条</span>                 <span class="token string">'gsm'</span><span class="token punctuation">:</span> <span class="token string">'1e'</span><span class="token punctuation">,</span>                 <span class="token string">'1618827096642'</span><span class="token punctuation">:</span> <span class="token string">''</span>                 <span class="token punctuation">}</span>        request <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token operator">=</span>url<span class="token punctuation">,</span> headers<span class="token operator">=</span>header<span class="token punctuation">,</span> params<span class="token operator">=</span>param<span class="token punctuation">)</span>        <span class="token keyword">if</span> request<span class="token punctuation">.</span>status_code <span class="token operator">==</span> <span class="token number">200</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Request success.'</span><span class="token punctuation">)</span>        request<span class="token punctuation">.</span>encoding <span class="token operator">=</span> <span class="token string">'utf-8'</span>        <span class="token comment"># 正则方式提取图片链接</span>        html <span class="token operator">=</span> request<span class="token punctuation">.</span>text        image_url_list <span class="token operator">=</span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span><span class="token string">'"thumbURL":"(.*?)",'</span><span class="token punctuation">,</span> html<span class="token punctuation">,</span> re<span class="token punctuation">.</span>S<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>image_url_list<span class="token punctuation">)</span>        <span class="token comment"># # 换一种方式</span>        <span class="token comment"># request_dict = request.json()</span>        <span class="token comment"># info_list = request_dict['data']</span>        <span class="token comment"># # 看它的值最后多了一个，删除掉</span>        <span class="token comment"># info_list.pop()</span>        <span class="token comment"># image_url_list = []</span>        <span class="token comment"># for info in info_list:</span>        <span class="token comment">#     image_url_list.append(info['thumbURL'])</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span>save_dir<span class="token punctuation">)</span><span class="token punctuation">:</span>            os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span>save_dir<span class="token punctuation">)</span>        <span class="token keyword">for</span> image_url <span class="token keyword">in</span> image_url_list<span class="token punctuation">:</span>            image_data <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token operator">=</span>image_url<span class="token punctuation">,</span> headers<span class="token operator">=</span>header<span class="token punctuation">)</span><span class="token punctuation">.</span>content            <span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>save_dir<span class="token punctuation">,</span> <span class="token string-interpolation"><span class="token string">f'</span><span class="token interpolation"><span class="token punctuation">{</span>n<span class="token punctuation">:</span><span class="token format-spec">06d</span><span class="token punctuation">}</span></span><span class="token string">.jpg'</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'wb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fp<span class="token punctuation">:</span>                fp<span class="token punctuation">.</span>write<span class="token punctuation">(</span>image_data<span class="token punctuation">)</span>            n <span class="token operator">=</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    fashion <span class="token operator">=</span> get_label<span class="token punctuation">(</span>i<span class="token punctuation">)</span>    save_dir <span class="token operator">=</span> <span class="token string">"./ImageSet/"</span> <span class="token operator">+</span> fashion    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Start get images of %s'</span> <span class="token operator">%</span> fashion<span class="token punctuation">)</span>    <span class="token comment"># 使用try和finally主要是怕搜到的图片页数没有这么多，然后提前终止了</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        get_images_from_baidu<span class="token punctuation">(</span>keyword<span class="token operator">=</span>fashion<span class="token punctuation">,</span> page_num<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> save_dir<span class="token operator">=</span>save_dir<span class="token punctuation">)</span>    <span class="token keyword">finally</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"error!"</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Get images of %s finished.'</span> <span class="token operator">%</span> fashion<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="图片预处理"><a href="#图片预处理" class="headerlink" title="图片预处理"></a>图片预处理</h2><p>FashionMNIST数据集里面的图片是28*28的灰度图，因此我们设计的卷积神经网络FashionCNN第一层的输入就是1*28*28。</p><p>而我们从网上爬取到的图片很难满足这样的要求，因此我们需要进行图片预处理之后才可以让FashionCNN来进行分类。</p><p><strong>预处理步骤:</strong></p><ol><li><p><strong>整理爬取的图片，仅保留有单件服装的图片</strong></p><p>从我们做的问题开始考虑，因为我们做的是服装分类问题，不是服装检测问题，而我们的数据集里面基本都是只有一件服装的，所以可以认为我们做的是对单件服装进行分类的问题。</p><p>但爬取到的图片里面有的有好多件服装，有的包括了其他种类的服装（比如搜索的Tshirt，但爬取到的是穿Tshirt的模特的全身照），还有的服装并不是我们搜索的服装，因此我们需要先整理爬取的图片，保证爬取的图片是没有问题的。</p><p>这一步的话，就只能人为的整理了，比较费时费力。</p></li><li><p><strong>读取文件夹下所有的图片，进行“前景提取”（服装部分处理成白色，其余部分处理为黑色）</strong></p><p><strong>这里可能是整个过程中花的时间最多的地方，尝试的最多的地方。</strong></p><p>最开始不进行任何处理，只是简简单单的转化为灰度图并且调整分辨率，用训练的网络进行分类时正确率只有8%多一点，好像效果还没有随机的好，随机能到10%左右。</p><p>之后就尝试了阈值化处理，这里主要也是把白色的背景处理成黑色，其余地方保留像素值或者处理成白色，这样的效果能好一些，到了30%左右。</p><p>然后上网查到了OpenCV的grabCut函数，听说这个做前景提取效果很好，但是在我尝试的时候，处理速度太慢了，而且效果也没有我想的那么理想，这个就直接放弃了。</p><p>最后我是打算用轮廓检测的方法来做，具体的步骤是：</p><ol><li><p><strong>阈值化处理</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> cv2<span class="token punctuation">.</span>cv2 <span class="token keyword">as</span> cv<span class="token keyword">import</span> os                  <span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt      image<span class="token operator">=</span>cv<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">"src/test/T-shirt/005.jpg"</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>cv<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>image<span class="token punctuation">,</span>cv<span class="token punctuation">.</span>COLOR_BGR2RGB<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/machine-learning-7/output_29_1.png"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">_<span class="token punctuation">,</span> img_binary <span class="token operator">=</span> cv<span class="token punctuation">.</span>threshold<span class="token punctuation">(</span>image<span class="token punctuation">,</span> <span class="token number">250</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> cv<span class="token punctuation">.</span>THRESH_BINARY_INV<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>cv<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>img_binary<span class="token punctuation">,</span>cv<span class="token punctuation">.</span>COLOR_BGR2RGB<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/images/machine-learning-7/output_30_1.png"></p></li><li><p><strong>进行轮廓检测并且填充轮廓，处理掉轮廓面积过大的图片，利用填充的轮廓作为mask来提取服装</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 尝试通过轮廓检测的方式来优化处理结果</span>mask <span class="token operator">=</span> np<span class="token punctuation">.</span>ones_like<span class="token punctuation">(</span>img_binary<span class="token punctuation">)</span><span class="token comment"># 找到所有的轮廓</span>contours<span class="token punctuation">,</span> _ <span class="token operator">=</span> cv<span class="token punctuation">.</span>findContours<span class="token punctuation">(</span>img_binary<span class="token punctuation">,</span> cv<span class="token punctuation">.</span>RETR_EXTERNAL<span class="token punctuation">,</span> cv<span class="token punctuation">.</span>CHAIN_APPROX_NONE<span class="token punctuation">)</span>area <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment"># 找到最大的轮廓</span><span class="token keyword">for</span> k <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>contours<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    area<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cv<span class="token punctuation">.</span>contourArea<span class="token punctuation">(</span>contours<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>max_idx <span class="token operator">=</span> np<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>area<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 如果轮廓几乎和图片一样大，说明很可能是被阈值化成全白或者全黑的图，应该舍去</span>w<span class="token punctuation">,</span> h <span class="token operator">=</span> img_binary<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">if</span> area<span class="token punctuation">[</span>max_idx<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0.9</span> <span class="token operator">*</span> w <span class="token operator">*</span> h<span class="token punctuation">:</span>    <span class="token comment"># 填充最大的轮廓</span>    cv<span class="token punctuation">.</span>drawContours<span class="token punctuation">(</span>mask<span class="token punctuation">,</span> contours<span class="token punctuation">,</span> max_idx<span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> cv<span class="token punctuation">.</span>FILLED<span class="token punctuation">)</span>    <span class="token keyword">del</span> area    <span class="token comment"># 利用轮廓填充的mask来提取服装</span>    img_end<span class="token operator">=</span>mask <span class="token operator">&amp;</span> image    plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>cv<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>img_end<span class="token punctuation">,</span> cv<span class="token punctuation">.</span>COLOR_BGR2RGB<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"轮廓检测填充方法失败！"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/machine-learning-7/output_32_0.png"></p></li><li><p><strong>调整分辨率并进行归一化处理</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img_end <span class="token operator">=</span> cv<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>img_end<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">28</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">)</span>new_image <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>img_end<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>cv<span class="token punctuation">.</span>normalize<span class="token punctuation">(</span>img_end<span class="token punctuation">,</span> new_image<span class="token punctuation">,</span> alpha<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> beta<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> norm_type<span class="token operator">=</span>cv<span class="token punctuation">.</span>NORM_MINMAX<span class="token punctuation">,</span> dtype<span class="token operator">=</span>cv<span class="token punctuation">.</span>CV_32F<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>cv<span class="token punctuation">.</span>cvtColor<span class="token punctuation">(</span>new_image<span class="token punctuation">,</span> cv<span class="token punctuation">.</span>COLOR_BGR2RGB<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/machine-learning-7/output_35_1.png"></p></li><li><p><strong>整合图片处理的过程，并且打上标签</strong></p><p>前面的处理都是针对图片的，没有提到图片标签的问题。因为我这里的爬虫爬取到图片之后，每一种图片会放到不同的文件夹，所以可以直接根据文件夹名称来知道图片的种类。我们只需要在读取图片的同时根据读取的文件夹来打上标签即可。（这部分代码略）</p><p>预处理的所有代码整理成了函数在processImage.py中。</p></li></ol></li></ol><h2 id="对不支持类别进行判断-1"><a href="#对不支持类别进行判断-1" class="headerlink" title="对不支持类别进行判断"></a>对不支持类别进行判断</h2><blockquote><p>这部分做的不好，仅仅是简单的判断了一下，做法自我感觉也不是很科学。。。</p></blockquote><p>这个部分我网上找了很多的资料，了解了比较多的内容。如果我们要在这个服装分类上再加一个不支持类别的判断的话，这个分类问题就从闭集分类问题变成了开集分类问题。其中：</p><ul><li>闭集分类问题：集合S包含N个有限类别，且该N个类别有具体标签，闭集分类问题即划分这N个类别</li><li>开集分类问题：集合S包含N个有具体标签的有限类别，且S包含K个有限或无限未知类别，开集分类问题即划分这N个类别且拒绝这K个未知类别</li></ul><p>由于我们手头上只有服装的数据集，不支持类别的数据几乎没有，而且就算制作，不支持类别的数据可能是无穷无尽的，并不好制作。所以我一开始的想法就是利用OCSVM（one class support vector machine,即单类支持向量机）来做一个分类判断，如果不是服装就拒绝后面的分类，如果是服装就再进行服装分类。</p><p>OCSVM该模型将数据样本通过核函数映射到高维特征空间，使其具有更良好的聚集性，在特征空间中求解一个最优超平面实现目标数据与坐标原点的最大分离。这个模型适合样本不均衡的情况，样本被映射到新的空间后，大类样本能够聚成簇(cluster)，小类样本作为异常点在簇之外，这个簇可以用超平面刻画。</p><p>不过，因为目前已经在这个项目上面花了比较多的时间，实现OCSVM的过程中还需要对图像进行特征提取等，这些目前还没做。所以我先尝试了一下直接通过CNN最后一层输出的每个类的概率来判断是否是不支持类别。</p><p>这种方法的思想很简单：判断输出向量里面最大值与平均值的差是不是过小、最大值是不是过小来看CNN是不是明显的做出分类。这个部分的代码如下所示：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">judgeOutLiner</span><span class="token punctuation">(</span>outputs<span class="token punctuation">,</span> sigma<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">,</span> threshold1<span class="token operator">=</span><span class="token number">0.9</span><span class="token punctuation">,</span> threshold2<span class="token operator">=</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    labels <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token builtin">sum</span> <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>outputs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        label <span class="token operator">=</span> outputs<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>np<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>label<span class="token punctuation">)</span> <span class="token operator">-</span> np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>label<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> sigma <span class="token keyword">and</span> np<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>label<span class="token punctuation">)</span> <span class="token operator">&lt;</span> threshold1 <span class="token keyword">or</span> np<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>label<span class="token punctuation">)</span> <span class="token operator">&lt;</span> threshold2<span class="token punctuation">:</span>            <span class="token comment"># print("out liners!")</span>            labels<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>            <span class="token builtin">sum</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># print("type is:", np.argmax(label))</span>            labels<span class="token punctuation">.</span>append<span class="token punctuation">(</span>np<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>label<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># print(labels)</span>    <span class="token keyword">return</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>labels<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">sum</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="测试CNN"><a href="#测试CNN" class="headerlink" title="测试CNN"></a>测试CNN</h2><p>首先要引用图像预处理的代码和可视化部分的代码，以及其他库</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> src<span class="token punctuation">.</span>processImage <span class="token keyword">import</span> get_dataset<span class="token keyword">from</span> src<span class="token punctuation">.</span>fashion_tools <span class="token keyword">import</span> display_result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="对FashionMNIST测试集进行测试"><a href="#对FashionMNIST测试集进行测试" class="headerlink" title="对FashionMNIST测试集进行测试"></a>对FashionMNIST测试集进行测试</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">display<span class="token operator">=</span><span class="token boolean">True</span><span class="token comment"># 加载模型</span>model <span class="token operator">=</span> FashionCNN<span class="token punctuation">(</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>model<span class="token punctuation">.</span>load_state_dict<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token string">'./src/new_best_model.pth'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>total <span class="token operator">=</span> <span class="token number">0</span>correct <span class="token operator">=</span> <span class="token number">0</span>out_liner <span class="token operator">=</span> <span class="token number">0</span><span class="token comment"># Lists for knowing classwise accuracy</span>predictions_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>labels_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>test_images <span class="token operator">=</span> <span class="token boolean">None</span>test_labels <span class="token operator">=</span> <span class="token boolean">None</span>predictions <span class="token operator">=</span> <span class="token boolean">None</span><span class="token keyword">for</span> test_images<span class="token punctuation">,</span> test_labels <span class="token keyword">in</span> test_loader<span class="token punctuation">:</span>    test_images<span class="token punctuation">,</span> test_labels <span class="token operator">=</span> test_images<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token punctuation">,</span> test_labels<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>    labels_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>test_labels<span class="token punctuation">)</span>    test_real <span class="token operator">=</span> Variable<span class="token punctuation">(</span>test_images<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    outputs <span class="token operator">=</span> model<span class="token punctuation">(</span>test_real<span class="token punctuation">)</span>    <span class="token comment"># predictions = torch.max(outputs, 1)[1].to(device)</span>    predictions<span class="token punctuation">,</span> out <span class="token operator">=</span> judgeOutLiner<span class="token punctuation">(</span>outputs<span class="token punctuation">.</span>cpu<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    predictions <span class="token operator">=</span> torch<span class="token punctuation">.</span>from_numpy<span class="token punctuation">(</span>predictions<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>    out_liner <span class="token operator">+=</span> out    predictions_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>predictions<span class="token punctuation">)</span>    correct <span class="token operator">+=</span> <span class="token punctuation">(</span>predictions <span class="token operator">==</span> test_labels<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    total <span class="token operator">+=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>test_labels<span class="token punctuation">)</span>accuracy <span class="token operator">=</span> correct <span class="token operator">*</span> <span class="token number">100</span> <span class="token operator">/</span> total<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Accuracy: {}%"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>accuracy<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"不支持类别个数: {}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>out_liner<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> display<span class="token punctuation">:</span>    display_result<span class="token punctuation">(</span>test_images<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cpu<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> test_labels<span class="token punctuation">.</span>cpu<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                       predictions<span class="token punctuation">.</span>cpu<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"test_demo"</span><span class="token punctuation">)</span>    <span class="token comment"># 画出混淆矩阵</span>    predictions_l <span class="token operator">=</span> <span class="token punctuation">[</span>predictions_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>predictions_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    labels_l <span class="token operator">=</span> <span class="token punctuation">[</span>labels_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>labels_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    predictions_l <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>chain<span class="token punctuation">.</span>from_iterable<span class="token punctuation">(</span>predictions_l<span class="token punctuation">)</span><span class="token punctuation">)</span>    labels_l <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>chain<span class="token punctuation">.</span>from_iterable<span class="token punctuation">(</span>labels_l<span class="token punctuation">)</span><span class="token punctuation">)</span>    cm <span class="token operator">=</span> confusion_matrix<span class="token punctuation">(</span>labels_l<span class="token punctuation">,</span> predictions_l<span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>matshow<span class="token punctuation">(</span>cm<span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>colorbar<span class="token punctuation">(</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'Confusion Matrix'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Groundtruth'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'Predict'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-none"><code class="language-none">Accuracy: 83.73999786376953%不支持类别个数: 176<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/machine-learning-7/output_42_2.png"></p><p><img src="/images/machine-learning-7/output_42_3.png"></p><h3 id="对爬虫得到的数据集进行测试"><a href="#对爬虫得到的数据集进行测试" class="headerlink" title="对爬虫得到的数据集进行测试"></a>对爬虫得到的数据集进行测试</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">display<span class="token operator">=</span><span class="token boolean">True</span>images<span class="token punctuation">,</span> labels <span class="token operator">=</span> get_dataset<span class="token punctuation">(</span><span class="token string">"./src/test/"</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">,</span><span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token comment"># 加载模型</span>model <span class="token operator">=</span> FashionCNN<span class="token punctuation">(</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>model<span class="token punctuation">.</span>load_state_dict<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token string">'./src/new_best_model.pth'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>total <span class="token operator">=</span> <span class="token number">0</span>correct <span class="token operator">=</span> <span class="token number">0</span>out_liner <span class="token operator">=</span> <span class="token number">0</span><span class="token comment"># Lists for knowing classwise accuracy</span>predictions_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>labels_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>test_images <span class="token operator">=</span> <span class="token boolean">None</span>test_labels <span class="token operator">=</span> <span class="token boolean">None</span>predictions <span class="token operator">=</span> <span class="token boolean">None</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>images<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    test_images <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>images<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">:</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    test_labels <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>labels<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">:</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    labels_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>test_labels<span class="token punctuation">)</span>    test_images<span class="token punctuation">,</span> test_labels <span class="token operator">=</span> test_images<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token punctuation">,</span> test_labels<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>    test_real <span class="token operator">=</span> Variable<span class="token punctuation">(</span>test_images<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    outputs <span class="token operator">=</span> model<span class="token punctuation">(</span>test_real<span class="token punctuation">)</span>    <span class="token comment"># predictions = torch.max(outputs, 1)[1].to(device)</span>    predictions<span class="token punctuation">,</span> out <span class="token operator">=</span> judgeOutLiner<span class="token punctuation">(</span>outputs<span class="token punctuation">.</span>cpu<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    predictions <span class="token operator">=</span> torch<span class="token punctuation">.</span>from_numpy<span class="token punctuation">(</span>predictions<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span>    out_liner <span class="token operator">+=</span> out    predictions_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>predictions<span class="token punctuation">)</span>    correct <span class="token operator">+=</span> <span class="token punctuation">(</span>predictions <span class="token operator">==</span> test_labels<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    total <span class="token operator">+=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>test_labels<span class="token punctuation">)</span>accuracy <span class="token operator">=</span> correct <span class="token operator">*</span> <span class="token number">100</span> <span class="token operator">/</span> total<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Accuracy: {}%"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>accuracy<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"不支持类别个数: {}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>out_liner<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> display<span class="token punctuation">:</span>    display_result<span class="token punctuation">(</span>test_images<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cpu<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> test_labels<span class="token punctuation">.</span>cpu<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                       predictions<span class="token punctuation">.</span>cpu<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"test_real"</span><span class="token punctuation">)</span>    <span class="token comment"># 画出混淆矩阵</span>    predictions_l <span class="token operator">=</span> <span class="token punctuation">[</span>predictions_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>predictions_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    labels_l <span class="token operator">=</span> <span class="token punctuation">[</span>labels_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>labels_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    predictions_l <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>chain<span class="token punctuation">.</span>from_iterable<span class="token punctuation">(</span>predictions_l<span class="token punctuation">)</span><span class="token punctuation">)</span>    labels_l <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>chain<span class="token punctuation">.</span>from_iterable<span class="token punctuation">(</span>labels_l<span class="token punctuation">)</span><span class="token punctuation">)</span>    cm <span class="token operator">=</span> confusion_matrix<span class="token punctuation">(</span>labels_l<span class="token punctuation">,</span> predictions_l<span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>matshow<span class="token punctuation">(</span>cm<span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>colorbar<span class="token punctuation">(</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">'Confusion Matrix'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Groundtruth'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'Predict'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-none"><code class="language-none">Accuracy: 61.000003814697266%不支持类别个数: 22    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/machine-learning-7/output_44_3.png"></p><p><img src="/images/machine-learning-7/output_44_4.png"></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记（六）：深入理解卷积神经网络</title>
      <link href="2022/01/15/machine-learning-6/"/>
      <url>2022/01/15/machine-learning-6/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习笔记（六）：深入理解卷积神经网络"><a href="#机器学习笔记（六）：深入理解卷积神经网络" class="headerlink" title="机器学习笔记（六）：深入理解卷积神经网络"></a>机器学习笔记（六）：深入理解卷积神经网络</h1><h2 id="一、卷积计算层CONV"><a href="#一、卷积计算层CONV" class="headerlink" title="一、卷积计算层CONV"></a>一、卷积计算层CONV</h2><h3 id="1-1-什么是“卷积”？"><a href="#1-1-什么是“卷积”？" class="headerlink" title="1.1 什么是“卷积”？"></a>1.1 什么是“卷积”？</h3><p>什么是卷积：</p><ul><li><p>图像中<strong>不同数据窗口的数据</strong>和<strong>卷积核（一个滤波矩阵）</strong>作<strong>内积</strong>的操作叫做卷积。</p></li><li><p>简单来说，卷积(或称内积)就是“对应相乘，再结果累加”。</p></li></ul><p>卷积的计算过程又称为滤波（filter)，本质是提取图像不同频段的特征。</p><h3 id="1-2-什么是“卷积核”？"><a href="#1-2-什么是“卷积核”？" class="headerlink" title="1.2 什么是“卷积核”？"></a>1.2 什么是“卷积核”？</h3><p>什么是卷积核：</p><p>卷积核也称为滤波器filter，带着一组固定权重的神经元，通常是n*m二维的矩阵，n和m也是神经元的感受野。n*m 矩阵中存放的是对感受野中数据处理的系数。</p><p>一个卷积核的滤波可以用来提取特定的特征（例如可以提取物体轮廓、颜色深浅等）。</p><p>通过卷积层从原始数据中提取出新的特征的过程，又成为feature map(特征映射)。</p><h4 id="举例说明："><a href="#举例说明：" class="headerlink" title="举例说明："></a>举例说明：</h4><p>【1】比如，我现在要训练一个最简单的CNN，用来识别一张图片里的字母是X还是O</p><p><img src="/images/machine-learning-6/v2-ce4e2ad2cb9919d7e49a66fcd9f7a267_720w.jpg"></p><p>人眼一看，很简单，明显就是X，但是计算机不知道，它不明白什么是X。所以，我们给这张图片加一个标签，也就是俗称的Label，Label=X，就告诉了计算机这张图代表的是X。计算机就记住了X的长相。</p><p>【2】但是并不是所有的X都长这样。</p><p>比如说…</p><p><img src="/images/machine-learning-6/v2-547828bbcc202a030dfc98fcb3cfe5af_720w.jpg"></p><p>这四个都是X，但它们和之前那张X明显不一样，计算机没见过它们，又都不认识了。</p><p>【3】不认识了怎么办？</p><p>当然是计算机‘回忆’是不是见过差不多的。——这时候CNN要做的，就是如何提取内容为X的图片的特征。</p><p>我们都知道，图片在计算机内部以像素值的方式被存储。</p><p>也就是说，两张X在计算机看来，其实是这样子的。其中1代表白色，-1代表黑色</p><p><img src="/images/machine-learning-6/v2-8bc4063deeaf11853fe1f9531b71e50a_720w.jpg"></p><p><img src="/images/machine-learning-6/v2-e216abf6d8042827b1e6de85732f0060_720w.jpg"></p><p>如果按照每像素逐个比较，肯定是不科学，结果不对而且效率低下，因此提出其他匹配方法。</p><p>观察这两张X图，可以发现尽管像素值无法一一对应，但也存在着某些共同点。如下图所示，两张图中三个同色区域的结构完全一致！</p><p><img src="/images/machine-learning-6/v2-df0a51f10a46347704274ee6ddbb614a_720w.jpg"></p><p>Q: 要将这两张图联系起来，无法进行<strong>全体像素对应</strong>，但是否能进行<strong>局部匹配</strong>？</p><p>A：肯定可以！！！</p><p>【4】从标准的X图中我们提取出三个特征（feature）</p><p>1号特征：</p><p><img src="/images/machine-learning-6/v2-2230b625dcbac671af2646ff9d39a7d7_720w.jpg"></p><p>2号特征：</p><p><img src="/images/machine-learning-6/v2-292a36d6fedd82498d406846e6a8fba2_720w.jpg"></p><p>3号特征：</p><p><img src="/images/machine-learning-6/v2-2674d52504845d3fc062fa36a607fff2_720w.jpg"></p><p>发现，只要用这三个feature，便可定位到X图片的某个局部</p><p><img src="/images/machine-learning-6/v2-eaa1665a93ae616abad84971ac09f60d_720w.jpg"></p><p>【5】这样的feature，在CNN中也被成为卷积核或者卷积单元（filter），一般是3X3，或者5X5的大小。而feature里的值，是通过模型学习得到的。</p><h3 id="1-3-CNN中的二维卷积（Convolution2D）"><a href="#1-3-CNN中的二维卷积（Convolution2D）" class="headerlink" title="1.3 CNN中的二维卷积（Convolution2D）"></a>1.3 CNN中的二维卷积（Convolution2D）</h3><p>卷积神经网络（CNN）包括一维卷积神经网络，二维卷积神经网络以及三维卷积神经网络。</p><p>一维卷积神经网络主要用于序列类的数据处理， 二维卷积神经网络常应用于图像类文本的识别， 三维卷积神经网络主要应用于医学图像以及视频类数据识别。</p><p>2D卷积是一个比较简单的操作：</p><p>（1）先从一个 3*3 的权重矩阵，也就是卷积核（filter）开始，让它逐步在二维输入数据上“扫描”。<br>（2）卷积核“滑动”的同时，计算权重矩阵和扫描所得的数据矩阵的乘积，然后把结果汇总成一个输出像素。<br>（3）卷积核会在它经过的所有位置上，都重复以上操作，直到把输入特征矩阵转换为另一个二维的特征矩阵。</p><p>动图的演示：</p><p>这是2D视角的动图：</p><p><img src="/images/machine-learning-6/v2-f35f041aec9cbbf26b98af649536cc90_b.webp"></p><p>这是3D视角的动图：</p><p><img src="/images/machine-learning-6/v2-42f6d50e57aae703f72e290be267d575_b.webp"></p><h3 id="1-4-总结："><a href="#1-4-总结：" class="headerlink" title="1.4 总结："></a>1.4 总结：</h3><p>简而言之，输出的特征，基本上就是原输入特征的加权和（权重是卷积核自带的值），而从像素位置上看，它们所处的地方大致相同。</p><p>那么为什么输出特征，会落入这个“大致区域”呢？</p><p>这取决于卷积核的大小。 卷积核的大小直接决定了在生成输出特征时，它合并了多少输入特征，也就是说：卷积核越小，输入输出的位置越接近；卷积核越大，距离就越远。</p><p>这和全连接层很不一样。</p><p>在上图的例子中，我们的输入有5×5=25个特征，而我们的输出则是3×3=9个特征。<br>如果这是一个全连接层，输入25个特征后，我们会输出包含25×9=225个参数的权重矩阵，每个输出特征都是每个输入特征的加权和。</p><p>这意味着对于每个输入特征，卷积执行的操作是使用9个参数进行转换。</p><h2 id="二、非线性激活层"><a href="#二、非线性激活层" class="headerlink" title="二、非线性激活层"></a>二、非线性激活层</h2><blockquote><p>CNN中非线性激活层通常使用relu函数，所以我们这里先介绍relu，再介绍其他的激活函数</p></blockquote><h3 id="2-1-什么是relu"><a href="#2-1-什么是relu" class="headerlink" title="2.1 什么是relu"></a>2.1 什么是relu</h3><p>官方解释：卷积层对原图运算多个卷积，产生一组线性激活响应，而<strong>非线性激活层</strong>是对之前的结果进行一个非线性的激活响应。</p><p><strong>激活函数的作用</strong>是用来加入非线性因素，把卷积层输出结果做非线性映射。</p><p><img src="/images/machine-learning-6/v2-3436533f80cbb1cc52275ef34a6dd658_720w.jpg"></p><p>在卷积神经网络中用到最多的非线性激活函数是relu函数，</p><p>它的公式定义：f(x)=max(0,x)</p><p>即，保留大于等于0的值，其余所有小于0的数值直接改写为0</p><p>&gt;=0的值全部保持不变：</p><p><img src="/images/machine-learning-6/v2-27938069bbdff1ec7d3e31d35dc0e44f_720w.jpg"></p><p>而&lt;0的值全部改写为0：</p><p><img src="/images/machine-learning-6/v2-c9ab4a0dc54874a747773dd2550eb061_720w.jpg"></p><p>作用后的结果：</p><p><img src="/images/machine-learning-6/v2-1ae057962612ca7a840003152fbfd78e_720w.jpg"></p><h3 id="2-2-其他常见的非线性激活函数"><a href="#2-2-其他常见的非线性激活函数" class="headerlink" title="2.2 其他常见的非线性激活函数"></a>2.2 其他常见的非线性激活函数</h3><p>sigmoid函数：$sigmoid(x)=\frac{1}{1+e^{-x}} $</p><p>tanh函数： $tanh(x)=\frac{e^x-e^{-x}}{e^x+e^{-x}}$</p><p>这两个函数的图像如下所示：</p><p><img src="/images/machine-learning-6/tanh-sigmoid.png"></p><h3 id="2-3-为何使用relu"><a href="#2-3-为何使用relu" class="headerlink" title="2.3 为何使用relu"></a>2.3 为何使用relu</h3><p>实际应用中，特别是深层网络在训练时，tanh和sigmoid会在端值趋于饱和，造成训练速度减慢，故深层网络的激活函数默认大多采用relu函数，浅层网络可以采用sigmoid和tanh函数。</p><p>那么为什么现在这么多网络，都更多地使用relu函数呢？一个重要原因就是上面提到的，其稀疏激活性。</p><ol><li>标准的sigmoid函数输出不具备稀疏性，需要用一些惩罚因子来训练出一大堆接近0的冗余数据来，从而产生稀疏数据</li><li>而relu是线性修正。它的作用是如果计算出的值小于0，就让它等于0，否则保持原来的值不变。<br><strong>这是一种简单粗暴地强制某些数据为0的方法</strong>，然而经实践证明，训练后的网络完全具备适度的稀疏性。而且训练后的可视化效果和传统方式预训练出的效果很相似，这也说明了relu具备引导适度稀疏的能力。<br>因此，relu的使用，使得网络可以自行引入稀疏性，同时大大地提高了训练速度。</li></ol><h2 id="三、池化层pooling"><a href="#三、池化层pooling" class="headerlink" title="三、池化层pooling"></a>三、池化层pooling</h2><h3 id="3-1-池化的作用"><a href="#3-1-池化的作用" class="headerlink" title="3.1 池化的作用"></a>3.1 池化的作用</h3><p><strong>池化操作，最大的作用就是减少数据量。</strong>池化层的引入，是仿照人的视觉系统对视觉输入对象进行降维和抽象。</p><p>在卷积神经网络过去的工作中，研究者普遍认为池化层有如下三个功效：</p><ol><li><p><strong>特征不变形：</strong>池化操作使得模型更加关注是否存在某些特征，而不是特征具体的位置。</p></li><li><p><strong>特征降维：</strong>池化相当于在空间范围内做了维度约减，从而使模型可以抽取更加广范围的特征。同时减小了下一层的输入大小，进而减少计算量和参数个数。</p></li><li><p>在一定程度上<strong>防止过拟合</strong>，更方便优化。由1、2可知，这种池化机制能够有效地原因在于，在发现一个特征之后，它的精确位置远不及它和其他特征的相对位置的关系重要。池化层会不断地减小数据的空间大小，因此参数的数量和计算量也会下降，这在一定程度上也控制了过拟合。</p></li></ol><h3 id="3-2-池化的分类"><a href="#3-2-池化的分类" class="headerlink" title="3.2 池化的分类"></a>3.2 池化的分类</h3><p>池化分为两种，Max Pooling 最大池化、Average Pooling平均池化。</p><p>顾名思义，最大池化就是取最大值，平均池化就是取平均值。其中<strong>“最大池化（Max pooling）”最为常见</strong>。</p><p>当前最常用形式的池化层，是每隔2个元素从图像划分出2*2的区块，然后对每个区块中的4个数取最大值，这将会减少75%的数据量。</p><p><img src="/images/machine-learning-6/v2-bf209e09a438648ea1482ecb90b88e21_720w.jpg"></p><h3 id="3-3-池化操作"><a href="#3-3-池化操作" class="headerlink" title="3.3 池化操作"></a>3.3 池化操作</h3><p>通常，CNN的卷积层之间都会<strong>周期性地插入池化层</strong></p><p>举例说明：</p><p><img src="/images/machine-learning-6/v2-e20252d79fb8589c881f53adb82bb1fe_720w.jpg"></p><p>依据步长，滑动窗口</p><p><img src="/images/machine-learning-6/v2-510ec9e7b789992b242c0ec97be77601_720w.jpg"></p><p>得到池化后的feature map，明显发现数据量减少了很多</p><p><img src="/images/machine-learning-6/v2-761a58554ff71b20f7b78f9bf326ee3b_720w.jpg"></p><h3 id="3-4-池化操作总结"><a href="#3-4-池化操作总结" class="headerlink" title="3.4 池化操作总结"></a>3.4 池化操作总结</h3><p>因为最大池化保留了每一个小块内的最大值，所以它相当于保留了这一块最佳匹配结果。</p><p>这也就意味着：池化操作<strong>不会具体关注</strong>窗口内到底是哪一个地方匹配了，而<strong>只关注</strong>是不是有某个地方匹配上了。</p><p><strong>侧面说明——CNN能够发现图像中是否具有某种特征，而不用在意到底在哪里具有这种特征</strong>。</p><p>这也就帮助解决，之前提到的<strong>计算机逐一像素匹配</strong>的死板做法。</p><h2 id="四、全连接层"><a href="#四、全连接层" class="headerlink" title="四、全连接层"></a>四、全连接层</h2><h3 id="4-1-全连接层的作用"><a href="#4-1-全连接层的作用" class="headerlink" title="4.1 全连接层的作用"></a>4.1 全连接层的作用</h3><ol><li><p>从侧面来理解</p><p>我们知道，<strong>局部连接</strong>与<strong>参数共享</strong>是卷积神经网络最重要的两个性质</p><p><strong>局部连接？</strong>——回忆一下卷积层的操作，是用一个3X3的fliter与原图进行连接操作，很明显原图中只有一个3X3的窗口能够与fliter连接起来。<br><strong>参数共享？</strong>——那窗口之外的、未连接的部分怎么办呢？ 我们知道，采用的是将窗口滑动起来的方法后续进行连接。这个方法的思想就是“参数共享” ，参数指的就是filter，用滑动窗口的方式，将这个filter值共享给原图中的每一块区域，连接进行卷积运算。</p><p><img src="/images/machine-learning-6/v2-2ced3a81d5977a3bf70f9721a2fd725e_720w.jpg"></p></li><li><p>为什么是全连接？</p><p>卷积取的是局部特征，全连接就是把以前的局部特征重新通过权值矩阵，组装成完整的图，因为用到了所有的局部特征，所以叫全连接。</p></li><li><p>全连接层要做的，是什么？</p><p>起到<strong>“分类”的作用</strong>。</p><p>全连接层要做的，就是对之前的所有操作进行一个总结。对特征图进行<strong>维度上的改变</strong>，来<strong>得到每个分类类别对应的概率值</strong>。</p></li></ol><h3 id="4-2-全连接操作"><a href="#4-2-全连接操作" class="headerlink" title="4.2 全连接操作"></a>4.2 全连接操作</h3><p>接着上面的例子，原图片尺寸为9X9，在一系列的卷积、relu、池化操作后，得到尺寸被压缩为2X2的三张特征图。如下图所示：</p><p><img src="/images/machine-learning-6/v2-5054d37bc25a3a838d8533570a969811_720w.jpg"></p><p>将三个特征图改变维度直接变成一维的数据，展开的数据即为属于类别X的概率值，值大小也在对应X的线条粗细中表现出来了。以上所有的操作都是对标准的原图X来进行的，因此最终分类显示即为X。</p><p><img src="/images/machine-learning-6/v2-ed75d8e64864d8b57a63d9a57859c819_720w.jpg"></p><p>如果，对并不标准的图进行分类</p><p><img src="/images/machine-learning-6/v2-61d1f8a642a5f5b225bafd4e77cdc069_720w.jpg"></p><p>进行一系列操作后，0.92表示极其大可能是X，因此对应到X的黄色线条比对应到O的绿色线条要粗很多很多</p><p><img src="/images/machine-learning-6/v2-001a35b937e3eec733e1e4a89507a367_720w.jpg"></p><p>我们对结果进行统计分析后，可判断这张图片里的字母为X。</p><h2 id="五、CNN总结"><a href="#五、CNN总结" class="headerlink" title="五、CNN总结"></a>五、CNN总结</h2><p>卷积神经网络主要由两部分组成，一部分是特征提取（卷积、激活函数、池化），另一部分是分类识别（全连接）</p><p><img src="/images/machine-learning-6/v2-6293c0f53e211e032323c959a7d0e5ad_720w.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记（五）：初探卷积神经网络</title>
      <link href="2022/01/12/machine-learning-5/"/>
      <url>2022/01/12/machine-learning-5/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习笔记（五）：初探卷积神经网络"><a href="#机器学习笔记（五）：初探卷积神经网络" class="headerlink" title="机器学习笔记（五）：初探卷积神经网络"></a>机器学习笔记（五）：初探卷积神经网络</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>卷积神经网络主要由两部分组成：</p><ul><li>一部分是<strong>特征提取</strong>（卷积、激活函数、池化）</li><li>另一部分是<strong>分类识别</strong>（全连接）</li></ul><p>卷积神经网络应用非常广泛：</p><ul><li><p>图像分类：场景分类，目标分类</p></li><li><p>图像检测：显著性检测，物体检测，语义检测等等</p></li><li><p>图像识别：人脸识别，字符识别，车牌识别，行为识别，步态识别等等</p></li><li><p>图像分割：前景分割，语义分割</p></li></ul><p>但是，CNN真正能做的，只是起到一个<strong>图像特征提取器</strong>的作用！</p><h2 id="二、CNN是什么"><a href="#二、CNN是什么" class="headerlink" title="二、CNN是什么"></a>二、CNN是什么</h2><h3 id="2-1-卷积神经网络（CNN）是一种带有卷积结构的深度神经网络"><a href="#2-1-卷积神经网络（CNN）是一种带有卷积结构的深度神经网络" class="headerlink" title="2.1 卷积神经网络（CNN）是一种带有卷积结构的深度神经网络"></a>2.1 卷积神经网络（CNN）是一种带有卷积结构的深度神经网络</h3><p><strong>卷积结构</strong>可以减少深层网络占用的内存量。</p><p><strong>卷积结构有三个关键的操作</strong></p><ul><li>其一是局部感受野，</li><li>其二是权值共享，</li><li>其三是池化层pooling。</li></ul><p><strong>作用：</strong>可以有效的减少网络的参数个数，缓解模型的过拟合问题。</p><h3 id="2-2-卷积神经网络（CNN）与普通神经网络非常相似"><a href="#2-2-卷积神经网络（CNN）与普通神经网络非常相似" class="headerlink" title="2.2 卷积神经网络（CNN）与普通神经网络非常相似"></a>2.2 卷积神经网络（CNN）与普通神经网络非常相似</h3><p><strong>相同点</strong>：</p><p>它们都由具有“可学习的权重W”和“偏置常量b”的神经元组成。<br>每个神经元都接收一些输入，并做一些点积计算，输出是每个分类的分数，普通神经网络里的一些计算技巧到这里依旧适用。</p><p><strong>不同之处在哪？</strong></p><p><strong>CNN具有三维体积的神经元(3D volumes of neurons)</strong></p><p>卷积神经网络，利用输入是图片的特点，把神经元设计成三个维度：<strong>depth、height、width</strong></p><p>(注意这个depth不是神经网络的深度，而是用来描述神经元的) 。</p><p>比如，输入的图片大小是 3× 32 × 32 (rgb)，那么输入神经元就也具有 3× 32 × 32 的维度。</p><p>传统神经网络：</p><p><img src="/images/machine-learning/5-1.jpg"></p><p>卷积神经网络：一个CNN由很多层组成，它们的输入是三维的，输出也是三维的</p><p><img src="/images/machine-learning/5-2.jpg"></p><h3 id="2-3-卷积神经网络（CNN）的结构"><a href="#2-3-卷积神经网络（CNN）的结构" class="headerlink" title="2.3 卷积神经网络（CNN）的结构"></a>2.3 卷积神经网络（CNN）的结构</h3><h5 id="1）卷积层（Convolutional-layer）"><a href="#1）卷积层（Convolutional-layer）" class="headerlink" title="1）卷积层（Convolutional layer）"></a>1）卷积层（Convolutional layer）</h5><p>卷积神经网路中，每层卷积层由若干卷积核组成，每个卷积核的参数都是通过反向传播算法优化得到的。</p><p>卷积运算的目的是提取输入的不同特征，第一层卷积层可能只能提取一些低级的特征如边缘、线条和角等层级，更多层的网络能从低级特征中迭代提取更复杂的特征。</p><h5 id="2）线性整流层（Rectified-Linear-Units-layer-ReLU-layer）"><a href="#2）线性整流层（Rectified-Linear-Units-layer-ReLU-layer）" class="headerlink" title="2）线性整流层（Rectified Linear Units layer, ReLU layer）"></a>2）线性整流层（Rectified Linear Units layer, ReLU layer）</h5><p>这一层神经的激活函数（Activation function）使用线性整流（Rectified Linear Units, ReLU）。</p><h5 id="3）池化层（Pooling-layer）"><a href="#3）池化层（Pooling-layer）" class="headerlink" title="3）池化层（Pooling layer）"></a>3）池化层（Pooling layer）</h5><p>通常在卷积层之后，会得到维度很大的特征，将特征切成几个区域，取其最大值或平均值，得到新的、维度较小的特征。</p><h5 id="4）全连接层（-Fully-Connected-layer）"><a href="#4）全连接层（-Fully-Connected-layer）" class="headerlink" title="4）全连接层（ Fully-Connected layer）"></a>4）全连接层（ Fully-Connected layer）</h5><p>把所有局部特征，结合变成全局特征，用来计算最后每一类的得分。</p><h3 id="2-4-一个卷积神经网络各层应用实例"><a href="#2-4-一个卷积神经网络各层应用实例" class="headerlink" title="2.4 一个卷积神经网络各层应用实例"></a>2.4 一个卷积神经网络各层应用实例</h3><p><img src="/images/machine-learning/5-3.jpg"></p><p>上图中，CNN要做的事情是：给定一张图片，现在需要模型判断这张图片里具体是一个什么东西，总之输出一个结果：这是什么？</p><p>左边是：</p><ul><li><strong>数据输入层</strong>，对数据做一些处理。</li></ul><p>中间是：</p><ul><li>CONV：<strong>卷积计算层，</strong>线性乘积、求和。</li><li>RELU：<strong>激励层</strong>，ReLU是激活函数的一种。</li><li>POOL：<strong>池化层</strong>，简言之，即取区域平均或最大。</li></ul><p>右边是：</p><ul><li>FC：<strong>全连接层，</strong>所有局部特征，结合变成全局特征，分类评分</li></ul><p>其中，卷积计算层是CNN的核心！</p><h2 id="三、为什么使用CNN"><a href="#三、为什么使用CNN" class="headerlink" title="三、为什么使用CNN"></a>三、为什么使用CNN</h2><p>在图像领域，用传统的神经网络并不合适。</p><p>我们知道，图像是由一个个像素点构成，每个像素点有三个通道，分别代表RGB颜色。如果一个图像的尺寸是（28，28，1），即代表这个图像的是一个长宽均为28，channel为1的图像（channel也叫depth,此处1代表灰色图像）。</p><p>使用全连接的网络结构，即，网络中的神经与与相邻层上的每个神经元均连接，那就意味着我们的网络输入层有28 * 28 =784个神经元，再假设隐藏层采用了15个神经元，输出层采用了10个神经元。那么简单计算一下，我们需要的参数个数(w和b)就有：784*15*10+15+10=117625个。这个参数太多了，随便进行一次反向传播计算量都是巨大的，从计算资源和调参的角度都不建议用传统的神经网络。</p><p>使用卷积神经网络，就可以比较好的解决这个问题。卷积层可以很好的利用图像本身具有的二维空间特征，比全连接网络仅仅考虑单个像素点的效果会更好，同时使用卷积核后图片的尺寸变小，方便后续计算；而池化层通过降采样的方式，在不影响图像质量的情况下，压缩图片，减少参数，这样计算量也会比全连接网络小很多。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记（四）：手写多层神经网络并应用</title>
      <link href="2022/01/10/machine-learning-4/"/>
      <url>2022/01/10/machine-learning-4/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习笔记（四）：手写多层神经网络并应用"><a href="#机器学习笔记（四）：手写多层神经网络并应用" class="headerlink" title="机器学习笔记（四）：手写多层神经网络并应用"></a>机器学习笔记（四）：手写多层神经网络并应用</h1><p>在上一篇文章中，我们已经学习了多层神经网络的基本原理，并且对正向传播、反向传播和激活函数都有了一定的了解。</p><p>在这部分，我们将仅通过numpy和sklearn的accuracy_score（偷了个懒，没手写）来实现一个多层神经网络，并且将其应用到不同的情景中。</p><h2 id="多层神经网络的构建"><a href="#多层神经网络的构建" class="headerlink" title="多层神经网络的构建"></a>多层神经网络的构建</h2><p>在理解了多层神经网络的原理之后，手写一个下面这样的代码并不是很难，所以这里就讲一讲主要的思路：</p><ul><li>这里使用sigmoid函数作为激活函数；</li><li>根据上一篇文章介绍的神经网络的矩阵表示，我们这里直接用矩阵表示每一层的参数，并且将每一层的参数保存到一个列表中；</li><li>根据之前讲的正向传播、反向传播公式来构造正向传播、反向传播函数。</li><li>既然是使用矩阵表示神经网络，我们增加、减少层数都非常容易，所以我们可以通过初始化的时候传入参数来指定这个多层神经网络的结构，这样使用的时候就更灵活了。</li></ul><p>需要注意的地方：</p><ul><li><p>在手写实现的过程中我发现原始的sigmoid函数可能会溢出，所以就做了一点处理；</p></li><li><p>反向传播这里需要判断是输出层还是隐藏层，计算公式不一样；</p></li><li><p>softmax函数仅仅用在predict函数中，目的是输出每一个种类的概率；</p><p>这里的predict函数其实本质上就是正向传播，我为了方便处理数据才这么写的，实际上并不需要这么做。</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>metrics <span class="token keyword">import</span> accuracy_score<span class="token comment"># def sigmoid(x):</span><span class="token comment">#     """</span><span class="token comment">#     sigmoid函数</span><span class="token comment">#     """</span><span class="token comment">#     return 1.0 / (1 + np.exp(-x))</span><span class="token keyword">def</span> <span class="token function">sigmoid</span><span class="token punctuation">(</span>Z<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    sigmoid函数，解决了溢出的问题    把大于0和小于0的元素分别处理    原来的sigmoid函数是 1/(1+np.exp(-Z))    当Z是比较小的负数时会出现上溢，此时可以通过计算exp(Z) / (1+exp(Z)) 来解决    """</span>    mask <span class="token operator">=</span> <span class="token punctuation">(</span>Z <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    positive_out <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros_like<span class="token punctuation">(</span>Z<span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">'float64'</span><span class="token punctuation">)</span>    negative_out <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros_like<span class="token punctuation">(</span>Z<span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">'float64'</span><span class="token punctuation">)</span>    <span class="token comment"># 大于0的情况</span>    positive_out <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span><span class="token operator">-</span>Z<span class="token punctuation">,</span> positive_out<span class="token punctuation">,</span> where<span class="token operator">=</span>mask<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 清除对小于等于0元素的影响</span>    positive_out<span class="token punctuation">[</span><span class="token operator">~</span>mask<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment"># 小于等于0的情况</span>    expZ <span class="token operator">=</span> np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>Z<span class="token punctuation">,</span> negative_out<span class="token punctuation">,</span> where<span class="token operator">=</span><span class="token operator">~</span>mask<span class="token punctuation">)</span>    negative_out <span class="token operator">=</span> expZ <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> expZ<span class="token punctuation">)</span>    <span class="token comment"># 清除对大于0元素的影响</span>    negative_out<span class="token punctuation">[</span>mask<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">return</span> positive_out <span class="token operator">+</span> negative_out<span class="token comment"># FIXME softmax函数输出的概率比较低，比如错误分类概率为0.18，而正确概率为0.22，相差不太大</span><span class="token keyword">def</span> <span class="token function">softmax</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    对输入x的每一行计算softmax。    该函数对于输入是向量（将向量视为单独的行）或者矩阵（M x N）均适用。    代码利用softmax函数的性质: softmax(x) = softmax(x + c)    :param x: 一个N维向量，或者M x N维numpy矩阵.    """</span>    <span class="token comment"># 根据输入类型是矩阵还是向量分别计算softmax</span>    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>shape<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">:</span>        <span class="token comment"># 矩阵</span>        tmp <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 得到每行的最大值，用于缩放每行的元素，避免溢出。 shape为(x.shape[0],)</span>        x <span class="token operator">-=</span> tmp<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 利用性质缩放元素</span>        x <span class="token operator">=</span> np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token comment"># 计算所有值的指数</span>        tmp <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 每行求和</span>        x <span class="token operator">/=</span> tmp<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 求softmax</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token comment"># 向量</span>        tmp <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">max</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token comment"># 得到最大值</span>        x <span class="token operator">-=</span> tmp  <span class="token comment"># 利用最大值缩放数据</span>        x <span class="token operator">=</span> np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token comment"># 对所有元素求指数</span>        tmp <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token comment"># 求元素和</span>        x <span class="token operator">/=</span> tmp  <span class="token comment"># 求somftmax</span>    <span class="token keyword">return</span> x<span class="token keyword">class</span> <span class="token class-name">Neural_Network</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    多层全连接神经网络    """</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nodes<span class="token punctuation">,</span> rate<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">,</span> epoch<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        初始化一个神经网络实例        :param nodes: 网络层次结构        :param rate: 学习速率        :param epoch: 最大迭代次数        """</span>        <span class="token comment"># 网络层次结构</span>        self<span class="token punctuation">.</span>nodes <span class="token operator">=</span> nodes        <span class="token comment"># 学习速率</span>        self<span class="token punctuation">.</span>rate <span class="token operator">=</span> rate        <span class="token comment"># 最大迭代次数</span>        self<span class="token punctuation">.</span>epoch <span class="token operator">=</span> epoch        <span class="token comment"># 偏置矩阵</span>        self<span class="token punctuation">.</span>B <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 权重矩阵</span>        self<span class="token punctuation">.</span>W <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 每一层的输出</span>        self<span class="token punctuation">.</span>Z <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 初始化权重与偏重</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>nodes<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 对于每一层网络，根据该层节点数目进行初始化</span>            <span class="token comment"># 权重矩阵，不能初始化为0或1，不然迭代会失去梯度！</span>            w <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>self<span class="token punctuation">.</span>nodes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>nodes<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">/</span> np<span class="token punctuation">.</span>sqrt<span class="token punctuation">(</span>self<span class="token punctuation">.</span>nodes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            b <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>nodes<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>W<span class="token punctuation">.</span>append<span class="token punctuation">(</span>w<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>B<span class="token punctuation">.</span>append<span class="token punctuation">(</span>b<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        正向传播函数        """</span>        <span class="token comment"># 存放每层输出</span>        Z <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        x <span class="token operator">=</span> data        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>nodes<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            x <span class="token operator">=</span> sigmoid<span class="token punctuation">(</span>x<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>self<span class="token punctuation">.</span>W<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>B<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token comment"># 所有层输出存入list中</span>            Z<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>Z <span class="token operator">=</span> Z    <span class="token keyword">def</span> <span class="token function">backpropagation</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        反向传播函数        """</span>        D <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        d <span class="token operator">=</span> t        <span class="token comment"># 计算delta</span>        n_layer <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>nodes<span class="token punctuation">)</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n_layer <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> j <span class="token operator">==</span> n_layer <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">:</span>  <span class="token comment"># 如果是输出层</span>                <span class="token comment"># delta = y * (1 - y) * (t - y)</span>                d <span class="token operator">=</span> self<span class="token punctuation">.</span>Z<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> self<span class="token punctuation">.</span>Z<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>t <span class="token operator">-</span> self<span class="token punctuation">.</span>Z<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>  <span class="token comment"># 如果是隐藏层</span>                <span class="token comment"># delta = y * (1-y) * sum( delta_k * w_k)</span>                d <span class="token operator">=</span> self<span class="token punctuation">.</span>Z<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> self<span class="token punctuation">.</span>Z<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> np<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>d<span class="token punctuation">,</span> self<span class="token punctuation">.</span>W<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>T<span class="token punctuation">)</span>            <span class="token comment"># 存入list中，反向计算，后计算的存前面</span>            D<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span>        <span class="token comment"># 更新权重和偏置</span>        <span class="token comment"># w += n * delta</span>        self<span class="token punctuation">.</span>W<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> self<span class="token punctuation">.</span>rate <span class="token operator">*</span> np<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>data<span class="token punctuation">.</span>T<span class="token punctuation">,</span> D<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>B<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> self<span class="token punctuation">.</span>rate <span class="token operator">*</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>D<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> k <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>nodes<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>W<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+=</span> self<span class="token punctuation">.</span>rate <span class="token operator">*</span> np<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>self<span class="token punctuation">.</span>Z<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>T<span class="token punctuation">,</span> D<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>B<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+=</span> self<span class="token punctuation">.</span>rate <span class="token operator">*</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>D<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">train</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">,</span> label<span class="token punctuation">,</span> show_process<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        进行训练        :param data: 训练集数据        :param label: 训练集标签        :param show_process: 是否展示迭代过程        """</span>        <span class="token comment"># 根据样本个数创建正确结果矩阵，每个样本对应结果矩阵中正确的结果位置值1，其他置0</span>        t <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>shape<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>nodes<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>nodes<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            t<span class="token punctuation">[</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>label <span class="token operator">==</span> i<span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>epoch<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>forward<span class="token punctuation">(</span>data<span class="token punctuation">)</span>            <span class="token keyword">if</span> show_process<span class="token punctuation">:</span>                loss <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>t <span class="token operator">-</span> self<span class="token punctuation">.</span>Z<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span>                predict <span class="token operator">=</span> np<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>self<span class="token punctuation">.</span>Z<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>                accuracy <span class="token operator">=</span> accuracy_score<span class="token punctuation">(</span>label<span class="token punctuation">,</span> predict<span class="token punctuation">)</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Loss:%f"</span> <span class="token operator">%</span> loss<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"accuracy%f"</span> <span class="token operator">%</span> accuracy<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>backpropagation<span class="token punctuation">(</span>data<span class="token punctuation">,</span> t<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">predict</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">,</span> display<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        进行预测，通过softmax给出最后的预测结果和类别所属的概率        :param data: 预测数据        :param display: 是否展示softmax的结果        :return: 预测结果和预测概率        """</span>        <span class="token comment"># 存放每层输出</span>        Z <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        x <span class="token operator">=</span> data        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>nodes<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            x <span class="token operator">=</span> sigmoid<span class="token punctuation">(</span>x<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>self<span class="token punctuation">.</span>W<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>B<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token comment"># 所有层输出存入list中</span>            Z<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        softmax_result <span class="token operator">=</span> softmax<span class="token punctuation">(</span>Z<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        result <span class="token operator">=</span> np<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>softmax_result<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>        rate <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            rate<span class="token punctuation">.</span>append<span class="token punctuation">(</span>softmax_result<span class="token punctuation">[</span>i<span class="token punctuation">,</span> result<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> display<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>softmax_result<span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span class="token punctuation">,</span> rate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="解决circles问题"><a href="#解决circles问题" class="headerlink" title="解决circles问题"></a>解决circles问题</h2><p>这里使用的是和<a href="https://immortalqx.github.io/2022/01/07/machine-learning-1/">机器学习笔记（一）：K-Means聚类算法</a>一样的数据集，获取方式参考这篇文章即可。</p><p><img src="/images/machine-learning/1-1.png"></p><p>定义Neural Network实例时我们传入了参数<code>nodes=[2, 8, 8, 2]</code>，因为</p><ul><li>数据集是两个平面上的圆环，所以每个点的坐标都可以用两个数表示，从而输入层节点为2；</li><li>我们定义中间有两个隐藏层，每个隐藏层有8个节点；</li><li>我们需要预测某个点是属于哪个圆环上的，只有两种圆环，所以是一个二分类问题，因此输出层节点为2。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>metrics <span class="token keyword">import</span> accuracy_score<span class="token keyword">import</span> sklearn<span class="token punctuation">.</span>neural_network <span class="token keyword">as</span> NN<span class="token keyword">import</span> Neural_Network <span class="token keyword">as</span> MyNNfig_num <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">plotFeature</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> labels_<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    二维空间显示聚类结果    """</span>    <span class="token comment"># 获取簇集的个数</span>    clusterNum <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span><span class="token builtin">set</span><span class="token punctuation">(</span>labels_<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 内定的颜色种类</span>    scatterColors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"orange"</span><span class="token punctuation">,</span> <span class="token string">"purple"</span><span class="token punctuation">,</span> <span class="token string">"cyan"</span><span class="token punctuation">,</span> <span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"green"</span><span class="token punctuation">]</span>    <span class="token comment"># 判断数据的维度是不是２</span>    <span class="token keyword">if</span> np<span class="token punctuation">.</span>shape<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"sorry,the dimension of your dataset is not 2!"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span>    <span class="token comment"># 判断簇集类别是否大于５类</span>    <span class="token keyword">if</span> clusterNum <span class="token operator">&gt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>scatterColors<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"sorry,your k is too large,please add length of the scatterColors!"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span>    <span class="token comment"># 散点图的绘制</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>clusterNum<span class="token punctuation">)</span><span class="token punctuation">:</span>        colorSytle <span class="token operator">=</span> scatterColors<span class="token punctuation">[</span>i <span class="token operator">%</span> <span class="token builtin">len</span><span class="token punctuation">(</span>scatterColors<span class="token punctuation">)</span><span class="token punctuation">]</span>        subCluster <span class="token operator">=</span> data<span class="token punctuation">[</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>labels_ <span class="token operator">==</span> i<span class="token punctuation">)</span><span class="token punctuation">]</span>        plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>subCluster<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> subCluster<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token operator">=</span>colorSytle<span class="token punctuation">,</span> s<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span>    <span class="token comment"># 设置x、y轴和标题</span>    plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">"x-label"</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">"y-label"</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">load_circles</span><span class="token punctuation">(</span>rate<span class="token operator">=</span><span class="token number">0.7</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 从文本中加载数据</span>    dataset_circles <span class="token operator">=</span> np<span class="token punctuation">.</span>loadtxt<span class="token punctuation">(</span><span class="token string">"../dataset_circles.csv"</span><span class="token punctuation">,</span> delimiter<span class="token operator">=</span><span class="token string">","</span><span class="token punctuation">)</span>    <span class="token comment"># 随机打乱数据</span>    data_size <span class="token operator">=</span> np<span class="token punctuation">.</span>shape<span class="token punctuation">(</span>dataset_circles<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    shuffled_index <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>permutation<span class="token punctuation">(</span>data_size<span class="token punctuation">)</span>    dataset_circles <span class="token operator">=</span> dataset_circles<span class="token punctuation">[</span>shuffled_index<span class="token punctuation">]</span>    <span class="token comment"># 分割前两列为data</span>    data <span class="token operator">=</span> dataset_circles<span class="token punctuation">.</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span>    <span class="token comment"># 分割第三列为label</span>    label <span class="token operator">=</span> dataset_circles<span class="token punctuation">.</span>T<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>    <span class="token comment"># 分割数据集</span>    split_index <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>data_size <span class="token operator">*</span> rate<span class="token punctuation">)</span>    train_data <span class="token operator">=</span> data<span class="token punctuation">.</span>T<span class="token punctuation">[</span><span class="token punctuation">:</span>split_index<span class="token punctuation">]</span>    train_label <span class="token operator">=</span> label<span class="token punctuation">.</span>T<span class="token punctuation">[</span><span class="token punctuation">:</span>split_index<span class="token punctuation">]</span>    test_data <span class="token operator">=</span> data<span class="token punctuation">.</span>T<span class="token punctuation">[</span>split_index<span class="token punctuation">:</span><span class="token punctuation">]</span>    test_label <span class="token operator">=</span> label<span class="token punctuation">.</span>T<span class="token punctuation">[</span>split_index<span class="token punctuation">:</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> train_data<span class="token punctuation">,</span> train_label<span class="token punctuation">,</span> test_data<span class="token punctuation">,</span> test_label<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    train_data<span class="token punctuation">,</span> train_label<span class="token punctuation">,</span> test_data<span class="token punctuation">,</span> test_label <span class="token operator">=</span> load_circles<span class="token punctuation">(</span>rate<span class="token operator">=</span><span class="token number">0.75</span><span class="token punctuation">)</span>    <span class="token comment"># =====================使用自己的方法做预测========================</span>    <span class="token comment"># 构建一个多层神经网络</span>    nn <span class="token operator">=</span> MyNN<span class="token punctuation">.</span>Neural_Network<span class="token punctuation">(</span>nodes<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> rate<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">,</span> epoch<span class="token operator">=</span><span class="token number">2000</span><span class="token punctuation">)</span>    <span class="token comment"># 开始训练并且计时</span>    start <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>    nn<span class="token punctuation">.</span>train<span class="token punctuation">(</span>train_data<span class="token punctuation">,</span> train_label<span class="token punctuation">,</span> show_process<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>    end <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"MyNN 训练用时:\t%f s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 对训练集做预测并且输出准确度与结果</span>    train_result<span class="token punctuation">,</span> _ <span class="token operator">=</span> nn<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>train_data<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"MyNN 对训练集做预测:\t"</span><span class="token punctuation">,</span> accuracy_score<span class="token punctuation">(</span>train_label<span class="token punctuation">,</span> train_result<span class="token punctuation">)</span><span class="token punctuation">)</span>    plotFeature<span class="token punctuation">(</span>train_data<span class="token punctuation">,</span> train_result<span class="token punctuation">)</span>    <span class="token comment"># 对测试集做预测并且输出准确度与结果</span>    test_result<span class="token punctuation">,</span> _ <span class="token operator">=</span> nn<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>test_data<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"MyNN 对测试集做预测:\t"</span><span class="token punctuation">,</span> accuracy_score<span class="token punctuation">(</span>test_label<span class="token punctuation">,</span> test_result<span class="token punctuation">)</span><span class="token punctuation">)</span>    plotFeature<span class="token punctuation">(</span>test_data<span class="token punctuation">,</span> test_result<span class="token punctuation">)</span>    <span class="token comment"># =====================使用sklearn做预测========================</span>    <span class="token comment"># 构建一个多层神经网络</span>    <span class="token comment"># 因为这里使用的数据量很少，根据网上的介绍，使用lbfgs方法来优化权重，收敛更快效果也更好</span>    clf <span class="token operator">=</span> NN<span class="token punctuation">.</span>MLPClassifier<span class="token punctuation">(</span>solver<span class="token operator">=</span><span class="token string">'lbfgs'</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'logistic'</span><span class="token punctuation">,</span> max_iter<span class="token operator">=</span><span class="token number">300</span><span class="token punctuation">,</span> alpha<span class="token operator">=</span><span class="token number">1e-5</span><span class="token punctuation">,</span> hidden_layer_sizes<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 开始训练并且计时</span>    start <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>    clf<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>train_data<span class="token punctuation">,</span> train_label<span class="token punctuation">)</span>    end <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"sklearn 训练用时:\t%f s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 对训练集做预测并且输出准确度与结果</span>    train_result <span class="token operator">=</span> clf<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>train_data<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"sklearn 对训练集做预测:\t"</span><span class="token punctuation">,</span> accuracy_score<span class="token punctuation">(</span>train_label<span class="token punctuation">,</span> train_result<span class="token punctuation">)</span><span class="token punctuation">)</span>    plotFeature<span class="token punctuation">(</span>train_data<span class="token punctuation">,</span> train_result<span class="token punctuation">)</span>    <span class="token comment"># 对测试集做预测并且输出准确度与结果</span>    test_result <span class="token operator">=</span> clf<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>test_data<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"sklearn 对测试集做预测:\t"</span><span class="token punctuation">,</span> accuracy_score<span class="token punctuation">(</span>test_label<span class="token punctuation">,</span> test_result<span class="token punctuation">)</span><span class="token punctuation">)</span>    plotFeature<span class="token punctuation">(</span>test_data<span class="token punctuation">,</span> test_result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="解决moons问题"><a href="#解决moons问题" class="headerlink" title="解决moons问题"></a>解决moons问题</h2><p>这里我们使用的是sklearn的moons数据集，通过sklearn.datasets.make_moons函数就可以创建一个指定规模和噪声的数据集。</p><img src="/images/machine-learning/4-1.png" style="zoom:67%;"><p>这个数据集本质上和circles没有区别，都是二分类问题，所以代码基本上和上面一样。</p><p>不过因为之前的circles可以通过特征变换，变成点到原点的距离，然后采用KMeans可以得到一个比较好的效果；而这里的moons并不是很好处理，直接采用KMeans算法可能效果并不是很好。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> sklearn <span class="token keyword">import</span> datasets<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>metrics <span class="token keyword">import</span> accuracy_score<span class="token keyword">import</span> sklearn<span class="token punctuation">.</span>neural_network <span class="token keyword">as</span> NN<span class="token keyword">import</span> Neural_Network <span class="token keyword">as</span> MyNN<span class="token keyword">def</span> <span class="token function">load_moons</span><span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token number">200</span><span class="token punctuation">,</span> rate<span class="token operator">=</span><span class="token number">0.7</span><span class="token punctuation">,</span> noise<span class="token operator">=</span><span class="token number">0.20</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># generate sample data</span>    np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>seed<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    data<span class="token punctuation">,</span> label <span class="token operator">=</span> datasets<span class="token punctuation">.</span>make_moons<span class="token punctuation">(</span>size<span class="token punctuation">,</span> noise<span class="token operator">=</span>noise<span class="token punctuation">)</span>    <span class="token comment"># 随机打乱数据</span>    shuffled_index <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>permutation<span class="token punctuation">(</span>size<span class="token punctuation">)</span>    data <span class="token operator">=</span> data<span class="token punctuation">[</span>shuffled_index<span class="token punctuation">]</span>    label <span class="token operator">=</span> label<span class="token punctuation">[</span>shuffled_index<span class="token punctuation">]</span>    <span class="token comment"># 分割数据集</span>    split_index <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>size <span class="token operator">*</span> rate<span class="token punctuation">)</span>    train_data <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token punctuation">:</span>split_index<span class="token punctuation">]</span>    train_label <span class="token operator">=</span> label<span class="token punctuation">[</span><span class="token punctuation">:</span>split_index<span class="token punctuation">]</span>    test_data <span class="token operator">=</span> data<span class="token punctuation">[</span>split_index<span class="token punctuation">:</span><span class="token punctuation">]</span>    test_label <span class="token operator">=</span> label<span class="token punctuation">[</span>split_index<span class="token punctuation">:</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> train_data<span class="token punctuation">,</span> train_label<span class="token punctuation">,</span> test_data<span class="token punctuation">,</span> test_label<span class="token keyword">def</span> <span class="token function">plotFeature</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> label<span class="token punctuation">)</span><span class="token punctuation">:</span>    plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token operator">=</span>label<span class="token punctuation">,</span> cmap<span class="token operator">=</span>plt<span class="token punctuation">.</span>cm<span class="token punctuation">.</span>Spectral<span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    train_data<span class="token punctuation">,</span> train_label<span class="token punctuation">,</span> test_data<span class="token punctuation">,</span> test_label <span class="token operator">=</span> load_moons<span class="token punctuation">(</span>size<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">,</span> rate<span class="token operator">=</span><span class="token number">0.75</span><span class="token punctuation">,</span> noise<span class="token operator">=</span><span class="token number">0.20</span><span class="token punctuation">)</span>    <span class="token comment"># =====================使用自己的方法做预测========================</span>    <span class="token comment"># 构建一个多层神经网络</span>    nn <span class="token operator">=</span> MyNN<span class="token punctuation">.</span>Neural_Network<span class="token punctuation">(</span>nodes<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> rate<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">,</span> epoch<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">)</span>    <span class="token comment"># 开始训练并且计时</span>    start <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>    nn<span class="token punctuation">.</span>train<span class="token punctuation">(</span>train_data<span class="token punctuation">,</span> train_label<span class="token punctuation">,</span> show_process<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>    end <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"MyNN 训练用时:\t%f s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 对训练集做预测并且输出准确度与结果</span>    train_result<span class="token punctuation">,</span> _ <span class="token operator">=</span> nn<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>train_data<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"MyNN 对训练集做预测:\t"</span><span class="token punctuation">,</span> accuracy_score<span class="token punctuation">(</span>train_label<span class="token punctuation">,</span> train_result<span class="token punctuation">)</span><span class="token punctuation">)</span>    plotFeature<span class="token punctuation">(</span>train_data<span class="token punctuation">,</span> train_result<span class="token punctuation">)</span>    <span class="token comment"># 对测试集做预测并且输出准确度与结果</span>    test_result<span class="token punctuation">,</span> _ <span class="token operator">=</span> nn<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>test_data<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"MyNN 对测试集做预测:\t"</span><span class="token punctuation">,</span> accuracy_score<span class="token punctuation">(</span>test_label<span class="token punctuation">,</span> test_result<span class="token punctuation">)</span><span class="token punctuation">)</span>    plotFeature<span class="token punctuation">(</span>test_data<span class="token punctuation">,</span> test_result<span class="token punctuation">)</span>    <span class="token comment"># =====================使用sklearn做预测========================</span>    <span class="token comment"># 构建一个多层神经网络</span>    <span class="token comment"># 因为这里使用的数据量很少，根据网上的介绍，使用lbfgs方法来优化权重，收敛更快效果也更好</span>    clf <span class="token operator">=</span> NN<span class="token punctuation">.</span>MLPClassifier<span class="token punctuation">(</span>solver<span class="token operator">=</span><span class="token string">'lbfgs'</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'logistic'</span><span class="token punctuation">,</span> max_iter<span class="token operator">=</span><span class="token number">300</span><span class="token punctuation">,</span> alpha<span class="token operator">=</span><span class="token number">1e-5</span><span class="token punctuation">,</span> hidden_layer_sizes<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 开始训练并且计时</span>    start <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>    clf<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>train_data<span class="token punctuation">,</span> train_label<span class="token punctuation">)</span>    end <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"sklearn 训练用时:\t%f s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 对训练集做预测并且输出准确度与结果</span>    train_result <span class="token operator">=</span> clf<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>train_data<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"sklearn 对训练集做预测:\t"</span><span class="token punctuation">,</span> accuracy_score<span class="token punctuation">(</span>train_label<span class="token punctuation">,</span> train_result<span class="token punctuation">)</span><span class="token punctuation">)</span>    plotFeature<span class="token punctuation">(</span>train_data<span class="token punctuation">,</span> train_result<span class="token punctuation">)</span>    <span class="token comment"># 对测试集做预测并且输出准确度与结果</span>    test_result <span class="token operator">=</span> clf<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>test_data<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"sklearn 对测试集做预测:\t"</span><span class="token punctuation">,</span> accuracy_score<span class="token punctuation">(</span>test_label<span class="token punctuation">,</span> test_result<span class="token punctuation">)</span><span class="token punctuation">)</span>    plotFeature<span class="token punctuation">(</span>test_data<span class="token punctuation">,</span> test_result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="解决手写数字识别问题"><a href="#解决手写数字识别问题" class="headerlink" title="解决手写数字识别问题"></a>解决手写数字识别问题</h2><p>这里使用的是和<a href="https://immortalqx.github.io/2022/01/08/machine-learning-2/">机器学习（二）：逻辑回归算法</a>一样的数据集。</p><img src="/images/machine-learning/2-7.png" style="zoom:67%;"><p>手写数字识别比上面两个要稍微复杂一点，我们先分析手写数字识别的特征：</p><ul><li>每一张图片是8*8大小的，但这里我们定义的全连接神经网络不支持输入矩阵，所以我们需要把每一张图片变成向量，这样输入层节点数目就应该是64；</li><li>我们需要区分0~9这10个手写数字，所以这是一个多分类问题，输出层的节点数目应该是10。</li></ul><p>确定了输入输出，我们就可以很容易的定义一个多层神经网络来处理这个问题了。</p><p>这部分定义Neural Network实例时我们传入的参数<code>nodes=[64, 64, 32, 10]</code>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> load_digits<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>metrics <span class="token keyword">import</span> confusion_matrix<span class="token punctuation">,</span> accuracy_score<span class="token keyword">import</span> sklearn<span class="token punctuation">.</span>neural_network <span class="token keyword">as</span> NN<span class="token keyword">import</span> Neural_Network <span class="token keyword">as</span> MyNNfig_num <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">display</span><span class="token punctuation">(</span>images<span class="token punctuation">,</span> ground_truth<span class="token punctuation">,</span> predict<span class="token punctuation">,</span> rate<span class="token punctuation">,</span> fig_name<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    画出预测结果    :param images: 数字的图片    :param ground_truth: 真值    :param predict: 预测值    :param fig_name: 图片名字    """</span>    <span class="token comment"># plot the digits</span>    <span class="token keyword">global</span> fig_num    fig_num <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">if</span> fig_name <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>fig_num<span class="token punctuation">,</span> figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># figure size in inches</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>fig_name<span class="token punctuation">,</span> figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># figure size in inches</span>    fig<span class="token punctuation">.</span>subplots_adjust<span class="token punctuation">(</span>left<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> right<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> bottom<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> top<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> hspace<span class="token operator">=</span><span class="token number">0.05</span><span class="token punctuation">,</span> wspace<span class="token operator">=</span><span class="token number">0.05</span><span class="token punctuation">)</span>    size <span class="token operator">=</span> np<span class="token punctuation">.</span>shape<span class="token punctuation">(</span>predict<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">if</span> size <span class="token operator">&gt;</span> <span class="token number">56</span><span class="token punctuation">:</span>        size <span class="token operator">=</span> <span class="token number">56</span>    <span class="token comment"># plot the digits: each image is 8x8 pixels</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>        ax <span class="token operator">=</span> fig<span class="token punctuation">.</span>add_subplot<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> xticks<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> yticks<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        ax<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>images<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> cmap<span class="token operator">=</span>plt<span class="token punctuation">.</span>cm<span class="token punctuation">.</span>binary<span class="token punctuation">)</span>        <span class="token comment"># label the image with the target value</span>        ax<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span>ground_truth<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token builtin">int</span><span class="token punctuation">(</span>ground_truth<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token builtin">int</span><span class="token punctuation">(</span>predict<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            ax<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>predict<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'green'</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">15</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> rate <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                ax<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>rate<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'green'</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            ax<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>predict<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'red'</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> rate <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span><span class="token punctuation">:</span>                ax<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>rate<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'red'</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>    <span class="token comment"># plot confusion matrix</span>    cm <span class="token operator">=</span> confusion_matrix<span class="token punctuation">(</span>ground_truth<span class="token punctuation">,</span> predict<span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>matshow<span class="token punctuation">(</span>cm<span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>colorbar<span class="token punctuation">(</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span>fig_name <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> <span class="token string">'Confusion Matrix'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Groundtruth'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'Predict'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">load_data</span><span class="token punctuation">(</span>train_size<span class="token operator">=</span><span class="token number">0.75</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    加载数据同时分割出训练集和测试集    :param train_size: 训练集的比例    :return 分割好的数据集    """</span>    <span class="token comment"># 加载数据</span>    <span class="token comment"># 这个函数返回的应该是一个类实例，里面有很多的变量，需要“单独的拿出来用”</span>    digits <span class="token operator">=</span> load_digits<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 输出查看一下这个类的属性和方法</span>    <span class="token comment"># print(dir(digits))</span>    <span class="token comment"># 获得数据的大小</span>    data_size <span class="token operator">=</span> np<span class="token punctuation">.</span>shape<span class="token punctuation">(</span>digits<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token comment"># 将数据打乱，这里需要把这个类的要用上的变量都对应上，有点麻烦（是否有更简便的方法？）</span>    shuffled_index <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>permutation<span class="token punctuation">(</span>data_size<span class="token punctuation">)</span>    digits<span class="token punctuation">.</span>data <span class="token operator">=</span> digits<span class="token punctuation">.</span>data<span class="token punctuation">[</span>shuffled_index<span class="token punctuation">]</span>    digits<span class="token punctuation">.</span>images <span class="token operator">=</span> digits<span class="token punctuation">.</span>images<span class="token punctuation">[</span>shuffled_index<span class="token punctuation">]</span>    digits<span class="token punctuation">.</span>target <span class="token operator">=</span> digits<span class="token punctuation">.</span>target<span class="token punctuation">[</span>shuffled_index<span class="token punctuation">]</span>    <span class="token comment"># 分割数据集</span>    split_index <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>data_size <span class="token operator">*</span> train_size<span class="token punctuation">)</span>    train_data <span class="token operator">=</span> digits<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>split_index<span class="token punctuation">]</span>    train_target <span class="token operator">=</span> digits<span class="token punctuation">.</span>target<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>split_index<span class="token punctuation">]</span>    train_images <span class="token operator">=</span> digits<span class="token punctuation">.</span>images<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>split_index<span class="token punctuation">]</span>    test_data <span class="token operator">=</span> digits<span class="token punctuation">.</span>data<span class="token punctuation">[</span>split_index<span class="token punctuation">:</span><span class="token punctuation">]</span>    test_target <span class="token operator">=</span> digits<span class="token punctuation">.</span>target<span class="token punctuation">[</span>split_index<span class="token punctuation">:</span><span class="token punctuation">]</span>    test_images <span class="token operator">=</span> digits<span class="token punctuation">.</span>images<span class="token punctuation">[</span>split_index<span class="token punctuation">:</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> train_data<span class="token punctuation">,</span> train_target<span class="token punctuation">,</span> train_images<span class="token punctuation">,</span> test_data<span class="token punctuation">,</span> test_target<span class="token punctuation">,</span> test_images<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    <span class="token comment"># FIXME:</span>    <span class="token comment">#  1. 数据的加载应该没问题，在逻辑回归里面得到的结果是正确的</span>    <span class="token comment">#  但放到神经网络里面，如果给的训练集过多（1000以上），就没有收敛，但给的数据集少一些效果好一些</span>    <span class="token comment">#  2. 感觉是有地方溢出了，导致直接就没有收敛，猜测是sigmoid函数溢出</span>    <span class="token comment">#  3. 测试发现sigmoid函数没有溢出，可能是学习率过低，陷入了局部最优解，但调大学习率就会报警，说sigmoid函数溢出</span>    <span class="token comment">#  4. 调整sigmoid函数后，调大学习率没有影响，但把学习率调小会得到一个很好的结果。</span>    <span class="token comment">#  问题：如何获得最优的学习率？如何知道学习率是过大还是过小？</span>    <span class="token comment"># 加载并且分割各种数据</span>    train_data<span class="token punctuation">,</span> train_target<span class="token punctuation">,</span> train_images<span class="token punctuation">,</span> test_data<span class="token punctuation">,</span> test_target<span class="token punctuation">,</span> test_images <span class="token operator">=</span> load_data<span class="token punctuation">(</span>train_size<span class="token operator">=</span><span class="token number">0.75</span><span class="token punctuation">)</span>    <span class="token comment"># =====================使用自己的方法做预测========================</span>    nn <span class="token operator">=</span> MyNN<span class="token punctuation">.</span>Neural_Network<span class="token punctuation">(</span>nodes<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> rate<span class="token operator">=</span><span class="token number">0.001</span><span class="token punctuation">,</span> epoch<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">)</span>    <span class="token comment"># 开始训练并且计时</span>    <span class="token comment"># FIXME 这里时间测量的不对，但其他地方没有问题</span>    start <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>    nn<span class="token punctuation">.</span>train<span class="token punctuation">(</span>train_data<span class="token punctuation">,</span> train_target<span class="token punctuation">,</span> show_process<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    end <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"MyNN 训练用时:\t%f s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 对训练集做预测并且输出准确度与结果</span>    train_result<span class="token punctuation">,</span> train_rate <span class="token operator">=</span> nn<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>train_data<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"MyNN 对训练集做预测:\t"</span><span class="token punctuation">,</span> accuracy_score<span class="token punctuation">(</span>train_target<span class="token punctuation">,</span> train_result<span class="token punctuation">)</span><span class="token punctuation">)</span>    display<span class="token punctuation">(</span>train_images<span class="token punctuation">,</span> train_target<span class="token punctuation">,</span> train_result<span class="token punctuation">,</span> train_rate<span class="token punctuation">,</span> <span class="token string">"My Train"</span><span class="token punctuation">)</span>    <span class="token comment"># 对测试集做预测并且输出准确度与结果</span>    test_result<span class="token punctuation">,</span> test_rate <span class="token operator">=</span> nn<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>test_data<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"MyNN 对测试集做预测:\t"</span><span class="token punctuation">,</span> accuracy_score<span class="token punctuation">(</span>test_target<span class="token punctuation">,</span> test_result<span class="token punctuation">)</span><span class="token punctuation">)</span>    display<span class="token punctuation">(</span>test_images<span class="token punctuation">,</span> test_target<span class="token punctuation">,</span> test_result<span class="token punctuation">,</span> test_rate<span class="token punctuation">,</span> <span class="token string">"My Test"</span><span class="token punctuation">)</span>    <span class="token comment"># =====================使用sklearn做预测========================</span>    <span class="token comment"># 构建一个多层神经网络</span>    <span class="token comment"># 因为这里使用的数据量很少，根据网上的介绍，使用lbfgs方法来优化权重，收敛更快效果也更好</span>    clf <span class="token operator">=</span> NN<span class="token punctuation">.</span>MLPClassifier<span class="token punctuation">(</span>solver<span class="token operator">=</span><span class="token string">'lbfgs'</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'logistic'</span><span class="token punctuation">,</span> max_iter<span class="token operator">=</span><span class="token number">300</span><span class="token punctuation">,</span> alpha<span class="token operator">=</span><span class="token number">1e-5</span><span class="token punctuation">,</span> hidden_layer_sizes<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 开始训练并且计时</span>    start <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>    clf<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>train_data<span class="token punctuation">,</span> train_target<span class="token punctuation">)</span>    end <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"sklearn 训练用时:\t%f s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 对训练集做预测并且输出准确度与结果</span>    train_result <span class="token operator">=</span> clf<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>train_data<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"sklearn 对训练集做预测:\t"</span><span class="token punctuation">,</span> accuracy_score<span class="token punctuation">(</span>train_target<span class="token punctuation">,</span> train_result<span class="token punctuation">)</span><span class="token punctuation">)</span>    display<span class="token punctuation">(</span>train_images<span class="token punctuation">,</span> train_target<span class="token punctuation">,</span> train_result<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token string">"sklearn Train"</span><span class="token punctuation">)</span>    <span class="token comment"># 对测试集做预测并且输出准确度与结果</span>    test_result <span class="token operator">=</span> clf<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>test_data<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"sklearn 对测试集做预测:\t"</span><span class="token punctuation">,</span> accuracy_score<span class="token punctuation">(</span>test_target<span class="token punctuation">,</span> test_result<span class="token punctuation">)</span><span class="token punctuation">)</span>    display<span class="token punctuation">(</span>test_images<span class="token punctuation">,</span> test_target<span class="token punctuation">,</span> test_result<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token string">"sklearn Test"</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 多层神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记（三）：多层神经网络</title>
      <link href="2022/01/09/machine-learning-3/"/>
      <url>2022/01/09/machine-learning-3/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习笔记（三）：多层神经网络"><a href="#机器学习笔记（三）：多层神经网络" class="headerlink" title="机器学习笔记（三）：多层神经网络"></a>机器学习笔记（三）：多层神经网络</h1><p>基于生物神经元模型可得到多层感知器（Multi-layer Perceptron, MLP)的基本结构，最典型的MLP包括包括三层：输入层(Input Layer)、隐层(Hidden Layer)和输出层(Output Layer)，MLP神经网络不同层之间是全连接的（全连接的意思就是：上一层的任何一个神经元与下一层的所有神经元都有连接）。</p><p><img src="/images/neural-network/mlp_theory.gif"></p><h2 id="1-神经元"><a href="#1-神经元" class="headerlink" title="1. 神经元"></a>1. 神经元</h2><p>神经元和感知器本质上是一样的，感知器的激活函数是阶跃函数；而神经元的激活函数往往选择为sigmoid函数或tanh函数。如下图所示：</p><p><img src="/images/neural-network/neuron.gif"></p><p>计算一个神经元的输出的方法和计算一个感知器的输出是一样的。假设神经元的输入是向量$\vec{x}$，权重向量是$\vec{w}$(偏置项是$w_0$)，激活函数是sigmoid函数，则其输出$y$：<br>$$<br>y = sigmoid(\vec{w}^T \cdot \vec{x})<br>$$</p><p>sigmoid函数的定义如下：<br>$$<br>sigmoid(x) = \frac{1}{1+e^{-x}}<br>$$<br>将其带入前面的式子，得到<br>$$<br>y = \frac{1}{1+e^{-\vec{w}^T \cdot \vec{x}}}<br>$$</p><p>sigmoid函数是一个非线性函数，值域是(0,1)。函数图像如下图所示</p><p><img src="/images/neural-network/sigmod.jpg"></p><p>sigmoid函数的导数是：<br>$$<br>\begin{eqnarray}<br>y &amp; = &amp; sigmod(x) \tag{1} \<br>y’ &amp; = &amp; y(1-y)<br>\end{eqnarray}<br>$$<br>可以看到，sigmoid函数的导数可以用sigmoid函数自身来表示。这样，一旦计算出sigmoid函数的值，计算它的导数的值就非常方便。</p><h2 id="2-神经网络的结构"><a href="#2-神经网络的结构" class="headerlink" title="2. 神经网络的结构"></a>2. 神经网络的结构</h2><p><img src="/images/neural-network/nn1.jpeg"></p><p>神经网络就是按照一定规则连接起来的多个神经元。上图展示了一个全连接(Full Connected, FC)神经网络，通过观察上面的图，可以发现它的规则包括：</p><ul><li>神经元按照层来布局<ul><li>最左边的层叫做输入层，负责接收输入数据；</li><li>最右边的层叫输出层，可以从这层获取神经网络输出数据;</li><li>输入层和输出层之间的层叫做隐藏层，因为它们对于外部来说是不可见的。</li></ul></li><li>同一层的神经元之间没有连接</li><li>第N层的每个神经元和第N-1层的所有神经元相连(这就是full connected的含义)，第N-1层神经元的输出就是第N层神经元的输入</li><li>每个连接都有一个权值</li></ul><p>由此可知，神经网络主要有三个基本要素：权重、偏置和激活函数</p><ul><li>权重：神经元之间的连接强度由权重控制，权重的大小表示可能性的大小</li><li>偏置：偏置的设置是为了正确分类样本，是模型中一个重要的参数，即保证通过输入算出的输出值不能随便激活。</li><li>激活函数：起非线性映射的作用，其可将神经元的输出幅度限制在一定范围内，一般限制在（-1~1）或（0~1）之间。最常用的激活函数是Sigmoid函数，可将（-∞，+∞）的数映射到（0~1）的范围内。</li></ul><p>上面这些规则定义了全连接神经网络的结构。事实上还存在很多其它结构的神经网络，比如卷积神经网络(CNN)、循环神经网络(RNN)，他们都具有不同的连接规则。</p><h2 id="3-计算神经网络的输出"><a href="#3-计算神经网络的输出" class="headerlink" title="3. 计算神经网络的输出"></a>3. 计算神经网络的输出</h2><p>神经网络实际上就是一个输入向量$\vec{x}$到输出向量$\vec{y}$的函数，即：</p><p>$$<br>\vec{y} = f_{network}(\vec{x})<br>$$<br>根据输入计算神经网络的输出</p><ul><li>首先将输入向量$\vec{x}$的每个元素的值$x_i$赋给神经网络的输入层的对应神经元</li><li>然后根据式（1）依次向前计算每一层的每个神经元的值，直到最后一层输出层的所有神经元的值计算完毕</li><li>最后，将输出层每个神经元的值串在一起就得到了输出向量$\vec{y}$。</li></ul><p>接下来举一个例子来说明这个过程，我们先给神经网络的每个单元写上编号。</p><p><img src="/images/neural-network/nn2.png"></p><ul><li>输入层有三个节点，我们将其依次编号为1、2、3；</li><li>隐藏层的4个节点，编号依次为4、5、6、7；</li><li>最后输出层的两个节点编号为8、9。</li></ul><p>因为这个神经网络是全连接网络，所以可以看到每个节点都和上一层的所有节点有连接。比如，隐藏层的节点4，它和输入层的三个节点1、2、3之间都有连接，其连接上的权重分别为$w_{41}$,$w_{42}$,$w_{43}$。那么，怎样计算节点4的输出值$a_4$呢？</p><p>为了计算节点4的输出值，必须先得到其所有上游节点（也就是节点1、2、3）的输出值。节点1、2、3是输入层的节点，所以，他们的输出值就是输入向量$\vec{x}$本身。按照上图画出的对应关系，可以看到节点1、2、3的输出值分别是$x_1$,$x_2$,$x_3$。要求输入向量的维度和输入层神经元个数相同，而输入向量的某个元素对应到哪个输入节点是可以自由决定的。</p><p>一旦有了节点1、2、3的输出值，就可以根据式1计算节点4的输出值$a_4$：</p><p><img src="/images/neural-network/eqn_3_4.png"></p><p>上式的$w_{4b}$是节点4的偏置项，图中没有画出来。而$w_{41}$,$w_{42}$,$w_{43}$分别为节点1、2、3到节点4连接的权重，在给权重$w_{ji}$编号时，目标节点的编号$j$放在前面，把源节点的编号$i$放在后面。</p><p>同样，可以继续计算出节点5、6、7的输出值$a_5$,$a_6$,$a_7$。这样，隐藏层的4个节点的输出值就计算完成了，就可以接着计算输出层的节点8的输出值$y_1$：</p><p><img src="/images/neural-network/eqn_5_6.png"></p><p>同理，我们还可以计算出$y_2$的值。这样输出层所有节点的输出值计算完毕，就得到了在输入向量$\vec{x} = (x_1, x_2, x_3)^T$时，神经网络的输出向量$\vec{y} = (y_1, y_2)^T$。可以看出：输出向量的维度和输出层神经元个数相同。</p><h2 id="4-神经网络的矩阵表示"><a href="#4-神经网络的矩阵表示" class="headerlink" title="4. 神经网络的矩阵表示"></a>4. 神经网络的矩阵表示</h2><p>神经网络的计算如果用矩阵来表示会很方便，此外可以用优化加速算法提高计算速度。</p><p>隐藏层4个节点的计算依次排列出来：</p><p><img src="/images/neural-network/eqn_hidden_units.png"></p><p>接着，定义网络的输入向量$\vec{x}$和隐藏层每个节点的权重向量$\vec{w}$。令</p><p><img src="/images/neural-network/eqn_7_12.png"></p><p>代入到前面的一组式子，得到：</p><p><img src="/images/neural-network/eqn_13_16.png"></p><p>现在，把上述计算$a_4$, $a_5$,$a_6$,$a_7$的四个式子写到一个矩阵里面，每个式子作为矩阵的一行，就可以利用矩阵来表示它们的计算了。令</p><p><img src="/images/neural-network/eqn_matrix1.png"></p><p>带入前面的一组式子，得到</p><p><img src="/images/neural-network/formular_2.png"></p><p>在（式2）中，</p><ul><li>$f$是激活函数，在本例中是$sigmod$函数；</li><li>$W$是某一层的权重矩阵；</li><li>$\vec{x}$是某层的输入向量；</li><li>$\vec{a}$是某层的输出向量。</li></ul><p>（式2）说明神经网络的每一层的作用实际上就是先将输入向量左乘一个数组进行线性变换，得到一个新的向量，然后再对这个向量逐元素应用一个激活函数。</p><p>每一层的算法都是一样的。比如，对于包含一个输入层，一个输出层和三个隐藏层的神经网络，我们假设其权重矩阵分别为$W_1$,$W_2$,$W_3$,$W_4$，每个隐藏层的输出分别是$\vec{a}_1$,$\vec{a}_2$,$\vec{a}_3$，神经网络的输入为$\vec{x}$，神经网络的输出为$\vec{y}$，如下图所示：</p><p><img src="/images/neural-network/nn_parameters_demo.png"></p><p>则每一层的输出向量的计算可以表示为：</p><p><img src="/images/neural-network/eqn_17_20.png"></p><p>这就是神经网络输出值的矩阵计算方法。</p><p>如果写成一个公式：<br>$$<br>\vec{y} = f(W4 \cdot f(W3 \cdot f(W2 \cdot f(W1 \cdot \vec{x}))))<br>$$<br>神经网络正向计算的过程比较简单，就是一层一层不断做运算，动态的演示如下图所示：<br><img src="/images/neural-network/neural_network_demo.gif"></p><h2 id="5-神经网络的训练-反向传播算法"><a href="#5-神经网络的训练-反向传播算法" class="headerlink" title="5. 神经网络的训练 - 反向传播算法"></a>5. 神经网络的训练 - 反向传播算法</h2><p>神经网络的每个连接上的权值如果知道，那么就可以将输入数据代入得到希望的结果。神经网络是一个模型，那么这些权值就是<strong>模型的参数</strong>，也就是模型要学习的东西。然而，一个神经网络的连接方式、网络的层数、每层的节点数这些参数，则不是学习出来的，而是人为事先设置的。对于这些人为设置的参数，我们称之为**超参数(Hyper-Parameters)**。</p><p>前面课程中所学的最小二乘、逻辑回归等可以直接优化损失函数来求解模型参数的更新值。在多层神经网络中：</p><ul><li>最后一层的参数可以用这样的方式求解得到；</li><li>隐层节点没有输出的真值，因此无法直接构建损失函数来求解</li></ul><p>如何化解这个难题？</p><p>反向传播算法其实就是链式求导法则的应用。然而，这个如此简单且显而易见的方法，却是在Roseblatt提出感知器算法将近30年之后才被发明和普及的。对此，Bengio这样回应道：</p><blockquote><p>很多看似显而易见的想法只有在事后才变得显而易见。</p></blockquote><p>按照机器学习的通用套路，我们先确定神经网络的目标函数，然后用随机梯度下降优化算法去求目标函数最小值时的参数值。</p><p>我们取网络所有输出层节点的误差平方和作为目标函数：</p><p><img src="/images/neural-network/bp_loss.png"></p><p>其中，$E_d$表示是样本$d$的误差, <strong>t是样本的标签值</strong>，<strong>y是神经网络的输出值</strong>。</p><p>然后，使用随机梯度下降算法对目标函数进行优化：</p><p><img src="/images/neural-network/bp_weight_update.png"></p><p>随机梯度下降算法也就是需要求出误差$E_d$对于每个权重$w_{ji}$的偏导数（也就是梯度），如何求解？</p><p><img src="/images/neural-network/nn3.png"></p><p>观察上图，我们发现权重$w_{ji}$仅能通过影响节点$j$的输入值影响网络的其它部分，设$net_j$是节点$j$的加权输入，即</p><p><img src="/images/neural-network/eqn_21_22.png"></p><p>$E_d$是$net_j$的函数，而$net_j$是$w_{ji}$的函数。根据链式求导法则，可以得到：</p><p><img src="/images/neural-network/eqn_23_25.png"></p><p>上式中，$x_{ji}$是节点传递给节点$j$的输入值，也就是节点$i$的输出值。</p><p>对于的$\frac{\partial E_d}{\partial net_j}$推导，需要区分输出层和隐藏层两种情况。</p><h3 id="5-1-输出层权值训练"><a href="#5-1-输出层权值训练" class="headerlink" title="5.1 输出层权值训练"></a>5.1 输出层权值训练</h3><p><img src="/images/neural-network/nn3.png"></p><p>对于输出层来说，$net_j$仅能通过节点$j$的输出值$y_j$来影响网络其它部分，也就是说$E_d$是$y_j$的函数，而$y_j$是$net_j$的函数，其中$y_j = sigmod(net_j)$。所以我们可以再次使用链式求导法则：</p><p><img src="/images/neural-network/eqn_26.png"></p><p>考虑上式第一项:</p><p><img src="/images/neural-network/eqn_27_29.png"></p><p>考虑上式第二项：</p><p><img src="/images/neural-network/eqn_30_31.png"></p><p>将第一项和第二项带入，得到：</p><p><img src="/images/neural-network/eqn_ed_net_j.png"></p><p>如果令$\delta_j = - \frac{\partial E_d}{\partial net_j}$，也就是一个节点的误差项$\delta$是网络误差对这个节点输入的偏导数的相反数。带入上式，得到：</p><p><img src="/images/neural-network/eqn_delta_j.png"></p><p>将上述推导带入随机梯度下降公式，得到：</p><p><img src="/images/neural-network/eqn_32_34.png"></p><h3 id="5-2-隐藏层权值训练"><a href="#5-2-隐藏层权值训练" class="headerlink" title="5.2 隐藏层权值训练"></a>5.2 隐藏层权值训练</h3><p>现在我们要推导出隐藏层的$\frac{\partial E_d}{\partial net_j}$。</p><p><img src="/images/neural-network/nn3.png"></p><p>首先，我们需要定义节点$j$的所有直接下游节点的集合$Downstream(j)$。例如，对于节点4来说，它的直接下游节点是节点8、节点9。可以看到$net_j$只能通过影响$Downstream(j)$再影响$E_d$。设$net_k$是节点$j$的下游节点的输入，则$E_d$是$net_k$的函数，而$net_k$是$net_j$的函数。因为$net_k$有多个，我们应用全导数公式，可以做出如下推导：</p><p><img src="/images/neural-network/eqn_35_40.png"></p><p>因为$\delta_j = - \frac{\partial E_d}{\partial net_j}$，带入上式得到：</p><p><img src="/images/neural-network/eqn_delta_hidden.png"></p><p>至此，我们已经推导出了反向传播算法。需要注意的是，我们刚刚推导出的训练规则是根据激活函数是sigmoid函数、平方和误差、全连接网络、随机梯度下降优化算法。如果激活函数不同、误差计算方式不同、网络连接结构不同、优化算法不同，则具体的训练规则也会不一样。但是无论怎样，训练规则的推导方式都是一样的，应用链式求导法则进行推导即可。</p><h3 id="5-3-具体解释"><a href="#5-3-具体解释" class="headerlink" title="5.3 具体解释"></a>5.3 具体解释</h3><p>假设每个训练样本为$(\vec{x}, \vec{t})$，其中向量$\vec{x}$是训练样本的特征，而$\vec{t}$是样本的目标值。</p><p><img src="/images/neural-network/nn3.png"></p><p>首先，根据上一节介绍的算法，用样本的特征$\vec{x}$，计算出神经网络中每个隐藏层节点的输出$a_i$，以及输出层每个节点的输出$y_i$。</p><p>然后，按照下面的方法计算出每个节点的误差项$\delta_i$：</p><ul><li><strong>对于输出层节点$i$</strong></li></ul><p><img src="/images/neural-network/formular_3.png"></p><p>其中，$\delta_i$是节点$i$的误差项，$y_i$是节点$i$的输出值，$t_i$是样本对应于节点$i$的目标值。举个例子，根据上图，对于输出层节点8来说，它的输出值是$y_1$，而样本的目标值是$t_1$，带入上面的公式得到节点8的误差项应该是：</p><p><img src="/images/neural-network/forumlar_delta8.png"></p><ul><li><strong>对于隐藏层节点</strong></li></ul><p><img src="/images/neural-network/formular_4.png"></p><p>其中，$a_i$是节点$i$的输出值，$w_{ki}$是节点$i$到它的下一层节点$k$的连接的权重，$\delta_k$是节点$i$的下一层节点$k$的误差项。例如，对于隐藏层节点4来说，计算方法如下：</p><p><img src="/images/neural-network/forumlar_delta4.png"></p><p>最后，更新每个连接上的权值：</p><p><img src="/images/neural-network/formular_5.png"></p><p>其中，$w_{ji}$是节点$i$到节点$j$的权重，$\eta$是一个成为学习速率的常数，$\delta_j$是节点$j$的误差项，$x_{ji}$是节点$i$传递给节点$j$的输入。例如，权重$w_{84}$的更新方法如下：</p><p><img src="/images/neural-network/eqn_w84_update.png"></p><p>类似的，权重$w_{41}$的更新方法如下：</p><p><img src="/images/neural-network/eqn_w41_update.png"></p><p>偏置项的输入值永远为1。例如，节点4的偏置项$w_{4b}$应该按照下面的方法计算：</p><p><img src="/images/neural-network/eqn_w4b_update.png"></p><p>计算一个节点的误差项，需要先计算每个与其相连的下一层节点的误差项，这就要求误差项的计算顺序必须是从输出层开始，然后反向依次计算每个隐藏层的误差项，直到与输入层相连的那个隐藏层，这就是反向传播算法的名字的含义。当所有节点的误差项计算完毕后，就可以根据式5来更新所有的权重。</p><h2 id="6-为什么要使用激活函数"><a href="#6-为什么要使用激活函数" class="headerlink" title="6. 为什么要使用激活函数"></a>6. 为什么要使用激活函数</h2><p>激活函数在神经网络中非常重要，使用激活函数也是非常必要的，前面我们从人脑神经元的角度理解了激活函数，因为神经元需要通过激活才能往后传播，所以神经网络中需要激活函数，下面我们从数学的角度理解一下激活函数的必要性。</p><p>比如一个两层的神经网络，使用 f 表示激活函数，那么</p><p>$$<br>y = f( w_2  f(w_1 x) )<br>$$</p><p>如果不使用激活函数，那么神经网络的结果就是</p><p>$$<br>y = w_2 (w_1 x) = (w_2 w_1) x = \bar{w} x<br>$$</p><p>可以看到，将两层神经网络的参数合在一起，用 $\bar{w}$ 来表示，两层的神经网络其实就变成了一层神经网络，只不过参数变成了新的 $\bar{w}$，所以如果不使用激活函数，那么不管多少层的神经网络，$y = w_n \cdots w_2 w_1 x = \bar{w} x$，就都变成了单层神经网络，所以在每一层都必须使用激活函数。</p><p>最后看看激活函数对神经网络的影响</p><p><img src="/images/neural-network/nn-activation-function.gif"></p><p>可以看到使用了激活函数之后，神经网络可以通过改变权重实现任意形状，越是复杂的神经网络能拟合的形状越复杂，这就是著名的神经网络万有逼近定理。神经网络使用的激活函数都是非线性的，每个激活函数都输入一个值，然后做一种特定的数学运算得到一个结果。</p><h3 id="6-1-sigmoid-激活函数"><a href="#6-1-sigmoid-激活函数" class="headerlink" title="6.1 sigmoid 激活函数"></a>6.1 sigmoid 激活函数</h3><p>$$\sigma(x) = \frac{1}{1 + e^{-x}}$$</p><p><img src="/images/neural-network/act-sigmoid.jpg"></p><h3 id="6-2-tanh-激活函数"><a href="#6-2-tanh-激活函数" class="headerlink" title="6.2 tanh 激活函数"></a>6.2 tanh 激活函数</h3><p>$$tanh(x) = 2 \sigma(2x) - 1$$</p><p><img src="/images/neural-network/act-tanh.jpg"></p><h3 id="6-3-ReLU-激活函数"><a href="#6-3-ReLU-激活函数" class="headerlink" title="6.3 ReLU 激活函数"></a>6.3 ReLU 激活函数</h3><p>$$ReLU(x) = max(0, x)$$</p><p><img src="/images/neural-network/act-relu.jpg"></p><p>当输入 $x&lt;0$ 时，输出为 $0$，当 $x&gt; 0$ 时，输出为 $x$。该激活函数使网络更快速地收敛。它不会饱和，即它可以对抗梯度消失问题，至少在正区域（$x&gt; 0$ 时）可以这样，因此神经元至少在一半区域中不会把所有零进行反向传播。由于使用了简单的阈值化（thresholding），ReLU 计算效率很高。</p><p>在网络中，不同的输入可能包含着大小不同关键特征，使用大小可变的数据结构去做容器，则更加灵活。假如神经元激活具有稀疏性，那么不同激活路径上：不同数量（选择性不激活）、不同功能（分布式激活）。两种可优化的结构生成的激活路径，可以更好地从有效的数据的维度上，学习到相对稀疏的特征，起到自动化解离效果。</p><p><img src="/images/neural-network/nn-sparse.png"></p><p>稀疏特征并不需要网络具有很强的处理线性不可分机制，因此在深度学习模型中，使用简单、速度快的线性激活函数可能更为合适。如图，一旦神经元与神经元之间改为线性激活，网络的非线性部分仅仅来自于神经元部分选择性激活。</p><p>更倾向于使用线性神经激活函数的另外一个原因是，减轻梯度法训练深度网络时的Vanishing Gradient Problem。</p><p>看过BP推导的人都知道，误差从输出层反向传播算梯度时，在各层都要乘当前层的输入神经元值，激活函数的一阶导数。<br>$$<br>grad = error ⋅ sigmoid’(x) ⋅ x<br>$$</p><p>使用双端饱和(即值域被限制)Sigmoid系函数会有两个问题：</p><ol><li>sigmoid’(x) ∈ (0,1)  导数缩放</li><li>x∈(0,1)或x∈(-1,1)  饱和值缩放</li></ol><p>这样，经过每一层时，误差都是成倍的衰减，一旦进行递推式的多层的反向传播，梯度就会不停的衰减，消失，使得网络学习变慢。而校正激活函数的梯度是1，且只有一端饱和，梯度很好的在反向传播中流动，训练速度得到了很大的提高。</p><h2 id="7-算法与处理步骤"><a href="#7-算法与处理步骤" class="headerlink" title="7. 算法与处理步骤"></a>7. 算法与处理步骤</h2><pre class="line-numbers language-none"><code class="language-none">W = random# 每次训练for k in range(epoch)    # 正向计算    for j in range(NN_depth):        # 式2 ( a = xxx)        X_j = f( W_{j, j-1} X_{j-1})    ＃ 反向误差计算    for j in range(NN_depth, 0, -1):        # 式3， 式4        delta = y_i(1-y_i)(t_i-y_i)        or         delta = a_i(1-a_i) \sum w_ki delta_k        # 式5        w_ji = w_j + epsilon delta_j x_ji<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-1-正向计算："><a href="#7-1-正向计算：" class="headerlink" title="7.1 正向计算："></a>7.1 正向计算：</h3><p><img src="/images/neural-network/formular_2.png"></p><h3 id="7-2-反向传播："><a href="#7-2-反向传播：" class="headerlink" title="7.2 反向传播："></a>7.2 反向传播：</h3><p>输出层的误差计算：</p><p><img src="/images/neural-network/formular_3.png"></p><p>隐层的误差计算：</p><p><img src="/images/neural-network/formular_4.png"></p><p>权值更新：</p><p><img src="/images/neural-network/formular_5.png"></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 多层神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记（二）：逻辑回归算法</title>
      <link href="2022/01/08/machine-learning-2/"/>
      <url>2022/01/08/machine-learning-2/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习（二）：逻辑回归算法"><a href="#机器学习（二）：逻辑回归算法" class="headerlink" title="机器学习（二）：逻辑回归算法"></a>机器学习（二）：逻辑回归算法</h1><p>逻辑回归(Logistic Regression, LR)模型其实仅在线性回归的基础上，套用了一个逻辑函数，但也就由于这个逻辑函数，使得逻辑回归模型能够输出类别的概率。</p><p>逻辑回归的本质是：假设数据服从这个分布，然后使用极大似然估计做参数的估计。</p><p><img src="/images/machine-learning/2-1.png"></p><h2 id="1-什么是回归"><a href="#1-什么是回归" class="headerlink" title="1. 什么是回归"></a>1. 什么是回归</h2><p>一说回归最先想到的是终结者那句：I’ll be back</p><p>regress，re表示back，gress等于go，数值go back to mean value，也就是I’ll be back 的意思</p><p>在数理统计中，回归是确定多种变量相互依赖的定量关系的方法</p><blockquote><p>通俗理解：越来越接近期望值的过程，<strong>回归</strong> 于事物的本质</p></blockquote><p>最简单的回归是线性回归(Linear Regression)，也就是通过最小二乘等方法得到模型的参数。线性回归假设输出变量是若干输出变量的线性组合，并根据这一关系求解线性组合中的最优系数。</p><p>通俗理解：输出一个线性函数，例如$y=f(x; \theta)$，通过寻找最优的参数$\theta$使得观测数据与模型数据相吻合。</p><p><img src="/images/machine-learning/2-2.png"></p><h2 id="2-逻辑回归模型"><a href="#2-逻辑回归模型" class="headerlink" title="2. 逻辑回归模型"></a>2. 逻辑回归模型</h2><p>回归是一种比较容易理解的模型，就相当于$y=f(x)$，表明自变量$x$与因变量$y$的关系。</p><p>以常见的看医举例，医生治病时的望、闻、问、切，之后判定病人是否生病或生了什么病，其中的望闻问切就是获取自变量$x$，即特征数据，判断是否生病就相当于获取因变量$y$，即预测分类。</p><p>$X$为数据点——肿瘤的大小，$Y$为观测值——是否是恶性肿瘤。</p><p>通过构建线性回归模型，如$h_\theta(x)$所示，构建线性回归模型后，即可以根据肿瘤大小，预测是否为恶性肿瘤$h_\theta(x)) \ge 0.5$为恶性，$h_\theta(x) \lt 0.5$为良性。</p><p><img src="/images/machine-learning/2-3.gif"></p><p>然而线性回归的鲁棒性很差，例如在上图的数据集上建立回归，因最右边噪点的存在，使回归模型在训练集上表现都很差。这主要是由于线性回归在整个实数域内敏感度一致，而分类范围，需要在$[0,1]$。</p><p>逻辑回归就是一种减小预测范围，将预测值限定为$[0,1]$间的一种回归模型，其回归方程与回归曲线如下图所示。逻辑曲线在$z=0$时，十分敏感，在$z&gt;&gt;0$或$z&lt;&lt;0$处，都不敏感，将预测值限定为$(0,1)$。</p><h3 id="2-1-逻辑回归表达式"><a href="#2-1-逻辑回归表达式" class="headerlink" title="2.1 逻辑回归表达式"></a>2.1 逻辑回归表达式</h3><p>这个函数称为Logistic函数(Logistic Function)，也称为Sigmoid函数(Sigmoid Function)。函数公式如下：</p><p>$$<br>g(z) = \frac{1}{1+e^{-z}}<br>$$</p><p>Logistic函数:</p><ul><li>当$z$趋近于无穷大时，$g(z)$趋近于1；</li><li>当$z$趋近于无穷小时，$g(z)$趋近于0。</li></ul><p>Logistic函数的图形如上图所示。Logistic函数求导时有一个特性，这个特性将在下面的推导中用到，这个特性为：<br>$$<br>g’(z) =  \frac{d}{dz} \frac{1}{1+e^{-z}} \<br>      =  \frac{1}{(1+e^{-z})^2}(e^{-z}) \<br>      =  \frac{1}{(1+e^{-z})} (1 - \frac{1}{(1+e^{-z})}) \<br>      =  g(z)(1-g(z))<br>$$<br>逻辑回归本质上是线性回归，只是在特征到结果的映射中加入了一层函数映射，即先把特征线性求和，然后使用函数$g(z)$将做为假设函数来预测。</p><p>$g(z)$可以将连续值映射到0到1之间。线性回归模型的表达式带入$g(z)$，就得到逻辑回归的表达式:<br>$$<br>h_\theta(x) = g(\theta^T x) = \frac{1}{1+e^{-\theta^T x}}<br>$$</p><h3 id="2-2-逻辑回归的软分类"><a href="#2-2-逻辑回归的软分类" class="headerlink" title="2.2 逻辑回归的软分类"></a>2.2 逻辑回归的软分类</h3><p>现在我们将y的取值$h_\theta(x)$通过Logistic函数归一化到(0,1)间，$y$的取值有特殊的含义，它表示结果取1的概率，因此对于输入$x$分类结果为类别1和类别0的概率分别为：</p><p>$$<br>P(y=1|x,\theta) = h_\theta(x) \<br>P(y=0|x,\theta) = 1 - h_\theta(x)<br>$$</p><p>对上面的表达式合并一下就是：</p><p>$$<br>p(y|x,\theta) = (h_\theta(x))^y (1 - h_\theta(x))^{1-y}<br>$$</p><h3 id="2-3-梯度上升"><a href="#2-3-梯度上升" class="headerlink" title="2.3 梯度上升"></a>2.3 梯度上升</h3><p>得到了逻辑回归的表达式，下一步跟线性回归类似，构建似然函数，然后最大似然估计，最终推导出$\theta$的迭代更新表达式。只不过这里用的不是梯度下降，而是梯度上升，因为这里是最大化似然函数。</p><p>假设训练样本相互独立，那么似然函数表达式为：</p><p><img src="/images/machine-learning/2-4.png"></p><p>同样对似然函数取log，转换为：</p><p><img src="/images/machine-learning/2-5.png"></p><p>转换后的似然函数对$\theta$求偏导，在这里我们以只有一个训练样本的情况为例：</p><p><img src="/images/machine-learning/2-6.png"></p><p>这个求偏导过程中：</p><ul><li>第一步是对$\theta$偏导的转化，依据偏导公式：$y=lnx$, $y’=1/x$。</li><li>第二步是根据$g(z)$求导的特性$g’(z) = g(z)(1 - g(z))$ 。</li><li>第三步就是普通的变换。</li></ul><p>这样我们就得到了梯度上升每次迭代的更新方向，那么$\theta$的迭代表达式为：<br>$$<br>\theta = \theta + \eta (y^i - h_\theta(x^i)) x_j^i<br>$$</p><p>其中$\eta$是学习速率。</p><h2 id="3-手写逻辑回归"><a href="#3-手写逻辑回归" class="headerlink" title="3. 手写逻辑回归"></a>3. 手写逻辑回归</h2><p>这里以手写数字识别为例。我们手写一个逻辑回归类处理这个多分类问题，同时使用sklearn的逻辑回归模型作对比。</p><p><img src="/images/machine-learning/2-7.png"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> random<span class="token keyword">import</span> time<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> math <span class="token keyword">import</span> inf<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> load_digits<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>linear_model <span class="token keyword">import</span> LogisticRegression<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>metrics <span class="token keyword">import</span> confusion_matrix<span class="token keyword">def</span> <span class="token function">sigmoid</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    sigmoid函数    """</span>    <span class="token keyword">return</span> <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">acc_score</span><span class="token punctuation">(</span>predict_data<span class="token punctuation">,</span> raw_data<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    计算结果的准确率    :param predict_data: 预测值    :param raw_data: 真值    """</span>    cnt <span class="token operator">=</span> <span class="token number">0</span>    size <span class="token operator">=</span> np<span class="token punctuation">.</span>shape<span class="token punctuation">(</span>predict_data<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token builtin">int</span><span class="token punctuation">(</span>raw_data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token builtin">int</span><span class="token punctuation">(</span>predict_data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            cnt <span class="token operator">+=</span> <span class="token number">1</span>    score <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span>cnt <span class="token operator">/</span> size<span class="token punctuation">)</span>    <span class="token keyword">return</span> scorefig_num <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">display</span><span class="token punctuation">(</span>images<span class="token punctuation">,</span> ground_truth<span class="token punctuation">,</span> predict<span class="token punctuation">,</span> fig_name<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    画出预测结果    :param images: 数字的图片    :param ground_truth: 真值    :param predict: 预测值    :param fig_name: 图片名字    """</span>    <span class="token comment"># plot the digits</span>    <span class="token keyword">global</span> fig_num    fig_num <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">if</span> fig_name <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>        fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>fig_num<span class="token punctuation">,</span> figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># figure size in inches</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        fig <span class="token operator">=</span> plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>fig_name<span class="token punctuation">,</span> figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># figure size in inches</span>    fig<span class="token punctuation">.</span>subplots_adjust<span class="token punctuation">(</span>left<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> right<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> bottom<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> top<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> hspace<span class="token operator">=</span><span class="token number">0.05</span><span class="token punctuation">,</span> wspace<span class="token operator">=</span><span class="token number">0.05</span><span class="token punctuation">)</span>    size <span class="token operator">=</span> np<span class="token punctuation">.</span>shape<span class="token punctuation">(</span>predict<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">if</span> size <span class="token operator">&gt;</span> <span class="token number">56</span><span class="token punctuation">:</span>        size <span class="token operator">=</span> <span class="token number">56</span>    <span class="token comment"># plot the digits: each image is 8x8 pixels</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>        ax <span class="token operator">=</span> fig<span class="token punctuation">.</span>add_subplot<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> xticks<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> yticks<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        ax<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>images<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> cmap<span class="token operator">=</span>plt<span class="token punctuation">.</span>cm<span class="token punctuation">.</span>binary<span class="token punctuation">)</span>        <span class="token comment"># label the image with the target value</span>        ax<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span>ground_truth<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token builtin">int</span><span class="token punctuation">(</span>ground_truth<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token builtin">int</span><span class="token punctuation">(</span>predict<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            ax<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>predict<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'green'</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">15</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            ax<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>predict<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'red'</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span>    <span class="token comment"># plot confusion matrix</span>    cm <span class="token operator">=</span> confusion_matrix<span class="token punctuation">(</span>ground_truth<span class="token punctuation">,</span> predict<span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>matshow<span class="token punctuation">(</span>cm<span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>colorbar<span class="token punctuation">(</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span>fig_name <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> <span class="token string">'Confusion Matrix'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">'Groundtruth'</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">'Predict'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">load_data</span><span class="token punctuation">(</span>train_size<span class="token operator">=</span><span class="token number">0.75</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    加载数据同时分割出训练集和测试集    :param train_size: 训练集的比例    :return 分割好的数据集    """</span>    <span class="token comment"># 加载数据</span>    <span class="token comment"># 这个函数返回的应该是一个类实例，里面有很多的变量，需要“单独的拿出来用”</span>    digits <span class="token operator">=</span> load_digits<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 输出查看一下这个类的属性和方法</span>    <span class="token comment"># print(dir(digits))</span>    <span class="token comment"># 获得数据的大小</span>    data_size <span class="token operator">=</span> np<span class="token punctuation">.</span>shape<span class="token punctuation">(</span>digits<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token comment"># 将数据打乱，这里需要把这个类的要用上的变量都对应上，有点麻烦（是否有更简便的方法？）</span>    shuffled_index <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>permutation<span class="token punctuation">(</span>data_size<span class="token punctuation">)</span>    digits<span class="token punctuation">.</span>data <span class="token operator">=</span> digits<span class="token punctuation">.</span>data<span class="token punctuation">[</span>shuffled_index<span class="token punctuation">]</span>    digits<span class="token punctuation">.</span>images <span class="token operator">=</span> digits<span class="token punctuation">.</span>images<span class="token punctuation">[</span>shuffled_index<span class="token punctuation">]</span>    digits<span class="token punctuation">.</span>target <span class="token operator">=</span> digits<span class="token punctuation">.</span>target<span class="token punctuation">[</span>shuffled_index<span class="token punctuation">]</span>    <span class="token comment"># 分割数据集</span>    split_index <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>data_size <span class="token operator">*</span> train_size<span class="token punctuation">)</span>    train_data <span class="token operator">=</span> digits<span class="token punctuation">.</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>split_index<span class="token punctuation">]</span>    train_target <span class="token operator">=</span> digits<span class="token punctuation">.</span>target<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>split_index<span class="token punctuation">]</span>    train_images <span class="token operator">=</span> digits<span class="token punctuation">.</span>images<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>split_index<span class="token punctuation">]</span>    test_data <span class="token operator">=</span> digits<span class="token punctuation">.</span>data<span class="token punctuation">[</span>split_index<span class="token punctuation">:</span><span class="token punctuation">]</span>    test_target <span class="token operator">=</span> digits<span class="token punctuation">.</span>target<span class="token punctuation">[</span>split_index<span class="token punctuation">:</span><span class="token punctuation">]</span>    test_images <span class="token operator">=</span> digits<span class="token punctuation">.</span>images<span class="token punctuation">[</span>split_index<span class="token punctuation">:</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> train_data<span class="token punctuation">,</span> train_target<span class="token punctuation">,</span> train_images<span class="token punctuation">,</span> test_data<span class="token punctuation">,</span> test_target<span class="token punctuation">,</span> test_images<span class="token keyword">class</span> <span class="token class-name">Logistic_Regression</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    逻辑回归模型，通过OVR(One-Vs-All)解决多分类问题    """</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">,</span> label<span class="token punctuation">,</span> max_iter<span class="token operator">=</span><span class="token number">500</span><span class="token punctuation">,</span> alpha<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">,</span> tol<span class="token operator">=</span><span class="token number">0.000005</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        初始化逻辑回归类        :param data: 加载训练集        :param label: 加载训练集的标签        :param max_iter: 最大迭代次数        :param alpha: 学习率（步长）        :param tol: 停止求解的标准，当收敛速度过慢时停止求解        """</span>        <span class="token comment"># 保存传入数据</span>        self<span class="token punctuation">.</span>data <span class="token operator">=</span> data        self<span class="token punctuation">.</span>label <span class="token operator">=</span> label        self<span class="token punctuation">.</span>max_iter <span class="token operator">=</span> max_iter        self<span class="token punctuation">.</span>alpha <span class="token operator">=</span> alpha        self<span class="token punctuation">.</span>tol <span class="token operator">=</span> tol        <span class="token comment"># 进一步处理</span>        <span class="token comment"># 数据长度m与单个数据的长度n</span>        self<span class="token punctuation">.</span>m<span class="token punctuation">,</span> self<span class="token punctuation">.</span>n <span class="token operator">=</span> np<span class="token punctuation">.</span>shape<span class="token punctuation">(</span>data<span class="token punctuation">)</span>        <span class="token comment"># 数据权重</span>        self<span class="token punctuation">.</span>weights <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 常数项</span>        self<span class="token punctuation">.</span>b <span class="token operator">=</span> np<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">train</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> method<span class="token operator">=</span><span class="token string">"SGD"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        进行训练，这里采用的是OVR方法解决多分类问题        :param method: 使用的求解方法        """</span>        <span class="token comment"># 对于每一个数字</span>        <span class="token keyword">for</span> number <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 重新打标签</span>            label <span class="token operator">=</span> np<span class="token punctuation">.</span>copy<span class="token punctuation">(</span>self<span class="token punctuation">.</span>label<span class="token punctuation">)</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> label<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> number<span class="token punctuation">:</span>                    label<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    label<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">if</span> method <span class="token operator">==</span> <span class="token string">"SGD"</span><span class="token punctuation">:</span>                <span class="token comment"># 采用随机梯度上升法进行迭代求解</span>                self<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>number<span class="token punctuation">,</span> label<span class="token punctuation">)</span>            <span class="token keyword">elif</span> method <span class="token operator">==</span> <span class="token string">"MBGD"</span><span class="token punctuation">:</span>                <span class="token comment"># 采用小批量梯度下降法</span>                self<span class="token punctuation">.</span>MBGD<span class="token punctuation">(</span>number<span class="token punctuation">,</span> label<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"error method:"</span><span class="token punctuation">,</span> method<span class="token punctuation">)</span>                exit<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">predict</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> predict_data<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        进行预测        :param predict_data: 测试集        """</span>        <span class="token comment"># 保存对测试集的预测结果</span>        result <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>np<span class="token punctuation">.</span>shape<span class="token punctuation">(</span>predict_data<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment"># 保存对单个数据，每个分类器给出的结果</span>        ans <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>        <span class="token comment"># 开始对整个测试集进行预测</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 分别用每个数字的分类器进行预测</span>            <span class="token keyword">for</span> k <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                ans<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> sigmoid<span class="token punctuation">(</span><span class="token builtin">sum</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>weights<span class="token punctuation">[</span>k<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">*</span> predict_data<span class="token punctuation">[</span>i<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>b<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            ans <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span>            result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> ans<span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token builtin">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> result    <span class="token keyword">def</span> <span class="token function">SGD</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> number<span class="token punctuation">,</span> label<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        使用老师上课讲的随机梯度上升法求解        :param number: 目前需要被分类的数字        :param label: 根据这个数组制作的标签        """</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>max_iter<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 上次的误差</span>            last_error <span class="token operator">=</span> inf            num_index <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token comment"># FIXME</span>                <span class="token comment">#  之前其实是随机打乱了的，所以这里是不是没有必要进行这样的操作？</span>                <span class="token comment">#  这里实际上还是用上了所有的样本，所以实际上这里随机取值对结果并没有影响</span>                rand_index <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>num_index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                error <span class="token operator">=</span> label<span class="token punctuation">[</span>rand_index<span class="token punctuation">]</span> <span class="token operator">-</span> sigmoid<span class="token punctuation">(</span>                    <span class="token builtin">sum</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>weights<span class="token punctuation">[</span>number<span class="token punctuation">]</span> <span class="token operator">*</span> train_data<span class="token punctuation">[</span>rand_index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>b<span class="token punctuation">[</span>number<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token comment"># 实际上下面这样做的效果不好，error可能为正也可能为负。。。</span>                <span class="token comment"># if abs(error) &gt; abs(last_error):</span>                <span class="token comment"># if error &gt; last_error:</span>                <span class="token comment">#     continue</span>                <span class="token comment"># 下面右边应该是 学习率*(1-g(z))*z，是求偏导的过程</span>                self<span class="token punctuation">.</span>weights<span class="token punctuation">[</span>number<span class="token punctuation">]</span> <span class="token operator">+=</span> self<span class="token punctuation">.</span>alpha <span class="token operator">*</span> error <span class="token operator">*</span> train_data<span class="token punctuation">[</span>rand_index<span class="token punctuation">]</span>                self<span class="token punctuation">.</span>b<span class="token punctuation">[</span>number<span class="token punctuation">]</span> <span class="token operator">+=</span> self<span class="token punctuation">.</span>alpha <span class="token operator">*</span> error                <span class="token keyword">del</span> <span class="token punctuation">(</span>num_index<span class="token punctuation">[</span>rand_index<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>last_error <span class="token operator">-</span> error<span class="token punctuation">)</span> <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>tol<span class="token punctuation">:</span>                    <span class="token keyword">break</span>                last_error <span class="token operator">=</span> error    <span class="token keyword">def</span> <span class="token function">MBGD</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> number<span class="token punctuation">,</span> label<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        尝试使用小批量梯度下降法求解        :param number: 目前需要被分类的数字        :param label: 根据这个数组制作的标签        """</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>max_iter<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 上次的误差</span>            last_error <span class="token operator">=</span> inf            <span class="token comment"># 小批量的数目</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>m <span class="token operator">&lt;</span> <span class="token number">200</span><span class="token punctuation">:</span>                m <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>m<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                m <span class="token operator">=</span> random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span>            num_index <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>                rand_index <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>uniform<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>num_index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                error <span class="token operator">=</span> label<span class="token punctuation">[</span>rand_index<span class="token punctuation">]</span> <span class="token operator">-</span> sigmoid<span class="token punctuation">(</span>                    <span class="token builtin">sum</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>weights<span class="token punctuation">[</span>number<span class="token punctuation">]</span> <span class="token operator">*</span> train_data<span class="token punctuation">[</span>rand_index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>b<span class="token punctuation">[</span>number<span class="token punctuation">]</span><span class="token punctuation">)</span>                self<span class="token punctuation">.</span>weights<span class="token punctuation">[</span>number<span class="token punctuation">]</span> <span class="token operator">+=</span> self<span class="token punctuation">.</span>alpha <span class="token operator">*</span> error <span class="token operator">*</span> train_data<span class="token punctuation">[</span>rand_index<span class="token punctuation">]</span>                self<span class="token punctuation">.</span>b<span class="token punctuation">[</span>number<span class="token punctuation">]</span> <span class="token operator">+=</span> self<span class="token punctuation">.</span>alpha <span class="token operator">*</span> error                <span class="token keyword">del</span> <span class="token punctuation">(</span>num_index<span class="token punctuation">[</span>rand_index<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>last_error <span class="token operator">-</span> error<span class="token punctuation">)</span> <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>tol<span class="token punctuation">:</span>                    <span class="token keyword">break</span>                last_error <span class="token operator">=</span> error<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    <span class="token comment"># 加载并且分割各种数据</span>    train_data<span class="token punctuation">,</span> train_target<span class="token punctuation">,</span> train_images<span class="token punctuation">,</span> test_data<span class="token punctuation">,</span> test_target<span class="token punctuation">,</span> test_images <span class="token operator">=</span> load_data<span class="token punctuation">(</span>train_size<span class="token operator">=</span><span class="token number">0.75</span><span class="token punctuation">)</span>    <span class="token comment"># =====================使用自己的方法做预测========================</span>    <span class="token comment"># 生成一个逻辑回归类实例，并且把训练集导入</span>    lr <span class="token operator">=</span> Logistic_Regression<span class="token punctuation">(</span>train_data<span class="token punctuation">,</span> train_target<span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">,</span> <span class="token number">0.01</span><span class="token punctuation">,</span> <span class="token number">0.0000005</span><span class="token punctuation">)</span>    <span class="token comment"># 开始训练并且计时</span>    start <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>    lr<span class="token punctuation">.</span>train<span class="token punctuation">(</span>method<span class="token operator">=</span><span class="token string">"SGD"</span><span class="token punctuation">)</span>    end <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"训练用时:\t%f s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 对训练集做预测并且输出准确度与结果</span>    train_result <span class="token operator">=</span> lr<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>train_data<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"对训练集做预测:\t"</span><span class="token punctuation">,</span> acc_score<span class="token punctuation">(</span>train_result<span class="token punctuation">,</span> train_target<span class="token punctuation">)</span><span class="token punctuation">)</span>    display<span class="token punctuation">(</span>train_images<span class="token punctuation">,</span> train_target<span class="token punctuation">,</span> train_result<span class="token punctuation">,</span> <span class="token string">"My Train"</span><span class="token punctuation">)</span>    <span class="token comment"># 对测试集做预测并且输出准确度与结果</span>    test_result <span class="token operator">=</span> lr<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>test_data<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"对测试集做预测:\t"</span><span class="token punctuation">,</span> acc_score<span class="token punctuation">(</span>test_result<span class="token punctuation">,</span> test_target<span class="token punctuation">)</span><span class="token punctuation">)</span>    display<span class="token punctuation">(</span>test_images<span class="token punctuation">,</span> test_target<span class="token punctuation">,</span> test_result<span class="token punctuation">,</span> <span class="token string">"My Test"</span><span class="token punctuation">)</span>    <span class="token comment"># =====================使用sklearn做预测========================</span>    skl <span class="token operator">=</span> LogisticRegression<span class="token punctuation">(</span><span class="token punctuation">)</span>    start <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>    skl<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>train_data<span class="token punctuation">,</span> train_target<span class="token punctuation">)</span>    end <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"训练用时:\t%f s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span>    pred_train <span class="token operator">=</span> skl<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>train_data<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"对训练集做预测:\t"</span><span class="token punctuation">,</span> acc_score<span class="token punctuation">(</span>pred_train<span class="token punctuation">,</span> train_target<span class="token punctuation">)</span><span class="token punctuation">)</span>    display<span class="token punctuation">(</span>train_images<span class="token punctuation">,</span> train_target<span class="token punctuation">,</span> pred_train<span class="token punctuation">,</span> <span class="token string">"Sklearn Train"</span><span class="token punctuation">)</span>    pred_test <span class="token operator">=</span> skl<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>test_data<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"对测试集做预测:\t"</span><span class="token punctuation">,</span> acc_score<span class="token punctuation">(</span>pred_test<span class="token punctuation">,</span> test_target<span class="token punctuation">)</span><span class="token punctuation">)</span>    display<span class="token punctuation">(</span>test_images<span class="token punctuation">,</span> test_target<span class="token punctuation">,</span> pred_test<span class="token punctuation">,</span> <span class="token string">"Sklearn Test"</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>手写逻辑回归预测结果展示：</p><p><img src="/images/machine-learning/2-8.png"></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 逻辑回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记（一）：K-Means聚类算法</title>
      <link href="2022/01/07/machine-learning-1/"/>
      <url>2022/01/07/machine-learning-1/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习笔记（一）：K-Means聚类算法"><a href="#机器学习笔记（一）：K-Means聚类算法" class="headerlink" title="机器学习笔记（一）：K-Means聚类算法"></a>机器学习笔记（一）：K-Means聚类算法</h1><blockquote><p>2021年下半年选修了两门机器学习相关的课程，感觉学到了非常多的知识，打算好好整理一下。</p><p>大部分内容是从课件里面搬运来的，但大部分代码是自己理解的基础上写出来的。</p></blockquote><p>根据训练样本中是否包含标签信息，机器学习可以分为 <strong>监督学习</strong> 和 <strong>无监督学习</strong>。</p><p>聚类算法是典型的无监督学习，其训练的样本中值包含样本的特征，<strong>不包含样本的标签信息</strong>。在聚类算法中，利用样本的特征，将具有相似特征空间分布的样本划分到同一类别中。</p><h2 id="1-算法原理"><a href="#1-算法原理" class="headerlink" title="1. 算法原理"></a>1. 算法原理</h2><p>由于具有出色的速度和良好的可扩展性，K-Means聚类算法是最经典的聚类方法。</p><p><strong>k-Means算法是一个重复移动类中心点（重心，centroids）的过程</strong>:</p><ul><li>移动中心点到其包含成员的平均位置;</li><li>然后重新划分其内部成员。</li></ul><p><code>k</code>是算法中的超参数，表示类的数量；k-Means可以自动分配样本到不同的类，但是不能决定究竟要分几个类。</p><p><code>k</code>必须是一个比训练集样本数小的正整数。有时，类的数量是由问题内容指定的。例如，一个鞋厂有三种新款式，它想知道每种新款式都有哪些潜在客户，于是它调研客户，然后从数据里找出三类。也有一些问题没有指定聚类的数量，最优的聚类数量是不确定的。</p><p>k-Means的参数是类的重心位置和其内部观测值的位置。与广义线性模型和决策树类似，k-Means参数的最优解也是以代价函数最小化为目标。k-Means代价函数公式如下：<br>$$<br>J = \sum_{k=1}^{K} \sum_{i \in C_k} | x_i - u_k|^2<br>$$</p><p>$u_k$是第$k$个类的重心位置，定义为：<br>$$<br>u_k = \frac{1}{|C_k|} \sum_{i \in C_k} x_i<br>$$</p><p>成本函数是各个类畸变程度（distortions）之和。每个类的畸变程度等于该类重心与其内部成员位置距离的平方和。若类内部的成员彼此间越紧凑则类的畸变程度越小，反之，若类内部的成员彼此间越分散则类的畸变程度越大。</p><h2 id="2-算法流程"><a href="#2-算法流程" class="headerlink" title="2. 算法流程"></a>2. 算法流程</h2><p>求解成本函数最小化的参数就是一个重复配置每个类包含的观测值，并不断移动类重心的过程。</p><p>输入：$T={ x_1, x_2, …, x_N}$，其中$x_i \in R_n$，i=1,2…N</p><p>输出：聚类集合$C_k$, 聚类中心$u_k$, 其中k=1,2,…K</p><ol><li>初始化类的重心$u_k$，可以随机选择样本作为聚类中心</li><li>每次迭代的时候，把所有样本分配到离它们最近的类，即更新聚类集合$C_k$</li><li>然后把重心移动到该类全部成员位置的平均值那里，即更新$u_k$</li><li>若达到最大迭代步数，或两次迭代差小于设定的阈值则算法结束，否则重复步骤2</li></ol><h2 id="3-算法实现"><a href="#3-算法实现" class="headerlink" title="3. 算法实现"></a>3. 算法实现</h2><p>K-Means的简单实现如下所示，根据不同情景的需要设计不同的距离函数即可。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">compute_distances</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># TODO 根据实际应用场景进行定义</span>    <span class="token keyword">pass</span><span class="token keyword">def</span> <span class="token function">K_means</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> K<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    KMeans聚类算法的具体实现    :param data:    :param K: 聚类的个数    :param N: 算法的迭代次数    :return: 类别标志labels与中心坐标centerPoints    """</span>    <span class="token comment"># 获取数据行数</span>    n <span class="token operator">=</span> np<span class="token punctuation">.</span>shape<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token comment"># 从n条数据中随机选择K条，作为初始中心向量</span>    <span class="token comment"># centerId是初始中心向量的索引坐标</span>    centerId <span class="token operator">=</span> random<span class="token punctuation">.</span>sample<span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">,</span> K<span class="token punctuation">)</span>    <span class="token comment"># 获得初始中心向量，共k个</span>    centerPoints <span class="token operator">=</span> data<span class="token punctuation">[</span>centerId<span class="token punctuation">]</span>    <span class="token comment"># 计算data到centerPoints的距离矩阵</span>    <span class="token comment"># dist[i][:],是i个点到各个中心点的距离</span>    dist <span class="token operator">=</span> compute_distances<span class="token punctuation">(</span>data<span class="token punctuation">,</span> centerPoints<span class="token punctuation">)</span>    <span class="token comment"># 这里进行第一次判断，距离哪个中心点进就判断为哪一类</span>    <span class="token comment"># axis=1寻找每一行中最小值的索引</span>    labels <span class="token operator">=</span> np<span class="token punctuation">.</span>argmin<span class="token punctuation">(</span>dist<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 迭代次数</span>    count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment"># 循环次数小于迭代次数，一直迭代</span>    <span class="token keyword">while</span> count <span class="token operator">&lt;</span> N<span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>K<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 重新计算每一个类别的中心点</span>            centerPoints<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>data<span class="token punctuation">[</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>labels <span class="token operator">==</span> i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment"># 重新计算距离矩阵</span>        dist <span class="token operator">=</span> compute_distances<span class="token punctuation">(</span>data<span class="token punctuation">,</span> centerPoints<span class="token punctuation">)</span>        <span class="token comment"># 重新分类</span>        labels <span class="token operator">=</span> np<span class="token punctuation">.</span>argmin<span class="token punctuation">(</span>dist<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 迭代次数加1</span>        count <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token comment"># 返回类别标识，中心坐标</span>    <span class="token keyword">return</span> labels<span class="token punctuation">,</span> centerPoints<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-算法应用"><a href="#4-算法应用" class="headerlink" title="4. 算法应用"></a>4. 算法应用</h2><p>比如我们要对下面的数据应用K-Means算法，以此来区分两个圆环：</p><p><img src="/images/machine-learning/1-1.png"></p><p>我们可以先进行特征变换，将数据从每一个点的坐标(x, y)变换为点到原点的距离disc，这样我们就可以更方便的区分这两个圆环：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 进行特征变化，这里很容易想到将特征变化为点到原点的距离（这里用的平方）</span>trans_data <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>train_data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">**</span> <span class="token number">2</span> <span class="token operator">+</span> train_data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>之后我们构造下面这样的距离函数：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">compute_distances</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    计算两组向量之间的距离，两个向量要有一样的维度和长度    """</span>    <span class="token comment"># 与sqrt(sum(power(vecA - vecB, 2)))相比，这个可以直接计算一整组的距离，更方便</span>    <span class="token keyword">return</span> cdist<span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> metric<span class="token operator">=</span><span class="token string">"euclidean"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就可以应用上面实现的K-Means算法了。</p><p>注：</p><p>该部分的数据自己随机生成即可，如果不会生成，可以使用这个网址上的数据：<a href="https://github.com/Immortalqx/ML_Homework/blob/master/homework_03_kmeans/dataset_circles.csv">https://github.com/Immortalqx/ML_Homework/blob/master/homework_03_kmeans/dataset_circles.csv</a></p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> random<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">from</span> scipy<span class="token punctuation">.</span>spatial<span class="token punctuation">.</span>distance <span class="token keyword">import</span> cdist<span class="token keyword">def</span> <span class="token function">compute_distances</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    计算两组向量之间的距离，两个向量要有一样的维度和长度    """</span>    <span class="token comment"># 与sqrt(sum(power(vecA - vecB, 2)))相比，这个可以直接计算一整组的距离，更方便</span>    <span class="token keyword">return</span> cdist<span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> metric<span class="token operator">=</span><span class="token string">"euclidean"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">K_means</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> K<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    KMeans聚类算法的具体实现    :param data:    :param K: 聚类的个数    :param N: 算法的迭代次数    :return: 类别标志labels与中心坐标centerPoints    """</span>    <span class="token comment"># 获取数据行数</span>    n <span class="token operator">=</span> np<span class="token punctuation">.</span>shape<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token comment"># 从n条数据中随机选择K条，作为初始中心向量</span>    <span class="token comment"># centerId是初始中心向量的索引坐标</span>    centerId <span class="token operator">=</span> random<span class="token punctuation">.</span>sample<span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">,</span> K<span class="token punctuation">)</span>    <span class="token comment"># 获得初始中心向量，共k个</span>    centerPoints <span class="token operator">=</span> data<span class="token punctuation">[</span>centerId<span class="token punctuation">]</span>    <span class="token comment"># 计算data到centerPoints的距离矩阵</span>    <span class="token comment"># dist[i][:],是i个点到各个中心点的距离</span>    dist <span class="token operator">=</span> compute_distances<span class="token punctuation">(</span>data<span class="token punctuation">,</span> centerPoints<span class="token punctuation">)</span>    <span class="token comment"># 这里进行第一次判断，距离哪个中心点进就判断为哪一类</span>    <span class="token comment"># axis=1寻找每一行中最小值的索引</span>    labels <span class="token operator">=</span> np<span class="token punctuation">.</span>argmin<span class="token punctuation">(</span>dist<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 迭代次数</span>    count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment"># 循环次数小于迭代次数，一直迭代</span>    <span class="token keyword">while</span> count <span class="token operator">&lt;</span> N<span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>K<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 重新计算每一个类别的中心点</span>            centerPoints<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>data<span class="token punctuation">[</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>labels <span class="token operator">==</span> i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment"># 重新计算距离矩阵</span>        dist <span class="token operator">=</span> compute_distances<span class="token punctuation">(</span>data<span class="token punctuation">,</span> centerPoints<span class="token punctuation">)</span>        <span class="token comment"># 重新分类</span>        labels <span class="token operator">=</span> np<span class="token punctuation">.</span>argmin<span class="token punctuation">(</span>dist<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 迭代次数加1</span>        count <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token comment"># 返回类别标识，中心坐标</span>    <span class="token keyword">return</span> labels<span class="token punctuation">,</span> centerPoints<span class="token keyword">def</span> <span class="token function">evaluate</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> labels<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    评估聚类的结果    """</span>    num<span class="token punctuation">,</span> div <span class="token operator">=</span> np<span class="token punctuation">.</span>shape<span class="token punctuation">(</span>data<span class="token punctuation">)</span>    <span class="token comment"># 判断数据的维度是不是1</span>    <span class="token keyword">if</span> div <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"sorry,the dimension of your dataset is not 1!"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span>    count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> labels<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>            count <span class="token operator">+=</span> <span class="token number">1</span>        i <span class="token operator">+=</span> <span class="token number">1</span>    score <span class="token operator">=</span> count <span class="token operator">*</span> <span class="token number">1.0</span> <span class="token operator">/</span> num    <span class="token comment"># 因为分类是随机的，不一定对应的上（比如0和1对应，1和0对应，导致正确率为0），所以要调整一下</span>    <span class="token keyword">if</span> <span class="token number">1</span> <span class="token operator">-</span> score <span class="token operator">&gt;</span> score<span class="token punctuation">:</span>        score <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> score    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"score = %f"</span> <span class="token operator">%</span> <span class="token punctuation">(</span><span class="token number">100.0</span> <span class="token operator">*</span> score<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">getCenterPoint</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> K<span class="token punctuation">,</span> labels<span class="token punctuation">)</span><span class="token punctuation">:</span>    centerPoints <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token punctuation">:</span>K<span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>K<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 重新计算每一个类别的中心点</span>        centerPoints<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> np<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>data<span class="token punctuation">[</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>labels <span class="token operator">==</span> i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> centerPoints<span class="token keyword">def</span> <span class="token function">plotFeature</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> labels_<span class="token punctuation">,</span> centerPoints<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    二维空间显示聚类结果    """</span>    <span class="token comment"># 获取簇集的个数</span>    clusterNum <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span><span class="token builtin">set</span><span class="token punctuation">(</span>labels_<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 内定的颜色种类</span>    scatterColors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"orange"</span><span class="token punctuation">,</span> <span class="token string">"purple"</span><span class="token punctuation">,</span> <span class="token string">"cyan"</span><span class="token punctuation">,</span> <span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"green"</span><span class="token punctuation">]</span>    <span class="token comment"># 判断数据的维度是不是２</span>    <span class="token keyword">if</span> np<span class="token punctuation">.</span>shape<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"sorry,the dimension of your dataset is not 2!"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span>    <span class="token comment"># 判断簇集类别是否大于５类</span>    <span class="token keyword">if</span> clusterNum <span class="token operator">&gt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>scatterColors<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"sorry,your k is too large,please add length of the scatterColors!"</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span>    <span class="token comment"># 散点图的绘制</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>clusterNum<span class="token punctuation">)</span><span class="token punctuation">:</span>        colorSytle <span class="token operator">=</span> scatterColors<span class="token punctuation">[</span>i <span class="token operator">%</span> <span class="token builtin">len</span><span class="token punctuation">(</span>scatterColors<span class="token punctuation">)</span><span class="token punctuation">]</span>        subCluster <span class="token operator">=</span> data<span class="token punctuation">[</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>labels_ <span class="token operator">==</span> i<span class="token punctuation">)</span><span class="token punctuation">]</span>        plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>subCluster<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> subCluster<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token operator">=</span>colorSytle<span class="token punctuation">,</span> s<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span>    <span class="token comment"># 中心点的绘制</span>    mark <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"*"</span><span class="token punctuation">,</span> <span class="token string">"^"</span><span class="token punctuation">,</span> <span class="token string">"o"</span><span class="token punctuation">,</span> <span class="token string">"X"</span><span class="token punctuation">,</span> <span class="token string">"D"</span><span class="token punctuation">]</span>  <span class="token comment"># 这个是设置绘制的形状</span>    label <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"0"</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">,</span> <span class="token string">"4"</span><span class="token punctuation">]</span>  <span class="token comment"># label的作用是设置图例</span>    c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"blue"</span><span class="token punctuation">,</span> <span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"peru"</span><span class="token punctuation">,</span> <span class="token string">"violet"</span><span class="token punctuation">,</span> <span class="token string">"black"</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>clusterNum<span class="token punctuation">)</span><span class="token punctuation">:</span>        plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>centerPoints<span class="token punctuation">[</span>i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> centerPoints<span class="token punctuation">[</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                 mark<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> markersize<span class="token operator">=</span><span class="token number">15</span><span class="token punctuation">,</span> label<span class="token operator">=</span>label<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token operator">=</span>c<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        plt<span class="token punctuation">.</span>legend<span class="token punctuation">(</span>loc<span class="token operator">=</span><span class="token string">"upper left"</span><span class="token punctuation">)</span>  <span class="token comment"># 图例</span>    <span class="token comment"># 设置x、y轴和标题</span>    plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span><span class="token string">"x-label"</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span><span class="token string">"y-label"</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token string">"k-means cluster result"</span><span class="token punctuation">)</span>    plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    <span class="token comment"># 用户定义聚类数</span>    K <span class="token operator">=</span> <span class="token number">2</span>    <span class="token comment"># 从文本中加载数据</span>    data <span class="token operator">=</span> np<span class="token punctuation">.</span>loadtxt<span class="token punctuation">(</span><span class="token string">"../dataset_circles.csv"</span><span class="token punctuation">,</span> delimiter<span class="token operator">=</span><span class="token string">","</span><span class="token punctuation">)</span>    <span class="token comment"># 分割前两列作为训练集</span>    train_data <span class="token operator">=</span> data<span class="token punctuation">.</span>T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span>    <span class="token comment"># 进行特征变化，这里很容易想到将特征变化为点到原点的距离（这里用的平方）</span>    trans_data <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>train_data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">**</span> <span class="token number">2</span> <span class="token operator">+</span> train_data<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment"># 分割第三列作为测试集</span>    test_data <span class="token operator">=</span> data<span class="token punctuation">.</span>T<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>    <span class="token comment"># 开始计时</span>    start <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 执行KMeans算法</span>    labels<span class="token punctuation">,</span> _ <span class="token operator">=</span> K_means<span class="token punctuation">(</span>trans_data<span class="token punctuation">.</span>T<span class="token punctuation">,</span> K<span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span>    <span class="token comment"># 结束计时</span>    end <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 由于这里进行特征变化了，返回的中心点是一维的，因此要根据聚类结果重新计算中心点</span>    centerPoints <span class="token operator">=</span> getCenterPoint<span class="token punctuation">(</span>train_data<span class="token punctuation">.</span>T<span class="token punctuation">,</span> K<span class="token punctuation">,</span> labels<span class="token punctuation">)</span>    <span class="token comment"># 评估聚类算法的结果</span>    evaluate<span class="token punctuation">(</span>test_data<span class="token punctuation">.</span>T<span class="token punctuation">,</span> labels<span class="token punctuation">)</span>    <span class="token comment"># 输出聚类算法所用时间</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"time = %s"</span> <span class="token operator">%</span> <span class="token builtin">str</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 绘图显示</span>    plotFeature<span class="token punctuation">(</span>train_data<span class="token punctuation">.</span>T<span class="token punctuation">,</span> labels<span class="token punctuation">,</span> centerPoints<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K-Means </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APSIPA ASC 2021杰出讲师报告会参会总结</title>
      <link href="2022/01/05/meeting-1/"/>
      <url>2022/01/05/meeting-1/</url>
      
        <content type="html"><![CDATA[<h1 id="APSIPA-ASC-2021杰出讲师报告会参会总结"><a href="#APSIPA-ASC-2021杰出讲师报告会参会总结" class="headerlink" title="APSIPA ASC 2021杰出讲师报告会参会总结"></a>APSIPA ASC 2021杰出讲师报告会参会总结</h1><blockquote><p>这是从我选修的研究生课程的课程报告整理过来的。</p><blockquote><p>根据“人工智能：神经网络与深度学习”课程教学要求，安排学生参加相关前沿学术报告，本学期安排参加亚太信号与信息处理协会组织的杰出讲者报告会（寒假学校）。</p></blockquote><p>这里我做的仅仅是记录老师们介绍的工作内容，不敢说有多深入的理解，最后做的总结也仅仅是从我目前的状况（没接触过科研，没发表过文章的菜鸡本科生）出发的。</p></blockquote><h3 id="Lecture-3-Exploration-of-depth-super-resolution-based-on-deep-learning"><a href="#Lecture-3-Exploration-of-depth-super-resolution-based-on-deep-learning" class="headerlink" title="Lecture 3: Exploration of depth super-resolution based on deep learning"></a>Lecture 3: Exploration of depth super-resolution based on deep learning</h3><p>白慧慧首先介绍了超分辨率技术的研究背景与研究现状，后面再介绍了她最近的三项工作以及未来的研究方向。内容要点如下所示。</p><p><strong>超分辨率技术的分类：</strong></p><ol><li><p>Interpolated-based approach（基于插值的方法）</p></li><li><p>Reconstructed-based approach（基于重构的方法）</p></li><li><p>Learning-based approach（基于学习的方法）</p><p>a)    Bicubic pre-interpolated images as input</p><p>b)   LR images as input—–post-upsampling</p><p>c)    GAN based image SR</p></li></ol><h4 id="recent-work-1-Image-SR-based-on-deep-learning"><a href="#recent-work-1-Image-SR-based-on-deep-learning" class="headerlink" title="recent work 1: Image SR based on deep learning"></a>recent work 1: Image SR based on deep learning</h4><p><strong><em>The main issue of image SR</em></strong> ：有效的恢复低分辨率（LR）输入的高频细节。</p><p><strong><em>现有方法的问题：</em></strong>现有CNN方法内存消耗和计算成本都很大；大多数SR网络中，LR特征的低频和高频分量在训练过程中被同等对待，忽略了局部详细信息，阻碍了网络的表示能力。</p><p><strong><em>作者提出的网络结构：</em></strong></p><p><img src="/images/meeting/1-1.png"></p><h4 id="recent-work-2-Video-SR-based-on-deep-learning"><a href="#recent-work-2-Video-SR-based-on-deep-learning" class="headerlink" title="recent work 2: Video SR based on deep learning"></a>recent work 2: Video SR based on deep learning</h4><p><strong><em>Video super-resolution (SR) aims to</em></strong> reconstruct the corresponding high- resolution (HR) frames from consecutive lower-solution (LR) frames, which focuses on modeling the inter-frame temporal correlations and intra-frame spatial correlations among frames.</p><p><strong><em>Overall Architecture:</em></strong> </p><p><img src="/images/meeting/1-2.png"></p><h4 id="recent-work-3-Depth-SR-based-on-deep-learning"><a href="#recent-work-3-Depth-SR-based-on-deep-learning" class="headerlink" title="recent work 3: Depth SR based on deep learning"></a>recent work 3: Depth SR based on deep learning</h4><p><strong><em>Motivation:</em></strong> 通过深度图超分辨率（Depth SR）解决深度图分辨率与RGB图像分辨率无法匹配的问题。</p><p><strong><em>Limitations:</em></strong> 缺乏现实世界配对的 LR 和 HR 深度图。 大多数现有的深度图 SR 方法使用下采样来获得成对的训练样本。深度图 SR 中的锐利边界和精细细节很难恢复，尤其是当缩放因子很大时。</p><p><strong><em>Proposed Method:</em></strong></p><p><img src="/images/meeting/1-3.png"></p><h4 id="Future-research-directions"><a href="#Future-research-directions" class="headerlink" title="Future research directions"></a>Future research directions</h4><ol><li><p>Unsupervised Image/Depth SR</p></li><li><p>Real Degradation</p></li><li><p>Higher SR rates</p></li><li><p>Arbitrary SR rates</p></li></ol><h3 id="Lecture-5：Glass-Reflection-Removal-for-Images-and-3D-Point-Clouds"><a href="#Lecture-5：Glass-Reflection-Removal-for-Images-and-3D-Point-Clouds" class="headerlink" title="Lecture 5：Glass Reflection Removal for Images and 3D Point Clouds"></a>Lecture 5：Glass Reflection Removal for Images and 3D Point Clouds</h3><p>Jae-Young Sim主要介绍的是去除图像和点云中玻璃反光的方法。</p><h4 id="Reflection-removal-for-2D-glass-images"><a href="#Reflection-removal-for-2D-glass-images" class="headerlink" title="Reflection removal for 2D glass images"></a>Reflection removal for 2D glass images</h4><p>Jae-Young Sim去除图像玻璃反光的方法主要是Multiple Image Warping，具体的步骤如下所示：</p><ol><li><p>Formulated a weighted low-rank matrix completion problem in image gradient domain for the purpose of reflection removal.</p></li><li><p>Employ co-saliency detection for glass image alignment.</p></li><li><p>Iteratively obtained low-rank gradient matrix to restore the transmission gradients while suppressing the reflection gradients.</p></li><li><p>Reconstruction of transmission image</p></li></ol><h4 id="Reflection-removal-for-3D-point-clouds"><a href="#Reflection-removal-for-3D-point-clouds" class="headerlink" title="Reflection removal for 3D point clouds"></a>Reflection removal for 3D point clouds</h4><p>对于只有单个玻璃平面的情况：</p><ul><li>First work of reflection removal</li><li>Analyzing characteristic of LiDAR scanner</li><li>Removing virtual points using symmetry relation</li></ul><p>对于有多个玻璃平面的情况：</p><ul><li>Detecting multiple glass planes</li><li>Estimating trajectories of laser pulses·</li><li>Quantitative evaluation</li></ul><h3 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h3><p>我觉得参与这样规格的会议对我的帮助还是挺大的，我目前才大三，对自己未来的研究方向还不是很明确，仅仅是对深度学习、计算机视觉方面比较感兴趣。通过这次会议，我从Wan-Chi Siu教授这里了解了深度学习的发展历程，对深度学习领域现在研究的方向有了大概的了解，同时也从白慧慧教授和Jae-Young Sim教授这里了解到计算机视觉不同分支的发展情况。</p><p>具体来说，我的收获可以总结为以下几点：</p><h4 id="一些技术的原理和思想并不复杂"><a href="#一些技术的原理和思想并不复杂" class="headerlink" title="一些技术的原理和思想并不复杂"></a>一些技术的原理和思想并不复杂</h4><p>我本来觉得，随着技术的进步，新的技术会变得越来越复杂。不过从Jae-Young Sim教授的报告中我发现其实有的技术的原理和思想是挺好理解的，不过具体的实现可能会复杂一些。</p><p>Jae-Young Sim介绍3D点云去除反光点的时候，首先介绍了激光雷达扫描的特性，以及对于单个玻璃平面反光的情况。单个玻璃平面反光会导致激光雷达接收到两个以上的点：一个来自物体，一个来自玻璃上的反射脉冲，所以去除单个玻璃平面造成的反光点就可以通过检测这个反射脉冲来实现，而反射点到激光雷达的距离比真实点的距离大（我理解的是如果反射点距离更小就意味着有其他物体在激光雷达和真实物体之间，这样就会阻挡真实物体的光线，这样就不可能会检测到被遮挡在后面的物体），所以就可以通过距离来进行打分，判断一个点是不是反射点。</p><p><img src="/images/meeting/1-4.png"></p><p>而对于多个玻璃平面的情况，由于玻璃之间的互相折射，通过距离的方法不能有效检测出反射点，但是被多次折射的物理位姿往往是不正确的（如下图）。这样就可以通过检测物体位姿的合理性来判断该物体是否是反射点构成的。</p><p><img src="/images/meeting/1-5.png"></p><h4 id="比起新方法的实现，数据集的设计与获取也非常关键"><a href="#比起新方法的实现，数据集的设计与获取也非常关键" class="headerlink" title="比起新方法的实现，数据集的设计与获取也非常关键"></a>比起新方法的实现，数据集的设计与获取也非常关键</h4><p>我在参加这个会议的时候发现，Jae-Young Sim介绍完他们的工作后，Nakamasa Inoue就提了一个关于Ground Truth获取的问题。后面我回顾这个细节，感觉数据集或者Ground Truth的获取确实是一个很重要的问题，数据是研究的基础，任何研究都离不开数据。</p><p>比如我们做一些创新性的工作时，可能现成的数据集就不是很适合，这时候就需要新的数据集来测试我们的工作，并验证我们工作的正确性，而且一个高质量的数据集往往能够提高模型训练的质量和预测的准确率。所以，这个数据集如何得到，真实值到底真不真实，都是比较重要的。</p><p>这次会议中，白慧慧就介绍了他们制作的RGB-D-D数据集，用于深度图超分辨率技术。</p><h4 id="需要加强对英语的学习"><a href="#需要加强对英语的学习" class="headerlink" title="需要加强对英语的学习"></a>需要加强对英语的学习</h4><p>国外的学术会议一般都是把英语作为会议的主要用语，老师们做报告的时候也是用英语来进行表达的。</p><p>我英语不太行，参加会议的时候跟不上老师讲的内容,,ԾㅂԾ,,</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学术会议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于SIFT的图像拼接（融合）实现</title>
      <link href="2021/12/31/opencv-notes-6/"/>
      <url>2021/12/31/opencv-notes-6/</url>
      
        <content type="html"><![CDATA[<h1 id="基于SIFT的图像拼接（融合）实现"><a href="#基于SIFT的图像拼接（融合）实现" class="headerlink" title="基于SIFT的图像拼接（融合）实现"></a>基于SIFT的图像拼接（融合）实现</h1><p><strong>要求：</strong></p><ol><li>给出你用手机拍摄两张有重叠视野的照片（建议两幅图像打光不同，以体现融合的效果）。</li><li>用sift特征或者任意你熟悉的特征进行匹配。</li><li>给出变换矩阵，并完成拼接，给出拼接后的图像。</li><li>对拼接后的图像进行融合，附融合后的图像。</li></ol><h3 id="加载图片并进行预处理"><a href="#加载图片并进行预处理" class="headerlink" title="加载图片并进行预处理"></a>加载图片并进行预处理</h3><p>第一步肯定是图片的加载和预处理。这里我的想法是：</p><ul><li>先加载图片，然后调整第一张图片的分辨率，强制宽度为600；</li><li>之后再调整第二张图片的分辨率，让这两张图片的分辨率一样。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">load_image</span><span class="token punctuation">(</span>img1_path<span class="token punctuation">,</span> img2_path<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    加载两张图片，并进行预处理    :param img1_path: 图片1的路径    :param img2_path: 图片2的路径    :return: 处理后的图片1与图片2    """</span>    <span class="token comment"># ================ 图片加载 ================</span>    img1 <span class="token operator">=</span> cv<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>img1_path<span class="token punctuation">)</span>    img2 <span class="token operator">=</span> cv<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>img2_path<span class="token punctuation">)</span>    <span class="token comment"># ================ 分辨率调整 ================</span>    rate <span class="token operator">=</span> <span class="token number">600</span> <span class="token operator">/</span> img1<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    img1 <span class="token operator">=</span> cv<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>img1<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>rate <span class="token operator">*</span> img1<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span>rate <span class="token operator">*</span> img1<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    img2 <span class="token operator">=</span> cv<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>img2<span class="token punctuation">,</span> <span class="token punctuation">(</span>img1<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> img1<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># FIXME:</span>    <span class="token comment">#  - 使用边界填充：特征点匹配的结果图带有很大的黑域</span>    <span class="token comment">#  - 不使用边界填充：最后图像拼接和融合不方便，还是需要新建一张更大的图或者提前算好图的大小</span>    <span class="token comment"># ================ 边界填充 ================</span>    top<span class="token punctuation">,</span> bot<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">250</span><span class="token punctuation">,</span> <span class="token number">250</span><span class="token punctuation">,</span> <span class="token number">250</span><span class="token punctuation">,</span> <span class="token number">250</span>    img1 <span class="token operator">=</span> cv<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img1<span class="token punctuation">,</span> top<span class="token punctuation">,</span> bot<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> cv<span class="token punctuation">.</span>BORDER_CONSTANT<span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    img2 <span class="token operator">=</span> cv<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img2<span class="token punctuation">,</span> top<span class="token punctuation">,</span> bot<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> cv<span class="token punctuation">.</span>BORDER_CONSTANT<span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> img1<span class="token punctuation">,</span> img2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是预处理之后的两张图片（第二张图片亮度明显比第一张低）</p><p><img src="/images/OpenCV-Notes/6-01.png"></p><h3 id="特征点计算与匹配"><a href="#特征点计算与匹配" class="headerlink" title="特征点计算与匹配"></a>特征点计算与匹配</h3><p>得到处理好的两张图片之后，我使用OpenCV的SIFT特征点进行匹配。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">match_feather_point</span><span class="token punctuation">(</span>img1<span class="token punctuation">,</span> img2<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    计算特征点并进行匹配    :param img1: 第一张图片    :param img2: 第二张图片    :return: 匹配的特征点    """</span>    <span class="token comment"># ================ 计算SIFT特征 ================</span>    sift <span class="token operator">=</span> cv<span class="token punctuation">.</span>SIFT_create<span class="token punctuation">(</span><span class="token punctuation">)</span>    kp1<span class="token punctuation">,</span> des1 <span class="token operator">=</span> sift<span class="token punctuation">.</span>detectAndCompute<span class="token punctuation">(</span>img1<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>    kp2<span class="token punctuation">,</span> des2 <span class="token operator">=</span> sift<span class="token punctuation">.</span>detectAndCompute<span class="token punctuation">(</span>img2<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>    <span class="token comment"># ================ FLANN特征匹配 ================</span>    FLANN_INDEX_KDTREE <span class="token operator">=</span> <span class="token number">1</span>    index_params <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span>algorithm<span class="token operator">=</span>FLANN_INDEX_KDTREE<span class="token punctuation">,</span> trees<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>    search_params <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span>checks<span class="token operator">=</span><span class="token number">50</span><span class="token punctuation">)</span>    flann <span class="token operator">=</span> cv<span class="token punctuation">.</span>FlannBasedMatcher<span class="token punctuation">(</span>index_params<span class="token punctuation">,</span> search_params<span class="token punctuation">)</span>    matches <span class="token operator">=</span> flann<span class="token punctuation">.</span>knnMatch<span class="token punctuation">(</span>des1<span class="token punctuation">,</span> des2<span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> kp1<span class="token punctuation">,</span> kp2<span class="token punctuation">,</span> matches<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="计算变换矩阵并完成拼接"><a href="#计算变换矩阵并完成拼接" class="headerlink" title="计算变换矩阵并完成拼接"></a>计算变换矩阵并完成拼接</h3><p>这部分的思路：</p><ul><li><p>根据匹配点间的距离选择了一些好的匹配点对；</p></li><li><p>利用OpenCV的findHomography函数计算得到了变换矩阵（所以这里使用的是投射模型）；</p></li><li><p>根据变换矩阵和OpenCV的warpPerspective函数对第二张图片进行了配准（这里是前向映射）；</p><blockquote><p>前向映射就是根据原图用变换公式直接算出输出图像相应像素的空间位置</p><p>反向映射（Inverse Mapping）：扫描输出图像的位置(x,y)，通过 Image （为T的逆矩阵）计算输入图像对应的位置 (v,w)，通过插值方法决定输出图像该位置的灰度值。</p></blockquote></li><li><p>之后使用拷贝的方法完成了一个非常简单的拼接。</p></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_good_match</span><span class="token punctuation">(</span>img1<span class="token punctuation">,</span> img2<span class="token punctuation">,</span> kp1<span class="token punctuation">,</span> kp2<span class="token punctuation">,</span> matches<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    提取好的匹配点对、计算变换矩阵并拼接图像    :param img1: 第一张图片    :param img2: 第二张图片    :param kp1: 第一张图片特征点    :param kp2: 第二张图片特征点    :param matches: 匹配结果    :return: 第一张图片，配准的第二张图片，匹配结果，拼接图片，变换矩阵    """</span>    <span class="token comment"># TODO 使用RANSAC方法去除错误匹配点对</span>    matches_mask <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>matches<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    good_match <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i<span class="token punctuation">,</span> <span class="token punctuation">(</span>m<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>matches<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> m<span class="token punctuation">.</span>distance <span class="token operator">&lt;</span> <span class="token number">0.5</span> <span class="token operator">*</span> n<span class="token punctuation">.</span>distance<span class="token punctuation">:</span>            good_match<span class="token punctuation">.</span>append<span class="token punctuation">(</span>m<span class="token punctuation">)</span>            matches_mask<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>    <span class="token comment"># ================ 画出匹配结果图 ================</span>    draw_params <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span>matchColor<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                       singlePointColor<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                       matchesMask<span class="token operator">=</span>matches_mask<span class="token punctuation">,</span>                       flags<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>    img3 <span class="token operator">=</span> cv<span class="token punctuation">.</span>drawMatchesKnn<span class="token punctuation">(</span>img1<span class="token punctuation">,</span> kp1<span class="token punctuation">,</span> img2<span class="token punctuation">,</span> kp2<span class="token punctuation">,</span> matches<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token operator">**</span>draw_params<span class="token punctuation">)</span>    <span class="token comment"># ================ 图像配准，对第二幅图像进行变换 ================</span>    MIN_MATCH_COUNT <span class="token operator">=</span> <span class="token number">10</span>    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>good_match<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MIN_MATCH_COUNT<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Not enough matches are found - {}/{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>good_match<span class="token punctuation">)</span><span class="token punctuation">,</span> MIN_MATCH_COUNT<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">None</span>    src_pts <span class="token operator">=</span> np<span class="token punctuation">.</span>float32<span class="token punctuation">(</span><span class="token punctuation">[</span>kp1<span class="token punctuation">[</span>m<span class="token punctuation">.</span>queryIdx<span class="token punctuation">]</span><span class="token punctuation">.</span>pt <span class="token keyword">for</span> m <span class="token keyword">in</span> good_match<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    dst_pts <span class="token operator">=</span> np<span class="token punctuation">.</span>float32<span class="token punctuation">(</span><span class="token punctuation">[</span>kp2<span class="token punctuation">[</span>m<span class="token punctuation">.</span>trainIdx<span class="token punctuation">]</span><span class="token punctuation">.</span>pt <span class="token keyword">for</span> m <span class="token keyword">in</span> good_match<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    M<span class="token punctuation">,</span> mask <span class="token operator">=</span> cv<span class="token punctuation">.</span>findHomography<span class="token punctuation">(</span>src_pts<span class="token punctuation">,</span> dst_pts<span class="token punctuation">,</span> cv<span class="token punctuation">.</span>RANSAC<span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">)</span>    img2 <span class="token operator">=</span> cv<span class="token punctuation">.</span>warpPerspective<span class="token punctuation">(</span>img2<span class="token punctuation">,</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>img2<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> img2<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                              flags<span class="token operator">=</span>cv<span class="token punctuation">.</span>WARP_INVERSE_MAP<span class="token punctuation">)</span>    <span class="token comment"># ================ 图像拼接（拷贝拼接，效果不好） ================</span>    dst <span class="token operator">=</span> img1<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>img2<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>img2<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            pix <span class="token operator">=</span> img2<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span>            <span class="token keyword">if</span> pix<span class="token punctuation">.</span><span class="token builtin">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dst<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> pix    <span class="token keyword">return</span> img1<span class="token punctuation">,</span> img2<span class="token punctuation">,</span> img3<span class="token punctuation">,</span> dst<span class="token punctuation">,</span> M<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>初始匹配的结果：</p><p><img src="/images/OpenCV-Notes/6-02.png"></p><p>去除错误匹配之后的结果：</p><p><img src="/images/OpenCV-Notes/6-03.png"></p><p>计算得到的变换矩阵：</p><pre class="line-numbers language-none"><code class="language-none">变换矩阵：[[ 2.73415935e-01  4.12585718e-01  2.88797035e+02] [-2.82455289e-01  1.26241598e+00 -2.13730468e+02] [-1.02250262e-03  7.60354200e-04  1.00000000e+00]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>图片拼接的结果：（拼接痕迹明显）</p><p><img src="/images/OpenCV-Notes/6-04.png"></p><h3 id="进行图像融合"><a href="#进行图像融合" class="headerlink" title="进行图像融合"></a>进行图像融合</h3><p>这部分的思路：</p><ul><li><p>主要是根据某种权重来进行融合；</p></li><li><p>这里很自然的想到计算左右重叠的部分，然后根据重叠部分某个点到左右边界的距离来计算权重；</p><blockquote><p>由于上面仅仅是计算左右重叠的部分，所以最后得到的结果可能会有横向拼接痕迹；</p><p>我后面尝试了上下左右都考虑进去，但是考虑的方法不是很好，没有取得比较好的效果。</p></blockquote></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">blend_image</span><span class="token punctuation">(</span>src_img<span class="token punctuation">,</span> warp_img<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    图像融合    :param src_img: 第一张图片    :param warp_img:  第二张图片    :return:  融合后的图片    """</span>    <span class="token comment"># ================ 基本变量定义 ================</span>    rows<span class="token punctuation">,</span> cols <span class="token operator">=</span> src_img<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span>    result <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">[</span>rows<span class="token punctuation">,</span> cols<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>    left <span class="token operator">=</span> <span class="token number">0</span>    right <span class="token operator">=</span> <span class="token number">0</span>    up <span class="token operator">=</span> <span class="token number">0</span>    down <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment"># ================ 找到左右重叠区域 ================</span>    <span class="token keyword">for</span> col <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> cols<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> src_img<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> col<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">and</span> warp_img<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> col<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            left <span class="token operator">=</span> col            <span class="token keyword">break</span>    <span class="token keyword">for</span> col <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>cols <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> src_img<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> col<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">and</span> warp_img<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> col<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            right <span class="token operator">=</span> col            <span class="token keyword">break</span>    <span class="token comment"># ================ 找到上下重叠区域 ================</span>    <span class="token comment"># for row in range(0, rows):</span>    <span class="token comment">#     if src_img[row, :].any() and warp_img[row, :].any():</span>    <span class="token comment">#         up = row</span>    <span class="token comment">#         break</span>    <span class="token comment"># for row in range(rows - 1, 0, -1):</span>    <span class="token comment">#     if src_img[row, :].any() and warp_img[row, :].any():</span>    <span class="token comment">#         down = row</span>    <span class="token comment">#         break</span>    <span class="token comment"># ================ 根据权重进行图像融合 ================</span>    <span class="token comment"># FIXME:</span>    <span class="token comment">#  - 根据左右重叠区域进行融合会导致图片中有横向的拼接痕迹</span>    <span class="token comment">#  - 利用上下与左右重叠的区域进行简单融合的效果并不好，需要一些别的办法</span>    <span class="token keyword">for</span> row <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> rows<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> col <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> cols<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token keyword">not</span> src_img<span class="token punctuation">[</span>row<span class="token punctuation">,</span> col<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># src不存在</span>                result<span class="token punctuation">[</span>row<span class="token punctuation">,</span> col<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> warp_img<span class="token punctuation">[</span>row<span class="token punctuation">,</span> col<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span>            <span class="token keyword">elif</span> <span class="token keyword">not</span> warp_img<span class="token punctuation">[</span>row<span class="token punctuation">,</span> col<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># warp_img 不存在</span>                result<span class="token punctuation">[</span>row<span class="token punctuation">,</span> col<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> src_img<span class="token punctuation">[</span>row<span class="token punctuation">,</span> col<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>  <span class="token comment"># src 和warp都存在，就是交叉区域</span>                src_len <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token builtin">abs</span><span class="token punctuation">(</span>col <span class="token operator">-</span> left<span class="token punctuation">)</span><span class="token punctuation">)</span>                test_len <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token builtin">abs</span><span class="token punctuation">(</span>col <span class="token operator">-</span> right<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment"># src_width = float(abs(row - down))</span>                <span class="token comment"># test_width = float(abs(row - up))</span>                alpha_1 <span class="token operator">=</span> src_len <span class="token operator">/</span> <span class="token punctuation">(</span>src_len <span class="token operator">+</span> test_len<span class="token punctuation">)</span>                <span class="token comment"># alpha_2 = src_width / (src_width + test_width)</span>                result<span class="token punctuation">[</span>row<span class="token punctuation">,</span> col<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> src_img<span class="token punctuation">[</span>row<span class="token punctuation">,</span> col<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">*</span> alpha_1 <span class="token operator">+</span> \                                      warp_img<span class="token punctuation">[</span>row<span class="token punctuation">,</span> col<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> alpha_1<span class="token punctuation">)</span>    <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后得到的融合结果：</p><p><img src="/images/OpenCV-Notes/6-05.png"></p><h2 id="其他运行结果"><a href="#其他运行结果" class="headerlink" title="其他运行结果"></a>其他运行结果</h2><h3 id="测试一"><a href="#测试一" class="headerlink" title="测试一"></a>测试一</h3><p><img src="/images/OpenCV-Notes/6-06.png"></p><p><img src="/images/OpenCV-Notes/6-07.png"></p><p><img src="/images/OpenCV-Notes/6-08.png"></p><h3 id="测试二"><a href="#测试二" class="headerlink" title="测试二"></a>测试二</h3><p><img src="/images/OpenCV-Notes/6-09.png"></p><p><img src="/images/OpenCV-Notes/6-10.png"></p><p><img src="/images/OpenCV-Notes/6-11.png"></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token triple-quoted-string string">"""TODO 要求：    1.给出你用手机拍摄两张有重叠视野的照片（建议两幅图像打光不同，以体现第五步融合的效果）。    2.用sift特征或者任意你熟悉的特征进行匹配。（附特征点图）    3.用RANSAC方法去除误匹配点对。（附筛除后的特征点图）    4.给出变换矩阵（仿射模型或投射模型都可以，需注明），并完成拼接（前向映射或反向映射都可以，需注明），给出拼接后的图像。    5.对拼接后的图像进行融合（任意你喜欢的融合方法），附融合后的图像。 注意：    尽量描述清楚每一步的思路，并附上对应代码。    完成任意四步就可以拿到满分（即可以不筛除离群点，或不进行融合）。    网上代码较多，可以参考。"""</span><span class="token keyword">import</span> time<span class="token keyword">import</span> cv2<span class="token punctuation">.</span>cv2 <span class="token keyword">as</span> cv<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token comment"># 1.给出你用手机拍摄两张有重叠视野的照片（建议两幅图像打光不同，以体现第五步融合的效果）。</span><span class="token keyword">def</span> <span class="token function">load_image</span><span class="token punctuation">(</span>img1_path<span class="token punctuation">,</span> img2_path<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    加载两张图片，并进行预处理    :param img1_path: 图片1的路径    :param img2_path: 图片2的路径    :return: 处理后的图片1与图片2    """</span>    <span class="token comment"># ================ 图片加载 ================</span>    img1 <span class="token operator">=</span> cv<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>img1_path<span class="token punctuation">)</span>    img2 <span class="token operator">=</span> cv<span class="token punctuation">.</span>imread<span class="token punctuation">(</span>img2_path<span class="token punctuation">)</span>    <span class="token comment"># ================ 分辨率调整 ================</span>    rate <span class="token operator">=</span> <span class="token number">600</span> <span class="token operator">/</span> img1<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    img1 <span class="token operator">=</span> cv<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>img1<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>rate <span class="token operator">*</span> img1<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span>rate <span class="token operator">*</span> img1<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    img2 <span class="token operator">=</span> cv<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>img2<span class="token punctuation">,</span> <span class="token punctuation">(</span>img1<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> img1<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># FIXME:</span>    <span class="token comment">#  - 使用边界填充：特征点匹配的结果图带有很大的黑域</span>    <span class="token comment">#  - 不使用边界填充：最后图像拼接和融合不方便，还是需要新建一张更大的图或者提前算好图的大小</span>    <span class="token comment"># ================ 边界填充 ================</span>    top<span class="token punctuation">,</span> bot<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right <span class="token operator">=</span> <span class="token number">250</span><span class="token punctuation">,</span> <span class="token number">250</span><span class="token punctuation">,</span> <span class="token number">250</span><span class="token punctuation">,</span> <span class="token number">250</span>    img1 <span class="token operator">=</span> cv<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img1<span class="token punctuation">,</span> top<span class="token punctuation">,</span> bot<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> cv<span class="token punctuation">.</span>BORDER_CONSTANT<span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    img2 <span class="token operator">=</span> cv<span class="token punctuation">.</span>copyMakeBorder<span class="token punctuation">(</span>img2<span class="token punctuation">,</span> top<span class="token punctuation">,</span> bot<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> cv<span class="token punctuation">.</span>BORDER_CONSTANT<span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> img1<span class="token punctuation">,</span> img2<span class="token comment"># 2.用sift特征或者任意你熟悉的特征进行匹配。（附特征点图）</span><span class="token keyword">def</span> <span class="token function">match_feather_point</span><span class="token punctuation">(</span>img1<span class="token punctuation">,</span> img2<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    计算特征点并进行匹配    :param img1: 第一张图片    :param img2: 第二张图片    :return: 匹配的特征点    """</span>    <span class="token comment"># ================ 计算SIFT特征 ================</span>    sift <span class="token operator">=</span> cv<span class="token punctuation">.</span>SIFT_create<span class="token punctuation">(</span><span class="token punctuation">)</span>    kp1<span class="token punctuation">,</span> des1 <span class="token operator">=</span> sift<span class="token punctuation">.</span>detectAndCompute<span class="token punctuation">(</span>img1<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>    kp2<span class="token punctuation">,</span> des2 <span class="token operator">=</span> sift<span class="token punctuation">.</span>detectAndCompute<span class="token punctuation">(</span>img2<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">)</span>    <span class="token comment"># ================ FLANN特征匹配 ================</span>    FLANN_INDEX_KDTREE <span class="token operator">=</span> <span class="token number">1</span>    index_params <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span>algorithm<span class="token operator">=</span>FLANN_INDEX_KDTREE<span class="token punctuation">,</span> trees<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>    search_params <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span>checks<span class="token operator">=</span><span class="token number">50</span><span class="token punctuation">)</span>    flann <span class="token operator">=</span> cv<span class="token punctuation">.</span>FlannBasedMatcher<span class="token punctuation">(</span>index_params<span class="token punctuation">,</span> search_params<span class="token punctuation">)</span>    matches <span class="token operator">=</span> flann<span class="token punctuation">.</span>knnMatch<span class="token punctuation">(</span>des1<span class="token punctuation">,</span> des2<span class="token punctuation">,</span> k<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> kp1<span class="token punctuation">,</span> kp2<span class="token punctuation">,</span> matches<span class="token comment"># 3.用RANSAC方法去除误匹配点对。（附筛除后的特征点图）</span><span class="token comment"># 4.给出变换矩阵（仿射模型或投射模型都可以，需注明），并且进行图像配准，完成拼接（前向映射或反向映射都可以，需注明），给出拼接后的图像。</span><span class="token keyword">def</span> <span class="token function">get_good_match</span><span class="token punctuation">(</span>img1<span class="token punctuation">,</span> img2<span class="token punctuation">,</span> kp1<span class="token punctuation">,</span> kp2<span class="token punctuation">,</span> matches<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    提取好的匹配点对、计算变换矩阵并拼接图像    :param img1: 第一张图片    :param img2: 第二张图片    :param kp1: 第一张图片特征点    :param kp2: 第二张图片特征点    :param matches: 匹配结果    :return: 第一张图片，配准的第二张图片，匹配结果，拼接图片，变换矩阵    """</span>    <span class="token comment"># TODO 使用RANSAC方法去除错误匹配点对</span>    matches_mask <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>matches<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    good_match <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i<span class="token punctuation">,</span> <span class="token punctuation">(</span>m<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token builtin">enumerate</span><span class="token punctuation">(</span>matches<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> m<span class="token punctuation">.</span>distance <span class="token operator">&lt;</span> <span class="token number">0.5</span> <span class="token operator">*</span> n<span class="token punctuation">.</span>distance<span class="token punctuation">:</span>            good_match<span class="token punctuation">.</span>append<span class="token punctuation">(</span>m<span class="token punctuation">)</span>            matches_mask<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>    <span class="token comment"># ================ 画出匹配结果图 ================</span>    <span class="token comment"># # 　这是没去除的部分</span>    <span class="token comment"># draw_params = dict(matchColor=(0, 255, 0),</span>    <span class="token comment">#                    singlePointColor=(255, 0, 0),</span>    <span class="token comment">#                    matchesMask=None,</span>    <span class="token comment">#                    flags=0)</span>    <span class="token comment"># img3 = cv.drawMatchesKnn(img1, kp1, img2, kp2, matches, None, **draw_params)</span>    <span class="token comment"># cv.imshow("test", img3)</span>    <span class="token comment"># 这是去除后的部分</span>    draw_params <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span>matchColor<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                       singlePointColor<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                       matchesMask<span class="token operator">=</span>matches_mask<span class="token punctuation">,</span>                       flags<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>    img3 <span class="token operator">=</span> cv<span class="token punctuation">.</span>drawMatchesKnn<span class="token punctuation">(</span>img1<span class="token punctuation">,</span> kp1<span class="token punctuation">,</span> img2<span class="token punctuation">,</span> kp2<span class="token punctuation">,</span> matches<span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token operator">**</span>draw_params<span class="token punctuation">)</span>    <span class="token comment"># ================ 图像配准，对第二幅图像进行变换 ================</span>    MIN_MATCH_COUNT <span class="token operator">=</span> <span class="token number">10</span>    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>good_match<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MIN_MATCH_COUNT<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Not enough matches are found - {}/{}"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>good_match<span class="token punctuation">)</span><span class="token punctuation">,</span> MIN_MATCH_COUNT<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">None</span>    src_pts <span class="token operator">=</span> np<span class="token punctuation">.</span>float32<span class="token punctuation">(</span><span class="token punctuation">[</span>kp1<span class="token punctuation">[</span>m<span class="token punctuation">.</span>queryIdx<span class="token punctuation">]</span><span class="token punctuation">.</span>pt <span class="token keyword">for</span> m <span class="token keyword">in</span> good_match<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    dst_pts <span class="token operator">=</span> np<span class="token punctuation">.</span>float32<span class="token punctuation">(</span><span class="token punctuation">[</span>kp2<span class="token punctuation">[</span>m<span class="token punctuation">.</span>trainIdx<span class="token punctuation">]</span><span class="token punctuation">.</span>pt <span class="token keyword">for</span> m <span class="token keyword">in</span> good_match<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    M<span class="token punctuation">,</span> mask <span class="token operator">=</span> cv<span class="token punctuation">.</span>findHomography<span class="token punctuation">(</span>src_pts<span class="token punctuation">,</span> dst_pts<span class="token punctuation">,</span> cv<span class="token punctuation">.</span>RANSAC<span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">)</span>    img2 <span class="token operator">=</span> cv<span class="token punctuation">.</span>warpPerspective<span class="token punctuation">(</span>img2<span class="token punctuation">,</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>img2<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> img2<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                              flags<span class="token operator">=</span>cv<span class="token punctuation">.</span>WARP_INVERSE_MAP<span class="token punctuation">)</span>    <span class="token comment"># ================ 图像拼接（拷贝拼接，效果不好） ================</span>    dst <span class="token operator">=</span> img1<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>img2<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>img2<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            pix <span class="token operator">=</span> img2<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span>            <span class="token keyword">if</span> pix<span class="token punctuation">.</span><span class="token builtin">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                dst<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span> <span class="token operator">=</span> pix    <span class="token keyword">return</span> img1<span class="token punctuation">,</span> img2<span class="token punctuation">,</span> img3<span class="token punctuation">,</span> dst<span class="token punctuation">,</span> M<span class="token comment"># 5.对拼接后的图像进行融合（任意你喜欢的融合方法），附融合后的图像。</span><span class="token keyword">def</span> <span class="token function">blend_image</span><span class="token punctuation">(</span>src_img<span class="token punctuation">,</span> warp_img<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    图像融合    :param src_img: 第一张图片    :param warp_img:  第二张图片    :return:  融合后的图片    """</span>    <span class="token comment"># ================ 基本变量定义 ================</span>    rows<span class="token punctuation">,</span> cols <span class="token operator">=</span> src_img<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span>    result <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">[</span>rows<span class="token punctuation">,</span> cols<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>    left <span class="token operator">=</span> <span class="token number">0</span>    right <span class="token operator">=</span> <span class="token number">0</span>    up <span class="token operator">=</span> <span class="token number">0</span>    down <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment"># ================ 找到左右重叠区域 ================</span>    <span class="token keyword">for</span> col <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> cols<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> src_img<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> col<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">and</span> warp_img<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> col<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            left <span class="token operator">=</span> col            <span class="token keyword">break</span>    <span class="token keyword">for</span> col <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>cols <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> src_img<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> col<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">and</span> warp_img<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> col<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            right <span class="token operator">=</span> col            <span class="token keyword">break</span>    <span class="token comment"># ================ 找到上下重叠区域 ================</span>    <span class="token comment"># for row in range(0, rows):</span>    <span class="token comment">#     if src_img[row, :].any() and warp_img[row, :].any():</span>    <span class="token comment">#         up = row</span>    <span class="token comment">#         break</span>    <span class="token comment"># for row in range(rows - 1, 0, -1):</span>    <span class="token comment">#     if src_img[row, :].any() and warp_img[row, :].any():</span>    <span class="token comment">#         down = row</span>    <span class="token comment">#         break</span>    <span class="token comment"># ================ 根据权重进行图像融合 ================</span>    <span class="token comment"># FIXME:</span>    <span class="token comment">#  - 根据左右重叠区域进行融合会导致图片中有横向的拼接痕迹</span>    <span class="token comment">#  - 利用上下与左右重叠的区域进行简单融合的效果并不好，需要一些别的办法</span>    <span class="token keyword">for</span> row <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> rows<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> col <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> cols<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token keyword">not</span> src_img<span class="token punctuation">[</span>row<span class="token punctuation">,</span> col<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># src不存在</span>                result<span class="token punctuation">[</span>row<span class="token punctuation">,</span> col<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> warp_img<span class="token punctuation">[</span>row<span class="token punctuation">,</span> col<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span>            <span class="token keyword">elif</span> <span class="token keyword">not</span> warp_img<span class="token punctuation">[</span>row<span class="token punctuation">,</span> col<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># warp_img 不存在</span>                result<span class="token punctuation">[</span>row<span class="token punctuation">,</span> col<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> src_img<span class="token punctuation">[</span>row<span class="token punctuation">,</span> col<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>  <span class="token comment"># src 和warp都存在，就是交叉区域</span>                src_len <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token builtin">abs</span><span class="token punctuation">(</span>col <span class="token operator">-</span> left<span class="token punctuation">)</span><span class="token punctuation">)</span>                test_len <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token builtin">abs</span><span class="token punctuation">(</span>col <span class="token operator">-</span> right<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment"># src_width = float(abs(row - down))</span>                <span class="token comment"># test_width = float(abs(row - up))</span>                alpha_1 <span class="token operator">=</span> src_len <span class="token operator">/</span> <span class="token punctuation">(</span>src_len <span class="token operator">+</span> test_len<span class="token punctuation">)</span>                <span class="token comment"># alpha_2 = src_width / (src_width + test_width)</span>                result<span class="token punctuation">[</span>row<span class="token punctuation">,</span> col<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> src_img<span class="token punctuation">[</span>row<span class="token punctuation">,</span> col<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">*</span> alpha_1 <span class="token operator">+</span> \                                      warp_img<span class="token punctuation">[</span>row<span class="token punctuation">,</span> col<span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> alpha_1<span class="token punctuation">)</span>    <span class="token keyword">return</span> result<span class="token keyword">def</span> <span class="token function">main_process</span><span class="token punctuation">(</span>path1<span class="token operator">=</span><span class="token string">'./images/testA_1.jpg'</span><span class="token punctuation">,</span> path2<span class="token operator">=</span><span class="token string">'./images/testA_2.jpg'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">""""""</span>    <span class="token comment"># ================ 加载图片 ================</span>    src_img<span class="token punctuation">,</span> warp_img <span class="token operator">=</span> load_image<span class="token punctuation">(</span>path1<span class="token punctuation">,</span> path2<span class="token punctuation">)</span>    <span class="token comment"># ================ 特征点计算与匹配 ================</span>    start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    kp1<span class="token punctuation">,</span> kp2<span class="token punctuation">,</span> matches <span class="token operator">=</span> match_feather_point<span class="token punctuation">(</span>src_img<span class="token punctuation">,</span> warp_img<span class="token punctuation">)</span>    end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'特征点计算以及匹配的时间：'</span><span class="token punctuation">,</span> end <span class="token operator">-</span> start<span class="token punctuation">)</span>    <span class="token comment"># ================ 去除误匹配点、计算变换矩阵并进行拼接 ================</span>    start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    img1<span class="token punctuation">,</span> img2<span class="token punctuation">,</span> img3<span class="token punctuation">,</span> dst<span class="token punctuation">,</span> M <span class="token operator">=</span> get_good_match<span class="token punctuation">(</span>src_img<span class="token punctuation">,</span> warp_img<span class="token punctuation">,</span> kp1<span class="token punctuation">,</span> kp2<span class="token punctuation">,</span> matches<span class="token punctuation">)</span>    end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'去除误匹配点、计算变换矩阵并进行拼接的时间：'</span><span class="token punctuation">,</span> end <span class="token operator">-</span> start<span class="token punctuation">)</span>    <span class="token comment"># ================ 图像融合 ================</span>    start <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    res <span class="token operator">=</span> blend_image<span class="token punctuation">(</span>img1<span class="token punctuation">,</span> img2<span class="token punctuation">)</span>    end <span class="token operator">=</span> time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'图像融合时间：'</span><span class="token punctuation">,</span> end <span class="token operator">-</span> start<span class="token punctuation">)</span>    <span class="token comment"># ================ 打印最后的结果 ================</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"变换矩阵"</span><span class="token punctuation">,</span> M<span class="token punctuation">)</span>    cv<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"splicing"</span><span class="token punctuation">,</span> dst<span class="token punctuation">)</span>    cv<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"sift_match"</span><span class="token punctuation">,</span> img3<span class="token punctuation">)</span>    cv<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">"blend_result"</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> cv<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">27</span><span class="token punctuation">:</span>            <span class="token keyword">break</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    path1 <span class="token operator">=</span> <span class="token string">"./images/testD_2.jpg"</span>    path2 <span class="token operator">=</span> <span class="token string">"./images/testX_1.jpg"</span>    main_process<span class="token punctuation">(</span>path1<span class="token punctuation">,</span> path2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 三维视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 多线程编程（二）：pthread的基本使用</title>
      <link href="2021/12/05/cpp-notes-4/"/>
      <url>2021/12/05/cpp-notes-4/</url>
      
        <content type="html"><![CDATA[<h1 id="C-多线程编程（二）：pthread的基本使用"><a href="#C-多线程编程（二）：pthread的基本使用" class="headerlink" title="C++ 多线程编程（二）：pthread的基本使用"></a>C++ 多线程编程（二）：pthread的基本使用</h1><p>在C++开发中，原生的线程库主要有两个，一个是C++11提供的&lt;thread&gt;(std::thread类)，另一个是Linux下的&lt;pthread.h&gt;(p_thread类)，本文主要介绍pthread的基本使用方式，线程基础知识和std::thread的使用在<a href="https://immortalqx.github.io/2021/12/04/cpp-notes-3/">上一篇博客</a>中已经有过介绍。</p><h2 id="pthread简介"><a href="#pthread简介" class="headerlink" title="pthread简介"></a>pthread简介</h2><p>pthread中的p是POSIX的缩写，而POSIX是Portable Operating System Interface的缩写，是IEEE为要在各种UNIX操作系统上运行软件，而定义API的一系列互相关联的标准的总称。（Windows环境下无pthread，Linux GCC4.6以下编译需加-pthread编译选项）</p><p><strong>与std::thread对比：</strong></p><p>std::thread是C++11中的新特性，将多线程程序的编写提升到了语言层面，使得编写的多线程程序的可移植性大大提高。</p><p>对二者特性对比，用一句话简单概括就是：<strong>std::thread更加简便易用，而pthread功能更加强大。</strong></p><h2 id="线程的创建和管理"><a href="#线程的创建和管理" class="headerlink" title="线程的创建和管理"></a>线程的创建和管理</h2><p>每个线程都有一个在进程中唯一的线程标识符，用一个数据类型 pthread_t 表示，该数据类型在 Linux 中就是一个无符号长整型数据。</p><h3 id="创建新的线程"><a href="#创建新的线程" class="headerlink" title="创建新的线程"></a>创建新的线程</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_create</span> <span class="token punctuation">(</span><span class="token class-name">pthread_t</span> <span class="token operator">*</span>thread<span class="token punctuation">,</span><span class="token class-name">pthread_attr_t</span> <span class="token operator">*</span>attr<span class="token punctuation">,</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>start_routine<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>若创建成功，返回0；若出错，则返回错误编号。</p><ul><li>thread 是线程标识符，但这个参数不是由用户指定的，而是由 pthread_create 函数在创建时将新的线程的标识符放到这个变量中。</li><li>attr 指定线程的属性，可以用 NULL 表示默认属性。</li><li>start_routine 指定线程开始运行的函数。</li><li>arg 是 start_routine 所需要的参数，是一个无类型指针。</li></ul><p>默认地，线程在被创建时要被赋予一定的属性，这个属性存放在数据类型 pthread_attr_t 中，它包含了线程的调度策略，堆栈的相关信息，join or detach 的状态等。</p><p>pthread_attr_init 和 pthread_attr_destroy 函数分别用来创建和销毁 pthread_attr_t，具体函数声明可参考man帮助。</p><h3 id="结束线程"><a href="#结束线程" class="headerlink" title="结束线程"></a>结束线程</h3><p>当发生以下情形之一时，线程就会结束：</p><ul><li>线程运行的函数return了，也就是线程的任务已经完成；</li><li>线程调用了 pthread_exit 函数；</li><li>其他线程调用 pthread_cancel 结束这个线程；</li><li>进程调用 exec() 或 exit()，结束了；</li><li>main() 函数先结束了，而且 main() 自己没有调用 pthread_exit 来等所有线程完成任务。</li></ul><p>当然，一个线程结束，并不意味着它的所有信息都已经消失，后面会看到僵尸线程的问题。</p><p>下面介绍这两个函数。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">pthread_exit</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>retval<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>retval 是由用户指定的参数， pthread_exit 完成之后可以通过这个参数获得线程的退出状态。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_cancel</span> <span class="token punctuation">(</span><span class="token class-name">pthread_t</span> thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一个线程可以通过调用 pthread_cancel 函数来请求取消同一进程中的线程，这个线程由thread 参数指定。</p><p>如果操作成功则返回0，失败则返回对应的错误编号。</p><h3 id="一个简单的多线程实现"><a href="#一个简单的多线程实现" class="headerlink" title="一个简单的多线程实现"></a>一个简单的多线程实现</h3><p>这里是一个非常简单的基于pthread的多线程实现：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NUM_THREADS</span>    <span class="token expression"><span class="token number">5</span></span></span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">PrintHello</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>threadid<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">long</span> tid<span class="token punctuation">;</span>    tid <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> threadid<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World! It's me, thread #%ld!\n"</span><span class="token punctuation">,</span> tid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">pthread_t</span> threads<span class="token punctuation">[</span>NUM_THREADS<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> rc<span class="token punctuation">;</span>    <span class="token keyword">long</span> t<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> t <span class="token operator">&lt;</span> NUM_THREADS<span class="token punctuation">;</span> t<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"In main: creating thread %ld\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>        rc <span class="token operator">=</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>threads<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> PrintHello<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rc<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ERROR; return code from pthread_create() is %d\n"</span><span class="token punctuation">,</span> rc<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/* Last thing that main() should do */</span>    <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以在终端通过下面的命令编译执行：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">gcc <span class="token parameter variable">-Wall</span> hello.c <span class="token parameter variable">-lpthread</span> <span class="token parameter variable">-o</span> hello./hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>输出的结果为：</p><pre class="line-numbers language-none"><code class="language-none">In main: creating thread 0In main: creating thread 1Hello World! It's me, thread #0!In main: creating thread 2Hello World! It's me, thread #1!In main: creating thread 3Hello World! It's me, thread #2!In main: creating thread 4Hello World! It's me, thread #3!Hello World! It's me, thread #4!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意输出的顺序可能不同， 要特别注意的是， main() 显示地调用了 pthread_exit() 来等待其他线程的结束。（如果不使用这个函数的话，可能main()函数结束了也有线程没有执行完毕！）</p><h3 id="给线程传入初始化参数"><a href="#给线程传入初始化参数" class="headerlink" title="给线程传入初始化参数"></a>给线程传入初始化参数</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NUM_THREADS</span>    <span class="token expression"><span class="token number">8</span></span></span><span class="token keyword">char</span> <span class="token operator">*</span>messages<span class="token punctuation">[</span>NUM_THREADS<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">thread_data</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> thread_id<span class="token punctuation">;</span>    <span class="token keyword">int</span> sum<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>message<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">thread_data</span> thread_data_array<span class="token punctuation">[</span>NUM_THREADS<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">PrintHello</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>threadarg<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> taskid<span class="token punctuation">,</span> sum<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>hello_msg<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">thread_data</span> <span class="token operator">*</span>my_data<span class="token punctuation">;</span>    <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    my_data <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">thread_data</span> <span class="token operator">*</span><span class="token punctuation">)</span> threadarg<span class="token punctuation">;</span>    taskid <span class="token operator">=</span> my_data<span class="token operator">-&gt;</span>thread_id<span class="token punctuation">;</span>    sum <span class="token operator">=</span> my_data<span class="token operator">-&gt;</span>sum<span class="token punctuation">;</span>    hello_msg <span class="token operator">=</span> my_data<span class="token operator">-&gt;</span>message<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Thread %d: %s  Sum=%d\n"</span><span class="token punctuation">,</span> taskid<span class="token punctuation">,</span> hello_msg<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">pthread_t</span> threads<span class="token punctuation">[</span>NUM_THREADS<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>taskids<span class="token punctuation">[</span>NUM_THREADS<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> rc<span class="token punctuation">,</span> t<span class="token punctuation">,</span> sum<span class="token punctuation">;</span>    sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    messages<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"English: Hello World!"</span><span class="token punctuation">;</span>    messages<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"French: Bonjour, le monde!"</span><span class="token punctuation">;</span>    messages<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Spanish: Hola al mundo"</span><span class="token punctuation">;</span>    messages<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Klingon: Nuq neH!"</span><span class="token punctuation">;</span>    messages<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"German: Guten Tag, Welt!"</span><span class="token punctuation">;</span>    messages<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Russian: Zdravstvytye, mir!"</span><span class="token punctuation">;</span>    messages<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Japan: Sekai e konnichiwa!"</span><span class="token punctuation">;</span>    messages<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Latin: Orbis, te saluto!"</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> t <span class="token operator">&lt;</span> NUM_THREADS<span class="token punctuation">;</span> t<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        sum <span class="token operator">=</span> sum <span class="token operator">+</span> t<span class="token punctuation">;</span>        thread_data_array<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">.</span>thread_id <span class="token operator">=</span> t<span class="token punctuation">;</span>        thread_data_array<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">.</span>sum <span class="token operator">=</span> sum<span class="token punctuation">;</span>        thread_data_array<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">.</span>message <span class="token operator">=</span> messages<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Creating thread %d\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>        rc <span class="token operator">=</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>threads<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> PrintHello<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>                <span class="token operator">&amp;</span>thread_data_array<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rc<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ERROR; return code from pthread_create() is %d\n"</span><span class="token punctuation">,</span> rc<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-none"><code class="language-none">Creating thread 0Creating thread 1Creating thread 2Creating thread 3Creating thread 4Creating thread 5Creating thread 6Creating thread 7Thread 4: German: Guten Tag, Welt!  Sum=10Thread 5: Russian: Zdravstvytye, mir!  Sum=15Thread 7: Latin: Orbis, te saluto!  Sum=28Thread 2: Spanish: Hola al mundo  Sum=3Thread 6: Japan: Sekai e konnichiwa!  Sum=21Thread 3: Klingon: Nuq neH!  Sum=6Thread 0: English: Hello World!  Sum=0Thread 1: French: Bonjour, le monde!  Sum=1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="对线程的阻塞（Joining-and-Detaching-Threads）"><a href="#对线程的阻塞（Joining-and-Detaching-Threads）" class="headerlink" title="对线程的阻塞（Joining and Detaching Threads）"></a>对线程的阻塞（Joining and Detaching Threads）</h3><p>阻塞是线程之间同步的一种方法。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_join</span><span class="token punctuation">(</span><span class="token class-name">pthread_t</span> threadid<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>value_ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>pthread_join 函数会让调用它的线程等待 threadid 线程运行结束之后再运行。</p><p>value_ptr 存放了其他线程的返回值。</p><p>一个可以被join的线程，仅仅可以被别的一个线程 join，如果同时有多个线程尝试 join 同一个线程时，最终结果是未知的。另外，线程不能 join 自己。</p><p>上面提到过，创建一个线程时，要赋予它一定的属性，这其中就包括joinable or detachable 的属性，只有被声明成joinable的线程，可以被其他线程join。</p><p>POSIX标准的最终版本指出线程应该被设置成joinable的。显式地设置一个线程为joinable，需要以下四个步骤：</p><ul><li>Declare a pthread attribute variable of the pthread_attr_t data type</li><li>Initialize the attribute variable with pthread_attr_init()</li><li>Set the attribute detached status with pthread_attr_setdetachstate()</li><li>When done, free library resources used by the attribute with pthread_attr_destroy()</li></ul><p>值得注意的的是：僵尸线程 ( “zombie” thread )是一种已经退出了的 joinable 的线程，但是等待其他线程调用 pthread_join 来 join 它，以收集它的退出信息(exit status)。如果没有其他线程调用 pthread_join 来 join 它的话，它占用的一些系统资源不会被释放，比如堆栈。如果main()函数需要长时间运行，并且创建大量 joinable 的线程，就有可能出现堆栈不足的 error 。</p><p>对于那些不需要 join 的线程，最好利用 pthread_detach，这样它运行结束后，资源就会及时得到释放。注意一个线程被使用 pthread_detach 之后，它就不能再被改成 joinable 的了。</p><p>总而言之，创建的每一个线程都应该使用 pthread_join 或者 pthread_detach 其中一个，以防止僵尸线程的出现。</p><p>相关函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">pthread_detach</span> <span class="token punctuation">(</span>threadid<span class="token punctuation">)</span><span class="token function">pthread_attr_setdetachstate</span> <span class="token punctuation">(</span>attr<span class="token punctuation">,</span>detachstate<span class="token punctuation">)</span><span class="token function">pthread_attr_getdetachstate</span> <span class="token punctuation">(</span>attr<span class="token punctuation">,</span>detachstate<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="显式地设置一个线程为-joinable"><a href="#显式地设置一个线程为-joinable" class="headerlink" title="显式地设置一个线程为 joinable"></a>显式地设置一个线程为 joinable</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;math.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NUM_THREADS</span> <span class="token expression"><span class="token number">4</span></span></span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">BusyWork</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">long</span> tid<span class="token punctuation">;</span>    <span class="token keyword">double</span> result <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>    tid <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> t<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Thread %ld starting...\n"</span><span class="token punctuation">,</span> tid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        result <span class="token operator">=</span> result <span class="token operator">+</span> <span class="token function">sin</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">tan</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Thread %ld done. Result = %e\n"</span><span class="token punctuation">,</span> tid<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">pthread_t</span> thread<span class="token punctuation">[</span>NUM_THREADS<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">pthread_attr_t</span> attr<span class="token punctuation">;</span>    <span class="token keyword">int</span> rc<span class="token punctuation">;</span>    <span class="token keyword">long</span> t<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>status<span class="token punctuation">;</span><span class="token comment">/* Initialize and set thread detached attribute */</span>    <span class="token function">pthread_attr_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_attr_setdetachstate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>attr<span class="token punctuation">,</span> PTHREAD_CREATE_JOINABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> t <span class="token operator">&lt;</span> NUM_THREADS<span class="token punctuation">;</span> t<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Main: creating thread %ld\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>        rc <span class="token operator">=</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>attr<span class="token punctuation">,</span> BusyWork<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rc<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ERROR; return code from pthread_create() is %d\n"</span><span class="token punctuation">,</span> rc<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment">/* Free attribute and wait for the other threads */</span>    <span class="token function">pthread_attr_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> t <span class="token operator">&lt;</span> NUM_THREADS<span class="token punctuation">;</span> t<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        rc <span class="token operator">=</span> <span class="token function">pthread_join</span><span class="token punctuation">(</span>thread<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rc<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ERROR; return code from pthread_join() is %d\n"</span><span class="token punctuation">,</span> rc<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Main: completed join with thread %ld having a status of %ld\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Main: program completed. Exiting.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-none"><code class="language-none">Main: creating thread 0Main: creating thread 1Thread 0 starting...Thread 1 starting...Thread 0 done. Result = 3.135632e+06Main: completed join with thread 0 having a status of 0Thread 1 done. Result = 3.135632e+06Main: completed join with thread 1 having a status of 1Main: program completed. Exiting.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="堆栈管理-（Stack-Management）"><a href="#堆栈管理-（Stack-Management）" class="headerlink" title="堆栈管理 （Stack Management）"></a>堆栈管理 （Stack Management）</h3><p>相关函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">pthread_attr_getstacksize</span> <span class="token punctuation">(</span>attr<span class="token punctuation">,</span> stacksize<span class="token punctuation">)</span><span class="token function">pthread_attr_setstacksize</span> <span class="token punctuation">(</span>attr<span class="token punctuation">,</span> stacksize<span class="token punctuation">)</span><span class="token function">pthread_attr_getstackaddr</span> <span class="token punctuation">(</span>attr<span class="token punctuation">,</span> stackaddr<span class="token punctuation">)</span><span class="token function">pthread_attr_setstackaddr</span> <span class="token punctuation">(</span>attr<span class="token punctuation">,</span> stackaddr<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>POSIX标准没有规定一个线程的堆栈大小。安全可移植的程序不会依赖于具体实现默认的堆栈限制，而是显式地调用 pthread_attr_setstacksize 来分配足够的堆栈空间。</p><h4 id="关于堆栈大小的一个例子"><a href="#关于堆栈大小的一个例子" class="headerlink" title="关于堆栈大小的一个例子"></a>关于堆栈大小的一个例子</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NTHREADS</span> <span class="token expression"><span class="token number">4</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">1000</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MEGEXTRA</span> <span class="token expression"><span class="token number">1000000</span></span></span><span class="token class-name">pthread_attr_t</span> attr<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">dowork</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>threadid<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">double</span> A<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>    <span class="token keyword">long</span> tid<span class="token punctuation">;</span>    <span class="token class-name">size_t</span> mystacksize<span class="token punctuation">;</span>    tid <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> threadid<span class="token punctuation">;</span>    <span class="token function">pthread_attr_getstacksize</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>attr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mystacksize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Thread %ld: stack size = %li bytes \n"</span><span class="token punctuation">,</span> tid<span class="token punctuation">,</span> mystacksize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">*</span> j<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">3.452</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>N <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">pthread_t</span> threads<span class="token punctuation">[</span>NTHREADS<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">size_t</span> stacksize<span class="token punctuation">;</span>    <span class="token keyword">int</span> rc<span class="token punctuation">;</span>    <span class="token keyword">long</span> t<span class="token punctuation">;</span>    <span class="token function">pthread_attr_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_attr_getstacksize</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>attr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>stacksize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Default stack size = %li\n"</span><span class="token punctuation">,</span> stacksize<span class="token punctuation">)</span><span class="token punctuation">;</span>    stacksize <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token operator">*</span> N <span class="token operator">*</span> N <span class="token operator">+</span> MEGEXTRA<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Amount of stack needed per thread = %li\n"</span><span class="token punctuation">,</span> stacksize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_attr_setstacksize</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>attr<span class="token punctuation">,</span> stacksize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Creating threads with stack size = %li bytes\n"</span><span class="token punctuation">,</span> stacksize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> t <span class="token operator">&lt;</span> NTHREADS<span class="token punctuation">;</span> t<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        rc <span class="token operator">=</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>threads<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>attr<span class="token punctuation">,</span> dowork<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rc<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ERROR; return code from pthread_create() is %d\n"</span><span class="token punctuation">,</span> rc<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Created %ld threads.\n"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-none"><code class="language-none">Default stack size = 8388608Amount of stack needed per thread = 9000000Creating threads with stack size = 9000000 bytesThread 2: stack size = 9000000 bytes Created 4 threads.Thread 1: stack size = 9000000 bytes Thread 0: stack size = 9000000 bytes Thread 3: stack size = 9000000 bytes <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="其他重要函数"><a href="#其他重要函数" class="headerlink" title="其他重要函数"></a>其他重要函数</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">pthread_self</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pthread_equal</span> <span class="token punctuation">(</span>thread1<span class="token punctuation">,</span>thread2<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>调用pthread_self 可以返回它的 thread ID。</p><p>pthread_equal 比较两个线程的 ID，如果不同则返回0，否则返回一个非零值。</p><h2 id="互斥锁-Mutex"><a href="#互斥锁-Mutex" class="headerlink" title="互斥锁 Mutex"></a>互斥锁 Mutex</h2><p>Mutex 常常被用来保护那些可以被多个线程访问的共享资源，比如可以防止多个线程同时更新同一个数据时出现混乱。</p><p>使用互斥锁的一般步骤是：</p><ul><li>创建一个互斥锁，即声明一个pthread_mutex_t类型的数据，然后初始化，只有初始化之后才能使用；</li><li>多个线程尝试锁定这个互斥锁；</li><li>只有一个成功锁定互斥锁，成为互斥锁的拥有者，然后进行一些指令；</li><li>拥有者解锁互斥锁；</li><li>其他线程尝试锁定这个互斥锁，重复上面的过程；</li><li>最后互斥锁被显式地调用 pthread_mutex_destroy 来进行销毁。</li></ul><p>有两种方式初始化一个互斥锁：</p><p>第一种，利用已经定义的常量初始化，例如</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">pthread_mutex_t</span> mymutex <span class="token operator">=</span> PTHREAD_MUTEX_INITIALIZER<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第二种方式是调用 pthread_mutex_init (mutex,attr) 进行初始化。</p><p>当多个线程同时去锁定同一个互斥锁时，失败的那些线程，如果是用 pthread_mutex_lock 函数，那么会被阻塞，直到这个互斥锁被解锁，它们再继续竞争；如果是用 pthread_mutex_trylock 函数，那么失败者只会返回一个错误。</p><p>最后需要指出的是，保护共享数据是程序员的责任。程序员要负责所有可以访问该数据的线程都使用mutex这种机制，否则，不使用 mutex 的线程还是有可能对数据造成破坏。</p><p>相关函数 (具体声明可以用 man 查看 )</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">pthread_mutex_init</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">,</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pthread_mutex_destroy</span> <span class="token punctuation">(</span><span class="token class-name">pthread_mutex_t</span> <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pthread_mutexattr_init</span> <span class="token punctuation">(</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pthread_mutexattr_destroy</span> <span class="token punctuation">(</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">phtread_mutex_lock</span><span class="token punctuation">(</span><span class="token class-name">pthread_mutex_t</span> <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">phtread_mutex_trylock</span><span class="token punctuation">(</span><span class="token class-name">pthread_mutex_t</span> <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">phtread_mutex_unlock</span><span class="token punctuation">(</span><span class="token class-name">pthread_mutex_t</span> <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下面是一个利用多线程进行向量点乘的程序，其中需要对 dotstr.sum 这个共同读写的数据进行保护。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span><span class="token comment">/*   The following structure contains the necessary information  to allow the function "dotprod" to access its input data and place its output into the structure.  This structure is unchanged from the sequential version.*/</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    <span class="token keyword">double</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>    <span class="token keyword">double</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>    <span class="token keyword">double</span> sum<span class="token punctuation">;</span>    <span class="token keyword">int</span> veclen<span class="token punctuation">;</span><span class="token punctuation">}</span> DOTDATA<span class="token punctuation">;</span><span class="token comment">/* Define globally accessible variables and a mutex */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NUMTHRDS</span> <span class="token expression"><span class="token number">4</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">VECLEN</span> <span class="token expression"><span class="token number">100000</span></span></span>DOTDATA dotstr<span class="token punctuation">;</span><span class="token class-name">pthread_t</span> callThd<span class="token punctuation">[</span>NUMTHRDS<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token class-name">pthread_mutex_t</span> mutexsum<span class="token punctuation">;</span><span class="token comment">/*The function dotprod is activated when the thread is created.As before, all input to this routine is obtained from a structure of type DOTDATA and all output from this function is written intothis structure. The benefit of this approach is apparent for the multi-threaded program: when a thread is created we pass a singleargument to the activated function - typically this argumentis a thread number. All  the other information required by the function is accessed from the globally accessible structure. */</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">dotprod</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">/* Define and use local variables for convenience */</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">,</span> len<span class="token punctuation">;</span>    <span class="token keyword">long</span> offset<span class="token punctuation">;</span>    <span class="token keyword">double</span> mysum<span class="token punctuation">,</span> <span class="token operator">*</span>x<span class="token punctuation">,</span> <span class="token operator">*</span>y<span class="token punctuation">;</span>    offset <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> arg<span class="token punctuation">;</span>    len <span class="token operator">=</span> dotstr<span class="token punctuation">.</span>veclen<span class="token punctuation">;</span>    start <span class="token operator">=</span> offset <span class="token operator">*</span> len<span class="token punctuation">;</span>    end <span class="token operator">=</span> start <span class="token operator">+</span> len<span class="token punctuation">;</span>    x <span class="token operator">=</span> dotstr<span class="token punctuation">.</span>a<span class="token punctuation">;</span>    y <span class="token operator">=</span> dotstr<span class="token punctuation">.</span>b<span class="token punctuation">;</span><span class="token comment">/*Perform the dot product and assign resultto the appropriate variable in the structure. */</span>    mysum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        mysum <span class="token operator">+=</span> <span class="token punctuation">(</span>x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> y<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment">/*Lock a mutex prior to updating the value in the sharedstructure, and unlock it upon updating.*/</span>    <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutexsum<span class="token punctuation">)</span><span class="token punctuation">;</span>    dotstr<span class="token punctuation">.</span>sum <span class="token operator">+=</span> mysum<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Thread %ld did %d to %d: mysum=%f global sum=%f\n"</span><span class="token punctuation">,</span> offset<span class="token punctuation">,</span> start<span class="token punctuation">,</span>           end<span class="token punctuation">,</span> mysum<span class="token punctuation">,</span> dotstr<span class="token punctuation">.</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutexsum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* The main program creates threads which do all the work and then print out result upon completion. Before creating the threads, The input data is created. Since all threads update a shared structure, we need a mutex for mutual exclusion. The main thread needs to wait for all threads to complete, it waits for each one of the threads. We specify a thread attribute value that allow the main thread tojoin with the threads it creates. Note also that we free up handles  when theyare no longer needed.*/</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">long</span> i<span class="token punctuation">;</span>    <span class="token keyword">double</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>status<span class="token punctuation">;</span>    <span class="token class-name">pthread_attr_t</span> attr<span class="token punctuation">;</span><span class="token comment">/* Assign storage and initialize values */</span>    a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span>NUMTHRDS <span class="token operator">*</span> VECLEN <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span>NUMTHRDS <span class="token operator">*</span> VECLEN <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> VECLEN <span class="token operator">*</span> NUMTHRDS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        b<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    dotstr<span class="token punctuation">.</span>veclen <span class="token operator">=</span> VECLEN<span class="token punctuation">;</span>    dotstr<span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>    dotstr<span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>    dotstr<span class="token punctuation">.</span>sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutexsum<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* Create threads to perform the dotproduct  */</span>    <span class="token function">pthread_attr_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_attr_setdetachstate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>attr<span class="token punctuation">,</span> PTHREAD_CREATE_JOINABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NUMTHRDS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment">/* Each thread works on a different set of data.         * The offset is specified by 'i'. The size of         * the data for each thread is indicated by VECLEN.         */</span>        <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>callThd<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>attr<span class="token punctuation">,</span> dotprod<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">pthread_attr_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* Wait on the other threads */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NUMTHRDS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">pthread_join</span><span class="token punctuation">(</span>callThd<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment">/* After joining, print out the results and cleanup */</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Sum =  %f \n"</span><span class="token punctuation">,</span> dotstr<span class="token punctuation">.</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_mutex_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutexsum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Thread <span class="token number">0</span> did <span class="token number">0</span> to <span class="token number">100000</span><span class="token operator">:</span>  mysum<span class="token operator">=</span><span class="token number">100000.000000</span> global sum<span class="token operator">=</span><span class="token number">100000.000000</span>Thread <span class="token number">1</span> did <span class="token number">100000</span> to <span class="token number">200000</span><span class="token operator">:</span>  mysum<span class="token operator">=</span><span class="token number">100000.000000</span> global sum<span class="token operator">=</span><span class="token number">200000.000000</span>Thread <span class="token number">2</span> did <span class="token number">200000</span> to <span class="token number">300000</span><span class="token operator">:</span>  mysum<span class="token operator">=</span><span class="token number">100000.000000</span> global sum<span class="token operator">=</span><span class="token number">300000.000000</span>Thread <span class="token number">3</span> did <span class="token number">300000</span> to <span class="token number">400000</span><span class="token operator">:</span>  mysum<span class="token operator">=</span><span class="token number">100000.000000</span> global sum<span class="token operator">=</span><span class="token number">400000.000000</span>Sum <span class="token operator">=</span>  <span class="token number">400000.000000</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="条件变量-Condition-Variable"><a href="#条件变量-Condition-Variable" class="headerlink" title="条件变量 Condition Variable"></a>条件变量 Condition Variable</h2><p>互斥锁只有两种状态，这限制了它的用途. 条件变量允许线程在阻塞的时候等待另一个线程发送的信号，当收到信号后，阻塞的线程就被唤醒并试图锁定与之相关的互斥锁. 条件变量要和互斥锁结合使用。</p><h3 id="条件变量的声明和初始化"><a href="#条件变量的声明和初始化" class="headerlink" title="条件变量的声明和初始化"></a>条件变量的声明和初始化</h3><p>通过声明 pthread_cond_t 类型的数据,并且必须先初始化才能使用。</p><p>初始化的方法也有两种：</p><p>第一种，利用内部定义的常量，例如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">pthread_cond_t</span> myconvar <span class="token operator">=</span> PTHREAD_COND_INITIALIZER<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第二种，利用函数 pthread_cond_init(cond,attr)，其中 attr 由 pthread_condattr_init() 和 pthread_condattr_destroy() 创建和销毁。</p><p>可以用 pthread_cond_destroy() 销毁一个条件变量。</p><p>相关函数：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">pthread_cond_wait</span> <span class="token punctuation">(</span>condition<span class="token punctuation">,</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pthread_cond_signal</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pthread_cond_broadcast</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>pthread_cond_wait() 会阻塞调用它的线程，直到收到某一信号。这个函数需要在 mutex 已经被锁之后进行调用，并且当线程被阻塞时，会自动解锁 mutex。信号收到后，线程被唤醒，这时 mutex 又会被这个线程锁定。</p><p>pthread_cond_signal() 函数结束时，必须解锁 mutex，以供 pthread_cond_wait() 锁定mutex。</p><p>当不止一个线程在等待信号时，要用 pthread_cond_broadcast() 代替 pthread_cond_signal() 来告诉所有被该条件变量阻塞的线程结束阻塞状态。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>下面是一个例子，三个线程共同访问 count 变量，thread 2 和 thread 3 竞争地对其进行加 1 的操作，thread 1 等 count 达到 12 的时候，一次性加 125 。 然后 thread 2 和 thread 3 再去竞争 count 的控制权，直到完成自己的对 count 加 10 次的任务。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NUM_THREADS</span>  <span class="token expression"><span class="token number">3</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">TCOUNT</span> <span class="token expression"><span class="token number">10</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">COUNT_LIMIT</span> <span class="token expression"><span class="token number">12</span></span></span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token class-name">pthread_mutex_t</span> count_mutex<span class="token punctuation">;</span><span class="token class-name">pthread_cond_t</span> count_threshold_cv<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">inc_count</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">long</span> my_id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> t<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> TCOUNT<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment">/*         Check the value of count and signal waiting thread when condition is        reached.  Note that this occurs while mutex is locked.         */</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> COUNT_LIMIT<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"inc_count(): thread %ld, count = %d  Threshold reached. "</span><span class="token punctuation">,</span>                   my_id<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count_threshold_cv<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Just sent signal.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"inc_count(): thread %ld, count = %d, unlocking mutex\n"</span><span class="token punctuation">,</span>               my_id<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/* Do some work so threads can alternate on mutex lock */</span>        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">watch_count</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>t<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">long</span> my_id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> t<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Starting watch_count(): thread %ld\n"</span><span class="token punctuation">,</span> my_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/*    Lock mutex and wait for signal.  Note that the pthread_cond_wait routine    will automatically and atomically unlock mutex while it waits.     Also, note that if COUNT_LIMIT is reached before this routine is run by    the waiting thread, the loop will be skipped to prevent pthread_cond_wait    from never returning.    */</span>    <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> COUNT_LIMIT<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"watch_count(): thread %ld Count= %d. Going into wait...\n"</span><span class="token punctuation">,</span> my_id<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count_threshold_cv<span class="token punctuation">,</span> <span class="token operator">&amp;</span>count_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"watch_count(): thread %ld Condition signal received. Count= %d\n"</span><span class="token punctuation">,</span> my_id<span class="token punctuation">,</span>               count<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"watch_count(): thread %ld Updating the value of count...\n"</span><span class="token punctuation">,</span> my_id<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>        count <span class="token operator">+=</span> <span class="token number">125</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"watch_count(): thread %ld count now = %d.\n"</span><span class="token punctuation">,</span> my_id<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"watch_count(): thread %ld Unlocking mutex.\n"</span><span class="token punctuation">,</span> my_id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span> rc<span class="token punctuation">;</span>    <span class="token keyword">long</span> t1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> t2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> t3 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token class-name">pthread_t</span> threads<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token class-name">pthread_attr_t</span> attr<span class="token punctuation">;</span>    <span class="token comment">/* Initialize mutex and condition variable objects */</span>    <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count_mutex<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_cond_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count_threshold_cv<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* For portability, explicitly create threads in a joinable state */</span>    <span class="token function">pthread_attr_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_attr_setdetachstate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>attr<span class="token punctuation">,</span> PTHREAD_CREATE_JOINABLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>threads<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>attr<span class="token punctuation">,</span> watch_count<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> t1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>threads<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>attr<span class="token punctuation">,</span> inc_count<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> t2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>threads<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>attr<span class="token punctuation">,</span> inc_count<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span> t3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Wait for all threads to complete */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NUM_THREADS<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">pthread_join</span><span class="token punctuation">(</span>threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Main(): Waited and joined with %d threads. Final value of count = %d. Done.\n"</span><span class="token punctuation">,</span>           NUM_THREADS<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Clean up and exit */</span>    <span class="token function">pthread_attr_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_mutex_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_cond_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count_threshold_cv<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-none"><code class="language-none">inc_count(): thread 3, count = 1, unlocking mutexinc_count(): thread 2, count = 2, unlocking mutexStarting watch_count(): thread 1watch_count(): thread 1 Count= 2. Going into wait...inc_count(): thread 3, count = 3, unlocking mutexinc_count(): thread 2, count = 4, unlocking mutexinc_count(): thread 3, count = 5, unlocking mutexinc_count(): thread 2, count = 6, unlocking mutexinc_count(): thread 3, count = 7, unlocking mutexinc_count(): thread 2, count = 8, unlocking mutexinc_count(): thread 3, count = 9, unlocking mutexinc_count(): thread 2, count = 10, unlocking mutexinc_count(): thread 3, count = 11, unlocking mutexinc_count(): thread 2, count = 12  Threshold reached. Just sent signal.inc_count(): thread 2, count = 12, unlocking mutexwatch_count(): thread 1 Condition signal received. Count= 12watch_count(): thread 1 Updating the value of count...watch_count(): thread 1 count now = 137.watch_count(): thread 1 Unlocking mutex.inc_count(): thread 3, count = 138, unlocking mutexinc_count(): thread 2, count = 139, unlocking mutexinc_count(): thread 3, count = 140, unlocking mutexinc_count(): thread 2, count = 141, unlocking mutexinc_count(): thread 3, count = 142, unlocking mutexinc_count(): thread 2, count = 143, unlocking mutexinc_count(): thread 3, count = 144, unlocking mutexinc_count(): thread 2, count = 145, unlocking mutexMain(): Waited and joined with 3 threads. Final value of count = 145. Done.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 多线程编程（一）：std::thread的使用</title>
      <link href="2021/12/04/cpp-notes-3/"/>
      <url>2021/12/04/cpp-notes-3/</url>
      
        <content type="html"><![CDATA[<h1 id="C-多线程编程（一）：std-thread的使用"><a href="#C-多线程编程（一）：std-thread的使用" class="headerlink" title="C++ 多线程编程（一）：std::thread的使用"></a>C++ 多线程编程（一）：std::thread的使用</h1><h2 id="多线程编程简介"><a href="#多线程编程简介" class="headerlink" title="多线程编程简介"></a>多线程编程简介</h2><p>说到多线程编程，就不得不提<strong>并行</strong>和<strong>并发</strong>，多线程是实现并发和并行的一种手段。</p><ul><li><p><strong>并行</strong>是指两个或多个独立的操作<strong>同时进行</strong>。</p></li><li><p><strong>并发</strong>是指<strong>一个时间段内</strong>执行多个操作。</p></li></ul><p>在单核时代，多个线程是<strong>并发</strong>的，在一个时间段内轮流执行；在多核时代，多个线程可以实现真正的<strong>并行</strong>，在多核上真正独立的并行执行。例如现在常见的<strong>4核4线程</strong>可以并行4个线程；<strong>4核8线程</strong>则使用了超线程技术，把一个物理核模拟为2个逻辑核心，可以并行8个线程。</p><h3 id="并发编程的方法"><a href="#并发编程的方法" class="headerlink" title="并发编程的方法"></a>并发编程的方法</h3><p>通常，要实现并发有两种方法：多进程并发和多线程并发。</p><h4 id="多进程并发"><a href="#多进程并发" class="headerlink" title="多进程并发"></a>多进程并发</h4><p>使用多进程并发是将一个应用程序划分为多个独立的进程（每个进程只有一个线程），这些独立的进程间可以互相通信，共同完成任务。</p><p>由于操作系统对进程提供了大量的保护机制，以避免一个进程修改了另一个进程的数据，使用多进程比多线程更容易写出<strong>安全</strong>的代码。但这也造就了多进程并发的两个缺点：</p><ul><li>在进程件的通信，无论是使用信号、套接字，还是文件、管道等方式，其使用要么比较复杂，要么就是速度较慢或者两者兼而有之。</li><li>运行多个线程的开销很大，操作系统要分配很多的资源来对这些进程进行管理。</li></ul><p>由于多个进程并发完成同一个任务时，不可避免的是：操作同一个数据和进程间的相互通信，上述的两个缺点也就决定了多进程的并发不是一个好的选择。</p><h4 id="多线程并发"><a href="#多线程并发" class="headerlink" title="多线程并发"></a>多线程并发</h4><p>多线程并发指的是在同一个进程中执行多个线程。</p><p>有操作系统相关知识的应该知道，线程是轻量级的进程，每个线程可以独立的运行不同的指令序列，但是线程不独立的拥有资源，依赖于创建它的进程而存在。也就是说，<strong>同一进程中的多个线程共享相同的地址空间，可以访问进程中的大部分数据，指针和引用可以在线程间进行传递</strong>。这样，同一进程内的多个线程能够很方便的进行数据共享以及通信，也就比进程更适用于并发操作。</p><p>由于缺少操作系统提供的保护机制，在多线程共享数据及通信时，就需要程序员做更多的工作以保证对共享数据段的操作是以预想的操作顺序进行的，并且要极力的避免**死锁(deadlock)**。</p><h2 id="std-thread简介"><a href="#std-thread简介" class="headerlink" title="std::thread简介"></a><code>std::thread</code>简介</h2><p>C++11之前，window和linux平台分别有各自的多线程标准，使用C++编写的多线程往往是依赖于特定平台的。</p><ul><li>Window平台提供用于多线程创建和管理的win32 api；</li><li>Linux下则有POSIX多线程标准，Threads或Pthreads库提供的API可以在类Unix上运行；</li></ul><p>在C++11新标准中，可以简单通过使用thread库，来管理多线程。thread库可以看做对不同平台多线程API的一层包装；因此使用新标准提供的线程库编写的程序是跨平台的。</p><h2 id="一个简单的多线程实现"><a href="#一个简单的多线程实现" class="headerlink" title="一个简单的多线程实现"></a>一个简单的多线程实现</h2><p>C++11的标准库中提供了多线程库，使用时需要<code>#include &lt;thread&gt;</code>头文件，该头文件主要包含了对线程的管理类<code>std::thread</code>以及其他管理线程相关的类。下面是使用C++多线程库的简单示例：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">output</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">uint8_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>thread <span class="token function">t</span><span class="token punctuation">(</span>output<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>t<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">getchar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在一个for循环内，创建4个线程分别输出数字0、1、2、3，并且在每个数字的末尾输出换行符。语句<code>thread t(output, i)</code>创建一个线程t，该线程运行<code>output</code>，第二个参数i是传递给<code>output</code>的参数。t在创建完成后自动启动，<code>t.detach</code>表示该线程在后台允许，无需等待该线程完成，继续执行后面的语句。这段代码的功能是很简单的，如果是顺序执行的话，其结果很容易预测得到：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token number">0</span><span class="token number">1</span><span class="token number">2</span><span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但是在并行多线程下，其执行的结果就多种多样了，比如下面就是代码一次运行的结果：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">01<span class="token number">2</span><span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这就涉及到多线程编程最核心的问题：<strong>资源竞争</strong>。</p><p>假设CPU有4核，可以同时执行4个线程，但是<strong>控制台却只有一个，同时只能有一个线程拥有这个唯一的控制台</strong>，将数字输出。将上面代码创建的四个线程进行编号：t0,t1,t2,t3，分别输出的数字：0,1,2,3。参照上图的执行结果，控制台的拥有权的转移如下：</p><ul><li>t0拥有控制台，输出了数字0，但是其没有来的及输出换行符，控制的拥有权却转移到了t1；（0）</li><li>t1完成自己的输出，t1线程完成 （1\n）</li><li>控制台拥有权转移给t0，输出换行符 （\n）</li><li>t2拥有控制台，完成输出 （2\n）</li><li>t3拥有控制台，完成输出 （3\n)</li></ul><p>由于控制台是系统资源，这里控制台拥有权的管理是操作系统完成的。但是，假如是多个线程共享进程空间的数据，这就需要自己写代码控制，每个线程何时能够拥有共享数据进行操作。</p><p><strong>共享数据的管理</strong>以及<strong>线程间的通信</strong>，是多线程编程的两大核心。</p><h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><p>每个应用程序至少有一个进程，而每个进程至少有一个主线程，除了主线程外，在一个进程中还可以创建多个线程。每个线程都需要一个入口函数，入口函数返回退出，该线程也会退出，主线程就是以<code>main</code>函数作为入口函数的线程。</p><p>在C++ 11的线程库中，将线程的管理放在了类<code>std::thread</code>中，使用<code>std::thread</code>可以创建、启动一个线程，并可以将线程挂起、结束等操作。</p><h3 id="启动一个线程"><a href="#启动一个线程" class="headerlink" title="启动一个线程"></a>启动一个线程</h3><p>C++ 11的线程库启动一个线程是非常简单的，只需要创建一个<code>std::thread</code>对象，就会启动一个线程，并使用该<code>std::thread</code>对象来管理该线程。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">do_task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token double-colon punctuation">::</span><span class="token function">thread</span><span class="token punctuation">(</span>do_task<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里创建<code>std::thread</code>传入的函数，实际上其构造函数需要的是可调用（callable）类型，只要是有函数调用类型的实例都是可以的。所以除了传递函数外，还可以使用：</p><ul><li><p>lambda表达式</p><p>使用lambda表达式启动线程输出数字</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>thread <span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>重载了()运算符的类的实例</p><p>使用重载了()运算符的类实现多线程数字输出</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Task</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">uint8_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>Task task<span class="token punctuation">;</span>thread <span class="token function">t</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>t<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>把函数对象传入<code>std::thread</code>的构造函数时，要注意一个C++的语法解析错误（C++’s most vexing parse）。向<code>std::thread</code>的构造函数中传入的是一个临时变量，而不是命名变量就会出现语法解析错误。如下代码：</p>  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span><span class="token function">Task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里相当于声明了一个函数t，其返回类型为<code>thread</code>，而不是启动了一个新的线程。可以使用新的初始化语法避免这种情况</p>  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>thread t<span class="token punctuation">{</span><span class="token function">Task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当线程启动后，<strong>一定要在和线程相关联的<code>thread</code>销毁前，确定以何种方式等待线程执行结束</strong>。</p><p>C++11有两种方式来等待线程结束：</p><ul><li><strong>detach方式</strong>，启动的线程自主在后台运行，当前的代码继续往下执行，不等待新线程结束。前面代码所使用的就是这种方式。<ul><li>调用detach表示thread对象和其表示的线程完全分离；</li><li>分离之后的线程是不在受约束和管制，会单独执行，直到执行完毕释放资源，可以看做是一个daemon线程；</li><li>分离之后thread对象不再表示任何线程；</li><li>分离之后joinable() == false，即使还在执行；</li></ul></li><li><strong>join方式</strong>，等待启动的线程完成，才会继续往下执行。假如前面的代码使用这种方式，其输出就会0,1,2,3，因为每次都是前一个线程输出完成了才会进行下一个循环，启动下一个新线程。<ul><li>只有处于活动状态线程才能调用join，可以通过joinable()函数检查;</li><li>joinable() == true表示当前线程是活动线程，才可以调用join函数；</li><li>默认构造函数创建的对象是joinable() == false;</li><li>join只能被调用一次，之后joinable就会变为false，表示线程执行完毕；</li><li>调用 ternimate()的线程必须是 joinable() == false;</li><li>如果线程不调用join()函数，即使执行完毕也是一个活动线程，即joinable() == true，依然可以调用join()函数；</li></ul></li></ul><p>无论在何种情形，一定要在<code>thread</code>销毁前，调用<code>t.join</code>或者<code>t.detach</code>，来决定线程以何种方式运行。</p><p>当使用join方式时，会阻塞当前代码，等待线程完成退出后，才会继续向下执行；</p><p>而使用detach方式则不会对当前代码造成影响，当前代码继续向下执行，创建的新线程同时并发执行，这时候需要特别注意：<strong>创建的新线程对当前作用域的变量的使用</strong>，创建新线程的作用域结束后，有可能线程仍然在执行，这时局部变量随着作用域的完成都已销毁，如果线程继续使用局部变量的<strong>引用或者指针</strong>，会出现意想不到的错误，并且这种错误很难排查。例如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> fn <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1010</span><span class="token punctuation">;</span>    thread <span class="token function">t</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    t<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在lambda表达式中，使用fn启动了一个新的线程，在装个新的线程中使用了局部变量a的指针，并且将该线程的运行方式设置为detach。这样，在lamb表达式执行结束后，变量a被销毁，但是在后台运行的线程仍然在使用已销毁变量a的指针，这样就可能会导致不正确的结果出现。</p><p>所以在以detach的方式执行线程时，要将线程访问的局部数据复制到线程的空间（使用值传递），一定要确保线程没有使用局部变量的引用或者指针，除非你能肯定该线程会在局部作用域结束前执行结束。</p><p>当然，使用join方式的话就不会出现这种问题，它会在作用域结束前完成退出。</p><h3 id="异常情况下等待线程完成"><a href="#异常情况下等待线程完成" class="headerlink" title="异常情况下等待线程完成"></a>异常情况下等待线程完成</h3><p>当决定以detach方式让线程在后台运行时，可以在创建<code>thread</code>的实例后立即调用<code>detach</code>，这样线程就会后<code>thread</code>的实例分离，即使出现了异常<code>thread</code>的实例被销毁，仍然能保证线程在后台运行。</p><p>但线程以join方式运行时，需要在主线程的合适位置调用<code>join</code>方法，如果调用<code>join</code>前出现了异常，<code>thread</code>被销毁，线程就会被异常所终结。为了避免异常将线程终结，或者由于某些原因，例如线程访问了局部变量，就要保证线程一定要在函数退出前完成，就要保证要在函数退出前调用<code>join</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>thread <span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello C++ 11"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span><span class="token punctuation">{</span><span class="token function">do_something_else</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">{</span>t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">throw</span><span class="token punctuation">;</span><span class="token punctuation">}</span>t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码能够保证在正常或者异常的情况下，都会调用<code>join</code>方法，这样线程一定会在函数<code>func</code>退出前完成。但是使用这种方法，不但代码冗长，而且会出现一些作用域的问题，并不是一个很好的解决方法。</p><p>一种比较好的方法是资源获取即初始化（RAII,Resource Acquisition Is Initialization)，该方法提供一个类，在析构函数中调用<code>join</code>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">thread_guard</span><span class="token punctuation">{</span>thread <span class="token operator">&amp;</span>t<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token operator">:</span><span class="token keyword">explicit</span> <span class="token function">thread_guard</span><span class="token punctuation">(</span>thread<span class="token operator">&amp;</span> _t<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">t</span><span class="token punctuation">(</span>_t<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">~</span><span class="token function">thread_guard</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">thread_guard</span><span class="token punctuation">(</span><span class="token keyword">const</span> thread_guard<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>thread_guard<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> thread_guard<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>thread <span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello thread"</span> <span class="token operator">&lt;&lt;</span>endl <span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>thread_guard <span class="token function">g</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>无论是何种情况，当函数退出时，局部变量<code>g</code>调用其析构函数销毁，从而能够保证<code>join</code>一定会被调用。</p><h3 id="向线程传递参数"><a href="#向线程传递参数" class="headerlink" title="向线程传递参数"></a>向线程传递参数</h3><p>向线程调用的函数传递参数也是很简单的，只需要在构造<code>thread</code>的实例时，依次传入即可。例如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">int</span> buffer<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>thread <span class="token function">t</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span>buffer<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的是，<strong>默认的会将传递的参数以拷贝的方式复制到线程空间，即使参数的类型是引用。</strong>例如：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>thread <span class="token function">t</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>func</code>的第二个参数是<code>string &amp;</code>，而传入的是一个字符串字面量。该字面量以<code>const char*</code>类型传入线程空间后，在**线程的空间内转换为<code>string</code>**。</p><p>如果在线程中使用引用来更新对象时，就需要注意了。默认的是将对象拷贝到线程空间，其引用的是拷贝的线程空间的对象，而不是初始希望改变的对象。如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">_tagNode</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token keyword">int</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>_tagNode <span class="token operator">&amp;</span>node<span class="token punctuation">)</span><span class="token punctuation">{</span>node<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>node<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>_tagNode node<span class="token punctuation">;</span>thread <span class="token function">t</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> node<span class="token punctuation">.</span>a <span class="token operator">&lt;&lt;</span> endl <span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> node<span class="token punctuation">.</span>b <span class="token operator">&lt;&lt;</span> endl <span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在线程内，将对象的字段a和b设置为新的值，但是在线程调用结束后，这两个字段的值并不会改变。这样由于引用的实际上是局部变量<code>node</code>的一个拷贝，而不是<code>node</code>本身。在将对象传入线程的时候，调用<code>std::ref</code>，将<code>node</code>的引用传入线程，而不是一个拷贝。例如：<code>thread t(func,std::ref(node));</code></p><p>也可以使用类的成员函数作为线程函数，示例如下</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">_tagNode</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">void</span> <span class="token function">do_some_work</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>_tagNode node<span class="token punctuation">;</span>thread <span class="token function">t</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>_tagNode<span class="token double-colon punctuation">::</span>do_some_work<span class="token punctuation">,</span> <span class="token operator">&amp;</span>node<span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面创建的线程会调用<code>node.do_some_work(20)</code>，第三个参数为成员函数的第一个参数，以此类推。</p><h3 id="转移线程的所有权"><a href="#转移线程的所有权" class="headerlink" title="转移线程的所有权"></a>转移线程的所有权</h3><p><code>thread</code>是可移动的(movable)的，但不可复制(copyable)。可以通过<code>move</code>来改变线程的所有权，灵活的决定线程在什么时候join或者detach。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">thread <span class="token function">t1</span><span class="token punctuation">(</span>f1<span class="token punctuation">)</span><span class="token punctuation">;</span>thread <span class="token function">t3</span><span class="token punctuation">(</span><span class="token function">move</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>将线程从t1转移给t3,这时候t1就不再拥有线程的所有权，调用<code>t1.join</code>或<code>t1.detach</code>会出现异常，要使用t3来管理线程。这也就意味着<code>thread</code>可以作为函数的返回类型，或者作为参数传递给函数，能够更为方便的管理线程。</p><p>线程的标识类型为<code>std::thread::id</code>，有两种方式获得到线程的id。</p><ul><li>通过<code>thread</code>的实例调用<code>get_id()</code>直接获取</li><li>在当前线程上调用<code>this_thread::get_id()</code>获取</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用RANSAC算法拟合点云中的平面</title>
      <link href="2021/11/28/ransac/"/>
      <url>2021/11/28/ransac/</url>
      
        <content type="html"><![CDATA[<h1 id="使用RANSAC算法拟合点云中的平面"><a href="#使用RANSAC算法拟合点云中的平面" class="headerlink" title="使用RANSAC算法拟合点云中的平面"></a>使用RANSAC算法拟合点云中的平面</h1><p>最近在写pi-slam-fusion这个项目，需要根据pi-slam计算出来的点云拟合出大地平面的方程，从而让map2dfusion根据这个方程进行地图拼接。</p><p>这一步我使用了ransac算法，并且对ransac算法进行了一点总（ban）结（yun）。</p><h2 id="RANSAC简介"><a href="#RANSAC简介" class="headerlink" title="RANSAC简介"></a>RANSAC简介</h2><p><strong>RANSAC</strong>(RAndom SAmple Consensus,随机采样一致)算法是从一组含有“外点”(outliers)的数据中正确估计数学模型参数的迭代算法。</p><p>“外点”一般指的的数据中的噪声，比如说匹配中的误匹配和估计曲线中的离群点。所以，RANSAC也是一种“外点”检测算法。RANSAC算法是一种不确定算法，它只能在一种概率下产生结果，并且这个概率会随着迭代次数的增加而加大。RANSAC算最早是由Fischler和Bolles在SRI上提出用来解决LDP(Location Determination Proble)问题的。</p><h3 id="RANSAC的基本假设"><a href="#RANSAC的基本假设" class="headerlink" title="RANSAC的基本假设"></a>RANSAC的基本假设</h3><ol><li>“<a href="https://zh.wikipedia.org/w/index.php?title=%E5%85%A7%E7%BE%A4&amp;action=edit&amp;redlink=1">内群</a>”(inlier, 似乎译为内点群更加妥当，即正常数据，正确数据)数据可以通过几组模型的参数来叙述其分布，而“<a href="https://zh.wikipedia.org/w/index.php?title=%E9%9B%A2%E7%BE%A4&amp;action=edit&amp;redlink=1">离群</a>”(outlier,似乎译为外点群更加妥当，异常数据)数据则是不适合模型化的数据。</li><li>数据会受噪声影响，噪声指的是离群，例如从极端的噪声或错误解释有关数据的测量或不正确的假设。</li><li>RANSAC假定，给定一组（通常很小）的内点群，存在一个程序，这个程序可以估算最佳解释或最适用于这一数据模型的参数。</li></ol><h3 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h3><p>这里用一个简单的例子来说明，在一组数据点中找到一条最适合的线。假设，此有一组集合包含了内点群以及外点群，其中内点群包含可以被拟合到线段上的点，而外点群则是无法被拟合的点。如果我们用简单的最小二乘法来找此线，我们将无法得到一条适合于内点群的直线，因为最小二乘法会受外点群影响而影响其结果。而用RANSAC，可以只由内点群来计算出模型，而且概率还够高。然而，RANSAC无法保证结果一定最好，所以必须小心选择参数，使其能有足够的概率。</p><p><img src="/images/ransac/01.png"></p><h3 id="算法基本思想和流程"><a href="#算法基本思想和流程" class="headerlink" title="算法基本思想和流程"></a>算法基本思想和流程</h3><p>RANSAC是通过反复选择数据集去估计出模型，一直迭代到估计出认为比较好的模型。<br>具体的实现步骤可以分为以下几步：</p><ol><li>选择出可以估计出模型的最小数据集；(对于直线拟合来说就是2个点，对于平面拟合就是3个点)</li><li>使用这个数据集来计算出数据模型；</li><li>将所有数据带入这个模型，计算出“内点”的数目；(累加在一定误差范围内的适合当前迭代推出模型的数据)</li><li>比较当前模型和之前推出的最好的模型的“内点“的数量，记录最大“内点”数的模型参数和“内点”数；</li><li>重复1-4步，直到迭代结束或者当前模型已经足够好了(“内点数目大于一定数量”)。</li></ol><h2 id="编程实现"><a href="#编程实现" class="headerlink" title="编程实现"></a>编程实现</h2><p>以RANSAC算法拟合点云中的平面为例，介绍python实现的核心代码。</p><h3 id="求解平面方程"><a href="#求解平面方程" class="headerlink" title="求解平面方程"></a>求解平面方程</h3><p>这里是根据最小数据集（点A、点B、点C）来计算数据模型（平面方程）的过程，对应上面的1、2步</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">solve_plane</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    求解平面方程    :param A: 点A    :param B: 点B    :param C: 点C    :return: Point(平面上一点),Quaternion(平面四元数),Nx(平面的法向量)    """</span>    <span class="token comment"># 两个常量</span>    N <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    Pi <span class="token operator">=</span> <span class="token number">3.1415926535</span>    <span class="token comment"># 计算平面的单位法向量，即BC 与 BA的叉积</span>    Nx <span class="token operator">=</span> np<span class="token punctuation">.</span>cross<span class="token punctuation">(</span>B <span class="token operator">-</span> C<span class="token punctuation">,</span> B <span class="token operator">-</span> A<span class="token punctuation">)</span>    Nx <span class="token operator">=</span> Nx <span class="token operator">/</span> np<span class="token punctuation">.</span>linalg<span class="token punctuation">.</span>norm<span class="token punctuation">(</span>Nx<span class="token punctuation">)</span>    <span class="token comment"># 计算单位旋转向量与旋转角（范围为0到Pi）</span>    Nv <span class="token operator">=</span> np<span class="token punctuation">.</span>cross<span class="token punctuation">(</span>Nx<span class="token punctuation">,</span> N<span class="token punctuation">)</span>    angle <span class="token operator">=</span> acos<span class="token punctuation">(</span>np<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>Nx<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 考虑到两个向量夹角不大于Pi/2，这里需要处理一下</span>    <span class="token keyword">if</span> angle <span class="token operator">&gt;</span> Pi <span class="token operator">/</span> <span class="token number">2.0</span><span class="token punctuation">:</span>        angle <span class="token operator">=</span> Pi <span class="token operator">-</span> angle        Nv <span class="token operator">=</span> <span class="token operator">-</span>Nv    <span class="token comment"># FIXME: 此处如何确定平面上的一个点？？？</span>    <span class="token comment"># Point = (A + B + C) / 3.0</span>    Point <span class="token operator">=</span> B    <span class="token comment"># 计算单位四元数</span>    Quaternion <span class="token operator">=</span> np<span class="token punctuation">.</span>append<span class="token punctuation">(</span>Nv <span class="token operator">*</span> sin<span class="token punctuation">(</span>angle <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cos<span class="token punctuation">(</span>angle <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># print("旋转向量:\t", Nv)</span>    <span class="token comment"># print("旋转角度:\t", angle)</span>    <span class="token comment"># print("对应四元数:\t", Quaternion)</span>    <span class="token keyword">return</span> Point<span class="token punctuation">,</span> Quaternion<span class="token punctuation">,</span> Nx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="计算点到平面的距离"><a href="#计算点到平面的距离" class="headerlink" title="计算点到平面的距离"></a>计算点到平面的距离</h3><p>我们可以根据点到平面的距离来判断这个点是否为内点。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">solve_distance</span><span class="token punctuation">(</span>M<span class="token punctuation">,</span> P<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    求解点M到平面(P,Q)的距离    :param M: 点M    :param P: 平面上一点    :param N: 平面的法向量    :return: 点到平面的距离    """</span>    <span class="token comment"># 从四元数到法向量</span>    <span class="token comment"># A = 2 * Q[0] * Q[2] + 2 * Q[1] * Q[3]</span>    <span class="token comment"># B = 2 * Q[1] * Q[2] - 2 * Q[0] * Q[3]</span>    <span class="token comment"># C = -Q[0] ** 2 - Q[1] ** 2 + Q[2] ** 2 + Q[3] ** 2</span>    <span class="token comment"># D = -A * P[0] - B * P[1] - C * P[2]</span>    <span class="token comment"># 为了计算简便，直接使用求解出的法向量</span>    A <span class="token operator">=</span> N<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    B <span class="token operator">=</span> N<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    C <span class="token operator">=</span> N<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>    D <span class="token operator">=</span> <span class="token operator">-</span>A <span class="token operator">*</span> P<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> B <span class="token operator">*</span> P<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> C <span class="token operator">*</span> P<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> fabs<span class="token punctuation">(</span>A <span class="token operator">*</span> M<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> B <span class="token operator">*</span> M<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> C <span class="token operator">*</span> M<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> D<span class="token punctuation">)</span> <span class="token operator">/</span> sqrt<span class="token punctuation">(</span>A <span class="token operator">**</span> <span class="token number">2</span> <span class="token operator">+</span> B <span class="token operator">**</span> <span class="token number">2</span> <span class="token operator">+</span> C <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="通过RANSAC算法进行拟合"><a href="#通过RANSAC算法进行拟合" class="headerlink" title="通过RANSAC算法进行拟合"></a>通过RANSAC算法进行拟合</h3><p>这里是RANSAC算法的主要实现过程。</p><p>下面的函数计算出的P是平面上的一点，Q是平面的四元数，N是平面的法向量。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">RANSAC</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    使用RANSAC算法估算模型    """</span>    <span class="token comment"># 数据规模</span>    SIZE <span class="token operator">=</span> data<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token comment"># 迭代最大次数，每次得到更好的估计会优化iters的数值，默认10000</span>    iters <span class="token operator">=</span> <span class="token number">10000</span>    <span class="token comment"># 数据和模型之间可接受的差值，默认0.25</span>    sigma <span class="token operator">=</span> <span class="token number">0.15</span>    <span class="token comment"># 内点数目</span>    pretotal <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment"># 希望的得到正确模型的概率，默认0.99</span>    Per <span class="token operator">=</span> <span class="token number">0.999</span>    <span class="token comment"># 初始化一下</span>    P <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    Q <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    N <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>iters<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># 随机在数据中选出三个点去求解模型</span>        sample_index <span class="token operator">=</span> random<span class="token punctuation">.</span>sample<span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span>SIZE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>        P<span class="token punctuation">,</span> Q<span class="token punctuation">,</span> N <span class="token operator">=</span> solve_plane<span class="token punctuation">(</span>data<span class="token punctuation">[</span>sample_index<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>sample_index<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>sample_index<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment"># 算出内点数目</span>        total_inlier <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> index <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>SIZE<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> solve_distance<span class="token punctuation">(</span>data<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> P<span class="token punctuation">,</span> N<span class="token punctuation">)</span> <span class="token operator">&lt;</span> sigma<span class="token punctuation">:</span>                total_inlier <span class="token operator">=</span> total_inlier <span class="token operator">+</span> <span class="token number">1</span>        <span class="token comment"># 判断当前的模型是否比之前估算的模型好</span>        <span class="token keyword">if</span> total_inlier <span class="token operator">&gt;</span> pretotal<span class="token punctuation">:</span>            iters <span class="token operator">=</span> log<span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> Per<span class="token punctuation">)</span> <span class="token operator">/</span> log<span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> <span class="token builtin">pow</span><span class="token punctuation">(</span>total_inlier <span class="token operator">/</span> SIZE<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            pretotal <span class="token operator">=</span> total_inlier        <span class="token comment"># 判断是否当前模型已经符合超过一半的点</span>        <span class="token keyword">if</span> total_inlier <span class="token operator">&gt;</span> SIZE <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>    <span class="token keyword">return</span> P<span class="token punctuation">,</span> Q<span class="token punctuation">,</span> N<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><p>具体的代码（包括C++实现和python实现）都放在<a href="https://github.com/Immortalqx/RANSAC.git">https://github.com/Immortalqx/RANSAC.git</a></p><p>你可以通过下面的指令运行这篇博客介绍的RANSAC算法。</p><p><strong>克隆本项目：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/Immortalqx/RANSAC.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>运行C++部分的代码：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> RANSAC<span class="token function">mkdir</span> build<span class="token builtin class-name">cd</span> buildcmake <span class="token punctuation">..</span><span class="token function">make</span>./RANSAC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行python部分的代码：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#在平面中用ransac算法拟合直线</span>python3 RANSAC_2D.py<span class="token comment">#在点云中用ransac算法拟合平面</span>python3 RANSAC_3D.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行结果：</strong></p><p>对2D平面中的直线进行拟合</p><img src="/images/ransac/02.png" style="zoom: 50%;"><p>对点云中的平面进行拟合</p><img src="/images/ransac/03.png" style="zoom: 67%;">]]></content>
      
      
      <categories>
          
          <category> 三维视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视觉SLAM </tag>
            
            <tag> 点云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的头文件</title>
      <link href="2021/11/21/cpp-notes-0/"/>
      <url>2021/11/21/cpp-notes-0/</url>
      
        <content type="html"><![CDATA[<h1 id="C-中的头文件"><a href="#C-中的头文件" class="headerlink" title="C++中的头文件"></a>C++中的头文件</h1><blockquote><p>最近在写pi-slam-fusion，遇到的问题比较多，最离谱的问题可能就是和头文件有关的这部分了。</p></blockquote><h3 id="1-关于为什么C-需要“在头文件中声明，在源文件中定义”？"><a href="#1-关于为什么C-需要“在头文件中声明，在源文件中定义”？" class="headerlink" title="1. 关于为什么C++需要“在头文件中声明，在源文件中定义”？"></a>1. 关于为什么C++需要“在头文件中声明，在源文件中定义”？</h3><blockquote><p>当时为了把pislam和map2dfusion弄到一个程序里面，想出了#include “main.cpp” 和把 “main.cpp”重命名为”pislam.h”再进行#include的操作，这样肯定是有问题的！</p><p>实际上当时一编译就会跟我报“重定义”的错误，然后我居然还以为是CMakeList没写好</p></blockquote><ul><li><p>第一，<strong>预编译指令#include的作用是将所包含的文件全文复制到#include的位置</strong>，相当于是个展开为一个文件的宏。</p><p>c++的预处理器在编译之前执行，它看到#include指令，就会把那个文件的内容替换到当前位置。其它的预处理指令例如#define, #ifdef, ##等也在这个阶段被执行、并产生相应的内容。</p><p>预处理器执行完成后，所有的预处理指令都会被移除。其结果是一个单个头的大文件（我猜测这文件只存在于内存里），这个文件才会被进一步传给编译器做编译。</p></li><li><p>第二，<strong>C++允许多次声明，但只允许一次实现。</strong>比如int foo();就是一次声明，而int foo(){}就是一次实现。</p><p>如果编译时有多个.cpp文件中#include了同一个含有函数实现的.h，这时候链接器就会在多个目标文件中找到这个函数的实现，而这在C++中是不允许的，此时就会引爆<strong>LNK1169错误:找到一个或多个重定义的符号。</strong></p><p>因此为了让函数可以在各个.cpp中共享，正确的做法就是在.h中只声明函数，并在另【 一个（重点）】.cpp中实现这个函数。这样就不会冲突了。</p><blockquote><p>所以#include一个.cpp文件也是不可以的，这和#include一个含有函数实现的.h文件效果一样糟糕。</p></blockquote></li></ul><h3 id="2-头文件中应该写什么内容？"><a href="#2-头文件中应该写什么内容？" class="headerlink" title="2. 头文件中应该写什么内容？"></a>2. 头文件中应该写什么内容？</h3><blockquote><p>因为问题一的存在，现在我其实对头文件里面应该写什么也不太清楚了，所以又查了一些内容。。。</p></blockquote><p><strong>头文件中应该只放变量和函数的声明，而不能放它们的定义。</strong>不过这样的规则有三个例外：</p><ol><li><p><strong>头文件中可以写 const 对象的定义。</strong></p><p>因为全局的 const 对象默认是没有 extern 的声明的，所以它只在当前文件中有效。</p><p>同理，static 对象的定义也可以放进头文件。</p></li><li><p><strong>头文件中可以写内联函数（inline）的定义。</strong></p><p>C++ 规定，内联函数可以在程序中定义多次，只要内联函数在一个 .cpp 文件中只出现一次，并且在所有的 .cpp 文件中，这个内联函数的定义是一样的，就能通过编译。</p><p>那么显然，把内联函数的定义放进一个头文件中是非常明智的做法。</p></li><li><p><strong>头文件中可以写类（class）的定义。</strong></p><p>编译器只有在这个类的定义完全可见的情况下，才能知道这个类的对象应该如何布局，所以，关于类的定义的要求，跟内联函数是基本一样的。</p><p>我们可以把类的定义放在头文件中，而把函数成员的实现代码放在一个 .cpp 文件中。</p><p>也可以直接把函数成员的实现代码也写进类定义里面。<strong>在 C++ 的类中，如果函数成员在类的定义体中被定义，那么编译器会视这个函数为内联的。</strong>因此，把函数成员的定义写进类定义体，一起放进头文件中，是合法的。</p><blockquote><p>注意一下，如果把函数成员的定义写在类定义的头文件中，而没有写进类定义中，这是不合法的，因为这个函数成员此时就不是内联的了。一旦头文件被两个或两个以上的 .cpp 文件包含，这个函数成员就被重定义了。</p></blockquote></li></ol><p><strong>头文件中的保护措施：</strong></p><p>设想一下，如果 a.h 中含有类 A 的定义，b.h 中含有类 B 的定义，由于类B的定义依赖了类 A，所以 b.h 中也 #include了a.h。现在有一个源文件，它同时用到了类A和类B，于是程序员在这个源文件中既把 a.h 包含进来了，也把 b.h 包含进来了。这时，问题就来了：类A的定义在这个源文件中出现了两次！于是整个程序就不能通过编译了。</p><p>使用 “#define” 配合条件编译可以很好地解决这个问题。在一个头文件中，通过 #define 定义一个名字，并且通过条件编译 #ifndef…#endif 使得编译器可以根据这个名字是否被定义，再决定要不要继续编译该头文中后续的内容。这个方法虽然简单，但是写头文件时一定记得写进去。</p><p><strong>综上所述</strong></p><p>.h文件中能包含：</p><ul><li>类成员数据的声明，但不能赋值</li><li>类静态数据成员的定义和赋值，但不建议，只是个声明就好。</li><li>类的成员函数的声明</li><li>非类成员函数的声明</li><li>常数的定义：如：constint a=5;</li><li>静态函数的定义</li><li>类的内联函数的定义</li></ul><p>不能包含：</p><ul><li>所有非静态变量（不是类的数据成员）的声明</li><li>默认命名空间声明不要放在头文件，using namespace std;等应放在.cpp中，在 .h 文件中使用 std::string</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Harris角点检测原理</title>
      <link href="2021/11/21/opencv-notes-5/"/>
      <url>2021/11/21/opencv-notes-5/</url>
      
        <content type="html"><![CDATA[<h1 id="Harris角点检测原理"><a href="#Harris角点检测原理" class="headerlink" title="Harris角点检测原理"></a>Harris角点检测原理</h1><p>Harris角点最早在paper A Combined Corner and Edge Detector中被Chris Harris &amp; Mike Stephens提出。</p><h2 id="0、Harris角点检测的基本思想："><a href="#0、Harris角点检测的基本思想：" class="headerlink" title="0、Harris角点检测的基本思想："></a>0、Harris角点检测的基本思想：</h2><p>算法基本思想是使用一个固定窗口在图像上进行任意方向上的滑动，比较滑动前与滑动后两种情况，窗口中的像素灰度变化程度，如果存在任意方向上的滑动，都有着较大灰度变化，那么我们可以认为该窗口中存在角点。</p><p><img src="/images/OpenCV-Notes/5-01.png"></p><h2 id="1、灰度变化描述"><a href="#1、灰度变化描述" class="headerlink" title="1、灰度变化描述"></a>1、灰度变化描述</h2><p>当窗口发生$ [u,v] $移动时，那么<strong>滑动前与滑动后对应的窗口中的像素点灰度变化</strong>描述如下：<br>$$<br>E(u,v)=\sum\limits_{(x,y)€W}w(x,y)[I(x+u,y+v)-I(x,y)]^2<br>$$<br>其中</p><ul><li>$[u,v]$是窗口$W$的偏移量；</li><li>$(x,y)$是窗口$W$所对应的像素坐标位置，窗口有多大，就有多少个位置；</li><li>$I(x,y)$是像素坐标位置$(x,y)$的图像灰度值；</li><li>$I(x+u,y+v)$是像素坐标位置$(x+u,y+v)$的图像灰度值；</li><li>$w(x,y)$是窗口函数，最简单情形就是窗口$W$内的所有像素所对应的$w$权重系数均为1.但有时候，我们会将$w(x,y)$函数设置为以窗口$W$中心为原点的二元正太分布。如果窗口$W$中心点是角点时，移动前与移动后，该点在灰度变化贡献最大；而离窗口$W$中心(角点)较远的点，这些点的灰度变化几近平缓，这些点的权重系数，可以设定小值，以示该点对灰度变化贡献较小，那么我们自然而然想到使用二元高斯函数来表示窗口函数；</li></ul><p>根据上述表达式，当窗口在平坦区域上移动灰度不会发生什么变换。如果窗口处在纹理比较丰富的区域上滑动，那么灰度变化会很大。</p><p>算法最终思想就是计算灰度发生较大变化时所对应的位置，当然这个较大是指任意方向上的滑动，并非单指某个方向。</p><h2 id="2、-E-u-v-化简"><a href="#2、-E-u-v-化简" class="headerlink" title="2、 $E(u,v)$化简"></a>2、 $E(u,v)$化简</h2><p>根据泰勒公式:<br>$$<br>f(x+u,y+v)≈f(x,y)+uf_x(x,y)+vf_y(x,y)<br>$$<br>我们可以将上面的公式化简为:<br>$$<br>\sum\limits_{(x,y)€W}w(x,y)[I(x+u,y+v)-I(x,y)]^2\\<br>≈\sum\limits_{(x,y)€W}w(x,y)[I(x,y)+uI_x+vI_y-I(x,y)]^2\\<br>=\sum\limits_{(x,y)€W}w(x,y)[u^2I_x^2+2uvI_xI_y+v^2I_y^2]\\<br>=\sum\limits_{(x,y)€W}w(x,y)\begin{bmatrix}u &amp; v\end{bmatrix}\begin{bmatrix} I_x^2 &amp; I_xIy \   I_xI_y &amp; I_y^2\end{bmatrix}\begin{bmatrix}u \ v\end{bmatrix}\\<br>=\begin{bmatrix}u &amp; v\end{bmatrix}(\sum\limits_{(x,y)€W}w(x,y)\begin{bmatrix} I_x^2 &amp; I_xIy \   I_xI_y &amp; I_y^2\end{bmatrix})\begin{bmatrix}u \ v\end{bmatrix}<br>$$<br>所以$E(u,v)$表达式可以更新为：<br>$$<br>E(u,v)=\begin{bmatrix}u &amp; v\end{bmatrix}M\begin{bmatrix}u \ v\end{bmatrix}<br>$$<br>其中：$M=\sum\limits_{(x,y)€W}w(x,y)\begin{bmatrix} I_x^2 &amp; I_xIy \   I_xI_y &amp; I_y^2\end{bmatrix}$,</p><p>$I_x$,$I_y$分别为窗口内像素点$(x,y)$在$x$方向上和$y$方向上的梯度值。</p><h2 id="3、矩阵-M-的关键性"><a href="#3、矩阵-M-的关键性" class="headerlink" title="3、矩阵$M$的关键性"></a>3、矩阵$M$的关键性</h2><p>Harris角点检测算法并不是直接根据$E(u,v)$来判断角点的，而是通过对窗口内的每个像素的$x$方向上的梯度与$y$方向上的梯度进行统计分析。假设我们这里以$I_x$和$I_y$为坐标轴，则每个像素的梯度坐标可以表示成$(I_x,I_y)$。</p><p>针对平坦区域，边缘区域以及角点区域三种情形进行分析：</p><p><img src="/images/OpenCV-Notes/5-02.png"></p><p>下图是对这三种情况窗口中的对应像素的梯度分布进行绘制：</p><p><img src="/images/OpenCV-Notes/5-03.png"></p><p>我们可以很明显的看出这三种区域的特点:</p><ul><li><p>平坦区域上的每个像素点所对应的$(I_x,I_y)$坐标分布在原点附近。</p><p>其实也很好理解：针对平坦区域的像素点，他们的梯度方向虽然各异，但是其幅值都不是很大，所以均聚集在原点附近。</p></li><li><p>边缘区域有一坐标轴分布较散。</p><p>至于是哪一个坐标上的数据分布较散不能一概而论，这要视边缘在图像上的具体位置而定，如果边缘是水平或者垂直方向，那么$I_y$轴方向或者$I_x$方向上的数据分布就比较散；</p></li><li><p>角点区域的$I_x$、$I_y$方向上的梯度分布都比较散。</p></li></ul><p>所以，我们可以尝试利用这些特征来判断哪些区域存在角点。</p><p>之前我们已经计算出了$M$矩阵：<br>$$<br>M=<br>\sum\limits_{(x,y)€W}w(x,y)\begin{bmatrix} I_x^2 &amp; I_xIy \   I_xI_y &amp; I_y^2\end{bmatrix}=<br>\begin{bmatrix} A &amp; C \   C &amp; B \end{bmatrix}<br>$$<br>我们可以把$E(u,v)$近似为二项函数：$E(u,v)=Au^2+2Cuv+Bv^2$</p><p>其中：<br>$$<br>A=\sum\limits_{(x,y)€W}w(x,y)*I_x^2\<br>B=\sum\limits_{(x,y)€W}w(x,y)*I_y^2\<br>C=\sum\limits_{(x,y)€W}w(x,y)*I_xI_y<br>$$<br>二次项函数本质上就是一个椭圆函数。椭圆的长和宽是由$M$的特征值$λ1,λ2$决定的(椭圆的长短轴正是矩阵$M$特征值平方根的倒数)，椭圆的方向是由$M$的特征向量决定的，椭圆方程为：<br>$$<br>\begin{bmatrix} u &amp; v \end{bmatrix}M\begin{bmatrix} u \ v \end{bmatrix}=1<br>$$</p><p>如果使用椭圆进行数据集表示，则绘制图示如下：</p><p><img src="/images/OpenCV-Notes/5-04.png"></p><p>从上图中我们可以看出：</p><ul><li>如果$λ1,λ2$都很大，并且很接近，就可以认为是一个角点</li><li>如果$λ1,λ2$中只有一个值大，那么这只是一个边缘，不是角点</li><li>如果$λ1,λ2$很接近但是数值比较小，那么这里就是一个平坦区域</li></ul><h2 id="4、角点响应的度量"><a href="#4、角点响应的度量" class="headerlink" title="4、角点响应的度量"></a>4、角点响应的度量</h2><p>通常用下面表达式进行度量，对每一个窗口计算得到一个分数$R$，根据$R$的大小来判定窗口内是否存在harris特征角点。分数$R$根据下面公式计算得到：<br>$$<br>R=det(M)-k(trace(M))^2\<br>det(M)=λ_1λ_2\<br>trace(M)=λ_1+λ_2<br>$$<br>这里$λ1,λ2$是矩阵$M$的2个特征值，$k$是一个指定值，这是一个经验参数，需要实验确定它的合适大小，通常它的值在0.04和0.06之间,它的存在只是调节函数的形状而已。</p><p>$R$取决于$M$的特征值，对于角点$|R|$很大，平坦的区域$|R|$很小，边缘的$R$为负值;</p><p><img src="/images/OpenCV-Notes/5-05.png"></p><p>最后设定R的阈值，进行角点判断即可。</p>]]></content>
      
      
      <categories>
          
          <category> 三维视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区分PIXHAWK、PX4与APM(ardupilot)</title>
      <link href="2021/07/27/uav-notes-1/"/>
      <url>2021/07/27/uav-notes-1/</url>
      
        <content type="html"><![CDATA[<h1 id="区分PIXHAWK、PX4与APM-ardupilot"><a href="#区分PIXHAWK、PX4与APM-ardupilot" class="headerlink" title="区分PIXHAWK、PX4与APM(ardupilot)"></a>区分PIXHAWK、PX4与APM(ardupilot)</h1><h3 id="一、PIXHAWK介绍"><a href="#一、PIXHAWK介绍" class="headerlink" title="一、PIXHAWK介绍"></a>一、PIXHAWK介绍</h3><p><strong>pixhawk是硬件平台</strong>，PX4是pixhawk的原生固件，专门为pixhawk开发。</p><img src="/images/UAV-notes/1-1.jpg" alt="" style="zoom: 18%;"><p>Pixhawk是一款由PX4开源项目设计并由3DR公司制造生产的高级自动驾驶仪系统，其前身是APM。APM（Ardupilot Mega）也是硬件，Ardupilot是APM的固件，所以称ArduPilot固件也叫APM。</p><img src="/images/UAV-notes/1-2.png" alt="" style="zoom:30%;"><p>由于APM的处理器已经接近满负荷，没有办法满足更复杂的运算处理，所以硬件厂商采用了目前新标准的32位ARM处理器，它采用了ST Microelectronic先进的处理器及传感器技术且搭载了NuttX的实时操作系统，在模型自动控制方面有着出色的性能、灵活性和可靠性。</p><p>PIXHAWK的所有硬件都是透明的，它用的是什么芯片和传感器一目了然，所有的总线和外设都进行引出，不但以后可以兼容一些其他外设，而且对于有开发能力的用户提供了方便。 PIXHAWK 是一个双处理器的飞行控制器，一个擅长于强大运算的 32 bit STM32F427 Cortex M4 核心 168 MHz/256 KB RAM/2 MB Flash 处理器，还有一个主要定位于工业用途的协处理器 32 bit STM32F103，它的特点就是安全稳定。所以就算主处理器死机了，还有一个协处理器来保障安全。</p><h3 id="二、PX4介绍"><a href="#二、PX4介绍" class="headerlink" title="二、PX4介绍"></a>二、PX4介绍</h3><p>PX4固件专为PIXHAWK开发的固件。相对封闭，代码体系相对简单清晰，社区相对小，迭代慢一些，但因为相对清晰，适合学习研究。</p><p>PX4地面控制站被称为QGroundControl，（简称QGC）是PX4自驾系统不可分割的一部分，可以运行在Windows，OS X或Linux等多个平台。可以将PX4固件烧写到硬件，设置机器，改变不同的参数，获得实时航班信息，创建和执行完全自主的任务。</p><h3 id="三、APM介绍"><a href="#三、APM介绍" class="headerlink" title="三、APM介绍"></a>三、APM介绍</h3><p>APM固件专为Arduupilot开发的固件，现也用于PIXHAWK。有ArduCopter社区支撑、开放，功能全、迭代升级快，适合直接用。由于有较多的历史兼容性需求，软件代码体系相对杂乱，还封装了PX4的内核，学习起来困难些。</p><p>APM地面控制站被称为Mission Planner，（简称MP）是APM自驾系统不可分割的一部分。可以将APM固件烧写到硬件，设置机器，改变不同的参数，获得实时航班信息，创建和执行完全自主的任务。</p><p>随着APM飞控软件的快速发展，AVR板子的性能已经不能满足需求，所以只能逐步移植到Pixhawk的硬件架构上来进行开发。所以，APM自驾仪软件也就兼容PIXHAWK飞控硬件了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>PIXHAWK飞控是硬件平台，PX4和APM都是开源固件，均可以烧写到PIXHAWK飞控中。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PX4 </tag>
            
            <tag> PIXHAWK </tag>
            
            <tag> APM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PX4 Offboard Control Using MAVROS on Gazebo</title>
      <link href="2021/07/23/ros-notes-6/"/>
      <url>2021/07/23/ros-notes-6/</url>
      
        <content type="html"><![CDATA[<h1 id="PX4-Offboard-Control-Using-MAVROS-on-Gazebo"><a href="#PX4-Offboard-Control-Using-MAVROS-on-Gazebo" class="headerlink" title="PX4 Offboard Control Using MAVROS on Gazebo"></a>PX4 Offboard Control Using MAVROS on Gazebo</h1><p>最近在学习PX4和mavros，感觉px4官网的教程总体上讲得不错，但有一些地方不是很友好，比如offboard control这一块儿，讲的比较简单，省略了gazebo的使用，我上网查了一大堆资料才勉强把这个示例代码在gazebo中跑出来。所以这里做一个记录，希望对看到的人有点帮助。</p><h2 id="安装MAVROS"><a href="#安装MAVROS" class="headerlink" title="安装MAVROS"></a>安装MAVROS</h2><blockquote><p>介绍安装mavros的两种方式，建议参考：<a href="https://docs.px4.io/master/en/ros/mavros_installation.html">ROS with MAVROS Installation Guide</a>。</p></blockquote><h3 id="方法一：二进制安装-Debian-Ubuntu"><a href="#方法一：二进制安装-Debian-Ubuntu" class="headerlink" title="方法一：二进制安装 (Debian / Ubuntu)"></a>方法一：二进制安装 (Debian / Ubuntu)</h3><p>ROS 存储库包含适用于 Ubuntu x86、amd64 (x86_64) 和 armhf (ARMv7) 的二进制包。Kinetic 还支持 Debian Jessie amd64 和 arm64 (ARMv8)。</p><p>使用<code>apt-get</code>安装：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> ros-melodic-mavros ros-melodic-mavros-extras<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后安装<a href="https://geographiclib.sourceforge.io/">GeographicLib</a>通过运行<code>install_geographiclib_datasets.sh</code>脚本获取数据集：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://raw.githubusercontent.com/mavlink/mavros/master/mavros/scripts/install_geographiclib_datasets.sh<span class="token function">sudo</span> <span class="token function">bash</span> ./install_geographiclib_datasets.sh   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="方法二：源码安装"><a href="#方法二：源码安装" class="headerlink" title="方法二：源码安装"></a>方法二：源码安装</h3><p>此安装假定您有一个 catkin 工作区位于<code>~/catkin_ws</code>如果您不使用以下内容创建一个：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> ~/catkin_ws/src<span class="token builtin class-name">cd</span> ~/catkin_wscatkin initwstool init src<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>您将使用 ROS Python 工具：<em>wstool</em>（用于检索源）、<em>rosinstall</em>和<em>catkin_tools</em>（构建）进行此安装。虽然它们可能是在您安装 ROS 期间安装的，但您也可以通过以下方式安装它们：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> python-catkin-tools python-rosinstall-generator <span class="token parameter variable">-y</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>虽然可以使用<strong>catkin_make</strong>构建包，但首选方法是使用<strong>catkin_tools，</strong>因为它是一种更通用且“友好”的构建工具。</p></blockquote><p>如果这是您第一次使用 wstool，则需要使用以下命令初始化源空间：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wstool init ~/catkin_ws/src<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在您已准备好进行构建</p><ol><li><p>安装 MAVLink；</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># We use the Kinetic reference for all ROS distros as it's not distro-specific and up to date</span>rosinstall_generator <span class="token parameter variable">--rosdistro</span> kinetic mavlink <span class="token operator">|</span> <span class="token function">tee</span> /tmp/mavros.rosinstall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>使用已发布或最新版本从源代码安装 MAVROS；</p><ul><li><p>发行版 / 稳定版</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rosinstall_generator <span class="token parameter variable">--upstream</span> mavros <span class="token operator">|</span> <span class="token function">tee</span> <span class="token parameter variable">-a</span> /tmp/mavros.rosinstall<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>最新源码</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rosinstall_generator --upstream-development mavros <span class="token operator">|</span> <span class="token function">tee</span> <span class="token parameter variable">-a</span> /tmp/mavros.rosinstall<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># For fetching all the dependencies into your catkin_ws, </span><span class="token comment"># just add '--deps' to the above scripts, E.g.:</span><span class="token comment">#   rosinstall_generator --upstream mavros --deps | tee -a /tmp/mavros.rosinstall</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>创建工作区 &amp; 安装依赖；</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wstool merge <span class="token parameter variable">-t</span> src /tmp/mavros.rosinstallwstool update <span class="token parameter variable">-t</span> src <span class="token parameter variable">-j4rosdep</span> <span class="token function">install</span> --from-paths src --ignore-src <span class="token parameter variable">-y</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>安装 <a href="https://geographiclib.sourceforge.io/">GeographicLib</a>数据集；</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./src/mavros/mavros/scripts/install_geographiclib_datasets.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>构建；</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">catkin build<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>确保您使用工作区中的 setup.bash 或 setup.zsh。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#Needed or rosrun can't find nodes from this workspace.</span><span class="token builtin class-name">source</span> devel/setup.bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><p>出现错误的情况下，<a href="https://github.com/mavlink/mavros/tree/master/mavros#installation">mavros repo</a>还有额外的安装和故障排除说明。</p><h2 id="构建offboard-control示例程序"><a href="#构建offboard-control示例程序" class="headerlink" title="构建offboard control示例程序"></a>构建offboard control示例程序</h2><blockquote><p>这里介绍构建官网示例代码的步骤，代码解读请参考：<a href="https://docs.px4.io/master/en/ros/mavros_offboard.html">MAVROS <em>Offboard</em> control example</a></p></blockquote><p>进入你的工作区并且创建一个包：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~/catkin_ws/srccatkin_create_pkg offboard_pkg roscpp std_msgs geometry_msgs mavros_msgs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在目录<code>~/catkin_ws/src/offboard_pkg/src/</code>中，新建一个文件<code>offboard_node.cpp</code>，写入如下的代码：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/** * @file offb_node.cpp * @brief Offboard control example node, written with MAVROS version 0.19.x, PX4 Pro Flight * Stack and tested in Gazebo SITL */</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;ros/ros.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;geometry_msgs/PoseStamped.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mavros_msgs/CommandBool.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mavros_msgs/SetMode.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;mavros_msgs/State.h&gt;</span></span>mavros_msgs<span class="token double-colon punctuation">::</span>State current_state<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">state_cb</span><span class="token punctuation">(</span><span class="token keyword">const</span> mavros_msgs<span class="token double-colon punctuation">::</span>State<span class="token double-colon punctuation">::</span>ConstPtr<span class="token operator">&amp;</span> msg<span class="token punctuation">)</span><span class="token punctuation">{</span>    current_state <span class="token operator">=</span> <span class="token operator">*</span>msg<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    ros<span class="token double-colon punctuation">::</span><span class="token function">init</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token string">"offb_node"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ros<span class="token double-colon punctuation">::</span>NodeHandle nh<span class="token punctuation">;</span>    ros<span class="token double-colon punctuation">::</span>Subscriber state_sub <span class="token operator">=</span> nh<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">subscribe</span><span class="token generic class-name"><span class="token operator">&lt;</span>mavros_msgs<span class="token double-colon punctuation">::</span>State<span class="token operator">&gt;</span></span></span>            <span class="token punctuation">(</span><span class="token string">"mavros/state"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> state_cb<span class="token punctuation">)</span><span class="token punctuation">;</span>    ros<span class="token double-colon punctuation">::</span>Publisher local_pos_pub <span class="token operator">=</span> nh<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">advertise</span><span class="token generic class-name"><span class="token operator">&lt;</span>geometry_msgs<span class="token double-colon punctuation">::</span>PoseStamped<span class="token operator">&gt;</span></span></span>            <span class="token punctuation">(</span><span class="token string">"mavros/setpoint_position/local"</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ros<span class="token double-colon punctuation">::</span>ServiceClient arming_client <span class="token operator">=</span> nh<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">serviceClient</span><span class="token generic class-name"><span class="token operator">&lt;</span>mavros_msgs<span class="token double-colon punctuation">::</span>CommandBool<span class="token operator">&gt;</span></span></span>            <span class="token punctuation">(</span><span class="token string">"mavros/cmd/arming"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ros<span class="token double-colon punctuation">::</span>ServiceClient set_mode_client <span class="token operator">=</span> nh<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">serviceClient</span><span class="token generic class-name"><span class="token operator">&lt;</span>mavros_msgs<span class="token double-colon punctuation">::</span>SetMode<span class="token operator">&gt;</span></span></span>            <span class="token punctuation">(</span><span class="token string">"mavros/set_mode"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//the setpoint publishing rate MUST be faster than 2Hz</span>    ros<span class="token double-colon punctuation">::</span>Rate <span class="token function">rate</span><span class="token punctuation">(</span><span class="token number">20.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// wait for FCU connection</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>ros<span class="token double-colon punctuation">::</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>current_state<span class="token punctuation">.</span>connected<span class="token punctuation">)</span><span class="token punctuation">{</span>        ros<span class="token double-colon punctuation">::</span><span class="token function">spinOnce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        rate<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    geometry_msgs<span class="token double-colon punctuation">::</span>PoseStamped pose<span class="token punctuation">;</span>    pose<span class="token punctuation">.</span>pose<span class="token punctuation">.</span>position<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    pose<span class="token punctuation">.</span>pose<span class="token punctuation">.</span>position<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    pose<span class="token punctuation">.</span>pose<span class="token punctuation">.</span>position<span class="token punctuation">.</span>z <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment">//send a few setpoints before starting</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> ros<span class="token double-colon punctuation">::</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>        local_pos_pub<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span>pose<span class="token punctuation">)</span><span class="token punctuation">;</span>        ros<span class="token double-colon punctuation">::</span><span class="token function">spinOnce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        rate<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    mavros_msgs<span class="token double-colon punctuation">::</span>SetMode offb_set_mode<span class="token punctuation">;</span>    offb_set_mode<span class="token punctuation">.</span>request<span class="token punctuation">.</span>custom_mode <span class="token operator">=</span> <span class="token string">"OFFBOARD"</span><span class="token punctuation">;</span>    mavros_msgs<span class="token double-colon punctuation">::</span>CommandBool arm_cmd<span class="token punctuation">;</span>    arm_cmd<span class="token punctuation">.</span>request<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    ros<span class="token double-colon punctuation">::</span>Time last_request <span class="token operator">=</span> ros<span class="token double-colon punctuation">::</span><span class="token class-name">Time</span><span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>ros<span class="token double-colon punctuation">::</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span> current_state<span class="token punctuation">.</span>mode <span class="token operator">!=</span> <span class="token string">"OFFBOARD"</span> <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span>ros<span class="token double-colon punctuation">::</span><span class="token class-name">Time</span><span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> last_request <span class="token operator">&gt;</span> ros<span class="token double-colon punctuation">::</span><span class="token function">Duration</span><span class="token punctuation">(</span><span class="token number">5.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span> set_mode_client<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>offb_set_mode<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                offb_set_mode<span class="token punctuation">.</span>response<span class="token punctuation">.</span>mode_sent<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">ROS_INFO</span><span class="token punctuation">(</span><span class="token string">"Offboard enabled"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            last_request <span class="token operator">=</span> ros<span class="token double-colon punctuation">::</span><span class="token class-name">Time</span><span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token operator">!</span>current_state<span class="token punctuation">.</span>armed <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span>ros<span class="token double-colon punctuation">::</span><span class="token class-name">Time</span><span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> last_request <span class="token operator">&gt;</span> ros<span class="token double-colon punctuation">::</span><span class="token function">Duration</span><span class="token punctuation">(</span><span class="token number">5.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span> arming_client<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arm_cmd<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    arm_cmd<span class="token punctuation">.</span>response<span class="token punctuation">.</span>success<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token function">ROS_INFO</span><span class="token punctuation">(</span><span class="token string">"Vehicle armed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                last_request <span class="token operator">=</span> ros<span class="token double-colon punctuation">::</span><span class="token class-name">Time</span><span class="token double-colon punctuation">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        local_pos_pub<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span>pose<span class="token punctuation">)</span><span class="token punctuation">;</span>        ros<span class="token double-colon punctuation">::</span><span class="token function">spinOnce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        rate<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后打开目录<code>~/catkin_ws/src/offboard_pkg/</code>下的<code>CMakeLists.txt</code>添加下面的两行：</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">add_executable</span><span class="token punctuation">(</span>offboard_node src/offboard_node.cpp<span class="token punctuation">)</span><span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>offboard_node <span class="token punctuation">${</span>catkin_LIBRARIES<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后到目录<code>~/catkin_ws</code>下，运行命令，完成编译：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">catkin_make<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后你可以在~.bashrc或者~.zshrc中写入source该工作空间的指令，如果出现了工作空间覆盖的问题，可以参考我的另外一篇博客<a href="https://immortalqx.github.io/2021/07/17/ros-notes-3/">解决source多个ROS工作空间时的覆盖问题</a>。</p><h2 id="安装PX4-Autopilot"><a href="#安装PX4-Autopilot" class="headerlink" title="安装PX4-Autopilot"></a>安装PX4-Autopilot</h2><blockquote><p>网上有一些教程讲的是Firmware，但两个应该都是一样的。</p></blockquote><h3 id="下载PX4-Autopilot"><a href="#下载PX4-Autopilot" class="headerlink" title="下载PX4-Autopilot"></a>下载PX4-Autopilot</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/PX4/PX4-Autopilot.git<span class="token builtin class-name">cd</span> PX4-Autopilot<span class="token function">git</span> checkout v1.12.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="编译PX4-Autopilot"><a href="#编译PX4-Autopilot" class="headerlink" title="编译PX4-Autopilot"></a>编译PX4-Autopilot</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> distclean<span class="token function">make</span> px4_sitl_default gazebo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>请确保<em>make px4_sitl_default gazebo</em>命令执行成功，如有报错信息，根据报错信息来进行修复即可。</p><p>在这条指令运行成功之后，gazebo会打开，你会看到如下的界面：</p><p><img src="/images/ros-notes/6-1.png"></p><h3 id="修改-bashrc或者-zshrc（optional）"><a href="#修改-bashrc或者-zshrc（optional）" class="headerlink" title="修改~.bashrc或者~.zshrc（optional）"></a>修改~.bashrc或者~.zshrc（optional）</h3><p>这一步不影响我们在gazebo中运行Offboard Control示例程序，但还是建议修改一下。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ~/PX4-Autopilot/Tools/setup_gazebo.bash ~/PX4-Autopilot ~/PX4-Autopilot/build/px4_sitl_defaultexport<span class="token builtin class-name">export</span> <span class="token assign-left variable">ROS_PACKAGE_PATH</span><span class="token operator">=</span><span class="token variable">$ROS_PACKAGE_PATH</span>:~/PX4-Autopilotexport<span class="token builtin class-name">export</span> <span class="token assign-left variable">ROS_PACKAGE_PATH</span><span class="token operator">=</span><span class="token variable">$ROS_PACKAGE_PATH</span>:~/PX4-Autopilot/Tools/sitl_gazebo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="在Gazebo中运行Offboard-Control示例程序"><a href="#在Gazebo中运行Offboard-Control示例程序" class="headerlink" title="在Gazebo中运行Offboard Control示例程序"></a>在Gazebo中运行Offboard Control示例程序</h2><h3 id="启动Gazebo"><a href="#启动Gazebo" class="headerlink" title="启动Gazebo"></a>启动Gazebo</h3><p>像之前一样，进入到PX4-Autopilot的目录中，运行如下指令打开Gazebo：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> px4_sitl_default gazebo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="运行MAVROS"><a href="#运行MAVROS" class="headerlink" title="运行MAVROS"></a>运行MAVROS</h3><p><strong>mavlink会开放<code>14557</code>, 接到这个端口将会接收到实际飞行中发出的所有数据。</strong></p><p>若要连接到一个特定的IP(fcu_url是SITL的IP/端口)，请使用一个如下形式的URL:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">roslaunch mavros px4.launch fcu_url:<span class="token operator">=</span><span class="token string">"udp://:14540@192.168.1.36:14557"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>连接本地:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">roslaunch mavros px4.launch fcu_url:<span class="token operator">=</span><span class="token string">"udp://:14540@127.0.0.1:14557"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里我们在自己的电脑上运行，因此使用连接本地的指令即可。</p><h3 id="运行offboard-node"><a href="#运行offboard-node" class="headerlink" title="运行offboard_node"></a>运行offboard_node</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rosrun offboard_pkg offboard_node<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最终的效果应该如下图所示，gazebo中的无人机起飞并且悬停在了空中。</p><p><img src="/images/ros-notes/6-2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MAVROS </tag>
            
            <tag> PX4 </tag>
            
            <tag> Gazebo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS中的URDF</title>
      <link href="2021/07/18/ros-notes-5/"/>
      <url>2021/07/18/ros-notes-5/</url>
      
        <content type="html"><![CDATA[<h1 id="ROS中的URDF"><a href="#ROS中的URDF" class="headerlink" title="ROS中的URDF"></a>ROS中的URDF</h1><h2 id="什么是URDF"><a href="#什么是URDF" class="headerlink" title="什么是URDF"></a>什么是URDF</h2><ul><li><p>Unified Robot Description Format，统一机器人描述格式，简称为URDF；</p></li><li><p>ROS中一个非常重要的机器人模型描述格式；</p></li><li><p>URDF文件使用XML格式描述机器人模型；</p></li><li><p>ROS中的urdf功能包包含一个URDF的C++解析器。</p></li></ul><h2 id="URDF标签说明"><a href="#URDF标签说明" class="headerlink" title="URDF标签说明"></a>URDF标签说明</h2><h3 id="lt-link-gt"><a href="#lt-link-gt" class="headerlink" title="<link>"></a>&lt;link&gt;</h3><p><strong>作用：</strong></p><ul><li>描述机器人某个刚体部分的外观和物理属性；</li><li>尺寸（size）、颜色（color）、形状（shape）、惯性矩阵（inertial matrix）、碰撞参数（collision properties）等。</li></ul><img src="/images/ros-notes/5-1.png" style="zoom:33%;"><p><strong>子标签：</strong></p><ul><li>&lt;visual&gt;：描述机器人link部分的外观参数；</li><li>&lt;inertial&gt;：描述link的惯性参数；</li><li>&lt;collision&gt;：描述link的碰撞属性。</li></ul><img src="/images/ros-notes/5-2.png" style="zoom: 67%;"><h3 id="lt-joint-gt"><a href="#lt-joint-gt" class="headerlink" title="<joint>"></a>&lt;joint&gt;</h3><p><strong>作用：</strong></p><ul><li>描述机器人关节的运动学和动力学属性；</li><li>包括关节运动的位置和速度限制；</li><li>根据关节运动的形式，可以将其分为六种类型。</li></ul><img src="/images/ros-notes/5-3.png" style="zoom:33%;"><table><thead><tr><th>关节类型</th><th>描述</th></tr></thead><tbody><tr><td>continuous</td><td>旋转关节，可以围绕单轴无限旋转</td></tr><tr><td>revolute</td><td>旋转关节，类似于continuous，但有旋转的角度限制</td></tr><tr><td>prismatic</td><td>滑动关节，沿某一轴线移动的关节，带有位置极限</td></tr><tr><td>planar</td><td>平面关节，允许在平面正交方向上平移或者旋转</td></tr><tr><td>floating</td><td>浮动关节，允许进行平移、旋转运动</td></tr><tr><td>fixed</td><td>固定关节，不允许运动的特殊关节</td></tr></tbody></table><p><strong>子标签：</strong></p><ul><li>&lt;calibration&gt;：关节的参考位置，用来校准关节的绝对位置；</li><li>&lt;dynamics&gt;：描述关节的物理属性，例如阻尼值、物理静摩擦力等，经常在动力学仿真中用到；</li><li>&lt;limit&gt;：描述运动的一些极限值，包括关节运动的上下限位置、速度限制、力矩限制等；</li><li>&lt;mimic&gt;：描述该关节与已有关节的关系；</li><li>&lt;safety＿controller&gt;：描述安全控制器参数。 </li></ul><img src="/images/ros-notes/5-4.png" style="zoom:67%;"><h3 id="lt-robot-gt"><a href="#lt-robot-gt" class="headerlink" title="<robot>"></a>&lt;robot&gt;</h3><ul><li>完整机器人模型的最顶层标签；</li><li>&lt;link&gt;和&lt;joint&gt;标签都必须包含在&lt;robot&gt;标签内。</li></ul><img src="/images/ros-notes/5-5.png" style="zoom:33%;"><p>一个完整的机器人模型，由一系列&lt;link&gt;和&lt;joint&gt;组成。</p><img src="/images/ros-notes/5-6.png" style="zoom:67%;"><h2 id="URDF建模优化"><a href="#URDF建模优化" class="headerlink" title="URDF建模优化"></a>URDF建模优化</h2><h3 id="URDF建模存在的问题："><a href="#URDF建模存在的问题：" class="headerlink" title="URDF建模存在的问题："></a>URDF建模存在的问题：</h3><ol><li>模型冗长，重复内容过多；</li><li>参数修改麻烦，不便于二次开发；</li><li>没有参数计算的功能。</li></ol><h3 id="URDF模型的进化版本——xacro模型文件"><a href="#URDF模型的进化版本——xacro模型文件" class="headerlink" title="URDF模型的进化版本——xacro模型文件"></a>URDF模型的进化版本——xacro模型文件</h3><ul><li>精简模型代码<ul><li>创建宏定义</li><li>文件包含</li></ul></li><li>提供可编程接口<ul><li>常量</li><li>变量</li><li>数学计算</li><li>条件语句</li></ul></li></ul><h3 id="常量的定义和使用"><a href="#常量的定义和使用" class="headerlink" title="常量的定义和使用"></a>常量的定义和使用</h3><p>常量定义：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">sacro:</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>M_PI<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>3.14159<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常量使用：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>origin</span> <span class="token attr-name">xyz</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0 0 0<span class="token punctuation">"</span></span> <span class="token attr-name">rpy</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${M_PI/2} 0 0<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/images/ros-notes/5-7.png" style="zoom:67%;"><h3 id="数学计算"><a href="#数学计算" class="headerlink" title="数学计算"></a>数学计算</h3><p>数学计算：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>origin</span> <span class="token attr-name">xyz</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0 ${(motor_length+wheel_length)/2} 0<span class="token punctuation">"</span></span> <span class="token attr-name">rpx</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0 0 0<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/images/ros-notes/5-8.png" style="zoom:67%;"><p>注意：所有的数学运算都会转换成浮点数进行，以保证运算精度。</p><h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><p>宏定义：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">sacro:</span>macro</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">params</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>A B C<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    ......<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">sacro:</span>macros</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>宏调用：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span> <span class="token attr-name">A</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>A_value<span class="token punctuation">"</span></span> <span class="token attr-name">B</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>B_value<span class="token punctuation">"</span></span> <span class="token attr-name">C</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>C_value<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/images/ros-notes/5-9.png" style="zoom:67%;"><h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><p>文件包含：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">xacro:</span>include</span> <span class="token attr-name">filename</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(find mbot_description)/urdf/xacro/mbot_base.xacro<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="/images/ros-notes/5-10.png" style="zoom:67%;"><h3 id="模型显示"><a href="#模型显示" class="headerlink" title="模型显示"></a>模型显示</h3><p>方法一：将xacro文件转换成URDF文件后显示</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rosrun xacro xacro.py mbot.xacro<span class="token operator">&gt;</span>mbot.urdf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方法二：直接调用xacro文件解析器</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>model<span class="token punctuation">"</span></span> <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(find xacro)/xacro --inorder '$(find mbot_description)/urdf/xacro/mbot.xacro'<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>robot_description<span class="token punctuation">"</span></span> <span class="token attr-name">command</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg model)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">roslaunch mbot_description display_mbot_base_xacro.launch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>相关学习资料：<a href="http://wiki.ros.org/urdf/Tutorials">http://wiki.ros.org/urdf/Tutorials</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS中的TF</title>
      <link href="2021/07/18/ros-notes-4/"/>
      <url>2021/07/18/ros-notes-4/</url>
      
        <content type="html"><![CDATA[<h1 id="ROS中的TF"><a href="#ROS中的TF" class="headerlink" title="ROS中的TF"></a>ROS中的TF</h1><h2 id="TF介绍"><a href="#TF介绍" class="headerlink" title="TF介绍"></a>TF介绍</h2><p>TF(TransForm)，就是坐标转换，包括了位置和姿态两个方面的变换。这里需要注意<strong>区分坐标转换和坐标系转换</strong>，坐标转换是一个坐标在不同坐标系下的表示，而坐标系转换不同坐标系的相对位姿关系。</p><p>ROS中机器人模型包含大量的部件，每一个部件统称之为<strong>link</strong>（比如手部、头部、某个关节、某个连杆），每一个link上面对应着一个<strong>frame（坐标系）</strong>， 用frame表示该部件的坐标系，frame和link是绑定在一起的。</p><p>tf是一个通俗的名称，实际上它有很多含义：</p><ol><li>可以被当做是一种标准规范，这套标准定义了坐标转换的数据格式和数据结构。tf本质是树状的数据结构，即”<strong>tf tree</strong>“。</li><li>tf也可以看成是一个话题<code>/tf</code>，<strong>话题中的消息保存的就是tf tree的数据结构格式</strong>。维护了整个机器人的甚至是地图的坐标转换关系。维持并更新机器人整个坐标系的话题是<code>/tf</code>，<code>/tf</code>话题表示的内容是整个机器人的tf树，而非仅仅是某两个坐标系的转换关系，这样的话，<code>/tf</code>话题是需要很多的节点来维护的，每一个节点维护两个frame之间的关系。</li><li>tf还可以看成是一个package，它当中包含了很多的工具。比如可视化，查看关节间的tf，debug tf等等。</li><li>tf含有一部分的API接口，用来节点程序中的编程。tf对发布器与订阅器进行了封装，使开发者通过tf的接口更加简单地建立对tf树中某些坐标系转换关系的维护与订阅。</li></ol><p>tf是一个树状结构，维护坐标系之间的关系，靠<strong>话题通信机制</strong>来持续地发布不同link之间的坐标关系。作为树状结构，要保证父子坐标系都有某个节点在持续地发布他们之间的位姿关系，才能使树状结构保持完整。只有父子坐标系的位姿关系能被正确的发布，才能保证任意两个frame之间的连通。</p><p>如果出现某一环节的断裂，就会引发error系统报错。所以完整的tf tree不能有任何断层的地方，这样我们才能查清楚任意两个frame之间的关系。</p><p>每两个相邻frame之间靠节点发布它们之间的位姿关系，这种节点称为broadcaster。broadcaster就是一个发布器publisher，如果两个frame之间发生了相对运动，broadcaster就会发布相关消息。</p><h2 id="TF的原理"><a href="#TF的原理" class="headerlink" title="TF的原理"></a>TF的原理</h2><h3 id="TF树的结构"><a href="#TF树的结构" class="headerlink" title="TF树的结构"></a>TF树的结构</h3><p>tf库的目的是实现系统中任一个点在所有坐标系之间的坐标变换。也就是说，只要给定一个坐标系下的一个点的坐标，就能获得这个点在其他任意坐标系的坐标。</p><p>为了达到上述目的，就需要提供当前ROS系统的中任意两个坐标系的位姿变换关系。</p><p>那么tf是用什么方式来描述与记录任意两个坐标系的位姿变换关系的呢？</p><blockquote><p>这里存在一个问题。假设有n个坐标系，那么他们之间的组合关系有c（n，2）个。如果这样穷举个数会非常多，所以不会采用这个方法。</p></blockquote><p>为了更合理、更高效地表示任意坐标系的变换关系。tf使用多层多叉树的形式来描述这个这个ROS系统的坐标系，树中的每一个节点都是一个坐标系。tf树的特点是每个节点只要一个父节点，即采用每个坐标系都有一个父坐标系，可以有多个子坐标系的原则。</p><h3 id="TF坐标系表示规范"><a href="#TF坐标系表示规范" class="headerlink" title="TF坐标系表示规范"></a>TF坐标系表示规范</h3><p>每个坐标系都有一个父坐标系，可以有多个子坐标系。tf树就是以父子坐标系的形式来组织的，最上面是父坐标系，往下是子坐标系。</p><p>在tf树中具有父子关系的坐标系是相邻的，用带箭头的线连接起来。在tf树中用箭头表示这种父子关系。</p><p><strong>描述规范：</strong></p><ol><li>source、target frame是在<strong>进行坐标变换</strong>时的概念，source是坐标变换的源坐标系，target是目标坐标系。这个时候，这个变换代表的是<strong>坐标变换</strong>。</li><li>parent、child frame是在<strong>描述坐标系变换</strong>时的概念，parent是原坐标系，child是变换后的坐标系，这个时候这个变换<strong>描述的是坐标系变换</strong>，也是child坐标系在parent坐标系下的描述。</li><li>a frame到b frame的坐标系变换（frame transform），也表示了b frame在a frame的描述，也代表了把一个点在b frame里坐标变换成在a frame里坐标的<strong>坐标变换</strong>。</li><li>从parent到child的坐标系变换（frame transform）等同于把一个点从child坐标系向parent坐标系的<strong>坐标变换</strong>，等于child坐标系在parent frame坐标系的姿态描述。</li></ol><h3 id="TF树的通信方式与TF树的具体表示"><a href="#TF树的通信方式与TF树的具体表示" class="headerlink" title="TF树的通信方式与TF树的具体表示"></a>TF树的通信方式与TF树的具体表示</h3><p>tf树的建立和维护是基于Topic通信机制的。</p><p>根据tf树的原理，它是靠建立与维护每个父子坐标系的变换关系来维护整个系统的所有坐标系的变换关系的。每个parent 坐标系到child坐标系变换关系是靠被称为broadcastor的发布器节点来持续发布的。</p><p>虽然是靠Topic通信机制发布的parent 坐标系到child坐标系的变换，但并不是让每一对父子坐标系都发布一个话题，<strong>实际上发布的唯一个话题是<code>/topic</code>，该话题集合了所有发布的父子坐标系的变换关系。</strong></p><p>也就是说tf机制并不是让每一对父子坐标系都发布一个话题，而是将所有的父子坐标系都集合到到一个话题上，该话题的消息中传递的数据是所有父子坐标系的变换关系，是父子坐标系变换关系的一个大数组。</p><p>使用tf的tflisener就可以监听从任意两个坐标系的变换。前提是tf的树上能把这两个联通。</p><h3 id="TF树的建立"><a href="#TF树的建立" class="headerlink" title="TF树的建立"></a>TF树的建立</h3><p>在开始建立tf树的时候需要指定第一个父坐标系（parent frame）作为最初的坐标系。比如机器人系统中的map坐标系。</p><p>在第一次发布一个从已有的parent frame到新的child frame的坐标系变换时，这棵树就会添加一个树枝，之后就是维护。</p><p>tf树的建立和维护靠的是tf提供的tfbroadcastor类的sendtransform接口。</p><blockquote><p><code>transformBroadcaster</code>类就是一个publisher，而sendTransform的作用是来封装publish的函数。</p></blockquote><h3 id="TF树的维护"><a href="#TF树的维护" class="headerlink" title="TF树的维护"></a>TF树的维护</h3><p>在运行过程中要不断更新已有的parent frame到已有的child frame的坐标系变换，从而保证最新的位姿转换关系。</p><p>作为树状结构，要保证父子frame都有某个节点在持续地发布这两个frame之间的位姿关系，才能使树状结构保持完整。只有每一个父子的frame的位姿关系能被正确的发布，才能保证任意两个frame之间的连通。</p><h3 id="TF树的使用"><a href="#TF树的使用" class="headerlink" title="TF树的使用"></a>TF树的使用</h3><p>一旦正常的建立一个tf树，保证每个父子坐标系都能得到正常的维护，那么就可以利用tf提供的订阅器，订阅任意两个坐标系的转换关系。</p><p><strong>如何根据tf树得到任意坐标系的转换关系？</strong></p><p>如果想要获得任意两个坐标系的转换关系，其实订阅器是收取的<code>/tf</code>话题上的消息，该消息集合了所有发布的父子坐标系的变换关系。订阅器接收的其实是当前时刻的整个tf树，然后搜索这棵树，根据不同的父子坐标系关系找到一条变换的路径。这条变换路径就能通过父子关系通路连接起所求的这两个坐标系，从而通过不断将该通路上的变换矩阵相乘得到最终的所求的这两个坐标系的变换关系。</p><blockquote><p>tf对发布器与订阅器进行了封装，使开发者通过tf的接口更加简单地建立对tf树中某些坐标系转换关系的维护与订阅。用tf的tflisener监听某一个指定的从一个a frame到b frame的变换即可。</p></blockquote><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>基本原理是，tfbroadcastor的类里有个publisher，tflisener的类里有个subscriber，一个发布叫<code>/tf</code>的topic，一个订阅这个topic，传送的消息message里包含了每一对parent frameid和child frameid的信息。这个机制意味着，所有的tfbroadcastor会发布某一特定的parent到child的变换，而所有tflisener会收到所有的这些变换，然后tflisener利用一个tfbuffercore的数据结构维护一个完整的树结构及其状态。</p><p>基于此，tflisener在使用这棵树时，会用lookuptransform或waitfortransform来获得任意坐标系之间的变换。这样即使只要是一个tflisener（即只监听两个坐标系的变换关系），就要跟所有tfbroadcastor建立连接，就要收取<code>/tf</code>上的整个tf树，还要负责搜索这棵树，找到一条变换的路径，然后通过变换矩阵相乘得到两个坐标系最终的变换关系。</p><h2 id="TF的特点"><a href="#TF的特点" class="headerlink" title="TF的特点"></a>TF的特点</h2><p><strong>优点：</strong></p><ol><li>各种数值计算的细节，你不用考虑，tf库可以帮你</li><li>接口很简洁，会广播和监听就行；</li><li>问题找的很准，那就是需要维护坐标系之间的关系，尤其是父子坐标系的关系</li><li>提供了很多工具程序</li><li>考虑了与时间相关的变换</li><li>支持tf-prefix，可以在多机器人上用。通过让不同机器人使用不同的prefix，来区分机器人。如果只有一个机器人一般是使用<code>/</code></li></ol><p><strong>缺点：</strong></p><ol><li>树的结构很简单，但有时候很笨拙。对于同级的坐标系，就需要从下到上找共同先辈，然后从这个先辈再往下找，进而确定二者的关系。</li><li>每个订阅器要想获得某两个坐标系的关系都要搜索同一颗树，这样的开销太大，主要是网络传输的负荷比较大。</li><li>很难满足实时性的要求，这一点比较显然。这也是为什么tf会将每个变换存10秒钟的数据</li><li>虽然整体比较容易上手但是很多细节不易理解。比如，now（）和time（0）；比如，技术文档里的一些术语名词；比如，采用了机器人里的习惯，与飞行器，惯导，车辆里的习惯区别较大，使用时不能想当然。</li></ol><h2 id="TF消息：两个frame之间的消息"><a href="#TF消息：两个frame之间的消息" class="headerlink" title="TF消息：两个frame之间的消息"></a>TF消息：两个frame之间的消息</h2><p>每个父子坐标系之间都会有broadcaster节点来发布消息维系坐标之间的转换关系。<code>TransformStampde.msg</code>就是<code>/tf</code>话题上消息。该消息格式用来表示两个frame之间一小段tf变换的相对坐标关系的。</p><p>说明：</p><p>ROS中实际上是靠tf tree来表示整个系统的坐标系关系的，而非简单地靠多个两两父子坐标系的转换关系来描述的。这里的<code>TransformStampde.msg</code>消息的tf tree消息类型的片段即其中的一对父子坐标系位姿的描述方式，tf tree消息类型基于<code>TransformStampde.msg</code>消息，因此先介绍<code>TransformStampde.msg</code>。<code>TransformStampde.msg</code>本质上描述的是tf tree中一小段tf变换。</p><p>具体消息类型如下：</p><p><code>geometry_msgs/TransformStamped</code>（可见该消息类型是属于<code>geometry_msgs</code>程序包的，而非tf包）</p><pre class="line-numbers language-none"><code class="language-none">std_mags/Header header        uint32 seq        time stamp        string frame_idstring child_frame_idgeometry_msgs/Transform transform        geometry_msgs/Vector3 translation                float64 x                float64 y                float64 z        geometry_msgs/Quaternion rotation                float64 x                float64 y                flaot64 z                float64 w<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="消息解释："><a href="#消息解释：" class="headerlink" title="消息解释："></a>消息解释：</h3><p>该消息表示的的是当前坐标系frame_id和它的子坐标系child_frame_id之间的转换关系。具体的转换位姿是由<code>geometry_msgs/Transform</code>消息类型来定义的，该消息类型用三维向量表示平移，用四元组表示旋转。</p><h2 id="TF消息：TF树的消息类型"><a href="#TF消息：TF树的消息类型" class="headerlink" title="TF消息：TF树的消息类型"></a>TF消息：TF树的消息类型</h2><p><code>/tf</code>话题表示的内容是整个机器人的tf树，而非仅仅是某两个坐标系的转换关系，这样的话，<code>/tf</code>话题是需要很多的节点来维护的，每一个节点维护两个父子frame之间的关系。即一个<code>/tf</code>话题上面，可能会有很多个node向上面发送消息。</p><p>这样就相当于tf tree是由很多的frame之间tf拼接而成。刚才说的<code>TransformStampde.msg</code>消息类型表示的是两个frame之间tf关系，接下来要介绍真正在<code>/tf</code>话题上进行传输的tf tree的消息类型。</p><p>在tf2中的tf树对应的消息类型是<code>tf2_msgs/TFMessage.msg</code>。可见该消息位于<code>tf2_msgs</code>程序包内。</p><p>tf2_msgs/TFMessage消息的具体格式：</p><pre class="line-numbers language-none"><code class="language-none">geometry_msgs/TransformStamped[] transforms        std_msgs/Header header                uint32 seq                time stamp                string frame_id        string child_frame_id        geometry_msgs/Transform transform                geometry_msgs/Vector3 translation                        float64 x                        float64 y                        float64 z                geometry_msgs/Quaternion rotation                        float64 x                        float64 y                        flaot64 z                        float64 w<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出tf树的消息类型实际上就是一个<code>TransformStamped</code>类型定义的可变长度数组。也就是说本质就是由很多个两个frame之间的tf消息<code>TransformStamped</code>形成描述整个机器人的tf树的消息类型<code>tf2_msgs/TFMessage.msg</code>。</p><h2 id="TF在roscpp与rospy中的接口"><a href="#TF在roscpp与rospy中的接口" class="headerlink" title="TF在roscpp与rospy中的接口"></a>TF在roscpp与rospy中的接口</h2><p>无论是roscpp中还是rospy中都有tf库，tf提供了很多有用的接口。这里只大体描述，具体使用的时候再参考具体的资料。</p><p>提供的结构种类：</p><ol><li>数据类型的定义（类）：向量、点、四元数、3*3旋转矩阵、位姿等</li><li>数据转换：给出了旋转矩阵、四元数、欧拉角、旋转轴之间的转换函数</li><li>关于点、向量、角度、四元数等的运算的函数</li><li>tf类，封装好了发布器与订阅器接口。可以将坐标系转换关系发布到<code>/tf</code>话题上的一段transform上；也可以订阅<code>/tf</code>话题，并且得到到从源坐标系到目标坐标系这两个坐标系之间的转换关系。</li></ol><p><code>TransformBroadcaster</code>类就是一个publisher，而sendTransform()的作用是来封装publish的函数。在实际的使用中，我们需要在某个Node中构建tf::TransformBroadcaster类，然后调用sendTransform()，将transform发布到<code>/tf</code>的一段transform上。</p><p><code>TransformListener</code>类就是从<code>/tf</code>上接收的类，继承自tf::Transformer。lookupTransform()用于返回两个坐标系的变换。</p><h2 id="TF程序包相关的命令行使用"><a href="#TF程序包相关的命令行使用" class="headerlink" title="TF程序包相关的命令行使用"></a>TF程序包相关的命令行使用</h2><ol><li><p>用命令行显示当前所有frame的方法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rosrun tf tf_monitor <span class="token comment">#显示当前坐标变换树的信息，主要是名称和实时的时间延时</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rostopic <span class="token builtin class-name">echo</span> /tf <span class="token comment">#以TransformStamped消息类型的数组显示所有父子frame的位姿转换关系</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>根据当前的tf树创建一个pdf图：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rosrun tf view_frames<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个工具首先订阅<code>/tf</code>，订阅5秒钟，根据这段时间接受到的tf信息，绘制成一张tf tree，然后创建成一个pdf图。</p><p>将会以图形的形式显示出tf树中所有的frame和两个frame 的父子关系及其Broadcaster、Average rate等</p></li><li><p>查看当前的tf树：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rosrun rqt_tf_tree rqt_tf_tree<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该命令同样是查询tf tree的，但是与第一个命令的区别是该命令是动态的查询当前的tf tree，当前的任何变化都能当即看到，例如何时断开何时连接，捕捉到这些然后通过rqt插件显示出来。</p></li><li><p>查看两个frame之间的变换关系：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rosrun tf tf_echo<span class="token punctuation">[</span>source_frame<span class="token punctuation">]</span><span class="token punctuation">[</span>target_frame<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将会持续的显示源坐标系和目标坐标系的位姿变换关系。</p></li></ol><p>相关学习资料：<a href="http://wiki.ros.org/tf/Tutorials">http://wiki.ros.org/tf/Tutorials</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决source多个ROS工作空间时的覆盖问题</title>
      <link href="2021/07/17/ros-notes-3/"/>
      <url>2021/07/17/ros-notes-3/</url>
      
        <content type="html"><![CDATA[<h1 id="解决source多个ROS工作空间时的覆盖问题"><a href="#解决source多个ROS工作空间时的覆盖问题" class="headerlink" title="解决source多个ROS工作空间时的覆盖问题"></a>解决source多个ROS工作空间时的覆盖问题</h1><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><strong>在~/.zshrc或者~/.bashrc中source 了多个工作空间，但有的工作空间并没有被成功source</strong></p><p>使用ros有时需要多个利用多个工作空间，但每打开一个终端就要source一次工作空间比较麻烦。将工作空间的setup.sh脚本写入~/.zshrc或者~/.bashrc中是一种较为方便的做法。</p><p>但有时候，有一些工作空间并不会被成功的source。在这样的情况下，<code>roslaunch</code>也不给自动补全，强行打出全名运行时也会报错，<code>echo $ROS_PACKAGE_PATH </code>输出的信息里面也看不见那几个包。</p><p>可能的原因是因为source 的部分工作空间在写入~/.zshrc或者~/.bashrc时没有编译导致顺序错乱。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p>比较方便的解决方法是，找到~/.zshrc或者~/.bashrc中最后被source的工作空间，然后修改其devel文件夹下的setup_util.py文件，查找CMAKE_PREFIX_PATH，在其中键入缺少的工作空间的devel路径，保存退出。之后重新打开一个终端时，应该所有工作空间都会被成功source了。</p><p>以下图为例，你需要找到的是<code>/home/lqx/catkin_workspace/catkin_drive</code>这个工作空间。</p><p><img src="/images/ros-notes/3-1.png"></p><p>之后，在其devel文件夹下的setup_util.py文件中查找查找CMAKE_PREFIX_PATH，找到如下图所示的部分。</p><p><img src="/images/ros-notes/3-2.png"></p><p>在其中键入缺少的工作空间的devel路径，具体的操作如下图所示。</p><p><img src="/images/ros-notes/3-3.png"></p><p>修改好之后，重新打开一个终端，或者在现有终端下重新source ~/.zshrc或者~/.bashrc文件即可。</p><p><strong>检验：</strong></p><p>可以查看<code>roslaunch</code>指令是否能自动补全工作空间中的包，并且能否成功的运行；</p><p>也可以检查<code>echo $ROS_PACKAGE_PATH </code>指令输出的信息中是否包含你所有的工作空间。</p><h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>修改~/.zshrc或者~/.bashrc中最后被source的工作空间下的文件并不是一种很合适的方法，毕竟这个工作空间下还放着需要使用的包，对其进行修改、编译等操作难免会产生一些影响。</p><p>因此，我们可以单独建立一个工作空间专门用来管理其他所有的工作空间，我们只需要将其source指令写入~/.zshrc或者~/.bashrc即可，每一次我们想增添新的工作空间，只要修改这个工作空间的devel文件夹下的_setup_util.py就可以了。</p><p>比如这里我建了一个叫做ros_manager的工作空间，修改好_setup_util.py文件之后，写入到~/.zshrc中，把其他工作空间的source指令都注释掉即可，以后添加新的工作空间，只需要修改ros_manager的_setup_util.py文件即可。</p><p><img src="/images/ros-notes/3-4.png"></p><h4 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h4><p>其实还可以将<code>--extend</code>参数传递给setup.sh文件，它只会添加到环境中，而不会设置环境。</p><p>在~/.zshrc或者~/.bashrc中，对应的操作是在source命令后面加上<code>--extend</code>。</p><p>但是这可能是危险的，建议做适当的工作区链接。</p>]]></content>
      
      
      <categories>
          
          <category> 编程基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解四元数</title>
      <link href="2021/07/10/slam-learning-3/"/>
      <url>2021/07/10/slam-learning-3/</url>
      
        <content type="html"><![CDATA[<h1 id="详解四元数"><a href="#详解四元数" class="headerlink" title="详解四元数"></a>详解四元数</h1><blockquote><p>昨天看了《视觉SLAM十四讲》第三讲四元数部分的内容，对里面的一些东西不是很懂，这两天好好地推导了一下。</p></blockquote><p>本文主要介绍：</p><ol><li>四元数几个重要性质、推论的推导</li><li>如何用四元数表示3D旋转</li><li>四元数、旋转向量、旋转矩阵之间的转换关系</li><li>四元数的双倍覆盖（严谨证明暂未给出）</li></ol><p>由于四元数推导这边的公式比较多，手写要方便一些，所以下面直接给出手写的推导证明过程。</p><h3 id="一、四元数几个比较重要的性质"><a href="#一、四元数几个比较重要的性质" class="headerlink" title="一、四元数几个比较重要的性质"></a>一、四元数几个比较重要的性质</h3><p><img src="/images/slam-learning/3-1.JPG"></p><p><img src="/images/slam-learning/3-2.JPG"></p><h3 id="二、四元数与3D旋转"><a href="#二、四元数与3D旋转" class="headerlink" title="二、四元数与3D旋转"></a>二、四元数与3D旋转</h3><p><img src="/images/slam-learning/3-3.JPG"></p><p><img src="/images/slam-learning/3-4.JPG"></p><p><img src="/images/slam-learning/3-5.JPG"></p><p><img src="/images/slam-learning/3-6.JPG"></p><h3 id="三、四元数、旋转向量、旋转矩阵之间的相互表示"><a href="#三、四元数、旋转向量、旋转矩阵之间的相互表示" class="headerlink" title="三、四元数、旋转向量、旋转矩阵之间的相互表示"></a>三、四元数、旋转向量、旋转矩阵之间的相互表示</h3><p><img src="/images/slam-learning/3-7.JPG"></p><p><img src="/images/slam-learning/3-8.JPG"></p><p><img src="/images/slam-learning/3-9.JPG"></p><h3 id="四、关于四元数的双倍覆盖"><a href="#四、关于四元数的双倍覆盖" class="headerlink" title="四、关于四元数的双倍覆盖"></a>四、关于四元数的双倍覆盖</h3><p><img src="/images/slam-learning/3-10.JPG"></p>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>罗德里格斯公式推导</title>
      <link href="2021/07/08/slam-learning-2/"/>
      <url>2021/07/08/slam-learning-2/</url>
      
        <content type="html"><![CDATA[<h1 id="罗德里格斯公式推导"><a href="#罗德里格斯公式推导" class="headerlink" title="罗德里格斯公式推导"></a>罗德里格斯公式推导</h1><blockquote><p>最近博主在重学《视觉SLAM十四讲》，之后可能会陆陆续续的发一些学习笔记或者公式的推导。</p></blockquote><p>书中第53页给出了罗德里格斯公式，这个公式描述了<strong>从旋转向量到旋转矩阵的转换过程。</strong></p><p>虽然作者后面会从李代数层面给出一个证明，但直接从线性代数的层面进行推导也并不麻烦，具体的推导过程如下所示：</p><p><img src="/images/slam-learning/2-1.jpg"></p><p><img src="/images/slam-learning/2-2.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu配置OpenCV及多版本OpenCV共存</title>
      <link href="2021/07/06/opencv-notes-0/"/>
      <url>2021/07/06/opencv-notes-0/</url>
      
        <content type="html"><![CDATA[<h1 id="Ubuntu配置OpenCV及多版本OpenCV共存"><a href="#Ubuntu配置OpenCV及多版本OpenCV共存" class="headerlink" title="Ubuntu配置OpenCV及多版本OpenCV共存"></a>Ubuntu配置OpenCV及多版本OpenCV共存</h1><p>本文主要介绍ubuntu下OpenCV的安装，以及如何实现多个OpenCV版本共存。</p><p>笔者使用的操作系统为Ubuntu18.04，安装的OpenCV版本有2.4.9、3.2.0、3.4.6、4.2.0。</p><h2 id="配置OpenCV"><a href="#配置OpenCV" class="headerlink" title="配置OpenCV"></a>配置OpenCV</h2><p>这里以opencv-4.2.0为例，但其他版本也基本适用。</p><h3 id="安装OpenCV的依赖包"><a href="#安装OpenCV的依赖包" class="headerlink" title="安装OpenCV的依赖包"></a>安装OpenCV的依赖包</h3><p>一步一步安装下面所有的依赖包，如果下面的安装报错，根据报错的具体信息上网查找相关资料即可解决。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> update <span class="token parameter variable">-y</span> <span class="token comment"># Update the list of packages</span><span class="token function">sudo</span> <span class="token function">apt-get</span> remove <span class="token parameter variable">-y</span> x264 libx264-dev <span class="token comment"># Remove the older version of libx264-dev and x264</span><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> build-essential checkinstall cmake pkg-config yasm<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> <span class="token function">git</span> gfortran<span class="token function">sudo</span> add-apt-repository <span class="token parameter variable">-y</span> <span class="token string">"deb http://security.ubuntu.com/ubuntu xenial-security main"</span><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> libjpeg8-dev libjasper-dev libpng12-dev<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> libtiff5-dev<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> libavcodec-dev libavformat-dev libswscale-dev libdc1394-22-dev<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> libxine2-dev libv4l-dev<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> qt5-default libgtk2.0-dev libtbb-dev<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> libatlas-base-dev<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> libfaac-dev libmp3lame-dev libtheora-dev<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> libvorbis-dev libxvidcore-dev<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> libopencore-amrnb-dev libopencore-amrwb-dev<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> x264 v4l-utils <span class="token comment"># Some Optional Dependencies</span><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> libprotobuf-dev protobuf-compiler<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> libgoogle-glog-dev libgflags-dev<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> libgphoto2-dev libeigen3-dev libhdf5-dev doxygen<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="下载需要的OpenCV版本"><a href="#下载需要的OpenCV版本" class="headerlink" title="下载需要的OpenCV版本"></a>下载需要的OpenCV版本</h3><p>所有OpenCV的发布版本都可以在下面这个网址找到，根据自己的需要下载即可。</p><p><a href="https://github.com/opencv/opencv/releases">https://github.com/opencv/opencv/releases</a></p><p>我们需要安装的是opencv-4.2.0以及它的扩展模块opencv_contrib-4.2.0，因此我们可以在下面的网址中下载：</p><p><a href="https://github.com/opencv/opencv/releases/tag/4.2.0">OpenCV 4.2.0</a></p><p><a href="https://github.com/opencv/opencv_contrib/releases/tag/4.2.0">OpenCV Contib 4.2.0</a></p><p>下载解压好之后，会得到两个文件夹，你可以像下面这样存放这两个文件夹：</p><p><img src="/images/OpenCV-Notes/0-1.png"></p><h3 id="使用cmake构建库"><a href="#使用cmake构建库" class="headerlink" title="使用cmake构建库"></a>使用cmake构建库</h3><p>我们先进入<code>opencv-4.2.0</code>文件夹，并且创建一个<code>build</code>文件，之后再进入这个文件夹：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> opencv-4.2.0<span class="token function">mkdir</span> build<span class="token builtin class-name">cd</span> build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>进入<code>build</code>文件夹后，你需要输入下面这种格式的cmake指令，<strong>需要根据你的实际情况，对下面的指令参数进行修改，不要复制过去就直接运行。</strong></p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">cmake -D <span class="token variable">CMAKE_BUILD_TYPE</span>=RELEASE \      -D <span class="token variable">CMAKE_INSTALL_PREFIX</span>=/usr/local/opencv_x.x.x \ <span class="token comment">#修改为你的opencv版本</span>      -D INSTALL_C_EXAMPLES=<span class="token boolean">ON</span> \      -D CUDA_ARCH_BIN='<span class="token number">6.1</span>' \ <span class="token comment">#修改为你使用的电脑显卡的计算能力</span>      -D WITH_CUDA=<span class="token boolean">ON</span> \      -D WITH_TBB=<span class="token boolean">ON</span> \      -D WITH_V4L=<span class="token boolean">ON</span> \      -D WITH_QT=<span class="token boolean">ON</span> \      -D WITH_OPENGL=<span class="token boolean">ON</span> \      -D OPENCV_EXTRA_MODULES_PATH=/YOU_PATH/opencv_contrib-x.x.x/modules \ <span class="token comment">#修改为你本机opencv_contrib的路径，不使用opencv_contrib就删掉这行</span>      -D BUILD_EXAMPLES=<span class="token boolean">ON</span> \      -D OPENCV_GENERATE_PKGCONFIG=YES ..<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意事项：</strong></p><ul><li><p>由于OpenCV 4.2.0支持使用CUDA对DNN模块进行加速计算，所以这里配置CUDA；在此之前需要自行配置好NVIDIA显卡的驱动与CUDA。</p></li><li><p>其中<code>CUDA_ARCH_BIN='6.1'</code>指的是显卡的计算能力，可以参考：<a href="https://blog.csdn.net/huixingshao/article/details/82215703">NVIDA CUDA显卡计算能力对应表</a></p></li></ul><p>上面这种格式的指令在笔者的电脑上构建opencv-4.2.0、opencv-3.4.6都没有发现问题，应该对于opencv3和opencv4都能够构建成功。</p><p>但是在构建opencv2，比如opencv-2.4.9时，建议参考下面的指令进行构建：</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">cmake -D <span class="token variable">CMAKE_BUILD_TYPE</span>=RELEASE \      -D <span class="token variable">CMAKE_INSTALL_PREFIX</span>=/usr/local/opencv_2.<span class="token number">4.9</span> \      -D WITH_CUDA=<span class="token boolean">OFF</span> \      -D WITH_OPENGL=<span class="token boolean">OFF</span> \      -D WITH_OPENCL=<span class="token boolean">OFF</span> \      -D BUILD_JPEG=<span class="token boolean">OFF</span> \      -D BUILD_PNG=<span class="token boolean">OFF</span> \      -D BUILD_JASPER=<span class="token boolean">OFF</span> \      -DBUILD_OPENEXR=<span class="token boolean">OFF</span> \      -D BUILD_TIFF=<span class="token boolean">OFF</span> \      -D BUILD_ZLIB=<span class="token boolean">OFF</span> \      -D WITH_FFMPEG=<span class="token boolean">OFF</span> \      -D <span class="token variable">CMAKE_CXX_FLAGS</span>=<span class="token string">"-std=c++11"</span> \      -D <span class="token variable">CMAKE_CXX_COMPILER</span>=/usr/bin/g++-<span class="token number">4.8</span> \      -D <span class="token variable">CMAKE_C_COMPILER</span>=/usr/bin/gcc-<span class="token number">4.8</span> \       ..<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用make编译库"><a href="#使用make编译库" class="headerlink" title="使用make编译库"></a>使用make编译库</h3><p>建议在make之前先查看CPU的核心数：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nproc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你可以根据你的核心数来调整make指令的参数，比如笔者的CPU核心数为12，则可以执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> <span class="token parameter variable">-j12</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你也可以不管CPU的核心数，直接运行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是为了防止编译期间内存占用过多，导致编译失败或者系统卡死，还是建议查看一下CPU的核心数，并且使用部分的核心来进行编译，比如<code>make -j8</code>。</p><p>在编译结束之后，执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="添加到系统环境变量"><a href="#添加到系统环境变量" class="headerlink" title="添加到系统环境变量"></a>添加到系统环境变量</h3><p>修改<code>~/.bashrc</code>或者<code>~/.zshrc</code>（用哪个终端就改哪个）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gedit ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>加入如下的内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#OpenCV_4.2.0</span><span class="token builtin class-name">export</span> <span class="token assign-left variable">PKG_CONFIG_PATH</span><span class="token operator">=</span>/usr/local/opencv_4.2.0/lib/pkgconfig<span class="token builtin class-name">export</span> <span class="token assign-left variable">LD_LIBRARY_PATH</span><span class="token operator">=</span>/usr/local/opencv_4.2.0/lib<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="验证配置结果"><a href="#验证配置结果" class="headerlink" title="验证配置结果"></a>验证配置结果</h3><p>任意目录创建一个<code>test.cpp</code>文件，写入如下内容：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"opencv.hpp"</span></span> <span class="token keyword">using</span> <span class="token keyword">namespace</span> cv<span class="token punctuation">;</span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span> <span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv <span class="token punctuation">)</span><span class="token punctuation">{</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"OpenCV version : "</span> <span class="token operator">&lt;&lt;</span> CV_VERSION <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Major version : "</span> <span class="token operator">&lt;&lt;</span> CV_MAJOR_VERSION <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Minor version : "</span> <span class="token operator">&lt;&lt;</span> CV_MINOR_VERSION <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Subminor version : "</span> <span class="token operator">&lt;&lt;</span> CV_SUBMINOR_VERSION <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用命令行在其文件夹下执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 编译test.cpp程序，并生成可执行文件</span>g++ <span class="token parameter variable">-std</span><span class="token operator">=</span>c++11 test.cpp <span class="token variable"><span class="token variable">`</span>pkg-config <span class="token parameter variable">--libs</span> <span class="token parameter variable">--cflags</span> opencv4<span class="token variable">`</span></span> <span class="token parameter variable">-o</span> result<span class="token comment"># 执行可执行文件</span>./result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出以下内容，即表明配置成功</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">OpenCV version <span class="token builtin class-name">:</span> <span class="token number">4.2</span>.0Major version <span class="token builtin class-name">:</span> <span class="token number">4</span>Minor version <span class="token builtin class-name">:</span> <span class="token number">2</span>Subminor version <span class="token builtin class-name">:</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="多个OpenCV版本共存"><a href="#多个OpenCV版本共存" class="headerlink" title="多个OpenCV版本共存"></a>多个OpenCV版本共存</h2><p>在开发不同工程时可能会需要不同版本的OpenCV，因此在电脑上安装多个版本的OpenCV很有必要。很多人不敢尝试是担心出问题，其实这并不难，成功的关键是<strong>安装到不同的路径，并在CMakeList.txt中找到需要的版本。</strong></p><p>假设我们已经安装好一版OpenCV，一般都安装在<code>/usr/local</code>下。如果需要安装另一个版本的OpenCV，就不能再安装到<code>/usr/local</code>，而是选择其他路径，否则会覆盖掉之前的版本。</p><h3 id="安装OpenCV到不同的路径"><a href="#安装OpenCV到不同的路径" class="headerlink" title="安装OpenCV到不同的路径"></a>安装OpenCV到不同的路径</h3><p>在上面的安装教程中，我们介绍的其实就是将各个版本的OpenCV安装到不同的路径，你可以继续根据上面的教程来安装其他的OpenCV版本。</p><h3 id="添加到系统环境变量-1"><a href="#添加到系统环境变量-1" class="headerlink" title="添加到系统环境变量"></a>添加到系统环境变量</h3><p>修改<code>~/.bashrc</code>或者<code>~/.zshrc</code>（用哪个终端就改哪个）：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gedit ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你应该像下面这样加入新的内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#OpenCV_4.2.0</span><span class="token comment">#export PKG_CONFIG_PATH=/usr/local/opencv_4.2.0/lib/pkgconfig</span><span class="token comment">#export LD_LIBRARY_PATH=/usr/local/opencv_4.2.0/lib</span><span class="token comment">#OpenCV_3.4.6</span><span class="token comment">#export PKG_CONFIG_PATH=/usr/local/opencv_3.4.6/lib/pkgconfig</span><span class="token comment">#export LD_LIBRARY_PATH=/usr/local/opencv_3.4.6/lib</span><span class="token comment">#OpenCV_2.4.9</span><span class="token comment">#export PKG_CONFIG_PATH=/usr/local/opencv_2.4.9/lib/pkgconfig</span><span class="token comment">#export LD_LIBRARY_PATH=/usr/local/opencv_2.4.9/lib</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>新加入OpenCV版本或者暂时不适用的OpenCV版本的建议注释掉。</strong></p><h3 id="切换OpenCV的版本"><a href="#切换OpenCV的版本" class="headerlink" title="切换OpenCV的版本"></a>切换OpenCV的版本</h3><p>在上面我们把新版本OpenCV添加到系统环境变量时，都加上了注释，因此你可以通过去掉注释来切换OpenCV的版本，比如我们需要使用OpenCV_2.4.9，就可以把上面的内容修改为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#OpenCV_4.2.0</span><span class="token comment">#export PKG_CONFIG_PATH=/usr/local/opencv_4.2.0/lib/pkgconfig</span><span class="token comment">#export LD_LIBRARY_PATH=/usr/local/opencv_4.2.0/lib</span><span class="token comment">#OpenCV_3.4.6</span><span class="token comment">#export PKG_CONFIG_PATH=/usr/local/opencv_3.4.6/lib/pkgconfig</span><span class="token comment">#export LD_LIBRARY_PATH=/usr/local/opencv_3.4.6/lib</span><span class="token comment">#OpenCV_2.4.9</span><span class="token builtin class-name">export</span> <span class="token assign-left variable">PKG_CONFIG_PATH</span><span class="token operator">=</span>/usr/local/opencv_2.4.9/lib/pkgconfig<span class="token builtin class-name">export</span> <span class="token assign-left variable">LD_LIBRARY_PATH</span><span class="token operator">=</span>/usr/local/opencv_2.4.9/lib<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="测试切换的效果"><a href="#测试切换的效果" class="headerlink" title="测试切换的效果"></a>测试切换的效果</h3><p>每次切换后，都需要更新<code>~/.bashrc</code>或者<code>~/.zshrc</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ~/.bashrc <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询OpenCV版本（也可以使用上面安装OpenCV时的测试代码）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pkg-config <span class="token parameter variable">--modversion</span> opencv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>笔者电脑上的切换效果如下所示：</p><p><img src="/images/OpenCV-Notes/0-2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 三维视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Kalibr进行Camera-IMU联合标定</title>
      <link href="2021/07/04/kalibr-for-camera-imu-calibration/"/>
      <url>2021/07/04/kalibr-for-camera-imu-calibration/</url>
      
        <content type="html"><![CDATA[<h1 id="使用kalibr进行Camera-IMU联合标定"><a href="#使用kalibr进行Camera-IMU联合标定" class="headerlink" title="使用kalibr进行Camera-IMU联合标定"></a>使用kalibr进行Camera-IMU联合标定</h1><p>本文以<u>Intel RealSense D435i</u>为例，介绍使用kalibr进行Camera-IMU联合标定的方法。</p><p>整个过程比较复杂，需要花费的时间比较多，进行的准备工作也比较多。具体分为三步，即首先使用imu_utils标定IMU，然后再通过kalibr标定相机，最后结合前面两步标定的结果用kalibr进行Camera-IMU联合标定。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="软件方面："><a href="#软件方面：" class="headerlink" title="软件方面："></a>软件方面：</h3><ul><li>Linux系统，例如Ubuntu 18.04</li><li>ROS环境，例如ROS Melodic</li><li><a href="https://github.com/IntelRealSense/librealsense/blob/master/doc/distribution_linux.md">RealSense SDK</a> 与 <a href="https://github.com/IntelRealSense/realsense-ros">realsense-ros-wrapper</a></li><li><a href="https://github.com/ethz-asl/kalibr">kalibr</a></li><li><a href="https://github.com/gaowenliang/code_utils">code_utils</a> 与 <a href="https://github.com/gaowenliang/imu_utils">imu_utils</a></li><li>其他相关依赖</li></ul><h3 id="硬件方面："><a href="#硬件方面：" class="headerlink" title="硬件方面："></a>硬件方面：</h3><ul><li>Intel Realsense D435i相机</li><li>标定板一个，例如打印好的AprilTag或棋盘格</li></ul><p><strong>注：</strong></p><p>使用kalibr生成标定板的命令格式如下，运行后可以得到一个pdf文件。需要使用原始尺寸打印出来，并且这里的参数要记好，后面需要用。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kalibr_create_target_pdf <span class="token parameter variable">--type</span> apriltag <span class="token parameter variable">--nx</span> <span class="token punctuation">[</span>NUM_COLS<span class="token punctuation">]</span> <span class="token parameter variable">--ny</span> <span class="token punctuation">[</span>NUM_ROWS<span class="token punctuation">]</span> <span class="token parameter variable">--tsize</span> <span class="token punctuation">[</span>TAG_WIDTH_M<span class="token punctuation">]</span> <span class="token parameter variable">--tspace</span> <span class="token punctuation">[</span>TAG_SPACING_PERCENT<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在开始下面的工作之前，你需要先做好这个部分的准备工作。标定板可以用纸张打印后平贴到墙壁上，相关软件、依赖参考官网的教程即可顺利完成，这里不再赘述。</p><h2 id="使用imu-utils标定imu"><a href="#使用imu-utils标定imu" class="headerlink" title="使用imu_utils标定imu"></a>使用imu_utils标定imu</h2><h3 id="1-运行D435i相机"><a href="#1-运行D435i相机" class="headerlink" title="1.运行D435i相机"></a>1.运行D435i相机</h3><p>你可以通过下面的方式指定参数来运行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">roslaunch realsense2_camera rs_camera.launch <span class="token punctuation">\</span>    unite_imu_method:<span class="token operator">=</span><span class="token string">"linear_interpolation"</span> <span class="token punctuation">\</span>    enable_gyro:<span class="token operator">=</span>true <span class="token punctuation">\</span>     enable_accel:<span class="token operator">=</span>true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当然，也可以修改<code>rs_camera.launch</code>这个文件里面的内容，把上面对应的部分修改好即可。然后直接运行：</p><pre class="line-numbers language-none"><code class="language-none">roslaunch realsense2_camera rs_camera.launch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-录制IMU数据包"><a href="#2-录制IMU数据包" class="headerlink" title="2.录制IMU数据包"></a>2.录制IMU数据包</h3><p>在相机运行起来后，imu数据会在<code>/camera/imu</code>话题下发布，录制这个话题的信息即可，建议录制比较长的时间。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rosbag record <span class="token parameter variable">-O</span> imu_calibration /camera/imu <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-使用imu-utils进行标定"><a href="#3-使用imu-utils进行标定" class="headerlink" title="3.使用imu_utils进行标定"></a>3.使用imu_utils进行标定</h3><p>首先需要新建一个<code>imu_utils</code>的launch文件，内容如下所示：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>launch</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>node</span> <span class="token attr-name">pkg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>imu_utils<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>imu_an<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>imu_an<span class="token punctuation">"</span></span> <span class="token attr-name">output</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>screen<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--IMU的话题--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>imu_topic<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>string<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>/camera/imu<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token comment">&lt;!--这个和最后保存的文件名有关，最后的文件名为D435i_imu_param.yaml--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>imu_name<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>string<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>D435i<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token comment">&lt;!--标定结果存放的文件目录--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>data_save_path<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>string<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>$(find imu_utils)/data/<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token comment">&lt;!--修改标定时间，单位是分钟，需要根据数据包的时长来调整--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>max_time_min<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>int<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>10<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>max_cluster<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>int<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>100<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>node</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>launch</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们把新建的launch文件命名为<code>d435i_imu_calibration.launch </code>，然后通过如下的命令就可以运行了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">roslaunch imu_utils d435i_imu_calibration.launch <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>运行之后imu_utils会等待imu数据的发布，因此我们还需要播放之前录制的数据包。找到之前录制的数据包，运行下面的命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rosbag play <span class="token parameter variable">-r</span> <span class="token number">200</span> imu_calibration.bag<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>-r 200</code>是以200倍的速度播放这个数据包。</p><p>这一部分的工作都完成之后，我们会得到D435i相机IMU的标定文件<code>D435i_imu_param.yaml</code>。</p><h2 id="使用kalibr标定Camera"><a href="#使用kalibr标定Camera" class="headerlink" title="使用kalibr标定Camera"></a>使用kalibr标定Camera</h2><h3 id="1-确认标定板的参数"><a href="#1-确认标定板的参数" class="headerlink" title="1.确认标定板的参数"></a>1.确认标定板的参数</h3><p>这里我使用kalibr生成的标定板，生成的命令如下所示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kalibr_create_target_pdf <span class="token parameter variable">--type</span> apriltag <span class="token parameter variable">--nx</span> <span class="token number">6</span> <span class="token parameter variable">--ny</span> <span class="token number">6</span> <span class="token parameter variable">--tsize</span> <span class="token number">0.03</span> <span class="token parameter variable">--tspace</span> <span class="token number">0.3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将上面命令中对应的参数保存到<code>april_s.yaml</code>文件中，之后我们还需要用到。文件内容如下所示：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">target_type</span><span class="token punctuation">:</span> <span class="token string">'aprilgrid'</span> <span class="token comment">#gridtype</span><span class="token key atrule">tagCols</span><span class="token punctuation">:</span> <span class="token number">6</span>               <span class="token comment">#number of apriltags</span><span class="token key atrule">tagRows</span><span class="token punctuation">:</span> <span class="token number">6</span>               <span class="token comment">#number of apriltags</span><span class="token key atrule">tagSize</span><span class="token punctuation">:</span> <span class="token number">0.03</span>           <span class="token comment">#size of apriltag, edge to edge [m]</span><span class="token key atrule">tagSpacing</span><span class="token punctuation">:</span> <span class="token number">0.3</span>          <span class="token comment">#ratio of space between tags to tagSize</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-修改D435i的launch文件"><a href="#2-修改D435i的launch文件" class="headerlink" title="2.修改D435i的launch文件"></a>2.修改D435i的launch文件</h3><p>由于需要标定的是D435i的两个红外摄像头，因此我们要<strong>在launch文件中开启D435i的红外摄像头，同时关掉D435i的激光，防止产生干扰。</strong>对应的launch文件保存为<code>rs_d435i.launch</code>，具体内容如下所示，可直接使用：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>launch</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>emitter_enable<span class="token punctuation">"</span></span>     <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>serial_no<span class="token punctuation">"</span></span>           <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>usb_port_id<span class="token punctuation">"</span></span>         <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>device_type<span class="token punctuation">"</span></span>         <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>json_file_path<span class="token punctuation">"</span></span>      <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>camera<span class="token punctuation">"</span></span>              <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>camera<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>tf_prefix<span class="token punctuation">"</span></span>           <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg camera)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>external_manager<span class="token punctuation">"</span></span>    <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>manager<span class="token punctuation">"</span></span>             <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>realsense2_camera_manager<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>output<span class="token punctuation">"</span></span>              <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>screen<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>respawn<span class="token punctuation">"</span></span>              <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fisheye_width<span class="token punctuation">"</span></span>       <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>-1<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fisheye_height<span class="token punctuation">"</span></span>      <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>-1<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>enable_fisheye<span class="token punctuation">"</span></span>      <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>depth_width<span class="token punctuation">"</span></span>         <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>640<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>depth_height<span class="token punctuation">"</span></span>        <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>480<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>enable_depth<span class="token punctuation">"</span></span>        <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>confidence_width<span class="token punctuation">"</span></span>    <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>-1<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>confidence_height<span class="token punctuation">"</span></span>   <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>-1<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>enable_confidence<span class="token punctuation">"</span></span>   <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>confidence_fps<span class="token punctuation">"</span></span>      <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>-1<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>infra_width<span class="token punctuation">"</span></span>         <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>640<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>infra_height<span class="token punctuation">"</span></span>        <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>480<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>enable_infra<span class="token punctuation">"</span></span>        <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>enable_infra1<span class="token punctuation">"</span></span>       <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>enable_infra2<span class="token punctuation">"</span></span>       <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>infra_rgb<span class="token punctuation">"</span></span>           <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>color_width<span class="token punctuation">"</span></span>         <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>640<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>color_height<span class="token punctuation">"</span></span>        <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>480<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>enable_color<span class="token punctuation">"</span></span>        <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fisheye_fps<span class="token punctuation">"</span></span>         <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>30<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>depth_fps<span class="token punctuation">"</span></span>           <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>30<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>infra_fps<span class="token punctuation">"</span></span>           <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>30<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>color_fps<span class="token punctuation">"</span></span>           <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>30<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>gyro_fps<span class="token punctuation">"</span></span>            <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>200<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>accel_fps<span class="token punctuation">"</span></span>           <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>250<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>enable_gyro<span class="token punctuation">"</span></span>         <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>enable_accel<span class="token punctuation">"</span></span>        <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>enable_pointcloud<span class="token punctuation">"</span></span>         <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pointcloud_texture_stream<span class="token punctuation">"</span></span> <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>RS2_STREAM_COLOR<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pointcloud_texture_index<span class="token punctuation">"</span></span>  <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>allow_no_texture_points<span class="token punctuation">"</span></span>   <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ordered_pc<span class="token punctuation">"</span></span>                <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>enable_sync<span class="token punctuation">"</span></span>               <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>align_depth<span class="token punctuation">"</span></span>               <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>publish_tf<span class="token punctuation">"</span></span>                <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>tf_publish_rate<span class="token punctuation">"</span></span>           <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>filters<span class="token punctuation">"</span></span>                   <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>clip_distance<span class="token punctuation">"</span></span>             <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>-2<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>linear_accel_cov<span class="token punctuation">"</span></span>          <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>0.01<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>initial_reset<span class="token punctuation">"</span></span>             <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>unite_imu_method<span class="token punctuation">"</span></span>          <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>linear_interpolation<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>topic_odom_in<span class="token punctuation">"</span></span>             <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>odom_in<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>calib_odom_file<span class="token punctuation">"</span></span>           <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>publish_odom_tf<span class="token punctuation">"</span></span>           <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stereo_module/exposure/1<span class="token punctuation">"</span></span>  <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>7500<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stereo_module/gain/1<span class="token punctuation">"</span></span>      <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>16<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stereo_module/exposure/2<span class="token punctuation">"</span></span>  <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>1<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stereo_module/gain/2<span class="token punctuation">"</span></span>      <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>16<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>group</span> <span class="token attr-name">ns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg camera)<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- rosparam set stereo_module/emitter_enabled false --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rosparam</span><span class="token punctuation">&gt;</span></span>      stereo_module/emitter_enabled: 0    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rosparam</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rosparam</span> <span class="token attr-name">if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg emitter_enable)<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>      stereo_module/emitter_enabled: 1    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rosparam</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span> <span class="token attr-name">file</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(find realsense2_camera)/launch/includes/nodelet.launch.xml<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>tf_prefix<span class="token punctuation">"</span></span>                <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg tf_prefix)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>external_manager<span class="token punctuation">"</span></span>         <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg external_manager)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>manager<span class="token punctuation">"</span></span>                  <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg manager)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>output<span class="token punctuation">"</span></span>                   <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg output)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>respawn<span class="token punctuation">"</span></span>                  <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg respawn)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>serial_no<span class="token punctuation">"</span></span>                <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg serial_no)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>usb_port_id<span class="token punctuation">"</span></span>              <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg usb_port_id)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>device_type<span class="token punctuation">"</span></span>              <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg device_type)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>json_file_path<span class="token punctuation">"</span></span>           <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg json_file_path)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>enable_pointcloud<span class="token punctuation">"</span></span>        <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg enable_pointcloud)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pointcloud_texture_stream<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg pointcloud_texture_stream)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pointcloud_texture_index<span class="token punctuation">"</span></span>  <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg pointcloud_texture_index)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>enable_sync<span class="token punctuation">"</span></span>              <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg enable_sync)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>align_depth<span class="token punctuation">"</span></span>              <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg align_depth)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fisheye_width<span class="token punctuation">"</span></span>            <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg fisheye_width)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fisheye_height<span class="token punctuation">"</span></span>           <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg fisheye_height)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>enable_fisheye<span class="token punctuation">"</span></span>           <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg enable_fisheye)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>depth_width<span class="token punctuation">"</span></span>              <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg depth_width)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>depth_height<span class="token punctuation">"</span></span>             <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg depth_height)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>enable_depth<span class="token punctuation">"</span></span>             <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg enable_depth)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>confidence_width<span class="token punctuation">"</span></span>         <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg confidence_width)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>confidence_height<span class="token punctuation">"</span></span>        <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg confidence_height)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>enable_confidence<span class="token punctuation">"</span></span>        <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg enable_confidence)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>confidence_fps<span class="token punctuation">"</span></span>           <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg confidence_fps)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>color_width<span class="token punctuation">"</span></span>              <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg color_width)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>color_height<span class="token punctuation">"</span></span>             <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg color_height)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>enable_color<span class="token punctuation">"</span></span>             <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg enable_color)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>infra_width<span class="token punctuation">"</span></span>              <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg infra_width)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>infra_height<span class="token punctuation">"</span></span>             <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg infra_height)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>enable_infra<span class="token punctuation">"</span></span>             <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg enable_infra)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>enable_infra1<span class="token punctuation">"</span></span>            <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg enable_infra1)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>enable_infra2<span class="token punctuation">"</span></span>            <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg enable_infra2)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>infra_rgb<span class="token punctuation">"</span></span>                <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg infra_rgb)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fisheye_fps<span class="token punctuation">"</span></span>              <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg fisheye_fps)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>depth_fps<span class="token punctuation">"</span></span>                <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg depth_fps)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>infra_fps<span class="token punctuation">"</span></span>                <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg infra_fps)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>color_fps<span class="token punctuation">"</span></span>                <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg color_fps)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>gyro_fps<span class="token punctuation">"</span></span>                 <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg gyro_fps)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>accel_fps<span class="token punctuation">"</span></span>                <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg accel_fps)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>enable_gyro<span class="token punctuation">"</span></span>              <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg enable_gyro)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>enable_accel<span class="token punctuation">"</span></span>             <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg enable_accel)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>publish_tf<span class="token punctuation">"</span></span>               <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg publish_tf)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>tf_publish_rate<span class="token punctuation">"</span></span>          <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg tf_publish_rate)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>filters<span class="token punctuation">"</span></span>                  <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg filters)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>clip_distance<span class="token punctuation">"</span></span>            <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg clip_distance)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>linear_accel_cov<span class="token punctuation">"</span></span>         <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg linear_accel_cov)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>initial_reset<span class="token punctuation">"</span></span>            <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg initial_reset)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>unite_imu_method<span class="token punctuation">"</span></span>         <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg unite_imu_method)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>topic_odom_in<span class="token punctuation">"</span></span>            <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg topic_odom_in)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>calib_odom_file<span class="token punctuation">"</span></span>          <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg calib_odom_file)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>publish_odom_tf<span class="token punctuation">"</span></span>          <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg publish_odom_tf)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stereo_module/exposure/1<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg stereo_module/exposure/1)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stereo_module/gain/1<span class="token punctuation">"</span></span>     <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg stereo_module/gain/1)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stereo_module/exposure/2<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg stereo_module/exposure/2)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stereo_module/gain/2<span class="token punctuation">"</span></span>     <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg stereo_module/gain/2)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>allow_no_texture_points<span class="token punctuation">"</span></span>  <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg allow_no_texture_points)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arg</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>ordered_pc<span class="token punctuation">"</span></span>               <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$(arg ordered_pc)<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>group</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>launch</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-录制Camera数据包"><a href="#3-录制Camera数据包" class="headerlink" title="3.录制Camera数据包"></a>3.录制Camera数据包</h3><h4 id="a-启动RealSense的Camera节点"><a href="#a-启动RealSense的Camera节点" class="headerlink" title="a) 启动RealSense的Camera节点"></a>a) 启动RealSense的Camera节点</h4><p>终端运行<code>roslaunch realsense2_camera rs_d435i.launch</code>，即运行我们上面编辑的launch文件，启动RealSense的Camera节点。</p><h4 id="b-可视化相机影像"><a href="#b-可视化相机影像" class="headerlink" title="b) 可视化相机影像"></a>b) 可视化相机影像</h4><p>方便起见，我们需要可视化相机影像，可以利用<code>rqt_image_view</code>工具来查看影像流，终端运行<code>rosrun rqt_image_view rqt_image_view</code>或者<code>rqt_image_view</code>即可。</p><p>我们需要标定的是D435i的两个红外摄像头，不过两个摄像头距离比较近，看到的东西差不多。所以开一个<code>rqt_image_view</code>，查看<code>/camera/infra1/image_rect_raw</code>或者<code>/camera/infra2/image_rect_raw</code>话题下的影像即可。</p><p>效果如下图所示：</p><img src="/images/kalibr-for-camera-imu-calibration/1.png" alt="" style="zoom:67%;"><h4 id="c-影像Topic重新发布"><a href="#c-影像Topic重新发布" class="headerlink" title="c) 影像Topic重新发布"></a>c) 影像Topic重新发布</h4><p><strong>然后需要做的是，将传感器的Topic发送速率“转换”一下，因为在Kalibr的<a href="https://github.com/ethz-asl/kalibr/wiki/multiple-camera-calibration">官方文档</a>中，对于相机标定，推荐的速率是每秒4帧左右(FPS=4)，而D435i默认是30帧每秒，所以需要转换一下，不然标定时间会非常漫长。</strong></p><p>转换使用ROS自带的<code>topic_tools</code>即可。新打开两个终端，分别在其中输入<code>rosrun topic_tools throttle messages /camera/infra1/image_rect_raw 4.0 /infra1_image_rect_raw</code>和<code>rosrun topic_tools throttle messages /camera/infra2/image_rect_raw 4.0 /infra2_image_rect_raw</code>即可。</p><p>这会将<code>/camera/infra1/image_rect_raw</code>和<code>/camera/infra2/image_rect_raw</code>的数据重新以4.0的频率在<code>/infra1_image_rect_raw</code>和<code>/infra2_image_rect_raw</code>下发布。</p><h4 id="d-录制Camera数据包"><a href="#d-录制Camera数据包" class="headerlink" title="d) 录制Camera数据包"></a>d) 录制Camera数据包</h4><p>确认前几步都做好后，我们将标定板固定在某处，让相机对着标定板运动。</p><p><strong>运动的方式为：先绕相机的各自三个轴，每个轴旋转三次，然后再沿着相机的三个轴，每个轴平移三次，基本就可以了，运动期间要保证相机基本能一直看到标定板的全部信息。</strong></p><p>不过因为这是标定Camera，所以也可以将打印出来的标定板拿好，然后在相机前面来回运动，但因为笔者是用纸张打印的标定板，所以没采用这种方式。</p><p>通过如下命令录制camera数据包：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rosbag record <span class="token parameter variable">-O</span> camera_calibration /infra1_image_rect_raw /infra2_image_rect_raw<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-使用Kalibr进行标定"><a href="#4-使用Kalibr进行标定" class="headerlink" title="4.使用Kalibr进行标定"></a>4.使用Kalibr进行标定</h3><p>通过如下的命令运行kalibr进行标定：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kalibr_calibrate_cameras <span class="token parameter variable">--target</span> ./yaml/april_s.yaml <span class="token parameter variable">--bag</span> ./rosbag/camera_calibration.bag --bag-from-to <span class="token number">30</span> <span class="token number">90</span> <span class="token parameter variable">--models</span> pinhole-radtan pinhole-radtan  <span class="token parameter variable">--topics</span> /infra1_image_rect_raw /infra2_image_rect_raw<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>--target</code>：标定板参数信息存放的路径，即我们上面的<code>april_s.yaml</code>的路径。</p><p><code>--bag</code>：录制的Camera数据包的路径。</p><p><code>--bag-from-to</code>：起始和终止时间，单位是秒。为了避免开始录制和结束录制时的抖动，这里取了第30秒到第90秒之间的信息。</p><p><code>models</code>：相机模型，一般为针孔模型，即pinhole-radtan。注意后面有几个话题前面就要写几次模型。</p><p><code>--topics</code>：影像流发布的话题。</p><p>等待一段比较长的时间后会得到标定结果。</p><h2 id="使用kalibr进行Camera-IMU联合标定-1"><a href="#使用kalibr进行Camera-IMU联合标定-1" class="headerlink" title="使用kalibr进行Camera-IMU联合标定"></a>使用kalibr进行Camera-IMU联合标定</h2><p>有了前几步的铺垫和积累，这里需要进行的工作并不是很多。</p><h3 id="1-录制Camera-IMU数据包"><a href="#1-录制Camera-IMU数据包" class="headerlink" title="1.录制Camera-IMU数据包"></a>1.录制Camera-IMU数据包</h3><h4 id="a-启动RealSense的Camera节点-1"><a href="#a-启动RealSense的Camera节点-1" class="headerlink" title="a) 启动RealSense的Camera节点"></a>a) 启动RealSense的Camera节点</h4><p>终端运行<code>roslaunch realsense2_camera rs_d435i.launch</code>，即运行我们之前编辑的launch文件，启动RealSense的Camera节点。</p><h4 id="b-可视化相机影像-1"><a href="#b-可视化相机影像-1" class="headerlink" title="b) 可视化相机影像"></a>b) 可视化相机影像</h4><p>和标定Camera时一样，利用<code>rqt_image_view</code>工具来查看影像流，终端运行<code>rosrun rqt_image_view rqt_image_view</code>或者<code>rqt_image_view</code>即可。</p><p>我们需要标定的是D435i的两个红外摄像头，开一个<code>rqt_image_view</code>，查看<code>/camera/infra1/image_rect_raw</code>或者<code>/camera/infra2/image_rect_raw</code>话题下的影像即可。</p><h4 id="c-影像Topic重新发布-1"><a href="#c-影像Topic重新发布-1" class="headerlink" title="c) 影像Topic重新发布"></a>c) 影像Topic重新发布</h4><p>这里也与前面类似，但是<strong>对于相机-IMU标定，<a href="https://github.com/ethz-asl/kalibr/wiki/Multi-IMU-and-IMU-intrinsic-calibration">官方文档</a>给出的建议帧率是：Camera 20FPS，IMU 200FPS。</strong></p><p>转换依然使用ROS自带的<code>topic_tools</code>即可，新打开三个终端，分别在其中输入：</p><p><code>rosrun topic_tools throttle messages /camera/infra1/image_rect_raw 4.0 /infra1_image_rect_raw</code></p><p><code>rosrun topic_tools throttle messages /camera/infra2/image_rect_raw 4.0 /infra2_image_rect_raw</code></p><p><code>rosrun topic_tools throttle messages /camera/imu 200.0 /imu</code></p><h4 id="d-录制Camera数据包-1"><a href="#d-录制Camera数据包-1" class="headerlink" title="d) 录制Camera数据包"></a>d) 录制Camera数据包</h4><p>确认前几步都做好后，我们将标定板固定在某处，让相机对着标定板运动，运动的方式是和之前一样的<strong>“三转、三移”</strong>。这里需要注意的是，一定要让相机对着标定板运动，因为我们需要标定imu，如果相机不动，imu的加速度就一直为0，无法进行标定。</p><p>通过如下命令录制camera数据包：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rosbag record <span class="token parameter variable">-O</span> camera_imu_calibration /infra1_image_rect_raw /infra2_image_rect_raw /imu<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2修改IMU标定文件"><a href="#2修改IMU标定文件" class="headerlink" title="2修改IMU标定文件"></a>2修改IMU标定文件</h3><p>我们之前使用<code>imu_utils</code>工具标定了IMU，但是得到标定文件是不能直接用的，还需要修改成kalibr指定的格式。</p><p>原来的格式如下所示：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">type</span><span class="token punctuation">:</span> IMU<span class="token key atrule">name</span><span class="token punctuation">:</span> D435i<span class="token key atrule">Gyr</span><span class="token punctuation">:</span>   <span class="token key atrule">unit</span><span class="token punctuation">:</span> <span class="token string">" rad/s"</span>   <span class="token key atrule">avg-axis</span><span class="token punctuation">:</span>      <span class="token key atrule">gyr_n</span><span class="token punctuation">:</span> <span class="token number">1.5309108696273642e-03</span>      <span class="token key atrule">gyr_w</span><span class="token punctuation">:</span> <span class="token number">2.0703289176602875e-05</span>   <span class="token key atrule">x-axis</span><span class="token punctuation">:</span>      <span class="token key atrule">gyr_n</span><span class="token punctuation">:</span> <span class="token number">1.4720250697508204e-03</span>      <span class="token key atrule">gyr_w</span><span class="token punctuation">:</span> <span class="token number">3.0849898119446267e-05</span>   <span class="token key atrule">y-axis</span><span class="token punctuation">:</span>      <span class="token key atrule">gyr_n</span><span class="token punctuation">:</span> <span class="token number">1.7709433080656571e-03</span>      <span class="token key atrule">gyr_w</span><span class="token punctuation">:</span> <span class="token number">2.0734874137051272e-05</span>   <span class="token key atrule">z-axis</span><span class="token punctuation">:</span>      <span class="token key atrule">gyr_n</span><span class="token punctuation">:</span> <span class="token number">1.3497642310656153e-03</span>      <span class="token key atrule">gyr_w</span><span class="token punctuation">:</span> <span class="token number">1.0525095273311089e-05</span><span class="token key atrule">Acc</span><span class="token punctuation">:</span>   <span class="token key atrule">unit</span><span class="token punctuation">:</span> <span class="token string">" m/s^2"</span>   <span class="token key atrule">avg-axis</span><span class="token punctuation">:</span>      <span class="token key atrule">acc_n</span><span class="token punctuation">:</span> <span class="token number">2.0588163388565360e-02</span>      <span class="token key atrule">acc_w</span><span class="token punctuation">:</span> <span class="token number">7.8368470789407288e-04</span>   <span class="token key atrule">x-axis</span><span class="token punctuation">:</span>      <span class="token key atrule">acc_n</span><span class="token punctuation">:</span> <span class="token number">1.7835189767520132e-02</span>      <span class="token key atrule">acc_w</span><span class="token punctuation">:</span> <span class="token number">6.6321457518985427e-04</span>   <span class="token key atrule">y-axis</span><span class="token punctuation">:</span>      <span class="token key atrule">acc_n</span><span class="token punctuation">:</span> <span class="token number">2.0230802690153690e-02</span>      <span class="token key atrule">acc_w</span><span class="token punctuation">:</span> <span class="token number">6.7027913345637114e-04</span>   <span class="token key atrule">z-axis</span><span class="token punctuation">:</span>      <span class="token key atrule">acc_n</span><span class="token punctuation">:</span> <span class="token number">2.3698497708022258e-02</span>      <span class="token key atrule">acc_w</span><span class="token punctuation">:</span> <span class="token number">1.0175604150359932e-03</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们需要的是<code>acc_n</code>、<code>acc_w</code>、<code>gyr_n</code>和<code>gyr_w</code>这四个数据，将其对应的填到文件中即可，文件格式如下所示：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment">#Accelerometers</span><span class="token key atrule">accelerometer_noise_density</span><span class="token punctuation">:</span> <span class="token number">2.0588163388565360e-02</span>   <span class="token comment">#Noise density (continuous-time)</span><span class="token key atrule">accelerometer_random_walk</span><span class="token punctuation">:</span>   <span class="token number">7.8368470789407288e-04</span>   <span class="token comment">#Bias random walk</span><span class="token comment">#Gyroscopes</span><span class="token key atrule">gyroscope_noise_density</span><span class="token punctuation">:</span>     <span class="token number">1.5309108696273642e-03</span>   <span class="token comment">#Noise density (continuous-time)</span><span class="token key atrule">gyroscope_random_walk</span><span class="token punctuation">:</span>       <span class="token number">2.0703289176602875e-05</span>   <span class="token comment">#Bias random walk</span><span class="token key atrule">rostopic</span><span class="token punctuation">:</span>                   /imu       <span class="token comment">#the IMU ROS topic</span><span class="token key atrule">update_rate</span><span class="token punctuation">:</span>                 <span class="token number">200.0</span>      <span class="token comment">#Hz (for discretization of the values above)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-进行Camera-IMU联合标定"><a href="#3-进行Camera-IMU联合标定" class="headerlink" title="3.进行Camera-IMU联合标定"></a>3.进行Camera-IMU联合标定</h3><p>通过如下的命令运行kalibr进行标定：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kalibr_calibrate_imu_camera <span class="token parameter variable">--target</span> ./yaml/april_s.yaml  <span class="token parameter variable">--cam</span> ./result/camera/camchain-.rosbagcamera_calibration.yaml <span class="token parameter variable">--imu</span> ./result/imu/D435i_imu_param.yaml <span class="token parameter variable">--bag</span> rosbag/camera_imu_calibration.bag  --bag-from-to <span class="token number">20</span> <span class="token number">130</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>--target</code>：标定板参数信息存放的路径，即我们上面的<code>april_s.yaml</code>的路径。</p><p><code>--cam</code>：Camera的标定文件路径。</p><p><code>--imu</code>：IMU的标定文件路径。</p><p><code>--bag</code>：录制的Camera-IMU数据包的路径。</p><p><code>--bag-from-to</code>：起始和终止时间，单位是秒。为了避免开始录制和结束录制时的抖动，这里取了第30秒到第90秒之间的信息。</p><p>等待一段比较长的时间后会得到标定结果。</p><h2 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h2><p>运行结束后会弹出result report，并且kalibr会自动帮你保存文件。</p><p><img src="/images/kalibr-for-camera-imu-calibration/2.png"></p><p>我们最后会得到下图所示的四个文件，其中的yaml文件就是我们最后标定得到的结果。</p><p><img src="/images/kalibr-for-camera-imu-calibration/3.png"></p><p>这两个文件看起来是下面这种样子的：</p><p><img src="/images/kalibr-for-camera-imu-calibration/4.png"></p>]]></content>
      
      
      <categories>
          
          <category> 三维视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 相机标定 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SLAM for L515</title>
      <link href="2021/07/03/slam-notes-1/"/>
      <url>2021/07/03/slam-notes-1/</url>
      
        <content type="html"><![CDATA[<h1 id="SLAM-for-L515"><a href="#SLAM-for-L515" class="headerlink" title="SLAM for L515"></a>SLAM for L515</h1><p>本文介绍两种适合Intel RealSense LiDAR Camera L515的SLAM方案，把这两种方案跑起来都非常容易，只要环境没问题，基本上就能跑一个大概的效果出来（效果好还是得费些功夫的）。</p><h2 id="SSL-SLAM"><a href="#SSL-SLAM" class="headerlink" title="SSL_SLAM"></a>SSL_SLAM</h2><p>固态激光雷达的轻量级 3-D 定位和映射（SSL_SLAM）是新加坡南洋理工大学一个博士提出的方案，这套方案基本上就是根据L515设计出来的，拿过来能直接用。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~/catkin_ws/src<span class="token function">git</span> clone https://github.com/wh200720041/ssl_slam.git<span class="token builtin class-name">cd</span> <span class="token punctuation">..</span>catkin_make<span class="token builtin class-name">source</span> ~/catkin_ws/devel/setup.bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#运行ssl_slam</span>roslaunch ssl_slam ssl_slam_mapping.launch<span class="token comment">#运行L515</span>roslaunch ssl_slam ssl_slam_L515.launch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>运行效果如下图所示：</p><p><img src="/images/slam-for-L515/0.png"></p><h2 id="RTAB-Map"><a href="#RTAB-Map" class="headerlink" title="RTAB-Map"></a>RTAB-Map</h2><p><strong>RTAB-Map</strong>（基于实时外观的映射）是一种基于 RGB-D、立体和激光雷达图的 SLAM 方法，它基于增量外观闭环检测器。闭环检测器使用词袋方法来确定新图像来自先前位置或新位置的可能性。当一个闭环假设被接受时，一个新的约束被添加到地图的图形中，然后图形优化器最小化地图中的错误。内存管理方法用于限制用于闭环检测和图形优化的位置数量，以便始终遵守对大规模环境的实时约束。RTAB-Map 可以单独与手持 Kinect、立体相机或 3D 激光雷达一起使用，用于 6DoF 映射，或用于配备激光测距仪的机器人进行 3DoF 映射。</p><h3 id="run-L515"><a href="#run-L515" class="headerlink" title="run L515"></a>run L515</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># ISSUE: Use unite_imu_method:="copy" if imu topics keep stopping</span>roslaunch realsense2_camera rs_camera.launch <span class="token punctuation">\</span>    align_depth:<span class="token operator">=</span>true <span class="token punctuation">\</span>    unite_imu_method:<span class="token operator">=</span><span class="token string">"linear_interpolation"</span> <span class="token punctuation">\</span>    enable_gyro:<span class="token operator">=</span>true <span class="token punctuation">\</span>     enable_accel:<span class="token operator">=</span>true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rosrun imu_filter_madgwick imu_filter_node <span class="token punctuation">\</span>    _use_mag:<span class="token operator">=</span>false <span class="token punctuation">\</span>    _publish_tf:<span class="token operator">=</span>false <span class="token punctuation">\</span>    _world_frame:<span class="token operator">=</span><span class="token string">"enu"</span> <span class="token punctuation">\</span>    /imu/data_raw:<span class="token operator">=</span>/camera/imu <span class="token punctuation">\</span>    /imu/data:<span class="token operator">=</span>/rtabmap/imu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Run-RTAB-Map"><a href="#Run-RTAB-Map" class="headerlink" title="Run RTAB-Map"></a>Run RTAB-Map</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rosrun nodelet nodelet standalone rtabmap_ros/point_cloud_xyz <span class="token punctuation">\</span>    _approx_sync:<span class="token operator">=</span>false  <span class="token punctuation">\</span>    /depth/image:<span class="token operator">=</span>/camera/depth/image_rect_raw <span class="token punctuation">\</span>    /depth/camera_info:<span class="token operator">=</span>/camera/depth/camera_info <span class="token punctuation">\</span>    _decimation:<span class="token operator">=</span><span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">roslaunch rtabmap_ros rtabmap.launch<span class="token punctuation">\</span>    rtabmap_args:<span class="token operator">=</span><span class="token string">"\      --delete_db_on_start \      --Icp/VoxelSize 0.05 \      --Icp/PointToPlaneRadius 0 \      --Icp/PointToPlaneK 20 \      --Icp/CorrespondenceRatio 0.2 \      --Icp/PMOutlierRatio 0.65 \      --Icp/Epsilon 0.005 \      --Icp/PointToPlaneMinComplexity 0 \      --Odom/ScanKeyFrameThr 0.7 \      --OdomF2M/ScanMaxSize 15000 \      --Optimizer/GravitySigma 0.3 \      --RGBD/ProximityPathMaxNeighbors 1 \      --Reg/Strategy 1"</span> <span class="token punctuation">\</span>    icp_odometry:<span class="token operator">=</span>true <span class="token punctuation">\</span>    scan_cloud_topic:<span class="token operator">=</span>/cloud <span class="token punctuation">\</span>    subscribe_scan_cloud:<span class="token operator">=</span>true <span class="token punctuation">\</span>    depth_topic:<span class="token operator">=</span>/camera/aligned_depth_to_color/image_raw <span class="token punctuation">\</span>    rgb_topic:<span class="token operator">=</span>/camera/color/image_raw <span class="token punctuation">\</span>    camera_info_topic:<span class="token operator">=</span>/camera/color/camera_info <span class="token punctuation">\</span>    approx_sync:<span class="token operator">=</span>false <span class="token punctuation">\</span>    wait_imu_to_init:<span class="token operator">=</span>true <span class="token punctuation">\</span>    imu_topic:<span class="token operator">=</span>/rtabmap/imu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#delete memory</span>rosservice call /rtabmap/reset<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>运行效果如下所示：</p><p><img src="/images/slam-for-L515/1.png"></p><p><img src="/images/slam-for-L515/2.png"></p>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2D碰撞检测</title>
      <link href="2021/05/16/2d-collision-detection/"/>
      <url>2021/05/16/2d-collision-detection/</url>
      
        <content type="html"><![CDATA[<h1 id="2D碰撞检测"><a href="#2D碰撞检测" class="headerlink" title="2D碰撞检测"></a>2D碰撞检测</h1><p>2D游戏中，通常使用矩形、圆形等来代替复杂图形的相交检测，因为这两种形状的碰撞检测速度是最快的。</p><p>其中矩形包围盒又可以分为轴对齐包围盒（AABB, Axis Aligned Bounding Box）与转向包围盒（OBB, Oriented Bounding Box）。AABB与OBB的区别在于，AABB中的矩形的其中一条边和坐标轴平行，OBB的计算复杂度要高于AABB。根据不同的使用场景，可以用不同的方案。</p><h3 id="圆形之间的碰撞检测"><a href="#圆形之间的碰撞检测" class="headerlink" title="圆形之间的碰撞检测"></a>圆形之间的碰撞检测</h3><p>圆形之间的碰撞检测比较简单，只需判断两圆心之间的距离是否小于两圆的半径之和即可，如下图所示。</p><img src="/images/2D-Collision-Detection/1.jpg" style="zoom: 33%;"><h3 id="圆形与矩形的碰撞检测"><a href="#圆形与矩形的碰撞检测" class="headerlink" title="圆形与矩形的碰撞检测"></a>圆形与矩形的碰撞检测</h3><p>涉及到矩形的碰撞检测问题都先要判断是否轴对称。</p><h4 id="矩形轴对称"><a href="#矩形轴对称" class="headerlink" title="矩形轴对称"></a>矩形轴对称</h4><p>如下图所示，设$c$为矩形中心，$h$为矩形半长，$p$为圆心，$r$为半径。</p><p>检测碰撞的方法是计算圆心与矩形的最短距离$ u$，若$ u $的长度小于$ r $则两者相碰撞。</p><p><img src="/images/2D-Collision-Detection/2.jpg"></p><p>为了计算$u$，我们首先利用$p – c$ 将圆心平移到矩形坐标系的第一象限，这不影响碰撞检测的结果：</p><img src="/images/2D-Collision-Detection/3.jpg" style="zoom: 67%;"><p>然后，计算向量 $v-h$，如果$v-h$的分量为负数则设置为0，最后得到圆心与矩形最短距离的矢量 $u$。</p><p>下图展示了4种情况，红色的$u$是结果。</p><p><img src="/images/2D-Collision-Detection/4.jpg"></p><p>最后比较 $u$ 和 $r$ 模长的大小，如果$u$的模长小则两者相交。</p><h4 id="矩形非轴对称"><a href="#矩形非轴对称" class="headerlink" title="矩形非轴对称"></a>矩形非轴对称</h4><p>将矩形的中心视为旋转中心，将矩形和圆形一起反向旋转将矩形转为轴对称，然后就可以套用上面的解法。</p><img src="/images/2D-Collision-Detection/5.jpg" style="zoom:33%;"><h3 id="两矩形都轴对称AABB"><a href="#两矩形都轴对称AABB" class="headerlink" title="两矩形都轴对称AABB"></a>两矩形都轴对称AABB</h3><p>想象一下两个矩形A和B，B紧贴着A的边走了一圈，B的矩形中心的轨迹是一个新的矩形，这样就简化成新矩形与B中心点这一点的相交问题，又因为点可以看成是半径为0的圆，所以问题又转换为圆形和矩形相交。</p><img src="/images/2D-Collision-Detection/6.jpg" style="zoom:33%;"><h3 id="两矩形相交非轴对称OBB"><a href="#两矩形相交非轴对称OBB" class="headerlink" title="两矩形相交非轴对称OBB"></a>两矩形相交非轴对称OBB</h3><p>两个矩形的OBB检测使用<strong>分离轴定理（Separating Axis Theorem）</strong></p><p>分离轴定理：通过判断任意两个矩形在任意角度下的投影是否均存在重叠，来判断是否发生碰撞。若在某一角度光源下，两物体的投影存在间隙，则为不碰撞，否则为发生碰撞。</p><p>因为矩形的对边平行，所以只要判断四条对称轴上两个矩阵的投影即可。如果四条对称轴上的投影均有重合部分，则矩阵发生碰撞，否则矩阵之间不发生碰撞。</p><img src="/images/2D-Collision-Detection/7.jpg" style="zoom:33%;">]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碰撞检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件相机介绍</title>
      <link href="2021/04/17/introduce-event-based-camera/"/>
      <url>2021/04/17/introduce-event-based-camera/</url>
      
        <content type="html"><![CDATA[<h1 id="Event-based-Camera"><a href="#Event-based-Camera" class="headerlink" title="Event-based Camera"></a>Event-based Camera</h1><blockquote><p>本文将网上的相关资料整理到了一起，方便阅读</p></blockquote><p><strong>前言</strong></p><p>事件相机英文名为：Event-based Camera，或简称为Event Camera，缩写为EB。有时也称作DVS（Dynamic Vision Sensor “动态视觉传感器”）、DAVIS（Dynamic and Active-Pixel Vision Sensor）等。 </p><p>不同于传统相机拍摄一幅完整的图像，事件相机拍摄的是“事件”，可以简单理解为“像素亮度的变化”，即事件相机输出的是像素亮度的变化情况。相比于以固定的帧率采集图像，这种相机通多测量每个像素的亮度变化来输出异步信号（包括事件，位置和亮度变化的符号）。</p><p>事件相机与传统相机相比具有很多的优点: 高的动态测量范围（140dB vs. 60dB）， 高时间分辨率， 低功耗，不受运动模糊的影响。在高速、高动态范围的场景下有着广阔的应用空间。</p><h2 id="零、传统相机的缺点"><a href="#零、传统相机的缺点" class="headerlink" title="零、传统相机的缺点"></a>零、传统相机的缺点</h2><p>传统相机，无论是CMOS传感器，还是CCD传感器，亦或是RGBD相机，都有一个参数：帧率。它们是以恒定的频率拍摄获取图像。这样，即使帧率能够达到1KHz，那也具有1ms的延时。所以传统相机存在一定的延迟问题。</p><p>除此之外，传统相机需要通过一定时间的曝光，使感光器件积累一定的光子，那么在曝光时间之内如果物体在高速运动，则会产生模糊，这也是传统相机的一个问题。</p><p>另外，传统相机的动态范围较低，具体表现为在光线极差或者亮度极高时，相机获取的信息有限。</p><p>以上三点，是由于相机自身硬件的限制，即使高性能相机能够一定程度减小这些问题，但由于相机原理，这些问题无法避免。这些问题极大地限制了一些应用场景。而事件相机完全不存在这些问题。 </p><h2 id="一、事件相机的介绍"><a href="#一、事件相机的介绍" class="headerlink" title="一、事件相机的介绍"></a>一、事件相机的介绍</h2><p>事件相机具有优势的典型场景包括实时交互系统，比如机器人与可穿戴设备，因为这些场景下的光照条件不可控，并且对于延时以及功率敏感。事件相机可以用于物体跟踪、识别以及手势控制，也可以应用在三维重建、光流估计、图像HDR和SLAM中，随着事件相机的发展，图像去模糊以及恒星跟踪也成为新的应用范围。</p><h2 id="二、事件相机的原理"><a href="#二、事件相机的原理" class="headerlink" title="二、事件相机的原理"></a>二、事件相机的原理</h2><p><strong>基本原理</strong></p><p>事件相机的最基本的原理，即：当某个像素的亮度变化累计达到一定阈值后，输出一个事件。这里强调几个概念：</p><p>a） 亮度变化：说明事件相机的输出和变化有关，而与亮度的绝对值没有关系；</p><p>b） 阈值：当亮度变化达到一定程度时，将输出数据，这个阈值是相机的固有参数。</p><p>下面重点解释什么是一个“事件”。事件具有三要素：时间戳、像素坐标与极性。一个事件表达的是“在什么时间，哪个像素点，发生了亮度的增加或减小”。</p><p>当场景中由物体运动或光照改变造成大量像素变化时，会产生一系列的事件，这些事件以事件流（Events stream）方式输出。事件流的数据量远小于传统相机传输的数据，且事件流没有最小时间单位，所以不像传统相机定时输出数据，具有低延迟特性。下面的动图揭示了事件相机与传统相机的成像的不同。</p><p><img src="/images/Event-Camera/001.gif"></p><p><em>（动图：左侧为有一个黑色斑块的圆盘，匀速旋转时，右上方的传统相机会定时拍摄完整的图像，下方事件相机的输出会仅输出变化，即黑斑的运动。当圆盘不转时，传统相机依旧傻傻的拍摄图像，而事件相机不会产生任何输出）</em></p><p>由于事件相机的成像原理，我们可以发现只要亮度一有变化就会输出，且仅输出变化的数据占用了很小的带宽，同时由于事件相机更擅长捕捉亮度变化，所以在较暗和强光场景下也能输出有效数据。事件相机具有低延迟（&lt;𝟏𝝁𝒔）、高动态范围（𝟏𝟒𝟎𝒅𝑩）、极低功耗（𝟏𝒎𝑾）等特性。</p><p><strong>深入了解</strong></p><p>事件相机是对每一个像素下面有一个计算电路，左边的光电转换电路将光强转换为电压值，中间是一个差分电路，结果达到触发阈值之后会触发信号。信号从片上到USB是采用一种AER（Address Event Representation）编码的方式，国内有人将这种编码用于二值图像的压缩，具体的结果就是USB传输过来的数据不是前文所说的$(x, y, polarity, timestamp)$的形式，而是需要解码之后才能得到，常见的解码程序有:</p><blockquote><p><a href="https://github.com/inivation/libcaer">https://github.com/inivation/libcaer</a></p><p><a href="https://github.com/SensorsINI/jaer">https://github.com/SensorsINI/jaer</a></p></blockquote><p>这些开源代码往往已经包含在了事件相机厂商提供的SDK中了。</p><p><img src="/images/Event-Camera/002.jpg" alt="简化事件相机的硬件电路"></p><p>虽然事件相机很好用，但有的时候还是有人想要使用绝对的灰度值。ATIS就实现了这样的一种相机，它通过触发事件后将电容器设置为高电压，然后在用另一个二极管从电容器中放电，光强越大放电越快，ATIS对放电事件进行编码得到强度值。但这样就导致在较暗的环境下放电速度不够快会导致新的事件打断放电过程（算法见<a href="https://github.com/SensorsINI/jaer/blob/master/src/eu/seebetter/ini/chips/davis/DavisAutoShooter.java">jaer</a>）。DAVIS是另一种使用广泛的将DVS（Dynamic Vision Sensor）和APS（Active Pixel Sensor）结合在一起的传感器，它将二者的光电二极管进行共享，不同在加装了一个读出电路，因此可以在输出事件的同时输出强度帧（来自APS）。</p><p>事件相机的理想模型很简单：<br>$$<br>\Delta L(x_k,t_k)=p_kC<br>$$<br>等式左边是对数灰度的变化，右边是输出的极性以及阈值，一般而言$C$会设置在 $15%-50%$。但是实际中事件相机会受到噪声以及像素错配的影响，所以一般会在该模型加上高斯随机噪声，这一点在事件相机的仿真器中有体现：</p><blockquote><p><a href="http://rpg.ifi.uzh.ch/esim.html">http://rpg.ifi.uzh.ch/esim.html</a></p></blockquote><p>跟普通相机一样，事件相机也有需要一个<a href="https://en.wikipedia.org/wiki/Fixed-pattern_noise">FPN</a>（Fixed Pixel Noise），即相机灰度的初始bias，对于事件相机而言，bias的定义就是指阈值 $C$ ，一般而言不同像素之间的 $C$ 可能相差 $2.5%-4%$，现在不存在事件相机的FPN标定计算方案，这是一个能做的研究方向。</p><p>BSI（back-side illumination）技术是广泛应用于智能手机相机上的增大填充系数的技术，目前事件相机上的光电芯片的FSI方法会阻碍光线到达像素，意味着必须增大像素面积才能获取足够的光强，使用BSI技术可以使得相机模块更薄、更小，但由于这项技术的难度与花费，现在只有少数的验证用的事件相机。</p><p>下面是一些现有的商业化的事件相机比较，最后一列是来自中国上海的芯仑科技的事件相机，最新的Celex-V相机是世界上第一台百万级像素的事件相机。（但是CeleX-IV的填充系数只有9per…）</p><p><img src="/images/Event-Camera/003.jpg" alt="现有的商业化的事件相机比较"></p><h2 id="三、事件相机的处理范式"><a href="#三、事件相机的处理范式" class="headerlink" title="三、事件相机的处理范式"></a>三、事件相机的处理范式</h2><p>事件相机的输出是事件流，主要有三种常见的处理范式，分别是：</p><h3 id="A-Event-by-Event"><a href="#A-Event-by-Event" class="headerlink" title="A. Event-by-Event"></a>A. Event-by-Event</h3><p>Event-by-Event的方法常常用于许多任务中，如SLAM里面的特征追踪、位姿追踪和图像重建。一类的方法是依赖于模型的（模型可以从其它类型的传感器数据中获得，如获得一个半稠密的深度图），然后再通过处理一个一个的事件来更新系统的状态。另一类方法是不依赖于模型的（数据驱动即机器学习）。</p><h3 id="B-Groups-of-Events"><a href="#B-Groups-of-Events" class="headerlink" title="B. Groups of Events"></a>B. Groups of Events</h3><p>由于每个事件的携带的信息很少，并且容易受到噪声的影响，因此将几个事件一起处理，能够为需要解决的问题产生足够的信噪比。基于模型的方法往往是将事件转化为frame，然后运用传统的视觉方法来解决问题。而另外一种就是基于数据驱动的事件组方法，其已经用在了分类、光流估计、深度估计等任务中。经典的CNN网络使用张量作为输入，因此事件组必须转为类似的形式。现有的一些转换方法有：事件的像素直方图、最近时间戳表面（SAE）、插值体素网格。在网络架构方面，这些任务往往都会使用流形的Encoder-Decoder架构，具体网络中的其它细节可以在引文中查找对应的引用。</p><p><img src="/images/Event-Camera/004.jpg" alt="流形的Encoder-Decoder架构"></p><h3 id="C-SNN"><a href="#C-SNN" class="headerlink" title="C. SNN"></a>C. SNN</h3><p>事件相机是受到生物学启发的传感器，SNN也是一种受到生物学启发的网络。SNN 使用脉冲（发生在时间点上的离散事件）进行连接。一个神经元从视觉空间的一个小区域（一个感受野）接受输入事件，在状态超过阈值时产生输出事件。神经元以分层的方式连接，形成一个网络，事件从输入到SNN的第一层一直往后传播。所以SNN跟事件相机搭配在一起就跟珍珠配奶茶一样自然。</p><h2 id="四、事件相机的发展与研究现状"><a href="#四、事件相机的发展与研究现状" class="headerlink" title="四、事件相机的发展与研究现状"></a>四、事件相机的发展与研究现状</h2><p>事件相机诞生于1990年，那个时间许多研究人员探讨动物感知环境的方式，发现对变化更为敏感，所以设计出了实验室用的事件相机。</p><p>2008年，诞生了第一款商用的事件相机。这么看来，事件相机从商用到现在也刚刚过了十来年。目前，许多商业公司致力于事件相机的发展，有韩国Samsung、法国prophesee、瑞士iniVation、中国CelePixel（芯仑科技）等。</p><p>在学术上，苏黎世联邦理工学院（ETH）的机器人与感知团队对事件相机有着系统深入的研究，其他高校例如帝国理工、慕尼黑大学等也开始相关研究。</p><p>事件相机，目前在在特征提取与跟踪、光流、三维重建、SLAM、模式识别、控制等方向正在不断进行着研究，具有广泛的应用前景。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事件相机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt速成指南</title>
      <link href="2021/04/06/introduce-qt/"/>
      <url>2021/04/06/introduce-qt/</url>
      
        <content type="html"><![CDATA[<h1 id="Qt速成指南"><a href="#Qt速成指南" class="headerlink" title="Qt速成指南"></a>Qt速成指南</h1><p>Qt Creator是使用Qt开发的IDE。Qt支持Windows、Linux/Unix、Mac OS X、Android、BlackBerry、QNX等多种平台，Qt Creator为不同平台提供了统一的开发环境。</p><p>Qt Creator集成了Qt Designer、Qt Assistant、Help等工具。因此，在开发过程中可以很快的通过Designer来设计界面。如果想从Qt API中获得更详细的信息，只需要将光标定位到相应的类或函数并按下F1即可。</p><h1 id="安装Qt-Creator"><a href="#安装Qt-Creator" class="headerlink" title="安装Qt Creator"></a>安装Qt Creator</h1><blockquote><p>这里仅介绍Linux下的</p></blockquote><p><strong>在Linux下，我们通过一条指令就可以安装好Qt环境</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> libqt4-dev libqt4-opengl-dev qtcreator<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以使用如下的指令打开项目文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">qtcreator simple_draw.pro<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="熟悉Qt-Creator-界面"><a href="#熟悉Qt-Creator-界面" class="headerlink" title="熟悉Qt Creator 界面"></a>熟悉Qt Creator 界面</h1><blockquote><p>部分转载</p></blockquote><h2 id="欢迎模式"><a href="#欢迎模式" class="headerlink" title="欢迎模式"></a>欢迎模式</h2><p>进入Qt Creator后，会默认进入欢迎模式，默认选择的是”Project”选项。当然，通过它我们可以很容易对工程进行操作。</p><h3 id="工程"><a href="#工程" class="headerlink" title="工程"></a>工程</h3><p><strong>New Project：</strong><br>新建工程。可以使Qt工程、Creator插件、C++库、其他项目。</p><p><strong>Open Project：</strong><br>打开工程</p><p><strong>Seeeions：</strong><br>会话。可以对会话进行管理，包括Clone。如果没打开工程，则显示的是最后一次打开的（会话）工程，否则，显示当前的会话（工程）。</p><p><strong>Recent Projects：</strong><br>列出最近打开的项目，通过它可以迅速打开指定项目。</p><p><strong>New to Qt：</strong><br>可以帮助你学习开发Qt项目和浏览Qt Creator。</p><p>Qt Account：Qt账户<br>Qt Cloud Services：Qt云服务<br>Online Community：网络社区<br>Blogs：博客<br>User Guide：用户手册</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>列出了所有的Qt Examples（Qt Widgets、QML相关的），选择任意一个你想到学习的示例打开，然后编译、运行。如果你看不到示例所示的内容，你可以运行以下指令并且重新打开Qt creator</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> qtbase5-examples qtbase5-doc-html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>建议大家一定要把”示例”用好，这绝对是熟悉Qt的一条捷径，里面有成为高手的必杀技。</p><h3 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h3><p>里面包含大量的Qt讲解视频及文档。</p><h2 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h2><p>当打开一个项目或者创建一个新的项目后，Qt Creator将会切换到编辑模式下。可以在左边看到项目文件，在中央区域看到代码编辑器。左边选中的文件将会被编辑器打开。</p><p>编辑器提供了语法高亮，代码补全和智能纠错的功能，也提供各种代码重构的命令。当使用编辑器工作时，你会觉得它的响应异常迅速。这感谢Qt Creaotor的开发者将这个工具做的如此杰出。</p><p><strong>在编辑模式工作</strong></p><p>可以编辑当前文件，添加新文件或者现有文件，添加库，还可以进行搜索结果的查找。</p><p>可以在编辑器工具栏中打开的文件和符号之间进行导航。也可以拆分视图同时对多个文件进行操作，添加书签，切换头文件/源文件、以及函数声明/定义等。</p><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><p><strong>语法高亮</strong></p><p>可以通过突出显示代码元素和块来编写格式良好的代码。使用语法高亮也可用于其他类型的文件，比如C++或QML。</p><p><strong>检查代码语法</strong></p><p>当写代码时，Qt Creator会检查错误并显示内嵌错误和警告消息。同样，可以检查一个JSON数据结构。此外，可以在项目中运行QML和JavaScript代码的静态检查，以找到共同的问题。</p><p><strong>完成代码</strong></p><p>Qt Creator可以预计你将写什么，并且为元素、属性和标识完成代码和代码段。</p><p><strong>缩进文本或代码</strong></p><p>Qt Creator根据C++、QML代码文件和其它文本文件指定的规则，进行缩进文本和代码。</p><p><strong>使用Qt Quick的工具栏</strong></p><p>当编辑QML代码时，可以指定QML组件的属性。对于某些属性并不简单，如颜色和字体。例如，很少有人能想象颜色＃18793f。如果要轻松编辑这些属性，可以使用Qt Quick工具栏。</p><p><strong>粘贴和提取代码段</strong></p><p>可以与其他开发人员合作通过从服务器粘贴和获取代码片段。例如，你可能会让同事来审查你计划提交到版本控制系统中的变化。</p><p><strong>使用文本编辑宏</strong></p><p>当你在代码编辑器中打开一个文件，可以记录键盘序列作为宏。然后，你可以运行重复序列的宏。可以保存最新的宏并分配快捷键运行，或从定位器运行。</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><strong>查找和替换</strong></p><p>当输入的时候，增量搜索会匹配窗口中高亮的字符串，同时输入高级搜索能够在文件系统中从当前打开的项目或文件中搜索。可以同时进行增量搜索和高级搜索。</p><p><strong>用定位器搜索</strong></p><p>定位器提供了Qt Creator中最简单的方法之一来浏览项目、文件、类、函数、文档和文件系统。</p><h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><p><strong>重构代码</strong></p><ul><li>提高应用程序的内部质量</li><li>提高性能和可扩展</li><li>提高代码的可读性和可维护性</li><li>简化代码结构</li></ul><p><strong>查找符号</strong></p><p>为了查找Qt C++或Qt Quick项目中特定符号或者QML组件的引用：</p><p>1、在编辑器中，将光标放在符号或组件上，然后选择：</p><ul><li>Tools -&gt; C++ &gt; Find Usages</li><li>Tools &gt; QML/JS -&gt; Find Usages</li><li>Ctrl+Shift+U</li></ul><p>Qt Creator在以下位置查找符号：</p><ol><li>列为项目的一部分文件</li><li>文件直接被项目文件所使用（例如，生成的文件）</li><li>使用框架和库的头文件</li></ol><p>注意：也可选择：Edit-&gt;Find/Replace-&gt;Advanced Find-&gt;C++ Symbols，以便搜索类、函数、枚举、和声明无论是项目的一部分文件或被代码使用的所有文件，如include文件。</p><p>2、”搜索结果”窗口打开并显示当前项目中符号的位置和数量。</p><p><strong>应用重构操作</strong></p><p>Qt Creator允许快速、方便地重构代码。重构的操作是否可用取决于光标在代码编辑器的位置以及你是否写的是C++或者QML代码。</p><p>要使用重构，以C++代码为例，鼠标右键一个操作数、条件语句、字符串或名称打开上下文菜单。在QML代码，可以点击某个项目的ID或名称，在上下文菜单中选择重构，然后选择一个重构操作。也可以按Alt+Enter键打开包含在当前光标位置可重构行为的上下文菜单。</p><p><strong>重构C++代码</strong></p><ul><li>参考：<a href="http://doc.qt.io/qtcreator/creator-editor-refactoring.html">重构</a></li></ul><h3 id="配置编辑器"><a href="#配置编辑器" class="headerlink" title="配置编辑器"></a>配置编辑器</h3><p>Qt Creator允许配置文本编辑器，以满足特定的需求。要配置编辑器，选择：工具-&gt;选项-&gt;文本编辑器。</p><p>这些设置适用于所有项目（全局设置），若要配置当前项目的文本编辑行为：</p><ol><li>选择：项目-&gt;编辑器。</li><li>编辑器设置选择”自定义设置”。</li><li>为项目指定文本编辑器设置。</li></ol><h3 id="字体和颜色"><a href="#字体和颜色" class="headerlink" title="字体和颜色"></a>字体和颜色</h3><p><strong>配置字体</strong></p><p>你可以选择字体和字号，可以查看文本指定百分比的缩放设置。也可以按Ctrl++或Ctrl+- 放大或缩小，或者按住Ctrl键向上或向下滚动鼠标滚轮。要禁用鼠标滚轮的功能，选择：工具-&gt;选项-&gt;文本编辑器-&gt;行为，并取消选中”开启鼠标滚轮缩放”复选框。</p><p>抗锯齿默认情况下启用，以使屏幕上的文本看起来更平滑更易读。取消”抗锯齿”复选框以关闭抗锯齿。</p><p><strong>定义配色方案</strong></p><p>可以选择语法高亮预定义的颜色方案中的一种或创建自定义配色方案。该配色方案适用于突出C++和QML文件和通用文件。</p><p>要创建一个颜色方案：</p><ol><li>选择工具-&gt;选项-&gt;文本编辑器-&gt;字体和颜色-&gt;复制。</li><li>输入颜色方案的名称（自定义），然后确定。</li><li>选择前景色。</li><li>选择背景色。</li></ol><p>这里是让大家了解如何自定义配色方案。当然，一般我不会去自己设置，我会使用”配色方案”中的默认选项”Dark”、然后”字号”改为12，其他均默认。这样，编辑器看起来就没有那么亮了，而且字体也变得比较大，看起来很舒服。</p><h3 id="行为"><a href="#行为" class="headerlink" title="行为"></a>行为</h3><p>这里主要介绍缩进、文件编码格式</p><p><strong>制表符和缩进</strong></p><p>当键入文字或代码时，会根据所选择的文本编辑器或代码样式选项自动缩进。当你按下Tab键，选择一个块缩进。按Shift+Tab键来减少缩进。也可以禁用自动缩进。</p><p>可以为以下文件指定缩进：</p><ol><li>C++文件</li><li>QML文件</li><li>其他文本文件</li></ol><p>也可以分别为每个项目指定缩进。可以指定多套代码风格设置，并在它们之间轻松切换。此外，你可以导入和导出代码样式设置。</p><p>更多参考：<a href="http://doc.qt.io/qtcreator/creator-indenting-code.html">缩进文件或代码</a></p><p><strong>文件编码</strong></p><p>Qt5需要UTF-8编码的源文件，因此在Qt Creator2.6版本默认编码从”System”改为”UTF-8”。尽管系统默认的编码设置为UTF-8，然而，默认编码字段仍然显示系统值。</p><p>检测正确的编码比较棘手，所以Qt Creator中不会尝试这样做。相反，当尝试编辑一个非UTF-8编码的文件，会显示错误信息：Error: Could not decode “filename” with “UTF-8”-encoding. Editing not possible.</p><p>要解决此问题，可以使用文件转换工具，如重新将文件编码转换为UTF-8。否则，正如预期一样，可能无法正常工作。</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>打开Qt Creator后，你会发现”设计”压根是不可用的，Why？呵呵哒。。。因为你没有编辑ui文件。</p><p>当我们双击工程中的一个ui文件时，默认会进入设计模式。这里主要分为5个区域：</p><p><strong>窗口部件盒：</strong><br>主要包含布局、拉伸、按钮、视图（基于Model）、视图（基于Item）、容器、输入控件、显示控件等。</p><p><strong>窗口编辑器：</strong><br>可以利用控件区的部件来对窗口进行布局，达到想要的效果。</p><p><strong>对象查看器：</strong><br>将窗体编辑区的控件按照父子关系以树形结构显示出来。与窗体编辑区的共同特点是：可以改变对象名称、样式表、信号和槽等。</p><p><strong>属性值编辑器：</strong><br>可以编辑相应控件的属性值，例如：名称、大小、文本、样式等。</p><p><strong>动作、信号/槽编辑器：</strong><br>可以指定编辑动作及相应控件的信号与槽。</p><p>这里先做简单的一些了解，后面会对Designer做详细的介绍，更多精彩待续。。。</p><h2 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h2><h3 id="调试C-程序"><a href="#调试C-程序" class="headerlink" title="调试C++程序"></a>调试C++程序</h3><p>要查看类及存储的数据，需要为程序设置断点。</p><p>如下所示：</p><p>1、为需要调试的代码设置断点。</p><p>2、开始”调试”。</p><p>或按下F5（调试-&gt;开始调试-&gt;开始调试）。</p><p>3、选择”Locals and Expressions”，查看类及数据成员信息。</p><p>也可以将鼠标滑过进行查看。</p><p>4、选择”Breakpoints”，查看断点信息。</p><p>包含：编号、函数、文件、行号等信息</p><p>5、选择”Stack”，查看堆栈信息。</p><p>包括：级别、函数、文件、行号等信息</p><h2 id="帮助模式"><a href="#帮助模式" class="headerlink" title="帮助模式"></a>帮助模式</h2><h3 id="使用帮助模式"><a href="#使用帮助模式" class="headerlink" title="使用帮助模式"></a>使用帮助模式</h3><p>Qt Creator完全集成Qt文档和Qt示例使用帮助插件。你可以为帮助模式添加外部文档，并且过滤文件显示更快地找到相关信息。此外，还可以为帮助页面添加书签。</p><ul><li>要查看文档，切换到帮助模式。</li><li>要查看Qt类或函数的提示（ToolTip）上下文敏感帮助，移动鼠标至类或函数上即可，如果帮助不可用，则提示显示符号的类型信息。</li><li>要显示一个Qt类或函数的全部信息，按F1。文档显示在代码编辑旁边的一个窗口，如果没有足够的垂直空间，则全屏显示帮助模式。</li><li>要选择和配置文档在帮助模式下的显示方式，选择：工具-&gt;选项-&gt;帮助。</li></ul><h3 id="查看功能提示"><a href="#查看功能提示" class="headerlink" title="查看功能提示"></a>查看功能提示</h3><p>若要隐藏默认的提示功能，选择：工具-&gt;选项-&gt;文本编辑器-&gt;行为，”鼠标和键盘”选项中”Show help tooltips using the mouse”选择”Shift+鼠标悬停时” 。这样就可以通过按住Shift键来查看提示。要使用键盘快捷键来查看帮助提示，选择”Show help tooltips using keyboard shortcut(Alt)”。</p><h3 id="在文档中查找信息"><a href="#在文档中查找信息" class="headerlink" title="在文档中查找信息"></a>在文档中查找信息</h3><p>Qt Creator、Qt和其他Qt交付的产品包含了如.qch文件的文档。所有的文件是在帮助模式下访问。</p><p>要查找文档中的信息，请选择：</p><ul><li>书签：查看添加至书签的页面列表。</li><li>内容：查找安装在开发电脑中的所有文档，来浏览文档内容。</li><li>索引：基于所有已安装的文档中的关键字列表查找。</li><li>打开页面，以查看当前打开的文档页面的列表。</li><li>查找：在所有已安装的文档中进行查找。</li></ul><h3 id="添加书签到帮助页"><a href="#添加书签到帮助页" class="headerlink" title="添加书签到帮助页"></a>添加书签到帮助页</h3><p>可以将书签添加到有用的帮助页面，之后在”书签”视图就可以轻松地找到它们。可以用页面标题作为书签，也可以将其更改为任何文本。可以在视图文件夹里组织书签。</p><p>要将书签添加到打开的帮助页面：</p><ol><li>单击工具栏上的按钮。</li><li>在”添加书签”对话框中，单击确定，在选中的文件夹中保存书签。</li></ol><p>要导入和导出书签，选择：工具-&gt;选项-&gt;帮助-&gt;概要-&gt;导入或导出。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cartographer探索记录</title>
      <link href="2021/03/28/learning-cartographer/"/>
      <url>2021/03/28/learning-cartographer/</url>
      
        <content type="html"><![CDATA[<h1 id="Cartographer探索笔记"><a href="#Cartographer探索笔记" class="headerlink" title="Cartographer探索笔记"></a>Cartographer探索笔记</h1><h2 id="Lua配置文件参数解析"><a href="#Lua配置文件参数解析" class="headerlink" title="Lua配置文件参数解析"></a>Lua配置文件参数解析</h2><table border="1" cellpadding="1" cellspacing="1"><tbody><tr><td style="width:153px;">参数</td><td style="width:590px;">解析</td><td>常用值</td></tr><tr><td style="width:153px;">map_frame</td><td style="width:590px;">用于发布submaps的ROS坐标系ID，位姿的父坐标系，通常使用“map”</td><td>“map”</td></tr><tr><td style="width:153px;">tracking_frame</td><td style="width:590px;">由SLAM算法追踪的ROS坐标系ID，如果使用IMU，应该使用其坐标系，通常选择是 “imu_link”</td><td>"base_footprint"</td></tr><tr><td style="width:153px;">published_frame</td><td style="width:590px;">用于发布位姿子坐标系的ROS坐标系ID，例如“odom”坐标系，如果一个“odom”坐标系由系统的不同部分提供，在这种情况下，map_frame中的“odom”姿势将被发布。 否则，将其设置为“base_link”可能是合适的</td><td>"odom"</td></tr><tr><td style="width:153px;">odom_frame</td><td style="width:590px;">在provide_odom_frame为真才启用，坐标系在published_frame和map_frame之间用于发布局部SLAM结果，通常是“odom”</td><td>"odom"</td></tr><tr><td style="width:153px;">provide_odom_frame</td><td style="width:590px;">如果启用，局部，非闭环，持续位姿会作为odom_frame发布在map_frame中发布。</td><td>true</td></tr><tr><td style="width:153px;">use_odometry</td><td style="width:590px;">如果启用，订阅关于“odom”话题的nav_msgs/Odometry消息。里程信息会提供，这些信息包含在SLAM里</td><td>false</td></tr><tr><td style="width:153px;">num_laser_scans</td><td style="width:590px;"> <p style="margin-left:0pt;">订阅的激光扫描话题数量。</p> <p style="margin-left:0pt;">在一个激光扫描仪的“scan”话题上订阅sensor_msgs/LaserScan</p> <p style="margin-left:0pt;">或在多个激光扫描仪上订阅话题“scan_1”，“scan_2”等</p> </td><td>1</td></tr><tr><td style="width:153px;">num_multi_echo_laser_scans</td><td style="width:590px;"> <p style="margin-left:0pt;">订阅的多回波激光扫描主题的数量。</p> <p style="margin-left:0pt;">在一个激光扫描仪的“echoes”话题上订阅sensor_msgs/MultiEchoLaserScan</p> <p style="margin-left:0pt;">或者为多个激光扫描仪订阅话题“echoes_1”，“echoes_2”等。</p> </td><td>0</td></tr><tr><td style="width:153px;">num_subdivisions_per_laser_scan</td><td style="width:590px;"> <p style="margin-left:0pt;">将每个接收到的（多回波）激光扫描分成的点云数。</p> <p style="margin-left:0pt;">细分扫描可以在扫描仪移动时取消扫描获取的扫描。</p> <p style="margin-left:0pt;">有一个相应的轨迹构建器选项可将细分扫描累积到将用于扫描匹配的点云中。</p> </td><td>1</td></tr><tr><td style="width:153px;">num_point_clouds</td><td style="width:590px;"> <p style="margin-left:0pt;">要订阅的点云话题的数量。</p> <p style="margin-left:0pt;">在一个测距仪的“points2”话题上订阅sensor_msgs/PointCloud2</p> <p style="margin-left:0pt;">或者为多个测距仪订阅话题“points2_1”，“points2_2”等。</p> </td><td>0</td></tr><tr><td style="width:153px;"> <p style="margin-left:0pt;">lookup_transform_timeout_sec</p> </td><td style="width:590px;">使用tf2查找变换的超时秒数</td><td>0.2</td></tr><tr><td style="width:153px;">submap_publish_period_sec</td><td style="width:590px;">发布submap的间隔（以秒为单位），例如， 0.3秒</td><td>0.3</td></tr><tr><td style="width:153px;">pose_publish_period_sec</td><td style="width:590px;">发布姿势的间隔（以秒为单位），例如 5e-3，频率为200 Hz。</td><td>5e-3</td></tr><tr><td style="width:153px;"> <p style="margin-left:0pt;">trajectory_publish_period_sec</p> </td><td style="width:590px;">以秒为单位发布轨迹标记的时间间隔，例如， 30e-3持续30毫秒</td><td>30e-3</td></tr></tbody></table><h2 id="urdf文件中的一些问题"><a href="#urdf文件中的一些问题" class="headerlink" title="urdf文件中的一些问题"></a>urdf文件中的一些问题</h2><ul><li><p><strong>把所有的坐标系转化到一起去没用，相机和雷达本身的坐标系是什么样子的，就应该在urdf中描述成什么样子。</strong></p></li><li><p><strong>urdf中的rpy是绕xyz轴旋转，并且是定轴！！！</strong></p><p>绕动轴z-y-x旋转的是Euler角(ypr)</p></li><li><p><strong>imu和雷达是绑定的，转一个的坐标系，另外一个也会跟着转</strong></p></li></ul><h2 id="使用cartographer建图"><a href="#使用cartographer建图" class="headerlink" title="使用cartographer建图"></a>使用cartographer建图</h2><blockquote><p>建图、导入保存本地的地图、导入地图时带入初始的位姿</p></blockquote><h4 id="保存地图到本地"><a href="#保存地图到本地" class="headerlink" title="保存地图到本地"></a>保存地图到本地</h4><p>1、Finish the first trajectory. No further data will be accepted on it.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rosservice call /finish_trajectory <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、Ask Cartographer to serialize its current state.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rosservice call /write_state <span class="token string">"{filename: '<span class="token variable">${<span class="token environment constant">HOME</span>}</span>/Downloads/mapName.pbstream'}"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3、transform pbstream to pgm and yaml</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">roslaunch cartographer_ros assets_writer_ros_map.launch bag_filenames:<span class="token operator">=</span><span class="token variable">${<span class="token environment constant">HOME</span>}</span>/Downloads/***.bag pose_graph_filename:<span class="token operator">=</span><span class="token variable">${<span class="token environment constant">HOME</span>}</span>/Downloads/***.pbstream<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>or</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rosrun cartographer_ros cartographer_pbstream_to_ros_map <span class="token parameter variable">-map_filestem</span><span class="token operator">=</span>/home/lqx/Downloads/savemap <span class="token parameter variable">-pbstream_filename</span><span class="token operator">=</span>/home/lqx/Downloads/***.pbstream <span class="token parameter variable">-resolution</span><span class="token operator">=</span><span class="token number">0.05</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="从本地导入地图"><a href="#从本地导入地图" class="headerlink" title="从本地导入地图"></a>从本地导入地图</h4><blockquote><p>cartographer pure localization</p></blockquote><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>node</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cartographer_node<span class="token punctuation">"</span></span> <span class="token attr-name">pkg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cartographer_ros<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cartographer_node<span class="token punctuation">"</span></span> <span class="token attr-name">args</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>-load_state_filename $MAP_NAME.pbstream<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面这个不太清楚，似乎不需要</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua">TRAJECTORY_BUILDER<span class="token punctuation">.</span>pure_localization <span class="token operator">=</span> <span class="token keyword">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="带入初始位姿信息"><a href="#带入初始位姿信息" class="headerlink" title="带入初始位姿信息"></a>带入初始位姿信息</h4><blockquote><p>cartographer pure localization initial pose</p></blockquote><p>在launch文件中加入 <code>        -start_trajectory_with_default_topics=false</code>，最后的效果如下所示：</p><pre class="line-numbers language-none"><code class="language-none">  &lt;node name="cartographer_node"        pkg="cartographer_ros"        type="cartographer_node"        args="-configuration_directory $(find cartographer_ros_launcher)/configuration_files -configuration_basename cartographer.lua -load_state_filename /home/lqx/Downloads/2021_map.pbstream -start_trajectory_with_default_topics=false"        output="screen"&gt;  &lt;/node&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>设置初始位姿时，需要注意四元数的归一化，并且map坐标是建图的时候就确定了的。使用的指令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rosservice call /start_trajectory <span class="token string">"configuration_directory: '/home/lqx/catkin_cv/src/cartographer_ros_launcher/configuration_files'configuration_basename: 'cartographer.lua'use_initial_pose: trueinitial_pose:  position: {x: 1.0, y: -1.5, z: 0.0}  orientation: {x: 0, y: 0, z: 0, w: 1}relative_to_trajectory_id: 0"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="多机协同，共用一张地图"><a href="#多机协同，共用一张地图" class="headerlink" title="多机协同，共用一张地图"></a>多机协同，共用一张地图</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li>单机器人的闭环检测，修正误差累计，保证地图一致性</li><li>实现场景识别，从而建立多机器人间的约束</li><li>压缩地图数据，使其满足带宽有限的机器人间的数据共享</li></ul><p><strong>To be continued……</strong></p>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 激光SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片上打印帧率等信息</title>
      <link href="2021/02/24/opencv-notes-1/"/>
      <url>2021/02/24/opencv-notes-1/</url>
      
        <content type="html"><![CDATA[<h1 id="图片上打印帧率等信息"><a href="#图片上打印帧率等信息" class="headerlink" title="图片上打印帧率等信息"></a>图片上打印帧率等信息</h1><h2 id="计算某一个算法的帧率"><a href="#计算某一个算法的帧率" class="headerlink" title="计算某一个算法的帧率"></a>计算某一个算法的帧率</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Start timer</span><span class="token keyword">double</span> timer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token function">getTickCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//待测算法</span><span class="token function">algorithm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// Calculate Frames per second (FPS)</span><span class="token keyword">float</span> fps <span class="token operator">=</span> <span class="token function">getTickFrequency</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token function">getTickCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> timer<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用putText-函数将信息直接输出到图片上"><a href="#使用putText-函数将信息直接输出到图片上" class="headerlink" title="使用putText()函数将信息直接输出到图片上"></a>使用putText()函数将信息直接输出到图片上</h2><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> cv<span class="token double-colon punctuation">::</span><span class="token function">putText</span><span class="token punctuation">(</span>cv<span class="token double-colon punctuation">::</span>Mat<span class="token operator">&amp;</span> img<span class="token punctuation">,</span> <span class="token comment">// 待绘制的图像</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> text<span class="token punctuation">,</span> <span class="token comment">// 待绘制的文字</span>cv<span class="token double-colon punctuation">::</span>Point origin<span class="token punctuation">,</span> <span class="token comment">// 文本框的左下角</span><span class="token keyword">int</span> fontFace<span class="token punctuation">,</span> <span class="token comment">// 字体 (如cv::FONT_HERSHEY_PLAIN)</span><span class="token keyword">double</span> fontScale<span class="token punctuation">,</span> <span class="token comment">// 尺寸因子，值越大文字越大</span>cv<span class="token double-colon punctuation">::</span>Scalar color<span class="token punctuation">,</span> <span class="token comment">// 线条的颜色（RGB）</span><span class="token keyword">int</span> thickness <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// 线条宽度</span><span class="token keyword">int</span> lineType <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token comment">// 线型（4邻域或8邻域，默认8邻域）</span><span class="token keyword">bool</span> bottomLeftOrigin <span class="token operator">=</span> <span class="token boolean">false</span> <span class="token comment">// true='origin at lower left'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>在图片左上角显示使用的算法，帧率，是否检测到目标物</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">putText</span><span class="token punctuation">(</span>frame<span class="token punctuation">,</span> detectionType<span class="token punctuation">,</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span> FONT_HERSHEY_SIMPLEX<span class="token punctuation">,</span> <span class="token number">0.75</span><span class="token punctuation">,</span> <span class="token function">Scalar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">170</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">putText</span><span class="token punctuation">(</span>frame<span class="token punctuation">,</span> <span class="token string">"FPS : "</span> <span class="token operator">+</span> <span class="token function">to_string</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">(</span>fps<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span> FONT_HERSHEY_SIMPLEX<span class="token punctuation">,</span> <span class="token number">0.75</span><span class="token punctuation">,</span> <span class="token function">Scalar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">170</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>detection_failed<span class="token punctuation">)</span><span class="token function">putText</span><span class="token punctuation">(</span>frame<span class="token punctuation">,</span> <span class="token string">" Detection failed"</span><span class="token punctuation">,</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">,</span> FONT_HERSHEY_SIMPLEX<span class="token punctuation">,</span> <span class="token number">0.75</span><span class="token punctuation">,</span> <span class="token function">Scalar</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是效果图：</p><p><img src="/images/OpenCV-Notes/1-1.png"></p><p><img src="/images/OpenCV-Notes/1-2.png"></p>]]></content>
      
      
      <categories>
          
          <category> 三维视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解SVM的三层境界</title>
      <link href="2021/02/23/opencv-notes-4/"/>
      <url>2021/02/23/opencv-notes-4/</url>
      
        <content type="html"><![CDATA[<h1 id="理解SVM的三层境界"><a href="#理解SVM的三层境界" class="headerlink" title="理解SVM的三层境界"></a>理解SVM的三层境界</h1><p>SVM是什么? 先来看看维基百科上对<a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA">SVM的定义</a>:</p><blockquote><p>支持向量机（英语：support vector machine，常简称为SVM，又名支持向量网络）是在分类与回归分析中分析数据的监督式学习模型与相关的学习算法。给定一组训练实例，每个训练实例被标记为属于两个类别中的一个或另一个，SVM训练算法创建一个将新的实例分配给两个类别之一的模型，使其成为非概率二元线性分类器。SVM模型是将实例表示为空间中的点，这样映射就使得单独类别的实例被尽可能宽的明显的间隔分开。然后，将新的实例映射到同一空间，并基于它们落在间隔的哪一侧来预测所属类别。</p></blockquote><p>如果从未接触SVM的话，维基的这一大段解释肯定会让你一头雾水。简单点讲，SVM就是一种二类分类模型，他的基本模型是的定义在特征空间上的<strong>间隔最大</strong>的线性分类器，SVM的学习策略就是间隔最大化。</p><p>下面是我从网上找到的一篇讲解SVM比较好的文章：</p><object data="/pdf/理解SVM的三层境界.pdf" type="application/pdf" width="100%" height="1000"></object>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SLAM问题的数学表述</title>
      <link href="2021/02/05/slam-learning-1/"/>
      <url>2021/02/05/slam-learning-1/</url>
      
        <content type="html"><![CDATA[<h1 id="SLAM问题的数学表述"><a href="#SLAM问题的数学表述" class="headerlink" title="SLAM问题的数学表述"></a>SLAM问题的数学表述</h1><blockquote><p>本文是作者对于SLAM问题数学表述的一些理解，如有错误，非常非常非常欢迎指正！</p></blockquote><h2 id="经典SLAM模型"><a href="#经典SLAM模型" class="headerlink" title="经典SLAM模型"></a>经典SLAM模型</h2><p>经典SLAM模型由一个<strong>运动方程</strong>和一个<strong>观测方程</strong>构成，如下所示：<br>$$<br>\begin{cases}<br>x_k &amp;= \ f(x_{k-1},u_k,w_k) \\<br>z_{k,j} &amp;= \ h(y_j,x_k,v_{k,j})<br>\end{cases}<br>$$<br>有时候也会写成下面这样的形式：<br>$$<br>\begin{cases}<br>x_k &amp;= \ f(x_{k-1},u_k) +w_k \\<br>z_{k,j} &amp;= \ h(y_j,x_k)+v_{k,j}<br>\end{cases}<br>$$<br>这两种形式本质上都是一样的。其中，$ x_k $表示第k次的位置或者位姿，$ u_k $表示第k次传感器的读数或者输入，$ w_k $表示第k次运动过程中的噪声；而$ y_j $为观测到的路标点j，$ z_{k,j} $则表示第k次观测中对于路标点j所得到的观测结果，$ v_{k,j} $为本次观测过程中的噪声。而上面的函数 $ f $ 和 $ h $ ，需要根据具体的情况来确定。</p><p>之后，我们将以视觉SLAM为例来更深入的理解SLAM的数学表述。</p><h2 id="针孔相机模型"><a href="#针孔相机模型" class="headerlink" title="针孔相机模型"></a>针孔相机模型</h2><p>考虑到视觉SLAM的传感器是相机，并且通常符合针孔相机模型。所以在继续探讨之前，我们将对针孔相机模型做一个简单的介绍。</p><h3 id="从相机坐标系到图像坐标系"><a href="#从相机坐标系到图像坐标系" class="headerlink" title="从相机坐标系到图像坐标系"></a>从相机坐标系到图像坐标系</h3><p>如下图，相机坐标系下的一点$ P(X, Y, Z) $，通过小孔成像在相机的物理成像平面上，记为$ P’(X’, Y’) $。</p><p><img src="/images/slam-learning/1-1.png"></p><p>我们能够很容易的得出以下结论：<br>$$<br>\frac Zf=- \frac X{X’}=- \frac Y{Y’}<br>$$<br>由于我们通常看到的像都是正的，并且为了公式的简洁，我们对上式加以整理，得到：<br>$$<br>X’=f \frac XZ \\<br>Y’=f \frac YZ<br>$$</p><h3 id="从图像坐标系到像素坐标系"><a href="#从图像坐标系到像素坐标系" class="headerlink" title="从图像坐标系到像素坐标系"></a>从图像坐标系到像素坐标系</h3><p>事实上，计算机看到的图像都是由像素构成的，从图像坐标系到像素坐标系还需要经过一次转化。这里我们记像素坐标为$ P’’(u,v) $。<br>$$<br>\begin{cases}<br>u=\alpha X’+c_x \\<br>v=\beta Y’+c_y<br>\end{cases}<br>$$<br>其中$ \alpha $和$ \beta $分别表示x轴和y轴的缩放系数，而$ c_x $和$ c_y $则表示平移量。</p><p>我们将之前得到的结论代入上式，可以得到：<br>$$<br>\begin{cases}<br>u=f_x\frac XZ+c_x \\<br>v=f_y\frac YZ+c_y<br>\end{cases}<br>$$<br>其矩阵形式可以表示为：<br>$$<br>\begin{pmatrix} u\\v\\1 \end{pmatrix}=\frac1Z\begin{pmatrix}f_x &amp; 0 &amp; c_x \\ 0 &amp; f_y &amp; c_y\\0 &amp; 0 &amp; 1 \end{pmatrix}<br>\begin{pmatrix}X\\Y\\Z\end{pmatrix}<br>\overset{\text{def}}{=}\frac 1ZKP<br>$$<br>但我们通常使用下面的公式来表示，它看上去更简洁：<br>$$<br>Z\begin{pmatrix} u\\v\\1 \end{pmatrix}=\begin{pmatrix}f_x &amp; 0 &amp; c_x \\ 0 &amp; f_y &amp; c_y\\0 &amp; 0 &amp; 1 \end{pmatrix}<br>\begin{pmatrix}X\\Y\\Z\end{pmatrix}<br>\overset{\text{def}}{=}KP<br>$$<br>左边的是齐次坐标，而右边的是非齐次坐标。我们把中间的矩阵称为内参数，记为K，内参通常在相机生产之后就已经固定，我们可以通过查询或者标定获得相机的内参。</p><h3 id="从世界坐标系到相机坐标系"><a href="#从世界坐标系到相机坐标系" class="headerlink" title="从世界坐标系到相机坐标系"></a>从世界坐标系到相机坐标系</h3><p>上面我们仅仅描述了物体从相机坐标系到像素坐标系的转化。而在SLAM中，我们通常需要设置一个世界坐标系以描述相机或机器人的位置信息。因此从物体被观测，再到获得观测结果，即物体的像素坐标，中间还有一个转化过程。我们使用如下的一个式子进行描述：<br>$$<br>ZP_{uv}=Z\begin{pmatrix} u\\v\\1 \end{pmatrix}=KP=K(RP_w+t)=KTP_w<br>$$<br>这里，$ R $是旋转矩阵，$ t $是平移矩阵，$ T= \begin{pmatrix} R &amp; t \\ 0 &amp; 1 \end{pmatrix} $。可以理解为使用世界坐标系描述的点$ P_w $经过旋转变化和平移变化，得到了使用相机坐标系描述的点$ P $。</p><p><strong>其中R，t 或T被称为外参，而外参正是SLAM估计的目标。</strong></p><h2 id="更具体的数学表述"><a href="#更具体的数学表述" class="headerlink" title="更具体的数学表述"></a>更具体的数学表述</h2><p>再回到最开始提到的运动方程和观测方程：<br>$$<br>\begin{cases}<br>x_k &amp;= \ f(x_{k-1},u_k) +w_k \\<br>z_{k,j} &amp;= \ h(y_j,x_k)+v_{k,j}<br>\end{cases}<br>$$</p><p>我们知道机器人有六个自由度，因此我们可以把$ x_k $理解为第k次观测时机器人的位姿，它是六维的，我们可以用向量表示，也可以使用变换矩阵表示，即上面的$ T $（可以认为当前机器人的位姿是由机器人在原点经过$ R $旋转和$ t $平移得到的）。此时运动方程描述的是机器人在第k-1次观测后，对其传感器输入$ u_k $，使机器人的位姿从$ x_{k-1} $变换到了$ x_k $，而$ w_k $则是此次运动中的噪声。</p><p>而我们上面讲的针孔相机模型，实际上就是视觉SLAM中的观测模型。公式中$ y_j $就是针孔相机模型中我们观测的点$ P_w $，表示世界坐标系下路标点j的坐标，而$ z_{k,j} $就是观测的最终结果——像素坐标$ P_{uv} $。$ x_k $既是机器人的位姿，实际上也是模型中的外参$ T $。$ v_{k,j} $则是此次观测中的噪声。</p><p>至此，我们可以用一种更具体的形式重写上面的运动方程和观测方程：<br>$$<br>\begin{cases}<br>T_k &amp;= \ f(T_{k-1},u_k) +w_k \\<br>s_j P_{uv(k,j)} &amp;= \ K(R_kP_{w(j)}+t_k)+v_{k,j}=KT_kP_{w(j)}+v_{k,j}<br>\end{cases}<br>$$<br>其中$ s_j $是路标点j到相机光心的距离。</p><h2 id="对SLAM问题的总结"><a href="#对SLAM问题的总结" class="headerlink" title="对SLAM问题的总结"></a>对SLAM问题的总结</h2><p>通常，由于各种复杂因素的影响，我们无法直接求解机器人实际的运动方程，也无法通过理论上的运动方程精确计算出机器人的位姿，因此我们通过求解观测方程来相对精确地计算机器人的位置信息。</p><p>在视觉SLAM中，这个过程可以表述为：已知相机内参$ K $，相机观测到的目标物坐标$ P_w $，目标物距离相机的距离$ s $以及它在图像上的像素坐标$ P_{uv} $，求解机器人的位姿$ T $。</p><p>当然，由于观测数据同样受噪声影响，最终得到的位姿也不是准确的，还需要通过一些处理来减小误差。</p>]]></content>
      
      
      <categories>
          
          <category> slam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视觉SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建指定OpenCV版本的ROS工程</title>
      <link href="2020/12/19/opencv-notes-3/"/>
      <url>2020/12/19/opencv-notes-3/</url>
      
        <content type="html"><![CDATA[<h1 id="创建指定OpenCV版本的ROS工程"><a href="#创建指定OpenCV版本的ROS工程" class="headerlink" title="创建指定OpenCV版本的ROS工程"></a>创建指定OpenCV版本的ROS工程</h1><h3 id="一、创建工作空间和程序包"><a href="#一、创建工作空间和程序包" class="headerlink" title="一、创建工作空间和程序包"></a>一、创建工作空间和程序包</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> ~/catkin_cv/src<span class="token builtin class-name">cd</span> catkin_cv/catkin_make<span class="token builtin class-name">source</span> devel/setup.sh<span class="token builtin class-name">cd</span> srccatkin_create_pkg ballseeker roscpp rospy std_msgs sensor_msgs cv_bridge image_transport dynamic_reconfigure<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二、创建并且编写cpp文件与hpp文件"><a href="#二、创建并且编写cpp文件与hpp文件" class="headerlink" title="二、创建并且编写cpp文件与hpp文件"></a>二、创建并且编写cpp文件与hpp文件</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gedit ballseeker/include/ballseeker/seek.hppgedit ballseeker/src/seek.cppgedit ballseeker/src/seekernode.cpp<span class="token comment">#代码见附录</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三、修改CMakeLists-txt"><a href="#三、修改CMakeLists-txt" class="headerlink" title="三、修改CMakeLists.txt"></a>三、修改CMakeLists.txt</h3><p>在CMakeLists最后加上：</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token comment"># catkin_add_nosetests(test)</span><span class="token keyword">set</span><span class="token punctuation">(</span>OpenCV_DIR   /usr/local/share/OpenCV4<span class="token punctuation">)</span><span class="token keyword">find_package</span><span class="token punctuation">(</span>OpenCV REQUIRED<span class="token punctuation">)</span><span class="token keyword">add_library</span><span class="token punctuation">(</span><span class="token punctuation">${</span><span class="token variable">PROJECT_NAME</span><span class="token punctuation">}</span>  src/seek.cpp<span class="token punctuation">)</span><span class="token keyword">add_dependencies</span><span class="token punctuation">(</span>   <span class="token punctuation">${</span><span class="token variable">PROJECT_NAME</span><span class="token punctuation">}</span>    <span class="token punctuation">${</span><span class="token punctuation">${</span><span class="token variable">PROJECT_NAME</span><span class="token punctuation">}</span>_EXPORTED_TARGETS<span class="token punctuation">}</span>    <span class="token punctuation">${</span>catkin_EXPORTED_TARGETS<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>   <span class="token punctuation">${</span><span class="token variable">PROJECT_NAME</span><span class="token punctuation">}</span>   <span class="token punctuation">${</span>catkin_LIBRARIES<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment">#add the publisher example  </span><span class="token keyword">add_executable</span><span class="token punctuation">(</span>seekernode src/seek.cpp include/ballseeker/seek.hpp src/seekernode.cpp<span class="token punctuation">)</span>  <span class="token keyword">target_link_libraries</span><span class="token punctuation">(</span>seekernode <span class="token punctuation">${</span>catkin_LIBRARIES<span class="token punctuation">}</span> <span class="token punctuation">${</span>OpenCV_LIBRARIES<span class="token punctuation">}</span><span class="token punctuation">)</span>   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="四、编译与运行"><a href="#四、编译与运行" class="headerlink" title="四、编译与运行"></a>四、编译与运行</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> catkin_cv/<span class="token builtin class-name">source</span> ~/catkin_cv/devel/setup.shcatkin_make<span class="token comment">#新开一个终端运行：</span>roscore<span class="token comment">#再回之前的终端运行：</span>rosrun ballseeker seekernode<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="五、编写launch文件快速启动"><a href="#五、编写launch文件快速启动" class="headerlink" title="五、编写launch文件快速启动"></a>五、编写launch文件快速启动</h3><p>在终端中运行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~/catkin_cv/src/ballseeker/launchgedit quickstart.launch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在quickstart.launch中写入：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>launch</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>node</span><span class="token attr-name">pkg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>ballseeker<span class="token punctuation">"</span></span><span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>quickseeknode<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>seekernode<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>launch</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回到终端再运行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> ~/catkin_cv/devel/setup.shroslaunch ballseeker quickstart.launch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="六、dynamic-reconfigure"><a href="#六、dynamic-reconfigure" class="headerlink" title="六、dynamic_reconfigure"></a>六、dynamic_reconfigure</h3><p>略</p><h3 id="七、调整与保存参数"><a href="#七、调整与保存参数" class="headerlink" title="七、调整与保存参数"></a>七、调整与保存参数</h3><p>略</p><h3 id="八、附录（示例代码）"><a href="#八、附录（示例代码）" class="headerlink" title="八、附录（示例代码）"></a>八、附录（示例代码）</h3><blockquote><p>这里的代码的作用是调用摄像头来检测它看到的网球</p></blockquote><p>在seek.hpp中写入：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"ros/ros.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"opencv2/opencv.hpp"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"vector"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"sstream"</span></span><span class="token keyword">const</span> <span class="token keyword">int</span> red_ball <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> yellow_ball <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> blue_ball <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">seek</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">seek</span><span class="token punctuation">(</span><span class="token keyword">int</span> service_id<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">~</span><span class="token function">seek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">getstart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//从摄像头获取图片、双边滤波、转化hsv</span>    <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//找球并展示中间效果和最终效果</span>    <span class="token keyword">void</span> <span class="token function">creatbar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//创建滑动条调整参数</span><span class="token keyword">private</span><span class="token operator">:</span>    <span class="token keyword">int</span> bgr_min<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> bgr_max<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hsv_min<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hsv_max<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    cv<span class="token double-colon punctuation">::</span>Mat src<span class="token punctuation">;</span>    cv<span class="token double-colon punctuation">::</span>Mat bgr_dst<span class="token punctuation">;</span>    cv<span class="token double-colon punctuation">::</span>Mat hsv_dst<span class="token punctuation">;</span>    cv<span class="token double-colon punctuation">::</span>Mat see_red<span class="token punctuation">;</span>    cv<span class="token double-colon punctuation">::</span>Mat see_yellow<span class="token punctuation">;</span>    cv<span class="token double-colon punctuation">::</span>Mat see_blue<span class="token punctuation">;</span>    cv<span class="token double-colon punctuation">::</span>VideoCapture capture<span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">updateparam</span><span class="token punctuation">(</span><span class="token keyword">int</span> type_of_ball<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>cv<span class="token double-colon punctuation">::</span>Mat<span class="token operator">&amp;</span> input<span class="token punctuation">,</span><span class="token keyword">int</span> type_of_ball<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//阈值化、膨胀、找轮廓、找矩形并筛选、画圆</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">on_change</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在seek.cpp中写入：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"../include/ballseeker/seek.hpp"</span></span>seek<span class="token double-colon punctuation">::</span><span class="token function">seek</span><span class="token punctuation">(</span><span class="token keyword">int</span> service_id<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//设置摄像机参数</span>    capture<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    capture<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>CV_CAP_PROP_FRAME_WIDTH<span class="token punctuation">,</span><span class="token number">640</span><span class="token punctuation">)</span><span class="token punctuation">;</span>capture<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>CV_CAP_PROP_FRAME_HEIGHT<span class="token punctuation">,</span><span class="token number">480</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">seek</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">seek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">void</span> seek<span class="token double-colon punctuation">::</span><span class="token function">getstart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    capture<span class="token operator">&gt;&gt;</span>src<span class="token punctuation">;</span>    cv<span class="token double-colon punctuation">::</span><span class="token function">bilateralFilter</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span>bgr_dst<span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cv<span class="token double-colon punctuation">::</span><span class="token function">cvtColor</span><span class="token punctuation">(</span>bgr_dst<span class="token punctuation">,</span>hsv_dst<span class="token punctuation">,</span>CV_BGR2HSV<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> seek<span class="token double-colon punctuation">::</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">process</span><span class="token punctuation">(</span>see_red<span class="token punctuation">,</span>red_ball<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//可能得会用bgr处理红球了，HSV下效果不太好</span>    <span class="token function">process</span><span class="token punctuation">(</span>see_yellow<span class="token punctuation">,</span>yellow_ball<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">process</span><span class="token punctuation">(</span>see_blue<span class="token punctuation">,</span>blue_ball<span class="token punctuation">)</span><span class="token punctuation">;</span>    cv<span class="token double-colon punctuation">::</span><span class="token function">imshow</span><span class="token punctuation">(</span><span class="token string">"SEE_RED_BALL"</span><span class="token punctuation">,</span>see_red<span class="token punctuation">)</span><span class="token punctuation">;</span>    cv<span class="token double-colon punctuation">::</span><span class="token function">imshow</span><span class="token punctuation">(</span><span class="token string">"SEE_YELLOW_BALL"</span><span class="token punctuation">,</span>see_yellow<span class="token punctuation">)</span><span class="token punctuation">;</span>    cv<span class="token double-colon punctuation">::</span><span class="token function">imshow</span><span class="token punctuation">(</span><span class="token string">"SEE_BLUE_BALL"</span><span class="token punctuation">,</span>see_blue<span class="token punctuation">)</span><span class="token punctuation">;</span>    cv<span class="token double-colon punctuation">::</span><span class="token function">imshow</span><span class="token punctuation">(</span><span class="token string">"FINALLY"</span><span class="token punctuation">,</span>src<span class="token punctuation">)</span><span class="token punctuation">;</span>    cv<span class="token double-colon punctuation">::</span><span class="token function">waitKey</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> seek<span class="token double-colon punctuation">::</span><span class="token function">process</span><span class="token punctuation">(</span>cv<span class="token double-colon punctuation">::</span>Mat<span class="token operator">&amp;</span> input<span class="token punctuation">,</span> <span class="token keyword">int</span> type_of_ball<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">updateparam</span><span class="token punctuation">(</span>type_of_ball<span class="token punctuation">)</span><span class="token punctuation">;</span>    cv<span class="token double-colon punctuation">::</span><span class="token function">inRange</span><span class="token punctuation">(</span>hsv_dst<span class="token punctuation">,</span>cv<span class="token double-colon punctuation">::</span><span class="token function">Scalar</span><span class="token punctuation">(</span>hsv_min<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>hsv_min<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>hsv_min<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        cv<span class="token double-colon punctuation">::</span><span class="token function">Scalar</span><span class="token punctuation">(</span>hsv_max<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>hsv_max<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>hsv_max<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>    cv<span class="token double-colon punctuation">::</span>Mat element <span class="token operator">=</span>cv<span class="token double-colon punctuation">::</span><span class="token function">getStructuringElement</span><span class="token punctuation">(</span>cv<span class="token double-colon punctuation">::</span>MORPH_RECT<span class="token punctuation">,</span> cv<span class="token double-colon punctuation">::</span><span class="token function">Size</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       cv<span class="token double-colon punctuation">::</span><span class="token function">dilate</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> input<span class="token punctuation">,</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Point<span class="token operator">&gt;</span> <span class="token operator">&gt;</span> contours<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Vec4i<span class="token operator">&gt;</span> hierarchy<span class="token punctuation">;</span>    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Rect<span class="token operator">&gt;</span> rects<span class="token punctuation">;</span>    cv<span class="token double-colon punctuation">::</span><span class="token function">findContours</span><span class="token punctuation">(</span>input<span class="token punctuation">,</span> contours<span class="token punctuation">,</span> hierarchy<span class="token punctuation">,</span> cv<span class="token double-colon punctuation">::</span>RETR_CCOMP<span class="token punctuation">,</span> cv<span class="token double-colon punctuation">::</span>CHAIN_APPROX_SIMPLE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> contours<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        rects<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>cv<span class="token double-colon punctuation">::</span><span class="token function">boundingRect</span><span class="token punctuation">(</span>contours<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>rects<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>height <span class="token operator">&lt;</span> <span class="token number">100</span> <span class="token operator">||</span> rects<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>width <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">||</span>            <span class="token function">fabsf</span><span class="token punctuation">(</span>rects<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>height <span class="token operator">-</span> rects<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>width<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">20</span><span class="token punctuation">)</span>            rects<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>rects<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> rects<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">double</span> R <span class="token operator">=</span> <span class="token punctuation">(</span>rects<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>height <span class="token operator">+</span> rects<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>width<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> x <span class="token operator">=</span> rects<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">+</span> R<span class="token punctuation">;</span>        <span class="token keyword">double</span> y <span class="token operator">=</span> rects<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">+</span> R<span class="token punctuation">;</span>        cv<span class="token double-colon punctuation">::</span>Point <span class="token function">center</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>        cv<span class="token double-colon punctuation">::</span><span class="token function">circle</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> center<span class="token punctuation">,</span> R <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">,</span> cv<span class="token double-colon punctuation">::</span><span class="token function">Scalar</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> seek<span class="token double-colon punctuation">::</span><span class="token function">updateparam</span><span class="token punctuation">(</span><span class="token keyword">int</span> type_of_ball<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>type_of_ball<span class="token punctuation">)</span>    <span class="token punctuation">{</span>    <span class="token keyword">case</span> red_ball<span class="token operator">:</span>        hsv_min<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>hsv_min<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span> <span class="token number">105</span> <span class="token punctuation">;</span>hsv_min<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span> <span class="token number">108</span> <span class="token punctuation">;</span>        hsv_max<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span> <span class="token number">11</span> <span class="token punctuation">;</span>hsv_max<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span> <span class="token number">255</span> <span class="token punctuation">;</span>hsv_max<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span> <span class="token number">255</span> <span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> yellow_ball<span class="token operator">:</span>        hsv_min<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span> <span class="token number">18</span> <span class="token punctuation">;</span>hsv_min<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span> <span class="token number">56</span> <span class="token punctuation">;</span>hsv_min<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span> <span class="token number">177</span> <span class="token punctuation">;</span>        hsv_max<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span> <span class="token number">71</span> <span class="token punctuation">;</span>hsv_max<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span> <span class="token number">187</span> <span class="token punctuation">;</span>hsv_max<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span> <span class="token number">255</span> <span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> blue_ball<span class="token operator">:</span>        hsv_min<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span> <span class="token number">85</span> <span class="token punctuation">;</span>hsv_min<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span> <span class="token number">129</span> <span class="token punctuation">;</span>hsv_min<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span> <span class="token number">128</span> <span class="token punctuation">;</span>        hsv_max<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span> <span class="token number">124</span> <span class="token punctuation">;</span>hsv_max<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span> <span class="token number">255</span> <span class="token punctuation">;</span>hsv_max<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span> <span class="token number">255</span> <span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">default</span><span class="token operator">:</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> seek<span class="token double-colon punctuation">::</span><span class="token function">creatbar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    cv<span class="token double-colon punctuation">::</span><span class="token function">namedWindow</span><span class="token punctuation">(</span><span class="token string">"SetParam"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cv<span class="token double-colon punctuation">::</span><span class="token function">createTrackbar</span><span class="token punctuation">(</span><span class="token string">"minH"</span><span class="token punctuation">,</span> <span class="token string">"SetParam"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>hsv_min<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">180</span><span class="token punctuation">,</span> on_change<span class="token punctuation">)</span><span class="token punctuation">;</span>cv<span class="token double-colon punctuation">::</span><span class="token function">createTrackbar</span><span class="token punctuation">(</span><span class="token string">"minS"</span><span class="token punctuation">,</span> <span class="token string">"SetParam"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>hsv_min<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> on_change<span class="token punctuation">)</span><span class="token punctuation">;</span>cv<span class="token double-colon punctuation">::</span><span class="token function">createTrackbar</span><span class="token punctuation">(</span><span class="token string">"minV"</span><span class="token punctuation">,</span> <span class="token string">"SetParam"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>hsv_min<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> on_change<span class="token punctuation">)</span><span class="token punctuation">;</span>cv<span class="token double-colon punctuation">::</span><span class="token function">createTrackbar</span><span class="token punctuation">(</span><span class="token string">"maxH"</span><span class="token punctuation">,</span> <span class="token string">"SetParam"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>hsv_max<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">180</span><span class="token punctuation">,</span> on_change<span class="token punctuation">)</span><span class="token punctuation">;</span>cv<span class="token double-colon punctuation">::</span><span class="token function">createTrackbar</span><span class="token punctuation">(</span><span class="token string">"maxS"</span><span class="token punctuation">,</span> <span class="token string">"SetParam"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>hsv_max<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> on_change<span class="token punctuation">)</span><span class="token punctuation">;</span>cv<span class="token double-colon punctuation">::</span><span class="token function">createTrackbar</span><span class="token punctuation">(</span><span class="token string">"maxV"</span><span class="token punctuation">,</span> <span class="token string">"SetParam"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>hsv_max<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> on_change<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">on_change</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> seek<span class="token double-colon punctuation">::</span><span class="token function">on_change</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在seekernode.cpp中写入：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"../include/ballseeker/seek.hpp"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span><span class="token punctuation">{</span>    ros<span class="token double-colon punctuation">::</span><span class="token function">init</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span>argv<span class="token punctuation">,</span><span class="token string">"seekernode"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ros<span class="token double-colon punctuation">::</span>NodeHandle n<span class="token punctuation">;</span>    seek <span class="token function">icu</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    icu<span class="token punctuation">.</span><span class="token function">creatbar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>ros<span class="token double-colon punctuation">::</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        icu<span class="token punctuation">.</span><span class="token function">getstart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        icu<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ros<span class="token double-colon punctuation">::</span><span class="token function">spinOnce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 三维视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
            <tag> ROS基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS中使用ddynamicReconfigure</title>
      <link href="2020/09/05/ros-notes-1/"/>
      <url>2020/09/05/ros-notes-1/</url>
      
        <content type="html"><![CDATA[<h1 id="ROS中使用ddynamicReconfigure"><a href="#ROS中使用ddynamicReconfigure" class="headerlink" title="ROS中使用ddynamicReconfigure"></a>ROS中使用ddynamicReconfigure</h1><h2 id="关于ddynamicReconfigure类"><a href="#关于ddynamicReconfigure类" class="headerlink" title="关于ddynamicReconfigure类"></a>关于ddynamicReconfigure类</h2><p>The DDynamicReconfigure class allows to use ROS dynamic reconfigure without the need to write a custom cpf file, <strong>variables are registered and exposed at run time</strong>.  Modification of the variables is done through a variable pointer or through a callback function.</p><p>The <a href="http://docs.ros.org/kinetic/api/ddynamic_reconfigure/html/classddynamic__reconfigure_1_1DDynamicReconfigure.html">DDynamicReconfigure</a> class is the main class responsible for keeping track of parameters basic properties, values, descriptions, etc. </p><p>It is also responsible of handling callbacks, config change requests, description setup and config setup, and the ROS publishers and  services.</p><p>To operate a DDynamic instance, you must go through the following procedure:</p><ol><li>Construct a <a href="http://docs.ros.org/kinetic/api/ddynamic_reconfigure/html/classddynamic__reconfigure_1_1DDynamicReconfigure.html">DDynamicReconfigure</a> instance with proper handling.</li><li>Add parameters to the instance as needed with any of the “add” methods.</li><li>Start the ROS services with any of the “start” methods.</li><li>If you need to change the callback after startup you may do so using “setCallback”.</li><li>When you need to get any of the stored parameters, call either “get” or “at” on this instance, rather than through the callback. </li></ol><h2 id="常用函数原型-amp-解析"><a href="#常用函数原型-amp-解析" class="headerlink" title="常用函数原型&amp;解析"></a>常用函数原型&amp;解析</h2><p>registerVariable register a variable to be modified via the dynamic_reconfigure API. </p><p>When a change is made, <strong>it will be reflected in the variable directly.</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>  <span class="token keyword">void</span> <span class="token function">registerVariable</span><span class="token punctuation">(</span>  <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>name<span class="token punctuation">,</span>   T <span class="token operator">*</span>variable<span class="token punctuation">,</span>  <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>description <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span>   T min <span class="token operator">=</span> <span class="token generic-function"><span class="token function">getMin</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>   T max <span class="token operator">=</span> <span class="token generic-function"><span class="token function">getMax</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>  <span class="token keyword">void</span> <span class="token function">registerEnumVariable</span><span class="token punctuation">(</span>  <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>name<span class="token punctuation">,</span>   T <span class="token operator">*</span>variable<span class="token punctuation">,</span>  <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>description <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span>  std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> T<span class="token operator">&gt;</span> enum_dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>enum_description <span class="token operator">=</span> <span class="token string">""</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>registerVariable register a variable to be modified via the dynamic_reconfigure API. </p><p>When a change is made, <strong>the callback will be called with the new value.</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>  <span class="token keyword">void</span> <span class="token function">registerVariable</span><span class="token punctuation">(</span>  <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>name<span class="token punctuation">,</span>   T current_value<span class="token punctuation">,</span>  <span class="token keyword">const</span> boost<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>callback<span class="token punctuation">,</span>  <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>description <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">,</span>   T min <span class="token operator">=</span> <span class="token generic-function"><span class="token function">getMin</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>   T max <span class="token operator">=</span> <span class="token generic-function"><span class="token function">getMax</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>  <span class="token keyword">void</span> <span class="token function">registerEnumVariable</span><span class="token punctuation">(</span>  <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>name<span class="token punctuation">,</span>   T current_value<span class="token punctuation">,</span>  <span class="token keyword">const</span> boost<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>callback<span class="token punctuation">,</span>  <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>description<span class="token punctuation">,</span>  std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> T<span class="token operator">&gt;</span> enum_dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>enum_description <span class="token operator">=</span> <span class="token string">""</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>publishServicesTopics <strong>starts the server</strong> once all the needed variables are registered.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">publishServicesTopics</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关于getMin()与getMax()</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">inline</span> T <span class="token function">getMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token class-name">numeric_limits</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token keyword">inline</span> <span class="token keyword">bool</span> <span class="token function">getMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token keyword">inline</span> std<span class="token double-colon punctuation">::</span>string <span class="token generic-function"><span class="token function">getMin</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">inline</span> T <span class="token function">getMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token class-name">numeric_limits</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token keyword">inline</span> <span class="token keyword">bool</span> <span class="token function">getMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token keyword">inline</span> std<span class="token double-colon punctuation">::</span>string <span class="token function">getMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;ros/ros.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;ddynamic_reconfigure/ddynamic_reconfigure.h&gt;</span></span><span class="token keyword">int</span> global_int<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">paramCb</span><span class="token punctuation">(</span><span class="token keyword">int</span> new_value<span class="token punctuation">)</span><span class="token punctuation">{</span>   global_int <span class="token operator">=</span> new_value<span class="token punctuation">;</span>   <span class="token function">ROS_INFO</span><span class="token punctuation">(</span><span class="token string">"Param modified: %d"</span><span class="token punctuation">,</span> global_int<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// ROS init stage</span>    ros<span class="token double-colon punctuation">::</span><span class="token function">init</span><span class="token punctuation">(</span>argc<span class="token punctuation">,</span> argv<span class="token punctuation">,</span> <span class="token string">"ddynamic_tutorials"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ros<span class="token double-colon punctuation">::</span>NodeHandle nh<span class="token punctuation">;</span>    ddynamic_reconfigure<span class="token double-colon punctuation">::</span>DDynamicReconfigure ddr<span class="token punctuation">;</span>        ddr<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">registerVariable</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"int_param"</span><span class="token punctuation">,</span><span class="token number">124</span><span class="token punctuation">,</span> boost<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>paramCb<span class="token punctuation">,</span> _1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"param description"</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">2357</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ddr<span class="token punctuation">.</span><span class="token function">publishServicesTopics</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Now parameter can be modified from the dynamic_reconfigure GUI or other tools and the callback is called on each update</span>    ros<span class="token double-colon punctuation">::</span><span class="token function">spin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS中nodelet的使用</title>
      <link href="2020/09/04/ros-notes-2/"/>
      <url>2020/09/04/ros-notes-2/</url>
      
        <content type="html"><![CDATA[<h1 id="ROS中nodelet的使用"><a href="#ROS中nodelet的使用" class="headerlink" title="ROS中nodelet的使用"></a>ROS中nodelet的使用</h1><h2 id="1-为什么使用nodelet？"><a href="#1-为什么使用nodelet？" class="headerlink" title="1. 为什么使用nodelet？"></a>1. 为什么使用nodelet？</h2><p>Nodelet提供了一种方法，可以在同一台计算机上，在同一个进程内，运行多个算法，且在进程内消息传递时不产生复制成本（zero  copy）。在一个node里面，roscpp利用指针传递可以实现在publish和subscribe调用时的零拷贝。为了实现相似的效果，多个nodelets允许将多个类动态加载到同一个node里，同时还提供独立的命名空间，从而使得这些nodelets尽管运行在同一个进程里，但却仍然像单独的node一样工作。也就实现了“在一个进程（node）里运行多个nodelet”的效果。</p><p>因此，大通量数据流可能包含多个nodelet，此时若将他们加载到同一个进程里，就可以避免数据拷贝和网络传输。</p><h2 id="2-在ROS工程中使用nodelet"><a href="#2-在ROS工程中使用nodelet" class="headerlink" title="2. 在ROS工程中使用nodelet"></a>2. 在ROS工程中使用nodelet</h2><h3 id="2-1-创建工作空间和程序包"><a href="#2-1-创建工作空间和程序包" class="headerlink" title="2.1 创建工作空间和程序包"></a>2.1 创建工作空间和程序包</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> ~/catkin_ar/src<span class="token builtin class-name">cd</span> catkin_ar/catkin_make<span class="token builtin class-name">source</span> devel/setup.sh<span class="token builtin class-name">cd</span> srccatkin_create_pkg try_nodelet roscpp rospy nodelet std_msgs sensor_msgs cv_bridge image_transport ddynamic_reconfigure<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-创建并且编写cpp文件与hpp文件"><a href="#2-2-创建并且编写cpp文件与hpp文件" class="headerlink" title="2.2 创建并且编写cpp文件与hpp文件"></a>2.2 创建并且编写cpp文件与hpp文件</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//try_use.hpp</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;nodelet/nodelet.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;ros/ros.h&gt;</span></span><span class="token keyword">namespace</span> try_nodelet<span class="token punctuation">{</span>    <span class="token keyword">class</span> <span class="token class-name">try_use</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> nodelet<span class="token double-colon punctuation">::</span><span class="token class-name">Nodelet</span></span>    <span class="token punctuation">{</span>    <span class="token keyword">public</span><span class="token operator">:</span>        <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">onInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//try_use.cpp</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pluginlib/class_list_macros.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;../include/try_nodelet/try_use.hpp&gt;</span></span><span class="token function">PLUGINLIB_EXPORT_CLASS</span><span class="token punctuation">(</span>try_nodelet<span class="token double-colon punctuation">::</span>try_use<span class="token punctuation">,</span>nodelet<span class="token double-colon punctuation">::</span>Nodelet<span class="token punctuation">)</span><span class="token keyword">namespace</span> try_nodelet<span class="token punctuation">{</span>    <span class="token keyword">void</span> try_use<span class="token double-colon punctuation">::</span><span class="token function">onInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">NODELET_DEBUG</span><span class="token punctuation">(</span><span class="token string">"Initializing nodelet..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ROS_INFO</span><span class="token punctuation">(</span><span class="token string">"Nodelet is Ok for test!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-编写nodelet-plugins-xml"><a href="#2-3-编写nodelet-plugins-xml" class="headerlink" title="2.3 编写nodelet_plugins.xml"></a>2.3 编写nodelet_plugins.xml</h3><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>library</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>lib/libtry_nodelet<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--上面这个try_nodelet是包的名字，下面的那个是命名空间的名字--&gt;</span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>class</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>try_nodelet/try_use<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>try_nodelet::try_use<span class="token punctuation">"</span></span> <span class="token attr-name">base_class_type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>nodelet::Nodelet<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">&gt;</span></span>  Trying to use nodelet in ROS.  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>class</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>library</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-修改CMakeLists-txt与package-xml"><a href="#2-4-修改CMakeLists-txt与package-xml" class="headerlink" title="2.4 修改CMakeLists.txt与package.xml"></a>2.4 修改CMakeLists.txt与package.xml</h3><p>修改CMakeLists.txt</p><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake"><span class="token keyword">cmake_minimum_required</span><span class="token punctuation">(</span><span class="token property">VERSION</span> <span class="token number">3.0.2</span><span class="token punctuation">)</span><span class="token keyword">project</span><span class="token punctuation">(</span>try_nodelet<span class="token punctuation">)</span><span class="token keyword">add_compile_options</span><span class="token punctuation">(</span>-std=c++<span class="token number">11</span><span class="token punctuation">)</span><span class="token comment">#上面这个最好加上，否则可能会编译失败</span><span class="token keyword">find_package</span><span class="token punctuation">(</span>catkin REQUIRED COMPONENTS  cv_bridge  ddynamic_reconfigure  image_transport  nodelet  roscpp  rospy  sensor_msgs  std_msgs<span class="token punctuation">)</span><span class="token function">catkin_package</span><span class="token punctuation">(</span>  INCLUDE_DIRS include  LIBRARIES try_nodelet  CATKIN_DEPENDS cv_bridge ddynamic_reconfigure image_transport nodelet roscpp rospy sensor_msgs std_msgs<span class="token comment">#  DEPENDS system_lib</span><span class="token punctuation">)</span><span class="token keyword">include_directories</span><span class="token punctuation">(</span>   include  <span class="token punctuation">${</span>catkin_INCLUDE_DIRS<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">add_library</span><span class="token punctuation">(</span><span class="token punctuation">${</span><span class="token variable">PROJECT_NAME</span><span class="token punctuation">}</span>     src/try_use.cpp<span class="token punctuation">)</span><span class="token keyword">add_dependencies</span><span class="token punctuation">(</span>    <span class="token punctuation">${</span><span class="token variable">PROJECT_NAME</span><span class="token punctuation">}</span>     <span class="token punctuation">${</span><span class="token punctuation">${</span><span class="token variable">PROJECT_NAME</span><span class="token punctuation">}</span>_EXPORTED_TARGETS<span class="token punctuation">}</span>     <span class="token punctuation">${</span>catkin_EXPORTED_TARGETS<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改package.xml</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>package</span> <span class="token attr-name">format</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">&gt;</span></span>try_nodelet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>0.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">&gt;</span></span>The try_nodelet package<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maintainer</span> <span class="token attr-name">email</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>npu-lqx@todo.todo<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>npu-lqx<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maintainer</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>license</span><span class="token punctuation">&gt;</span></span>TODO<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>license</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>buildtool_depend</span><span class="token punctuation">&gt;</span></span>catkin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>buildtool_depend</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_depend</span><span class="token punctuation">&gt;</span></span>cv_bridge<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_depend</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_depend</span><span class="token punctuation">&gt;</span></span>ddynamic_reconfigure<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_depend</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_depend</span><span class="token punctuation">&gt;</span></span>image_transport<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_depend</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_depend</span><span class="token punctuation">&gt;</span></span>nodelet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_depend</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_depend</span><span class="token punctuation">&gt;</span></span>roscpp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_depend</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_depend</span><span class="token punctuation">&gt;</span></span>rospy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_depend</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_depend</span><span class="token punctuation">&gt;</span></span>sensor_msgs<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_depend</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_depend</span><span class="token punctuation">&gt;</span></span>std_msgs<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_depend</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>cv_bridge<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>ddynamic_reconfigure<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>image_transport<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>nodelet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>roscpp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>rospy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>sensor_msgs<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>std_msgs<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_export_depend</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exec_depend</span><span class="token punctuation">&gt;</span></span>cv_bridge<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exec_depend</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exec_depend</span><span class="token punctuation">&gt;</span></span>ddynamic_reconfigure<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exec_depend</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exec_depend</span><span class="token punctuation">&gt;</span></span>image_transport<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exec_depend</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exec_depend</span><span class="token punctuation">&gt;</span></span>nodelet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exec_depend</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exec_depend</span><span class="token punctuation">&gt;</span></span>roscpp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exec_depend</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exec_depend</span><span class="token punctuation">&gt;</span></span>rospy<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exec_depend</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exec_depend</span><span class="token punctuation">&gt;</span></span>sensor_msgs<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exec_depend</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exec_depend</span><span class="token punctuation">&gt;</span></span>std_msgs<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exec_depend</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>export</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nodelet</span> <span class="token attr-name">plugin</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${prefix}/nodelet_plugins.xml<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>export</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>package</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-启动ROS节点"><a href="#3-启动ROS节点" class="headerlink" title="3.启动ROS节点"></a>3.启动ROS节点</h2><h3 id="3-1-编写launch文件进行快速启动"><a href="#3-1-编写launch文件进行快速启动" class="headerlink" title="3.1 编写launch文件进行快速启动"></a>3.1 编写launch文件进行快速启动</h3><p>新建一个launch文件夹，并在文件夹中新建一个start.launch文件</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>launch</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>node</span> <span class="token attr-name">pkg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>nodelet<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>nodelet<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>standalone_nodelet<span class="token punctuation">"</span></span>  <span class="token attr-name">args</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>manager<span class="token punctuation">"</span></span> <span class="token attr-name">output</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>screen<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>node</span> <span class="token attr-name">pkg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>nodelet<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>nodelet<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>using_nodelet<span class="token punctuation">"</span></span> <span class="token attr-name">args</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>load try_nodelet/try_use standalone_nodelet<span class="token punctuation">"</span></span> <span class="token attr-name">output</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>screen<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>node</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>launch</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-通过命令行运行"><a href="#3-2-通过命令行运行" class="headerlink" title="3.2 通过命令行运行"></a>3.2 通过命令行运行</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#终端1</span>roscore<span class="token comment">#终端2</span>rosrun nodelet nodelet manager __name:<span class="token operator">=</span>nodelet_manager<span class="token comment">#终端3</span>rosrun nodelet nodelet load try_nodelet/try_use nodelet_manager __name:<span class="token operator">=</span>using_nodelet<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，如果这里报错“According to the loaded plugin descriptions the class try_nodelet/try_use with base class type nodelet::Nodelet does not exist.”  一般是因为运行manager的窗口（终端2）没有source</p><p>所以要么一开始就把source写进配置文件中，要么就每个相关的窗口都要source，这样能够避免很多问题，也方便自己找到程序的bug所在。</p><h2 id="4-将已有的ROS工程改写为nodelet"><a href="#4-将已有的ROS工程改写为nodelet" class="headerlink" title="4.将已有的ROS工程改写为nodelet"></a>4.将已有的ROS工程改写为nodelet</h2><p>待补充~</p>]]></content>
      
      
      <categories>
          
          <category> 编程基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类的六个默认的成员函数</title>
      <link href="2020/08/22/cpp-notes-1/"/>
      <url>2020/08/22/cpp-notes-1/</url>
      
        <content type="html"><![CDATA[<h1 id="类的六个默认的成员函数"><a href="#类的六个默认的成员函数" class="headerlink" title="类的六个默认的成员函数"></a>类的六个默认的成员函数</h1><h2 id="类的6个默认的成员函数包括："><a href="#类的6个默认的成员函数包括：" class="headerlink" title="类的6个默认的成员函数包括："></a>类的6个默认的成员函数包括：</h2><p>构造函数、析构函数、拷贝构造函数、赋值运算符重载函数、取地址操作符重载、const修饰的取地址操作符重载。</p><h3 id="（一）构造函数"><a href="#（一）构造函数" class="headerlink" title="（一）构造函数"></a>（一）构造函数</h3><p>构造函数，顾名思义，为对象分配空间，进行初始化。它是一种特殊的成员函数，具有以下特点:</p><ol><li><p>函数名与类名相同。</p></li><li><p>无返回值。</p></li><li><p>构造对象的时候系统会自动调用构造函数。</p></li><li><p>可以重载。</p></li><li><p>可以在类中定义，也可以在类外定义。</p></li><li><p>如果类中没有给出构造函数，编译器会自动产生一个缺省的构造函数，如果类中有构造函数，编译器就不会产生缺省构造函数。</p></li><li><p>全缺省的构造函数和无参的构造函数只能有一个，否则调用的时候就会产生冲突。</p></li><li><p>没有this指针。因为构造函数才是创建对象的，没有创建对象就不会有对象的首地址。</p></li></ol><p>构造函数，说来就是给成员变量进行初始化。而初始化却有两种方法：初始化列表、构造函数函数体内赋值。尽量使用初始化列表，因为它更高效。</p><h4 id="有些成员变量必须再初始化列表中初始化，比如："><a href="#有些成员变量必须再初始化列表中初始化，比如：" class="headerlink" title="有些成员变量必须再初始化列表中初始化，比如："></a>有些成员变量必须再初始化列表中初始化，比如：</h4><ol><li><p>常量成员变量。（常量创建时必须初始化，因为对于一个常量，我们给它赋值，是不对的）</p></li><li><p>引用类型成员变量。（引用创建时必须初始化）</p></li><li><p>没有缺省构造函数的类成员变量。（如果构造函数的参数列表中有一个类的对象，并且该对象的类里没有缺省参数的构造函数时，要是不使用初始化列表，参数中会调用无参或者全缺省的构造函数，而那个类中又没有。）</p></li></ol><h3 id="（二）析构函数"><a href="#（二）析构函数" class="headerlink" title="（二）析构函数"></a>（二）析构函数</h3><h4 id="析构函数是一种特殊的成员函数，具有以下特点："><a href="#析构函数是一种特殊的成员函数，具有以下特点：" class="headerlink" title="析构函数是一种特殊的成员函数，具有以下特点："></a>析构函数是一种特殊的成员函数，具有以下特点：</h4><ol><li><p>析构函数函数名是在类名加上字符 ~ 。</p></li><li><p>无参数无返回值（但有this指针）。</p></li><li><p>一个类有且只有一个析构函数，所以肯定不能重载。若未显示定义，系统会自动生成缺省的析构函数。</p></li><li><p>对象生命周期结束时，C++编译系统系统自动调用析构函数。</p></li><li><p>注意析构函数体内并不是删除对象，而是做一些清理工作。（比如我们在构造函数中动态开辟过一段空间，函数结束后需要释放，而系统自动生成的析构函数才不管内存释放呢，所以需要人为地写出析构函数）</p></li></ol><p>注意：对象生命周期结束后，后构造的对象先释放。</p><h3 id="（三）拷贝构造函数"><a href="#（三）拷贝构造函数" class="headerlink" title="（三）拷贝构造函数"></a>（三）拷贝构造函数</h3><p>用已有的对象创建一个新的对象。</p><p>创建对象时使用同类对象来进行初始化，这时所用的构造函数就是拷贝构造函数（Copy  Constructor）。拷贝构造函数也是构造函数，但它只有一个参数，这个参数只能是本类的一个对象，而且采用对象的常引用形式。拷贝构造函数的作用就是将实参对象的各成员值一一赋给新的对象中对应的成员。</p><p>该函数的参数是一个常引用，如果不是引用，形参是实参的一份临时拷贝，由于两者都是对象，此时就会调用自己的拷贝构造函数，陷入无限递归中…….</p><h4 id="拷贝构造函数的特征"><a href="#拷贝构造函数的特征" class="headerlink" title="拷贝构造函数的特征"></a>拷贝构造函数的特征</h4><p> （1）拷贝构造函数其实是一个构造函数的重载。<br> （2）拷贝构造函数的参数必须使用引用传参，使用传参方式会引发无穷递归调用。<br> （3）若为显示定义，系统默认生成缺省的拷贝构造函数，缺省的拷贝构造函数会按照成员的声明顺序依次拷贝类成员进行初始化</p><h4 id="调用拷贝构造函数的两种方法："><a href="#调用拷贝构造函数的两种方法：" class="headerlink" title="调用拷贝构造函数的两种方法："></a>调用拷贝构造函数的两种方法：</h4><ol><li><p>代入法：</p><p>Person p2(p1);</p></li><li><p>赋值法：</p><p>Person p2 = p1;</p></li></ol><h4 id="为什么这里的对象可以直接访问私有成员变量？"><a href="#为什么这里的对象可以直接访问私有成员变量？" class="headerlink" title="为什么这里的对象可以直接访问私有成员变量？"></a>为什么这里的对象可以直接访问私有成员变量？</h4><p> 1）在类的成员函数里可以直接访问同类对象的私有或保护的成员。<br> 2）C++的访问限定符是以类为单位的，即：在这个单位内的成员可以互相访问。</p><h3 id="（四）赋值运算符重载函数"><a href="#（四）赋值运算符重载函数" class="headerlink" title="（四）赋值运算符重载函数"></a>（四）赋值运算符重载函数</h3><p>用一个对象修改已经存在对象的内容，不是去创建新的对象，修改之后，两个对象的内容一致</p><blockquote><ol><li>可以通过检查是否给自己赋值，进行优化</li><li><strong>如果需要连续赋值，返回值不能是void，一般为引用类型</strong></li><li>*<em>返回值一般是 <em>this</em></em></li><li>编译器默认生成的赋值运算符为字节拷贝，即浅拷贝，如果资源需要拷贝，需要显示定义，完成深拷贝</li></ol><p>=调用：如果对象都存在，调用赋值运算符重载函数</p><p>​              如果左边对象不存在，调用拷贝构造创建左边对象</p></blockquote><p><em>赋值是从右向左进行的</em></p><p>如果不写，编译器会自动生成，默认生成的也是字节拷贝，浅拷贝</p><p>如果当前类中有资源，则必须显示定义运算符重载函数，完成深拷贝</p><h4 id="普通运算符重载函数"><a href="#普通运算符重载函数" class="headerlink" title="普通运算符重载函数"></a>普通运算符重载函数</h4><blockquote><ol><li>不能创建新的操作符，如operator@</li><li>重载操作符必须有一个类类型或者枚举类型的操作符</li><li>用于内置类型的操作符，其含义不能改变</li><li>运算符重载函数如果是成员函数，则参数的个数比运算符需要的个数少一个，这里编译器会传入this指针作为第一个参数</li><li>普通的运算符重载函数，参数的个数和运算符需要的个数一致</li></ol></blockquote><p><strong>.*（成员指针访问运算符） ,  ::  ,  sizeof  ,  ? :  ,  .   五个运算符不能被重载</strong></p><h3 id="（五）取地址运算符重载函数-const取地址运算符重载函数：获取对象的地址"><a href="#（五）取地址运算符重载函数-const取地址运算符重载函数：获取对象的地址" class="headerlink" title="（五）取地址运算符重载函数 / const取地址运算符重载函数：获取对象的地址**"></a>（五）取地址运算符重载函数 / const取地址运算符重载函数：获取对象的地址**</h3><p>一般不需要显示定义，直接使用编译器自动生成的即可</p>]]></content>
      
      
      <categories>
          
          <category> 编程基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++描述符delete与override</title>
      <link href="2020/08/21/cpp-notes-2/"/>
      <url>2020/08/21/cpp-notes-2/</url>
      
        <content type="html"><![CDATA[<h1 id="delete与override"><a href="#delete与override" class="headerlink" title="delete与override"></a>delete与override</h1><h2 id="优先使用delete关键字删除函数而非private却又不实现的函数"><a href="#优先使用delete关键字删除函数而非private却又不实现的函数" class="headerlink" title="优先使用delete关键字删除函数而非private却又不实现的函数"></a>优先使用delete关键字删除函数而非private却又不实现的函数</h2><h3 id="为什么使用delete？"><a href="#为什么使用delete？" class="headerlink" title="为什么使用delete？"></a>为什么使用delete？</h3><p>​    不想让别的开发者调用特定的函数,你只需要不声明这个函数就可以了。但有时候 C++为你声明了一些函数,如果你想阻止客户调用这些函数,就不是那么容易的事了。</p><p>​    这种情况只有对“特殊的成员函数”才会出现,即这个成员函数是需要的时候C++自动生成的。    </p><p>在C++98中阻止这类函数被使用的方法是将这些函数声明为private,并且不定义它们。</p><p>​    将这些函数声明为私有来阻止客户调用他们。故意不定义它们是因为,如果有函数访问这些<br>函数(通过成员函数或者友好类)在链接的时候会导致没有定义而触发的错误。</p><p>​    在C++11中,有一个更好的方法可以基本上实现同样的功能:用 =delete标识拷贝复制函数<br>和拷贝赋值函数为删除的函数deleted functions 。</p><h3 id="delete的优点"><a href="#delete的优点" class="headerlink" title="delete的优点"></a>delete的优点</h3><p>​    删除函数一个重要的优势是任何函数都可以是删除的,然而仅有成员函数才可以是私有的。</p><h4 id="防止普通非成员函数中的隐式转化"><a href="#防止普通非成员函数中的隐式转化" class="headerlink" title="防止普通非成员函数中的隐式转化"></a>防止普通非成员函数中的隐式转化</h4><p>​    C++继承于C意味着,很多其他类型被隐式的转换为in 类型,但是有些调用可以编译但是没有任何意义.</p><p>​    举个例子,加入我们有个非成员函数,以一个整数位参数,然后返回这个参数是不是幸运数字:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">isLucky</span><span class="token punctuation">(</span><span class="token keyword">int</span> number<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">isLucky</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">isLucky</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">isLucky</span><span class="token punctuation">(</span><span class="token number">3.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    如果幸运数字一定要是一个整数,我们希望能到阻止上面那种形式的调用。</p><p>​    完成这个任务的一个方法是为想被排除出去的类型的重载函数声明为删除的:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">isLucky</span><span class="token punctuation">(</span><span class="token keyword">int</span> number<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">isLucky</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">delete</span><span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">isLucky</span><span class="token punctuation">(</span><span class="token keyword">bool</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">delete</span><span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">isLucky</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">delete</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    如果给float一个转换为int或者double的可能性, C++总是倾向于转化为double的。以float类型调用isLucky总是调用对应的double重载,而不是int类型的那个重载。结果就是将double类型的重载删除将会阻止float类型的调用编译。</p><h4 id="阻止应该被禁用的模板实现"><a href="#阻止应该被禁用的模板实现" class="headerlink" title="阻止应该被禁用的模板实现"></a>阻止应该被禁用的模板实现</h4><p>​    假设你需要使用一个内嵌指针的模板：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">void</span> <span class="token function">processPointer</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​    但是在指针家族中，有两个特殊的指针。</p><p>一个是 void* 指针，因为没有办法对它们解析引用，递增或者递减。</p><p>另一个是 char* 指针，因为它们往往表示指向C类型的字符串，而不是指向独立字符的指针。</p><p>​    这些特殊情况经常需要特殊处理。如果希望不能以 void* 或者 char* 为参数调用该函数，只需要删除这些实现：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token keyword">void</span> <span class="token generic-function"><span class="token function">processPointer</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">delete</span><span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token keyword">void</span> <span class="token generic-function"><span class="token function">processPointer</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">delete</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，使用 void* 或者 char* 调用该函数都是无效的，但使用 const void* 或者 const char* 调用也需要是无效的， 所以这些实现也需要被删除。（略）</p><p>如果类内部有一个函数模板，想通过声明它们为私有来禁止某些实现，是做不到的，因为赋予一个成员函数模板的某种特殊情况下的拥有不同于模板主体的访问权限是不可能的。</p><p>（可以声明 void* 和 char* 的版本却不实现它们 ）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token keyword">void</span> <span class="token function">function</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token comment">//错误！！！</span><span class="token keyword">void</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>并且模板的特殊情况必须要写在命名空间的作用域内，而不是类的作用域内。</p><p>不过，这个问题对于删除函数是不存在的，它们也可以在类外被声明为是被删除的（也就是在命名空间的作用域内）</p><h3 id="delete的注意事项"><a href="#delete的注意事项" class="headerlink" title="delete的注意事项"></a>delete的注意事项</h3><p>​    删除的函数不能通过任何方式被使用</p><p>​    方便起见,删除函数被声明为公有的,而不是私有的。这样设计的原因是,当客户端程序尝试使用一个成员函数的时候, C++会在检查删除状态之前检查可访问权限。当客户端代码尝试访问一个删除的私有函数时,一些编译器仅仅会警报该函数为私有,尽管这里函数的可访问性并不本质上影响它是否可以被使用。当把私有未定义的函数改为对应的删除函数时,牢记这一点是很有意义的,因为使这个函数为公有的可以产生更易读的错误信息。</p><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ol><li>优先使用删除函数而不是私有而不定义的函数</li><li>任何函数都可以被声明为删除，包括非成员函数和模板实现</li></ol><h3 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h3><h4 id="对于成员函数："><a href="#对于成员函数：" class="headerlink" title="对于成员函数："></a>对于成员函数：</h4><ol><li>被delete了还是可以重载的</li><li>被delete了，里面写个默认参数没问题</li><li>delete函数可以被继承的！！！（看IDE的报错）(但不能用)</li><li>私有的delete函数被类用户使用了会以“使用私有成员函数”的名义报错</li><li>delete函数不能够被定义，只能够被声明</li></ol><h4 id="对于普通函数："><a href="#对于普通函数：" class="headerlink" title="对于普通函数："></a>对于普通函数：</h4><ol><li>可以防止不想要的隐式转化</li><li>但删除一种类型的，可能会影响不止一种类型的隐式转化（会导致其他类型的不明确，ambiguous）</li><li>模板类的删除方式有两种，一种使用template，一种直接写出（暂时没发现会出啥问题）</li></ol><h2 id="使用override关键字声明覆盖的函数"><a href="#使用override关键字声明覆盖的函数" class="headerlink" title="使用override关键字声明覆盖的函数"></a>使用override关键字声明覆盖的函数</h2><p>在C++98中，如果要发生函数的覆盖，必须满足以下几个条件：</p><ul><li>基类中的函数必须是虚函数</li><li>基类和派生类中函数的名字必须完全相同（析构函数除外）</li><li>基类和派生类中的函数形参类型必须完全一样</li><li>基类和派生类中的函数的常量特性必须完全一样</li><li>基类和派生类中的函数返回值和异常声明必须是兼容的</li></ul><p>在C++11中，还有一条：</p><ul><li><p>基类和派生类的引用修饰符必须完全一样</p><p>（引用修饰符是为了实现限制成员函数仅用于左值或者右值）</p></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token punctuation">;</span><span class="token comment">//只有*this为左值时，这个版本才会被调用</span>    <span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span><span class="token punctuation">;</span><span class="token comment">//只有*this为右值时，这个函数才会被调用</span><span class="token punctuation">}</span><span class="token punctuation">;</span>Widget <span class="token function">makeWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//工厂函数，返回右值</span>Widget w<span class="token punctuation">;</span><span class="token comment">//正常对象（左值）</span>w<span class="token punctuation">.</span><span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用了Widget::doWork &amp;</span><span class="token function">makeWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用了Widget::doWork &amp;&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>正是因为覆盖有这么多的要求，所以一个很小的错误都可以造成很大的偏差。并且覆盖函数中出现的错误通常还是合法的，，但它导致的结果并不是你想要的。所以当你犯了某些错误的时候，你并不能依赖于编译器对你的通知。</p><p>例如下面这个例子，这些代码是完全合法的，但它一个虚函数都没有被覆盖——没有任何一个派生类的函数是和基类的对应函数绑定的。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span><span class="token class-name">Base</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span><span class="token keyword">void</span><span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span><span class="token keyword">void</span><span class="token function">mf2</span><span class="token punctuation">(</span><span class="token keyword">int</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span><span class="token keyword">void</span><span class="token function">mf3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token punctuation">;</span>    <span class="token keyword">void</span><span class="token function">mf4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">class</span><span class="token class-name">Derived</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span><span class="token class-name">Base</span></span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span><span class="token keyword">void</span><span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span><span class="token keyword">void</span><span class="token function">mf2</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token keyword">int</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span><span class="token keyword">void</span><span class="token function">mf3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">;</span>    <span class="token keyword">void</span><span class="token function">mf4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>提示：</p><ul><li>mf1在Base中声明常成员函数,但是在Derived中没有</li><li>mf2在Base中以int为参数,但是在Derived中以unsigned int为参数</li><li>mf3在Base中有左值修饰符,但是在Derived中是右值修饰符</li><li>mf4没有继承Base中的虚函数</li></ul><p>因为声明派生类的覆盖函数很重要，又如此容易出错，所以C++11提供了一种方法来显示的标明派生类中的函数是为了改写基类的版本，为其加上override声明即可。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span><span class="token class-name">Derived</span><span class="token operator">:</span><span class="token base-clause"><span class="token keyword">public</span><span class="token class-name">Base</span></span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf2</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">override</span><span class="token punctuation">;</span>    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，上面这些代码就无法通过编译了，并且编译器会把覆盖函数所有的问题揭露出来。</p><h3 id="扩展：-1"><a href="#扩展：-1" class="headerlink" title="扩展："></a>扩展：</h3><h4 id="与成员函数有关的几个描述符："><a href="#与成员函数有关的几个描述符：" class="headerlink" title="与成员函数有关的几个描述符："></a>与成员函数有关的几个描述符：</h4><ol><li>成员函数前面使用const 表示返回值为const</li><li>成员函数后面加 const表示函数不可以修改class的成员</li><li>如果<strong>派生类</strong>在虚函数声明时使用了override描述符，那么该函数必须重载其基类中的同名函数，否则代码将无法通过编译。</li><li>当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错</li></ol><h4 id="重载与覆盖"><a href="#重载与覆盖" class="headerlink" title="重载与覆盖"></a>重载与覆盖</h4><p>​    覆盖是指派生类中如果存在重新定义的函数，其函数名、参数列、返回值类型必须同父类中的相对应被覆盖的函数严格一致。覆盖函数和被覆盖函数只有函数体不同，当派生类对象调用子类中该同名函数时会自动调用子类中的覆盖版本，而不是父类中的被覆盖函数版本。</p><h5 id="成员函数被重载的特征："><a href="#成员函数被重载的特征：" class="headerlink" title="成员函数被重载的特征："></a>成员函数被重载的特征：</h5><p>（1）相同的范围（在同一个类中）；</p><p>（2）函数名字相同（必须的，否则属于不同的函数了，更谈不上重载）；</p><p>（3）参数类型或个数，至少有一种不同（如果都相同的话，就是函数的重定义了；还要注意的是：如果函数参数相同，仅返回值不同的话，不是重载函数，编译时会报“有歧义”的错误）；</p><p>（4）virtual关键字可有可无（这个重载函数与虚函数一点关系没有，即使加上了也不是虚函数。如果在面试题中遇到了，纯粹是为了混淆你的思维，考察你对概念的理解）。</p><h5 id="覆盖是指派生类函数覆盖基类函数，特征是："><a href="#覆盖是指派生类函数覆盖基类函数，特征是：" class="headerlink" title="覆盖是指派生类函数覆盖基类函数，特征是："></a>覆盖是指派生类函数覆盖基类函数，特征是：</h5><p><strong>（1）不同的范围（分别位于派生类与基类）；</strong></p><p><strong>（2）函数名字相同；</strong></p><p><strong>（3）参数相同（这就属于重定义函数了）；</strong></p><p><strong>（4）基类函数必须有virtual关键字（这就是虚函数了）。</strong></p><h4 id="令人迷惑的隐藏规则"><a href="#令人迷惑的隐藏规则" class="headerlink" title="令人迷惑的隐藏规则"></a>令人迷惑的隐藏规则</h4><p>本来仅仅区别重载与覆盖并不算困难，但是C++的隐藏规则使问题复杂性陡然增加。这里“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下： </p><p><strong>（1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。</strong></p><p><strong>（2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆；如果基类函数有virtual关键字，就属于函数的覆盖了）。</strong></p><h4 id="关于虚函数与纯虚函数："><a href="#关于虚函数与纯虚函数：" class="headerlink" title="关于虚函数与纯虚函数："></a>关于虚函数与纯虚函数：</h4><p>定义一个函数为虚函数，不代表函数为不被实现的函数。</p><p>定义它为虚函数是为了允许用基类的指针来调用子类的这个函数。</p><p>定义一个函数为纯虚函数，才代表函数没有被实现。（这里好像有问题。。。）</p><p>定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。</p><p>虚函数只能借助于指针或者引用来达到多态的效果</p>]]></content>
      
      
      <categories>
          
          <category> 编程基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几种常见的颜色空间</title>
      <link href="2020/08/17/opencv-notes-2/"/>
      <url>2020/08/17/opencv-notes-2/</url>
      
        <content type="html"><![CDATA[<h1 id="颜色空间"><a href="#颜色空间" class="headerlink" title="颜色空间"></a>颜色空间</h1><p><strong>颜色空间</strong>（英语：Color space）是对<a href="https://zh.wikipedia.org/wiki/%E8%89%B2%E5%BD%A9">色彩</a>的组织方式。借助色彩空间和针对物理设备的测试，可以得到色彩的固定<a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E6%93%AC%E4%BF%A1%E8%99%9F">模拟</a>和<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7">数字</a>表示。色彩空间可以只通过任意挑选一些颜色来定义，比如像<a href="https://zh.wikipedia.org/wiki/%E5%BD%A9%E9%80%9A">彩通</a>系统就只是把一组特定的颜色作为<a href="https://zh.wikipedia.org/wiki/%E8%AA%BF%E8%89%B2%E7%9B%A4_(%E9%9B%BB%E8%85%A6%E5%9C%96%E5%BD%A2%E5%AD%B8)">样本</a>，然后给每个颜色定义名字和代码；也可以是基于严谨的数学定义，比如 <a href="https://zh.wikipedia.org/wiki/Adobe_RGB%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4">Adobe RGB</a>、<a href="https://zh.wikipedia.org/wiki/SRGB%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4">sRGB</a>。</p><p>在计算机视觉，尤其颜色识别相关的算法中，rgb,hsv,lab颜色空间混用是常用的方法。</p><h2 id="RGB"><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>RGB颜色空间以R(Red:红)、G(Green:绿)、B(Blue:蓝)三种基本色为基础，进行不同程度的叠加，产生丰富而广泛的颜色，所以俗称三基色模式。在大自然中有无穷多种不同的颜色，而人眼只能分辨有限种不同的颜色，RGB模式可表示一千六百多万种不同的颜色，在人眼看来它非常接近大自然的颜色，故又称为自然色彩模式。红绿蓝代表可见光谱中的三种基本颜色或称为三原色，每一种颜色按其亮度的不同分为256个等级。当色光三原色重叠时，由于不同的混色比例能产生各种中间色，例如，三原色相加可产生白色。所以RGB模式是加色过程。屏幕显示的基础是RGB模式，彩色印刷品却无法用RGB模式来产生各种彩色，所以，<strong>RGB模式常用于视频、多媒体与网页设计</strong>。</p><h3 id="空间模型"><a href="#空间模型" class="headerlink" title="空间模型"></a>空间模型</h3><p>对图像处理而言，RGB是最为重要和常见的颜色模型，它建立在笛卡尔坐标系中，以红、绿、蓝三种基本色为基础，<strong>进行不同程度的叠加</strong>，产生丰富而广泛的颜色，俗称三基色模式。如下图所示：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9nc3MwLmJkc3RhdGljLmNvbS85NG8zZFNhZ194STRraEdrcG9XSzFIRjZoaHkvYmFpa2UvYzAlM0RiYWlrZTgwJTJDNSUyQzUlMkM4MCUyQzI2L3NpZ249MjdmYjUwZjlhYWVjMDhmYTMyMGQxYmY1Mzg4NzU2MDgvZTFmZTk5MjViYzMxNWM2MGU0NTA5ZmE5ODdiMWNiMTM0ODU0NzdhYi5qcGc?x-oss-process=image/format,png"></p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>RGB模型的原理来自于颜色的三刺激理论，它基于以下假设:在眼睛的中央部位有3种类型的对色彩敏感的锥状细胞。其中一类对位于可见光谱中间位置的光波敏感，这种光波经人的视觉系统转换产生绿色感。而其他两种锥状细胞对位于可见光波的上、下端即较长和较短的波长的光波敏感，它们分别被识别为红色和蓝色。从生理学的角度来看，由于眼睛仅包含3种不同类型的锥状细胞，因而对任意3种颜色适当混合均可产生白光视觉，条件是这3中颜色中任意两种的组合都并不能产生第3种颜色，则这三种颜色就被称为三原色。</p><h3 id="表达方式"><a href="#表达方式" class="headerlink" title="表达方式"></a>表达方式</h3><p> RGB空间是目前最常用的彩色信息表达方式，使用红、绿、蓝三原色的亮度来定量表示颜色，<strong>是以RGB三色光互相叠加来实现混色的方式</strong>。三种颜色所占比例不同，得到的颜色就不同。变换混合的比例，就会得到各种各样的混合效果。RGB颜色空间可以看作是三维直角坐标系中的一个单位正方体。任何一种颜色在RGB颜色空间中都可以用三维空间中的一个点来表示。在RGB颜色空间，任意色光F都可以用RGB三种颜色不同分量的相加混合而成：F=r[R]+g[G]+b[B]</p><h4 id="色度学规则："><a href="#色度学规则：" class="headerlink" title="色度学规则："></a>色度学规则：</h4><p> 　(1)通过R,G,B这三种颜色能产生任何颜色，并且这三种颜色混合后产生的颜色是唯一的。<br> 　(2)如果两个颜色相等，这三个颜色分量再乘以或者除以相同的数，得到的颜色仍然相等。<br> 　(3)混合色的亮度等于每种颜色亮度的和。</p><h3 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h3><p>优点： RGB颜色空间最大的优点就是直观，容易理解。</p><p>缺点：<strong>R,G,B这3个分量是高度相关的</strong>，即如果一个颜色的某一个分量发生了一定程度的改变，那么这个颜色很可能要发生改变；人眼对于常见的红绿蓝三色的敏感程度是不一样的，因此RGB颜色空间的均匀性非常差，且两种颜色之间的知觉差异色差不能表示为该颜色空间中两点间的距离，但是利用线性或非线性变换，则可以从RGB颜色空间推导出其他的颜色特征空间。</p><h2 id="HSV"><a href="#HSV" class="headerlink" title="HSV"></a>HSV</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>HSV(Hue, Saturation, Value)是根据颜色的直观特性由A. R.  Smith在1978年创建的一种颜色空间, 也称六角锥体模型(Hexcone  Model)。这个模型中颜色的参数分别是：<strong>色调（H），饱和度（S），明度（V）</strong>。</p><h3 id="空间模型-1"><a href="#空间模型-1" class="headerlink" title="空间模型"></a>空间模型</h3><h4 id="色调H："><a href="#色调H：" class="headerlink" title="色调H："></a>色调H：</h4><p>用角度度量，取值范围为0°～360°，从红色开始按逆时针方向计算，红色为0°，绿色为120°,蓝色为240°。它们的补色是：黄色为60°，青色为180°,品红为300°；</p><h4 id="饱和度S："><a href="#饱和度S：" class="headerlink" title="饱和度S："></a>饱和度S：</h4><p>饱和度S表示颜色接近光谱色的程度。一种颜色，可以看成是某种光谱色与白色混合的结果。其中光谱色所占的比例愈大，颜色接近光谱色的程度就愈高，颜色的饱和度也就愈高。饱和度高，颜色则深而艳。光谱色的白光成分为0，饱和度达到最高。通常取值范围为0%～100%，值越大，颜色越饱和。</p><h4 id="明度V："><a href="#明度V：" class="headerlink" title="明度V："></a>明度V：</h4><p>明度表示颜色明亮的程度，对于光源色，明度值与发光体的光亮度有关；对于物体色，此值和物体的透射比或反射比有关。通常取值范围为0%（黑）到100%（白）。</p><p><strong>RGB和CMY颜色模型都是面向硬件的，而HSV（Hue Saturation  Value）颜色模型是面向用户的。</strong>HSV模型的三维表示从RGB立方体演化而来。设想从RGB沿立方体对角线的白色顶点向黑色顶点观察，就可以看到立方体的六边形外形。六边形边界表示色彩，水平轴表示纯度，明度沿垂直轴测量。</p><p> <img src="https://img-blog.csdnimg.cn/20181128220932509.png"> </p><p> <img src="https://img-blog.csdnimg.cn/20181128220957174.png"></p><h3 id="从RGB到HSV的转换"><a href="#从RGB到HSV的转换" class="headerlink" title="从RGB到HSV的转换"></a>从RGB到HSV的转换</h3><p>HSV 在数学上定义为在 RGB 空间中的颜色的 R, G 和 B 的坐标的变换。设 (r, g, b) 分别是一个颜色的红、绿和蓝坐标，它们的值是在 0 到 1 之间的实数。设 max 等价于 r, g 和 b 中的最大者，设 min 等于这些值中的最小者。要找到在 HSV 空间中的 (h, s, v) 值，这里的 h ∈ [0,  360）是角度的色相角，而 s, v ∈ [0,1] 是饱和度和亮度，计算公式为：</p><p><img src="https://img-blog.csdnimg.cn/20181128221242343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ppYW5nSHVpMTIxMQ==,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/20181128221304329.png"></p><p><img src="https://img-blog.csdnimg.cn/2018112822132243.png"></p><p>HSV对用户来说是一种直观的颜色模型。我们可以从一种纯色彩开始，即指定色彩角H，并让V=S=1，然后我们可以通过向其中加入黑色和白色来得到我们需要的颜色。<strong>增加黑色可以减小V而S不变，同样增加白色可以减小S而V不变。</strong>例如，要得到深蓝色，V=0.4 S=1 H=240度。要得到淡蓝色，V=1 S=0.4 H=240度。</p><p>一般说来，人眼最大能区分128种不同的色彩，130种色饱和度，23种明暗度。如果我们用16Bit表示HSV的话，可以用7位存放H，4位存放S，5位存放V，即745或者655就可以满足我们的需要了。</p><p>由于HSV是一种比较直观的颜色模型，所以在许多图像编辑工具中应用比较广泛，如Photoshop（在Photoshop中叫HSB）等等，但这也决定了<strong>它不适合使用在光照模型中，许多光线混合运算、光强运算等都无法直接使用HSV来实现。</strong></p><h2 id="LAB"><a href="#LAB" class="headerlink" title="LAB"></a>LAB</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><p><a href="https://baike.baidu.com/item/Lab%E6%A8%A1%E5%BC%8F/7362402">Lab模式</a>是根据Commission International Eclairage（CIE）在1931年所制定的一种测定颜色的国际标准建立的。于1976年被改进，并且命名的一种色彩模式。Lab颜色模型弥补了<a href="https://baike.baidu.com/item/RGB/342517">RGB</a>和CMYK两种色彩模式的不足。它是一种<strong>设备无关的颜色模型</strong>，也是一种<strong>基于生理特征的颜色模型</strong>。 Lab颜色模型由三个要素组成，一个要素是亮度（L），a 和b是两个<a href="https://baike.baidu.com/item/%E9%A2%9C%E8%89%B2%E9%80%9A%E9%81%93/5706858">颜色通道</a>。a包括的颜色是从<a href="https://baike.baidu.com/item/%E6%B7%B1%E7%BB%BF%E8%89%B2/2192808">深绿色</a>（低亮度值）到灰色（中亮度值）再到亮粉红色（高亮度值）；b是从亮蓝色（低亮度值）到灰色（中亮度值）再到黄色（高亮度值）。因此，这种颜色混合后将产生具有明亮效果的色彩。</p><h3 id="空间模型-2"><a href="#空间模型-2" class="headerlink" title="空间模型"></a>空间模型</h3><p><a href="https://baike.baidu.com/item/Lab%E6%A8%A1%E5%BC%8F/7362402">Lab模式</a>既不依赖光线，也不依赖于颜料，它是CIE组织确定的一个理论上包括了人眼可以看见的所有色彩的色彩模式。Lab模式弥补了<a href="https://baike.baidu.com/item/RGB/342517">RGB</a>和CMYK两种色彩模式的不足。同RGB颜色空间相比，Lab是一种不常用的色彩空间。它是一种设备无关的颜色系统，也是一种基于生理特征的颜色系统。这也就意味着，<strong>它是用数字化的方法来描述人的视觉感应</strong>。Lab颜色空间中的L分量用于表示像素的亮度，取值范围是[0,100],表示从纯黑到纯白；a表示从红色到绿色的范围，取值范围是[127,-128]；b表示从黄色到蓝色的范围，取值范围是[127,-128]。下图所示为Lab颜色空间的图示：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9nc3MzLmJkc3RhdGljLmNvbS8tUG8zZFNhZ194STRraEdrcG9XSzFIRjZoaHkvYmFpa2UvYzAlM0RiYWlrZTgwJTJDNSUyQzUlMkM4MCUyQzI2L3NpZ249ZTM1OWY1YTZhNDRiZDExMzEwYzBiZjYwM2JjNmNmNmEvMDIzYjViYjVjOWVhMTVjZTFkMWZmMWRjYmYwMDNhZjMzYjg3YjI3NS5qcGc?x-oss-process=image/format,png"></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>Lab颜色空间比计算机显示器甚至比人类视觉的色域都要大 **，表示为Lab的位图比RGB或CMYK位图获得同样的精度需要要求更多的像素数据。<a href="https://baike.baidu.com/item/Lab%E6%A8%A1%E5%BC%8F/7362402">Lab模式</a>所定义的色彩最多，且与光线及设备无关并且</strong>处理速度与<a href="https://baike.baidu.com/item/RGB%E6%A8%A1%E5%BC%8F/7362104">RGB模式</a>同样快**，比<a href="https://baike.baidu.com/item/CMYK%E6%A8%A1%E5%BC%8F/305545">CMYK模式</a>快很多。因此，可以放心大胆的在图象编辑中使用Lab模 式。而且，Lab模式在转换成CMYK模式时色彩没有丢失或被替换。因此，最佳避免色彩损失的方法是：应用Lab模式编辑图象，再转换为CMYK模式打印输出。</p><h2 id="CMYK"><a href="#CMYK" class="headerlink" title="CMYK"></a>CMYK</h2><h3 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h3><p>当阳光照射到一个物体上时，这个物体将吸收一部分光线，并将剩下的光线进行反射，反射的光线就是我们所看见的物体颜色。这是一种**减色<a href="https://baike.baidu.com/item/%E8%89%B2%E5%BD%A9%E6%A8%A1%E5%BC%8F/10209468">色彩模式</a>**，同时也是与<a href="https://baike.baidu.com/item/RGB%E6%A8%A1%E5%BC%8F">RGB模式</a>的根本不同之处。不但我们看物体的颜色时用到了这种减色模式，而且在纸上印刷时应用的也是这种减色模式。CMYK代表印刷上用的四种颜色，C代表青色（Cyan），M代表<a href="https://baike.baidu.com/item/%E6%B4%8B%E7%BA%A2%E8%89%B2/6833575">洋红色</a>（Magenta），Y代表黄色（Yellow），K代表黑色（Black）。因为在实际应用中，青色、洋红色和黄色很难叠加形成真正的黑色，最多不过是褐色而已。因此才引入了K——黑色。黑色的作用是强化暗调，加深暗部色彩。</p><h3 id="打印模式"><a href="#打印模式" class="headerlink" title="打印模式"></a>打印模式</h3><p><strong>CMYK模式俗称四色打印模式，是最佳的打印模式</strong>。但是在进行实际打印时，两种模式存在转换问题，具体原因如下：</p><ol><li><p>CMYK模式编辑虽然能够避免色彩的损失，但运算速度很慢。主要原因如下：</p><p>1）、即使在CMYK模式下工作，<a href="https://baike.baidu.com/item/Photoshop/133866">Photoshop</a>也必须将CMYK模式转变为显示器所使用的RGB模式。</p><p>2）、对于同样的图像，RGB模式只需要处理三个<a href="https://baike.baidu.com/item/%E9%80%9A%E9%81%93">通道</a>即可，而CMYK模式则需要处理四个。</p></li><li><p> 用户所使用的扫描仪和显示器都是<a href="https://baike.baidu.com/item/RGB/342517">RGB</a>设备，所以无论什么时候使用CMYK模式工作都有把RGB模式转换为CMYK模式这样一个过程。因此，是否应用CMYK模式进行编辑都存在<a href="https://baike.baidu.com/item/RGB%E6%A8%A1%E5%BC%8F/7362104">RGB模式</a>和CMYK模式转换的问题。</p></li></ol><p>对于<a href="https://baike.baidu.com/item/RGB%E6%A8%A1%E5%BC%8F/7362104">RGB模式</a>和CMYK模式转换的问题，可以先用RGB模式进行编辑工作，再用CMYK模式进行打印工作，在打印前才进行转换，然后加入必要的<a href="https://baike.baidu.com/item/%E8%89%B2%E5%BD%A9%E6%A0%A1%E6%AD%A3/10786529">色彩校正</a>，<a href="https://baike.baidu.com/item/%E9%94%90%E5%8C%96/2189784">锐化</a>和修整。这样虽然使<a href="https://baike.baidu.com/item/Photoshop/133866">Photoshop</a>在CMYK模式下速度慢一些，但可节省大部分编辑时间。这种打印前的模式转换，并不是避免图像损失最佳的途径，最佳方法是将<a href="https://baike.baidu.com/item/Lab%E6%A8%A1%E5%BC%8F">Lab模式</a>和CMYK模式相结合使用，这样可以最大程度的减少图像失真。</p><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：可以满足打印的需求，解决RGB不能打印的问题</p><p>缺点：一定程度上存在色彩的缺失，运行速度慢</p>]]></content>
      
      
      <categories>
          
          <category> 三维视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
